// # ifdef __cplusplus\n// extern "C" {\n// # endif\n\n//========================================================================================================================================================================================================200\n//======================================================================================================================================================150\n//====================================================================================================100\n//==================================================50\n\n//========================================================================================================================================================================================================200\n//	INFORMATION\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	UPDATE\n//======================================================================================================================================================150\n\n// 2009; Amittai Aviram; entire code written in C; \n// 2010; Jordan Fix and Andrew Wilkes; code converted to CUDA; \n// 2011.10; Lukasz G. Szafaryn; code converted to portable form, to C, OpenMP, CUDA, PGI versions; \n// 2011.12; Lukasz G. Szafaryn; Split different versions for Rodinia.\n// 2011.12; Lukasz G. Szafaryn; code converted to OpenCL;\n\n//======================================================================================================================================================150\n//	DESCRIPTION\n//======================================================================================================================================================150\n\n// Description\n\n//======================================================================================================================================================150\n//	USE\n//======================================================================================================================================================150\n\n// EXAMPLE:\n// ./a.out -file ./input/mil.txt -cores 16\n// ...then enter any of the following commands after the prompt > :\n// f <x>  -- Find the value under key <x>\n// p <x> -- Print the path from the root to key k and its associated value\n// t -- Print the B+ tree\n// l -- Print the keys of the leaves (bottom row of the tree)\n// v -- Toggle output of pointer addresses ("verbose") in tree and leaves.\n// k <x> -- Run <x> bundled queries on the CPU and GPU (B+Tree) (Selects random values for each search)\n// j <x> <y> -- Run a range search of <x> bundled queries on the CPU and GPU (B+Tree) with the range of each search of size <y>\n// x <z> -- Run a single search for value z on the GPU and CPU\n// y <a> <b> -- Run a single range search for range a-b on the GPU and CPU\n// q -- Quit. (Or use Ctl-D.)\n\n//======================================================================================================================================================150\n//	END\n//======================================================================================================================================================150\n\n//========================================================================================================================================================================================================200\n//	DEFINE/INCLUDE\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	LIBRARIES\n//======================================================================================================================================================150\n\n#include <stdio.h>									// (in directory known to compiler)			needed by printf, stderr\n#include <limits.h>									// (in directory known to compiler)			needed by INT_MIN, INT_MAX\n// #include <sys/time.h>							// (in directory known to compiler)			needed by ???\n#include <math.h>									// (in directory known to compiler)			needed by log, pow\n#include <string.h>									// (in directory known to compiler)			needed by memset\n\n//======================================================================================================================================================150\n//	COMMON\n//======================================================================================================================================================150\n\n#include "./common.h"								// (in directory provided here)\n\n//======================================================================================================================================================150\n//	DEFINE\n//======================================================================================================================================================150\n\n//======================================================================================================================================================150\n//	UTILITIES\n//======================================================================================================================================================150\n\n#include "./util/timer/timer.h"						// (in directory provided here)\n#include "./util/num/num.h"							// (in directory provided here)\n\n//======================================================================================================================================================150\n//	KERNEL HEADERS\n//======================================================================================================================================================150\n\n#include "./kernel/kernel_cpu.h"					// (in directory provided here)\n#include "./kernel/kernel_cpu_2.h"					// (in directory provided here)\n\n//======================================================================================================================================================150\n//	HEADER\n//======================================================================================================================================================150\n\n#include "./main.h"									// (in directory provided here)\n\n//======================================================================================================================================================150\n//	END\n//======================================================================================================================================================150\n\n//========================================================================================================================================================================================================200\n//	VARIABLES\n//========================================================================================================================================================================================================200\n\n// general variables\nknode *knodes;\nrecord *krecords;\nchar *mem;\nlong freeptr;\nlong malloc_size;\nlong size;\nlong maxheight;\n\n/* The order determines the maximum and minimum\n* number of entries (keys and pointers) in any\n* node.  Every node has at most order - 1 keys and\n* at least (roughly speaking) half that number.\n* Every leaf has as many pointers to data as keys,\n* and every internal node has one more pointer\n* to a subtree than the number of keys.\n* This global variable is initialized to the\n* default value.\n*/\nint order = DEFAULT_ORDER;\n\n/* The queue is used to print the tree in\n* level order, starting from the root\n* printing each entire rank on a separate\n* line, finishing with the leaves.\n*/\nnode *queue = NULL;\n\n/* The user can toggle on and off the "verbose"\n* property, which causes the pointer addresses\n* to be printed out in hexadecimal notation\n* next to their corresponding keys.\n*/\nbool verbose_output = false;\n\n//========================================================================================================================================================================================================200\n//	FUNCTIONS\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	Components\n//======================================================================================================================================================150\n\nvoid \nlist_init(	list_t *l,\n			int32_t (*compare)(const void *key, \n			const void *with),\n			void (*datum_delete)(void *))\n{\n  l->head = l->tail = NULL;\n  l->length = 0;\n  l->compare = compare;\n  l->datum_delete = datum_delete;\n}\n\nvoid \nlist_delete(list_t *l)\n{\n\n  list_item_t *li, *del;\n\n  for (li = l->head; li;) {\n\n    del = li;\n    li = li->next;\n    list_item_delete(del, l->datum_delete);\n  }\n\n  l->head = l->tail = NULL;\n  l->length = 0;\n}\n\nvoid \nlist_reset(list_t *l)\n{\n  list_delete(l);\n}\n\nvoid \nlist_insert_item_head(	list_t *l, \n						list_item_t *i)\n{\n  if (l->head) {\n    i->next = l->head;\n    l->head->pred = i;\n    l->head = i;\n    l->head->pred = NULL;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_tail(	list_t *l, \n						list_item_t *i)\n{\n  if (l->head) {\n    l->tail->next = i;\n    i->pred = l->tail;\n    i->next = NULL;\n    l->tail = i;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_before(list_t *l, \n						list_item_t *next, \n						list_item_t *i)\n{\n  /* Assume next is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->head == next) {\n    i->next = next;\n    i->pred = NULL;\n    l->head = i;\n    next->pred = i;\n  } else {\n    i->next = next;\n    i->pred = next->pred;\n    next->pred->next = i;\n    next->pred = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_after(	list_t *l, \n						list_item_t *pred, \n						list_item_t *i)\n{\n  /* Assume pred is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->tail == pred) {\n    i->pred = pred;\n    i->next = NULL;\n    l->tail = i;\n    pred->next = i;\n  } else {\n    i->pred = pred;\n    i->next = pred->next;\n    pred->next->pred = i;\n    pred->next = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_sorted(list_t *l, \n						list_item_t *i)\n{\n  list_item_t *itr;\n\n  if (l->head) {\n    for (itr = l->head; itr && l->compare(list_item_get_datum(i),\n					  list_item_get_datum(itr)) < 0;\n	 itr = itr->next)\n      ;\n    if (itr) {\n      i->next = itr;\n      i->pred = itr->pred;\n      itr->pred = i;\n      i->pred->next = i;\n    } else {\n      l->tail->next = i;\n      i->pred = l->tail;\n      i->next = NULL;\n      l->tail = i;\n    }\n  } else {\n    l->head = l->tail = i;\n    i->pred = i->next = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_head(	list_t *l, \n					void *v)\n{\n  list_item_t *i;\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n  if (l->head) {\n    i->next = l->head;\n    l->head->pred = i;\n    l->head = i;\n    l->head->pred = NULL;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n\n}\n\nvoid \nlist_insert_tail(	list_t *l, \n					void *v)\n{\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n  if (l->head) {\n    l->tail->next = i;\n    i->pred = l->tail;\n    i->next = NULL;\n    l->tail = i;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_before(	list_t *l, \n					list_item_t *next, \n					void *v)\n{\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n\n  /* Assume next is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->head == next) {\n    i->next = next;\n    i->pred = NULL;\n    l->head = i;\n    next->pred = i;\n  } else {\n    i->next = next;\n    i->pred = next->pred;\n    next->pred->next = i;\n    next->pred = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_after(	list_t *l, \n					list_item_t *pred, \n					void *v)\n{\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n\n  /* Assume pred is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->tail == pred) {\n    i->pred = pred;\n    i->next = NULL;\n    l->tail = i;\n    pred->next = i;\n  } else {\n    i->pred = pred;\n    i->next = pred->next;\n    pred->next->pred = i;\n    pred->next = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_sorted(	list_t *l, \n					void *v)\n{\n  list_item_t *itr;\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n\n\n  if (l->head) {\n    for (itr = l->head; itr && l->compare(list_item_get_datum(i),\n					  list_item_get_datum(itr)) < 0;\n	 itr = itr->next)\n      ;\n    if (itr) {\n      i->next = itr;\n      i->pred = itr->pred;\n      itr->pred = i;\n      i->pred->next = i;\n    } else {\n      l->tail->next = i;\n      i->pred = l->tail;\n      i->next = NULL;\n      l->tail = i;\n    }\n  } else {\n    l->head = l->tail = i;\n    i->pred = i->next = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_remove_item(	list_t *l, \n					list_item_t *i)\n{\n  if (i == l->head) {\n    l->head = l->head->next;\n    if (l->head)\n      l->head->pred = NULL;\n    else\n      l->tail = NULL;\n  } else if (i == l->tail) {\n    l->tail = l->tail->pred;\n    l->tail->next = NULL;\n  } else {\n    i->pred->next = i->next;\n    i->next->pred = i->pred;\n  }\n  l->length--;\n  list_item_delete(i, l->datum_delete);\n}\n\nvoid \nlist_remove_head(list_t *l)\n{\n  list_remove_item(l, l->head);\n}\n\nvoid \nlist_remove_tail(list_t *l)\n{\n  list_remove_item(l, l->tail);\n}\n\nlist_item_t* \nlist_find_item(	list_t *l, \n				void *datum)\n{\n  list_item_t *li;\n\n  for (li = l->head; li && l->compare(datum, list_item_get_datum(li));\n       li = li->next)\n    ;\n\n  return li;\n}\n\nlist_item_t* \nlist_get_head_item(list_t *l)\n{\n  return l->head;\n}\n\nlist_item_t* \nlist_get_tail_item(list_t *l)\n{\n  return l->tail;\n}\n\nvoid* \nlist_find(	list_t *l, \n			void *datum)\n{\n  list_item_t *li;\n\n  for (li = l->head; li && l->compare(datum, list_item_get_datum(li));\n       li = li->next)\n    ;\n\n  return li ? li->datum : NULL;\n}\n\nvoid* \nlist_get_head(list_t *l)\n{\n  return l->head ? l->head->datum : NULL;\n}\n\nvoid* \nlist_get_tail(list_t *l)\n{\n  return l->tail ? l->tail->datum : NULL;\n}\n\nuint32_t \nlist_get_length(list_t *l)\n{\n  return l->length;\n}\n\nbool \nlist_is_empty(list_t *l)\n{\n  return (l->length == 0);\n}\n\nbool \nlist_not_empty(list_t *l)\n{\n  return (l->length != 0);\n}\n\nvoid \nlist_visit_items(	list_t *l, \n					void (*visitor)(void *v))\n{\n  list_item_t *li;\n\n  for (li = l->head; li; li = li->next)\n    visitor(list_item_get_datum(li));\n}\n\nvoid \nlist_item_init(	list_item_t *li, \n				void *datum)\n{\n  li->pred = li->next = NULL;\n  li->datum = datum;\n}\n\nvoid \nlist_item_delete(	list_item_t *li, \n					void (*datum_delete)(void *datum))\n{\n  if (datum_delete) {\n    datum_delete(li->datum);\n  }\n\n  free(li);\n}\n\nvoid *\nlist_item_get_datum(list_item_t *li)\n{\n  return li->datum;\n}\n\nvoid \nlist_iterator_init(	list_t *l, \n					list_iterator_t *li)\n{\n  *li = l ? l->head : NULL;\n}\n\nvoid \nlist_iterator_delete(list_iterator_t *li)\n{\n  *li = NULL;\n}\n\nvoid \nlist_iterator_next(list_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->next;\n}\n\nvoid \nlist_iterator_prev(list_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->pred;\n}\n\nvoid *\nlist_iterator_get_datum(list_iterator_t *li)\n{\n  return *li ? (*li)->datum : NULL;\n}\n\nbool \nlist_iterator_is_valid(list_iterator_t *li)\n{\n  return (*li != NULL);\n}\n\nvoid \nlist_reverse_iterator_init(	list_t *l, \n							list_reverse_iterator_t *li)\n{\n  *li = l ? l->tail : NULL;\n}\n\nvoid \nlist_reverse_iterator_delete(list_reverse_iterator_t *li)\n{\n  *li = NULL;\n}\n\nvoid \nlist_reverse_iterator_next(list_reverse_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->pred;\n}\n\nvoid \nlist_reverse_iterator_prev(list_reverse_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->next;\n}\n\nvoid *\nlist_reverse_iterator_get_datum(list_reverse_iterator_t *li)\n{\n  return *li ? (*li)->datum : NULL;\n}\n\nbool \nlist_reverse_iterator_is_valid(list_reverse_iterator_t *li)\n{\n  return (li != NULL);\n}\n\n//======================================================================================================================================================150\n// OUTPUT AND UTILITIES\n//======================================================================================================================================================150\n\n/*   */\nvoid *\nkmalloc(int size)\n{\n\n	//printf("size: %d, current offset: %p\n",size,freeptr);\n	void * r = (void *)freeptr;\n	freeptr+=size;\n	if(freeptr > malloc_size+(long)mem){\n		printf("Memory Overflow\n");\n		exit(1);\n	}\n	return r;\n}\n\n//transforms the current B+ Tree into a single, contiguous block of memory to be used on the GPU\nlong \ntransform_to_cuda(	node * root, \n					bool verbose)\n{\n\n	struct timeval one,two;\n	double time;\n	gettimeofday (&one, NULL);\n	long max_nodes = (long)(pow(order,log(size)/log(order/2.0)-1) + 1);\n	malloc_size = size*sizeof(record) + max_nodes*sizeof(knode); \n	mem = (char*)malloc(malloc_size);\n	if(mem==NULL){\n		printf("Initial malloc error\n");\n		exit(1);\n	}\n	freeptr = (long)mem;\n\n	krecords = (record * )kmalloc(size*sizeof(record));\n	// printf("%d records\n", size);\n	knodes = (knode *)kmalloc(max_nodes*sizeof(knode));\n	// printf("%d knodes\n", max_nodes);\n\n	queue = NULL;\n	enqueue(root);\n	node * n;\n	knode * k;\n	int i;\n	long nodeindex = 0;\n	long recordindex = 0;\n	long queueindex = 0;\n	knodes[0].location = nodeindex++;\n	\n	while( queue != NULL ) {\n		n = dequeue();\n		k = &knodes[queueindex];\n		k->location = queueindex++;\n		k->is_leaf = n->is_leaf;\n		k->num_keys = n->num_keys+2;\n		//start at 1 because 0 is set to INT_MIN\n		k->keys[0]=INT_MIN; \n		k->keys[k->num_keys-1]=INT_MAX;\n		for(i=k->num_keys; i < order; i++)k->keys[i]=INT_MAX;\n		if(!k->is_leaf){\n			k->indices[0]=nodeindex++;\n			// if(k->indices[0]>3953){\n				// printf("ERROR: %d\n", k->indices[0]);\n			// }\n			for(i=1;i<k->num_keys-1;i++){\n				k->keys[i] = n->keys[i-1];\n				enqueue((node * )n->pointers[i-1]);\n				k->indices[i] = nodeindex++;\n				// if(k->indices[i]>3953){\n					// printf("ERROR 1: %d\n", k->indices[i]);\n				// }\n				//knodes[nodeindex].location = nodeindex++;\n			}\n			//for final point of n\n			enqueue((node * )n->pointers[i-1]);\n		}\n		else{\n			k->indices[0]=0;\n			for(i=1;i<k->num_keys-1;i++){\n				k->keys[i] = n->keys[i-1];\n				krecords[recordindex].value=((record *)n->pointers[i-1])->value;\n				k->indices[i] = recordindex++;\n				// if(k->indices[i]>3953){\n					// printf("ERROR 2: %d\n", k->indices[i]);\n				// }\n			}\n		}\n		\n		k->indices[k->num_keys-1]=queueindex;\n		// if(k->indices[k->num_keys-1]>3953){\n			// printf("ERROR 3: %d\n", k->indices[k->num_keys-1]);\n		// }\n\n		if(verbose){\n			printf("Successfully created knode with index %d\n", k->location);\n			printf("Is Leaf: %d, Num Keys: %d\n", k->is_leaf, k->num_keys);\n			printf("Pointers: ");\n			for(i=0;i<k->num_keys;i++)\n				printf("%d | ", k->indices[i]);\n			printf("\nKeys: ");\n			for(i=0;i<k->num_keys;i++)\n				printf("%d | ", k->keys[i]);\n			printf("\n\n");\n		}\n	}\n	long mem_used = size*sizeof(record)+(nodeindex)*sizeof(knode);\n	if(verbose){\n		for(i = 0; i < size; i++)\n			printf("%d ", krecords[i].value);\n		printf("\nNumber of records = %d, sizeof(record)=%d, total=%d\n",size,sizeof(record),size*sizeof(record));\n		printf("Number of knodes = %d, sizeof(knode)=%d, total=%d\n",nodeindex,sizeof(knode),(nodeindex)*sizeof(knode));\n		printf("\nDone Transformation. Mem used: %d\n", mem_used);\n	}\n	gettimeofday (&two, NULL);\n	double oneD = one.tv_sec + (double)one.tv_usec * .000001;\n	double twoD = two.tv_sec + (double)two.tv_usec * .000001;\n	time = twoD-oneD;\n	printf("Tree transformation took %f\n", time);\n\n	return mem_used;\n\n}\n\n/*   */\nlist_t *\nfindRange(	node * root, \n			int start, \n			int end) \n{\n\n	int i;\n	node * c = find_leaf( root, start, false );\n\n	if (c == NULL) return NULL;\n	\n	list_t * retList = (list_t *)malloc(sizeof(list_t));\n	list_init(retList,NULL,NULL);\n	\n	int counter = 0;\n	bool cont = true;\n	while(cont && c!=0){\n		cont = false;\n		for(i = 0;i  < c->num_keys;i++){\n			if(c->keys[i] >= start && c->keys[i] <= end){\n				//list_insert_tail(retList,(record *)c->pointers[i]);\n				counter++;\n				cont = true;\n			}else{\n				cont = false;\n				break;\n			}\n		}\n		c = (node *)c->pointers[order-1];\n	}\n	return retList;\n}\n\n/* First message to the user. */\nvoid \nusage_1( void ) \n{\n\n	printf("B+ Tree of Order %d.\n", order);\n	printf("\tAmittai Aviram -- amittai.aviram@yale.edu  Version %s\n", Version);\n	printf("\tfollowing Silberschatz, Korth, Sidarshan, Database Concepts, 5th ed.\n\n");\n	printf("To build a B+ tree of a different order, start again and enter the order\n");\n	printf("as an integer argument:  bpt <order>.  ");\n	printf("3 <= order <=20\n");\n	printf("To start with input from a file of newline-delimited integers, start again and enter\n");\n	printf("the order followed by the filename:  bpt <order> <inputfile>.\n");\n\n}\n\n/* Second message to the user. */\nvoid \nusage_2( void ) \n{\n\n	printf("Enter any of the following commands after the prompt > :\n");\n	printf("\ti <k>  -- Insert <k> (an integer) as both key and value).\n");\n	printf("\tf <k>  -- Find the value under key <k>.\n");\n	printf("\tp <k> -- Print the path from the root to key k and its associated value.\n");\n	printf("\td <k>  -- Delete key <k> and its associated value.\n");\n	printf("\tx -- Destroy the whole tree.  Start again with an empty tree of the same order.\n");\n	printf("\tt -- Print the B+ tree.\n");\n	printf("\tl -- Print the keys of the leaves (bottom row of the tree).\n");\n	printf("\tv -- Toggle output of pointer addresses (\"verbose\") in tree and leaves.\n");\n	printf("\tq -- Quit. (Or use Ctl-D.)\n");\n	printf("\t? -- Print this help message.\n");\n}\n\n/* Helper function for printing the tree out.  See print_tree. */\nvoid \nenqueue( node* new_node ) \n{\n	node * c;\n	if (queue == NULL) {\n		queue = new_node;\n		queue->next = NULL;\n	}\n	else {\n		c = queue;\n		while(c->next != NULL) {\n			c = c->next;\n		}\n		c->next = new_node;\n		new_node->next = NULL;\n	}\n}\n\n/* Helper function for printing the tree out.  See print_tree. */\nnode *\ndequeue( void ) \n{\n	node * n = queue;\n	queue = queue->next;\n	n->next = NULL;\n	return n;\n}\n\n/* Prints the bottom row of keys of the tree (with their respective pointers, if the verbose_output flag is set. */\nvoid \nprint_leaves( node* root ) \n{\n	int i;\n	node * c = root;\n	if (root == NULL) {\n		printf("Empty tree.\n");\n		return;\n	}\n	while (!c->is_leaf)\n	c = (node *) c->pointers[0];\n	while (true) {\n		for (i = 0; i < c->num_keys; i++) {\n			if (verbose_output)\n			//printf("%x ", (unsigned int)c->pointers[i]);\n			printf("%d ", c->keys[i]);\n		}\n		if (verbose_output)\n		//printf("%x ", (unsigned int)c->pointers[order - 1]);\n		if (c->pointers[order - 1] != NULL) {\n			printf(" | ");\n			c = (node *) c->pointers[order - 1];\n		}\n		else\n		break;\n	}\n	printf("\n");\n}\n\n/* Utility function to give the height of the tree, which length in number of edges of the path from the root to any leaf. */\nint \nheight( node* root ) \n{\n	int h = 0;\n	node * c = root;\n	while (!c->is_leaf) {\n		c = (node *) c->pointers[0];\n		h++;\n	}\n	return h;\n}\n\n/* Utility function to give the length in edges of the path from any node to the root. */\nint \npath_to_root( node* root, node* child ) \n{\n	int length = 0;\n	node * c = child;\n	while (c != root) {\n		c = c->parent;\n		length++;\n	}\n	return length;\n}\n\n/* Prints the B+ tree in the command line in level (rank) order, with the keys in each node and the '|' symbol to separate nodes. With the verbose_output flag set. the values of the pointers corresponding to the keys also appear next to their respective keys, in hexadecimal notation. */\nvoid \nprint_tree( node* root ) \n{\n\n	node * n = NULL;\n	int i = 0;\n	int rank = 0;\n	int new_rank = 0;\n\n	if (root == NULL) {\n		printf("Empty tree.\n");\n		return;\n	}\n	queue = NULL;\n	enqueue(root);\n	while( queue != NULL ) {\n		n = dequeue();\n		if (n->parent != NULL && n == n->parent->pointers[0]) {\n			new_rank = path_to_root( root, n );\n			if (new_rank != rank) {\n				rank = new_rank;\n				printf("\n");\n			}\n		}\n		if (verbose_output) \n		printf("(%x)", n);\n		for (i = 0; i < n->num_keys; i++) {\n			if (verbose_output)\n			printf("%x ", n->pointers[i]);\n			printf("%d ", n->keys[i]);\n		}\n		if (!n->is_leaf)\n		for (i = 0; i <= n->num_keys; i++)\n		enqueue((node *) n->pointers[i]);\n		if (verbose_output) {\n			if (n->is_leaf) \n			printf("%x ", n->pointers[order - 1]);\n			else\n			printf("%x ", n->pointers[n->num_keys]);\n		}\n		printf("| ");\n	}\n	printf("\n");\n}\n\n/* Traces the path from the root to a leaf, searching by key.  Displays information about the path if the verbose flag is set. Returns the leaf containing the given key. */\nnode *\nfind_leaf( node* root, int key, bool verbose ) \n{\n\n	int i = 0;\n	node * c = root;\n	if (c == NULL) {\n		if (verbose) \n			printf("Empty tree.\n");\n		return c;\n	}\n	while (!c->is_leaf) {\n		if (verbose) {\n			printf("[");\n			for (i = 0; i < c->num_keys - 1; i++)\n				printf("%d ", c->keys[i]);\n			printf("%d] ", c->keys[i]);\n		}\n		i = 0;\n		while (i < c->num_keys) {\n			if (key >= c->keys[i]) \n				i++;\n			else \n				break;\n		}\n		if (verbose)\n			printf("%d ->\n", i);\n		c = (node *)c->pointers[i];\n	}\n	if (verbose) {\n		printf("Leaf [");\n		for (i = 0; i < c->num_keys - 1; i++)\n			printf("%d ", c->keys[i]);\n		printf("%d] ->\n", c->keys[i]);\n	}\n	return c;\n\n}\n\n/* Finds and returns the record to which a key refers. */\nrecord *\nfind( node* root, int key, bool verbose ) \n{\n\n	int i = 0;\n	node * c = find_leaf( root, key, verbose );\n	if (c == NULL) \n		return NULL;\n	for (i = 0; i < c->num_keys; i++)\n		if (c->keys[i] == key) \n			break;\n	if (i == c->num_keys) \n		return NULL;\n	else\n		return (record *)c->pointers[i];\n\n}\n\n/* Finds the appropriate place to split a node that is too big into two. */\nint \ncut( int length ) \n{\n	if (length % 2 == 0)\n	return length/2;\n	else\n	return length/2 + 1;\n}\n\n//======================================================================================================================================================150\n// INSERTION\n//======================================================================================================================================================150\n\n/* Creates a new record to hold the value to which a key refers. */\nrecord *\nmake_record(int value) \n{\n	record * new_record = (record *)malloc(sizeof(record));\n	if (new_record == NULL) {\n		perror("Record creation.");\n		exit(EXIT_FAILURE);\n	}\n	else {\n		new_record->value = value;\n	}\n	return new_record;\n}\n\n/* Creates a new general node, which can be adapted to serve as either a leaf or an internal node. */\nnode *\nmake_node( void ) \n{\n	node * new_node;\n	new_node = (node *) malloc(sizeof(node));\n	if (new_node == NULL) {\n		perror("Node creation.");\n		exit(EXIT_FAILURE);\n	}\n	new_node->keys = (int *) malloc( (order - 1) * sizeof(int) );\n	if (new_node->keys == NULL) {\n		perror("New node keys array.");\n		exit(EXIT_FAILURE);\n	}\n	new_node->pointers = (void **) malloc( order * sizeof(void *) );\n	if (new_node->pointers == NULL) {\n		perror("New node pointers array.");\n		exit(EXIT_FAILURE);\n	}\n	new_node->is_leaf = false;\n	new_node->num_keys = 0;\n	new_node->parent = NULL;\n	new_node->next = NULL;\n	return new_node;\n}\n\n/* Creates a new leaf by creating a node and then adapting it appropriately. */\nnode *\nmake_leaf( void ) \n{\n	node* leaf = make_node();\n	leaf->is_leaf = true;\n	return leaf;\n}\n\n/* Helper function used in insert_into_parent to find the index of the parent's pointer to the node to the left of the key to be inserted. */\nint \nget_left_index(node* parent, node* left) \n{\n\n	int left_index = 0;\n	while (left_index <= parent->num_keys && \n	parent->pointers[left_index] != left)\n	left_index++;\n	return left_index;\n}\n\n/* Inserts a new pointer to a record and its corresponding key into a leaf. Returns the altered leaf. */\nnode *\ninsert_into_leaf( node* leaf, int key, record* pointer ) \n{\n\n	int i, insertion_point;\n\n	insertion_point = 0;\n	while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)\n	insertion_point++;\n\n	for (i = leaf->num_keys; i > insertion_point; i--) {\n		leaf->keys[i] = leaf->keys[i - 1];\n		leaf->pointers[i] = leaf->pointers[i - 1];\n	}\n	leaf->keys[insertion_point] = key;\n	leaf->pointers[insertion_point] = pointer;\n	leaf->num_keys++;\n	return leaf;\n}\n\n/* Inserts a new key and pointer to a new record into a leaf so as to exceed the tree's order, causing the leaf to be split in half. */\nnode *\ninsert_into_leaf_after_splitting(	node* root, \n									node* leaf, \n									int key, \n									record* pointer) \n{\n\n	node * new_leaf;\n	int * temp_keys;\n	void ** temp_pointers;\n	int insertion_index, split, new_key, i, j;\n\n	new_leaf = make_leaf();\n\n	temp_keys = (int *) malloc( order * sizeof(int) );\n	if (temp_keys == NULL) {\n		perror("Temporary keys array.");\n		exit(EXIT_FAILURE);\n	}\n\n	temp_pointers = (void **) malloc( order * sizeof(void *) );\n	if (temp_pointers == NULL) {\n		perror("Temporary pointers array.");\n		exit(EXIT_FAILURE);\n	}\n\n	insertion_index = 0;\n	while (leaf->keys[insertion_index] < key && insertion_index < order - 1)\n	insertion_index++;\n\n	for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {\n		if (j == insertion_index) j++;\n		temp_keys[j] = leaf->keys[i];\n		temp_pointers[j] = leaf->pointers[i];\n	}\n\n	temp_keys[insertion_index] = key;\n	temp_pointers[insertion_index] = pointer;\n\n	leaf->num_keys = 0;\n\n	split = cut(order - 1);\n\n	for (i = 0; i < split; i++) {\n		leaf->pointers[i] = temp_pointers[i];\n		leaf->keys[i] = temp_keys[i];\n		leaf->num_keys++;\n	}\n\n	for (i = split, j = 0; i < order; i++, j++) {\n		new_leaf->pointers[j] = temp_pointers[i];\n		new_leaf->keys[j] = temp_keys[i];\n		new_leaf->num_keys++;\n	}\n\n	free(temp_pointers);\n	free(temp_keys);\n\n	new_leaf->pointers[order - 1] = leaf->pointers[order - 1];\n	leaf->pointers[order - 1] = new_leaf;\n\n	for (i = leaf->num_keys; i < order - 1; i++)\n	leaf->pointers[i] = NULL;\n	for (i = new_leaf->num_keys; i < order - 1; i++)\n	new_leaf->pointers[i] = NULL;\n\n	new_leaf->parent = leaf->parent;\n	new_key = new_leaf->keys[0];\n\n	return insert_into_parent(root, leaf, new_key, new_leaf);\n}\n\n/* Inserts a new key and pointer to a node into a node into which these can fit without violating the B+ tree properties. */\nnode *\ninsert_into_node(	node* root, \n					node* n, \n					int left_index, \n					int key, \n					node* right) \n{\n\n	int i;\n\n	for (i = n->num_keys; i > left_index; i--) {\n		n->pointers[i + 1] = n->pointers[i];\n		n->keys[i] = n->keys[i - 1];\n	}\n	n->pointers[left_index + 1] = right;\n	n->keys[left_index] = key;\n	n->num_keys++;\n	return root;\n}\n\n/* Inserts a new key and pointer to a node into a node, causing the node's size to exceed the order, and causing the node to split into two. */\nnode *\ninsert_into_node_after_splitting(	node* root, \n									node* old_node, \n									int left_index, \n									int key, \n									node * right) \n{\n\n	int i, j, split, k_prime;\n	node * new_node, * child;\n	int * temp_keys;\n	node ** temp_pointers;\n\n	/* First create a temporary set of keys and pointers\n* to hold everything in order, including\n* the new key and pointer, inserted in their\n* correct places. \n* Then create a new node and copy half of the \n* keys and pointers to the old node and\n* the other half to the new.\n*/\n\n	temp_pointers = (node **) malloc( (order + 1) * sizeof(node *) );\n	if (temp_pointers == NULL) {\n		perror("Temporary pointers array for splitting nodes.");\n		exit(EXIT_FAILURE);\n	}\n	temp_keys = (int *) malloc( order * sizeof(int) );\n	if (temp_keys == NULL) {\n		perror("Temporary keys array for splitting nodes.");\n		exit(EXIT_FAILURE);\n	}\n\n	for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {\n		if (j == left_index + 1) j++;\n		temp_pointers[j] = (node *) old_node->pointers[i];\n	}\n\n	for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {\n		if (j == left_index) j++;\n		temp_keys[j] = old_node->keys[i];\n	}\n\n	temp_pointers[left_index + 1] = right;\n	temp_keys[left_index] = key;\n\n	/* Create the new node and copy\n* half the keys and pointers to the\n* old and half to the new.\n*/  \n	split = cut(order);\n	new_node = make_node();\n	old_node->num_keys = 0;\n	for (i = 0; i < split - 1; i++) {\n		old_node->pointers[i] = temp_pointers[i];\n		old_node->keys[i] = temp_keys[i];\n		old_node->num_keys++;\n	}\n	old_node->pointers[i] = temp_pointers[i];\n	k_prime = temp_keys[split - 1];\n	for (++i, j = 0; i < order; i++, j++) {\n		new_node->pointers[j] = temp_pointers[i];\n		new_node->keys[j] = temp_keys[i];\n		new_node->num_keys++;\n	}\n	new_node->pointers[j] = temp_pointers[i];\n	free(temp_pointers);\n	free(temp_keys);\n	new_node->parent = old_node->parent;\n	for (i = 0; i <= new_node->num_keys; i++) {\n		child = (node *) new_node->pointers[i];\n		child->parent = new_node;\n	}\n\n	/* Insert a new key into the parent of the two\n* nodes resulting from the split, with\n* the old node to the left and the new to the right.\n*/\n\n	return insert_into_parent(root, old_node, k_prime, new_node);\n}\n\n/* Inserts a new node (leaf or internal node) into the B+ tree. Returns the root of the tree after insertion. */\nnode *\ninsert_into_parent(	node* root, \n					node* left, \n					int key, \n					node* right) \n{\n\n	int left_index;\n	node * parent;\n\n	parent = left->parent;\n\n	/* Case: new root. */\n\n	if (parent == NULL)\n	return insert_into_new_root(left, key, right);\n\n	/* Case: leaf or node. (Remainder of\n* function body.)  \n*/\n\n	/* Find the parent's pointer to the left \n* node.\n*/\n\n	left_index = get_left_index(parent, left);\n\n\n	/* Simple case: the new key fits into the node. \n*/\n\n	if (parent->num_keys < order - 1)\n	return insert_into_node(root, parent, left_index, key, right);\n\n	/* Harder case:  split a node in order \n* to preserve the B+ tree properties.\n*/\n\n	return insert_into_node_after_splitting(root, parent, left_index, key, right);\n}\n\n/* Creates a new root for two subtrees and inserts the appropriate key into the new root. */\nnode *\ninsert_into_new_root(	node* left, \n						int key, \n						node* right) \n{\n\n	node * root = make_node();\n	root->keys[0] = key;\n	root->pointers[0] = left;\n	root->pointers[1] = right;\n	root->num_keys++;\n	root->parent = NULL;\n	left->parent = root;\n	right->parent = root;\n	return root;\n}\n\n/* First insertion: start a new tree. */\nnode *\nstart_new_tree(	int key, \n				record* pointer) \n{\n\n	node * root = make_leaf();\n	root->keys[0] = key;\n	root->pointers[0] = pointer;\n	root->pointers[order - 1] = NULL;\n	root->parent = NULL;\n	root->num_keys++;\n	return root;\n}\n\n/* Master insertion function. Inserts a key and an associated value into the B+ tree, causing the tree to be adjusted however necessary to maintain the B+ tree properties. */\nnode *\ninsert(	node* root, \n		int key, \n		int value ) \n{\n\n	record* pointer;\n	node* leaf;\n\n	/* The current implementation ignores duplicates. */\n	if (find(root, key, false) != NULL)\n		return root;\n\n	/* Create a new record for the value. */\n	pointer = make_record(value);\n\n	/* Case: the tree does not exist yet. Start a new tree. */\n	if (root == NULL) \n		return start_new_tree(key, pointer);\n\n	/* Case: the tree already exists. (Rest of function body.) */\n	leaf = find_leaf(root, key, false);\n\n	/* Case: leaf has room for key and pointer. */\n	if (leaf->num_keys < order - 1) {\n		leaf = insert_into_leaf(leaf, key, pointer);\n		return root;\n	}\n\n	/* Case:  leaf must be split. */\n	return insert_into_leaf_after_splitting(root, leaf, key, pointer);\n}\n\n//======================================================================================================================================================150\n// DELETION\n//======================================================================================================================================================150\n\n/* Utility function for deletion. Retrieves the index of a node's nearest neighbor (sibling) to the left if one exists.  If not (the node is the leftmost child), returns -1 to signify this special case. */\nint \nget_neighbor_index( node* n ) \n{\n\n	int i;\n\n	/* Return the index of the key to the left\n* of the pointer in the parent pointing\n* to n.  \n* If n is the leftmost child, this means\n* return -1.\n*/\n	for (i = 0; i <= n->parent->num_keys; i++)\n	if (n->parent->pointers[i] == n)\n	return i - 1;\n\n	// Error state.\n	printf("Search for nonexistent pointer to node in parent.\n");\n	//printf("Node:  %#x\n", (unsigned int)n);\n	exit(EXIT_FAILURE);\n}\n\n/*   */\nnode* \nremove_entry_from_node(	node* n, \n						int key, \n						node * pointer) \n{\n\n	int i, num_pointers;\n\n	// Remove the key and shift other keys accordingly.\n	i = 0;\n	while (n->keys[i] != key)\n	i++;\n	for (++i; i < n->num_keys; i++)\n	n->keys[i - 1] = n->keys[i];\n\n	// Remove the pointer and shift other pointers accordingly.\n	// First determine number of pointers.\n	num_pointers = n->is_leaf ? n->num_keys : n->num_keys + 1;\n	i = 0;\n	while (n->pointers[i] != pointer)\n	i++;\n	for (++i; i < num_pointers; i++)\n	n->pointers[i - 1] = n->pointers[i];\n\n\n	// One key fewer.\n	n->num_keys--;\n\n	// Set the other pointers to NULL for tidiness.\n	// A leaf uses the last pointer to point to the next leaf.\n	if (n->is_leaf)\n	for (i = n->num_keys; i < order - 1; i++)\n	n->pointers[i] = NULL;\n	else\n	for (i = n->num_keys + 1; i < order; i++)\n	n->pointers[i] = NULL;\n\n	return n;\n}\n\n/*   */\nnode* \nadjust_root(node* root) \n{\n\n	node * new_root;\n\n	/* Case: nonempty root.\n* Key and pointer have already been deleted,\n* so nothing to be done.\n*/\n\n	if (root->num_keys > 0)\n	return root;\n\n	/* Case: empty root. \n*/\n\n	// If it has a child, promote \n	// the first (only) child\n	// as the new root.\n\n	if (!root->is_leaf) {\n		new_root = (node *) root->pointers[0];\n		new_root->parent = NULL;\n	}\n\n	// If it is a leaf (has no children),\n	// then the whole tree is empty.\n\n	else\n	new_root = NULL;\n\n	free(root->keys);\n	free(root->pointers);\n	free(root);\n\n	return new_root;\n}\n\n/* Coalesces a node that has become too small after deletion with a neighboring node that can accept the additional entries without exceeding the maximum. */\nnode* \ncoalesce_nodes(	node* root, \n				node* n, \n				node* neighbor, \n				int neighbor_index, \n				int k_prime) \n				{\n\n	int i, j, neighbor_insertion_index, n_start, n_end, new_k_prime;\n	node * tmp;\n	bool split;\n\n	/* Swap neighbor with node if node is on the\n* extreme left and neighbor is to its right.\n*/\n\n	if (neighbor_index == -1) {\n		tmp = n;\n		n = neighbor;\n		neighbor = tmp;\n	}\n\n	/* Starting point in the neighbor for copying\n* keys and pointers from n.\n* Recall that n and neighbor have swapped places\n* in the special case of n being a leftmost child.\n*/\n\n	neighbor_insertion_index = neighbor->num_keys;\n	\n	/*\n* Nonleaf nodes may sometimes need to remain split,\n* if the insertion of k_prime would cause the resulting\n* single coalesced node to exceed the limit order - 1.\n* The variable split is always false for leaf nodes\n* and only sometimes set to true for nonleaf nodes.\n*/\n\n	split = false;\n\n	/* Case:  nonleaf node.\n* Append k_prime and the following pointer.\n* If there is room in the neighbor, append\n* all pointers and keys from the neighbor.\n* Otherwise, append only cut(order) - 2 keys and\n* cut(order) - 1 pointers.\n*/\n\n	if (!n->is_leaf) {\n\n		/* Append k_prime.\n	*/\n\n		neighbor->keys[neighbor_insertion_index] = k_prime;\n		neighbor->num_keys++;\n\n\n		/* Case (default):  there is room for all of n's keys and pointers\n	* in the neighbor after appending k_prime.\n	*/\n\n		n_end = n->num_keys;\n\n		/* Case (special): k cannot fit with all the other keys and pointers\n	* into one coalesced node.\n	*/\n		n_start = 0; // Only used in this special case.\n		if (n->num_keys + neighbor->num_keys >= order) {\n			split = true;\n			n_end = cut(order) - 2;\n		}\n\n		for (i = neighbor_insertion_index + 1, j = 0; j < n_end; i++, j++) {\n			neighbor->keys[i] = n->keys[j];\n			neighbor->pointers[i] = n->pointers[j];\n			neighbor->num_keys++;\n			n->num_keys--;\n			n_start++;\n		}\n\n		/* The number of pointers is always\n	* one more than the number of keys.\n	*/\n\n		neighbor->pointers[i] = n->pointers[j];\n\n		/* If the nodes are still split, remove the first key from\n	* n.\n	*/\n		if (split) {\n			new_k_prime = n->keys[n_start];\n			for (i = 0, j = n_start + 1; i < n->num_keys; i++, j++) {\n				n->keys[i] = n->keys[j];\n				n->pointers[i] = n->pointers[j];\n			}\n			n->pointers[i] = n->pointers[j];\n			n->num_keys--;\n		}\n\n		/* All children must now point up to the same parent.\n	*/\n\n		for (i = 0; i < neighbor->num_keys + 1; i++) {\n			tmp = (node *)neighbor->pointers[i];\n			tmp->parent = neighbor;\n		}\n	}\n\n	/* In a leaf, append the keys and pointers of\n* n to the neighbor.\n* Set the neighbor's last pointer to point to\n* what had been n's right neighbor.\n*/\n\n	else {\n		for (i = neighbor_insertion_index, j = 0; j < n->num_keys; i++, j++) {\n			neighbor->keys[i] = n->keys[j];\n			neighbor->pointers[i] = n->pointers[j];\n			neighbor->num_keys++;\n		}\n		neighbor->pointers[order - 1] = n->pointers[order - 1];\n	}\n\n	if (!split) {\n		root = delete_entry(root, n->parent, k_prime, n);\n		free(n->keys);\n		free(n->pointers);\n		free(n); \n	}\n	else\n	for (i = 0; i < n->parent->num_keys; i++)\n	if (n->parent->pointers[i + 1] == n) {\n		n->parent->keys[i] = new_k_prime;\n		break;\n	}\n\n	return root;\n\n}\n\n/* Redistributes entries between two nodes when one has become too small after deletion but its neighbor is too big to append the small node's entries without exceeding the maximum */\nnode* \nredistribute_nodes(	node* root, \n					node* n, \n					node* neighbor, \n					int neighbor_index, \n					int k_prime_index, \n					int k_prime) \n{  \n\n	int i;\n	node * tmp;\n\n	/* Case: n has a neighbor to the left. \n* Pull the neighbor's last key-pointer pair over\n* from the neighbor's right end to n's left end.\n*/\n\n	if (neighbor_index != -1) {\n		if (!n->is_leaf)\n		n->pointers[n->num_keys + 1] = n->pointers[n->num_keys];\n		for (i = n->num_keys; i > 0; i--) {\n			n->keys[i] = n->keys[i - 1];\n			n->pointers[i] = n->pointers[i - 1];\n		}\n		if (!n->is_leaf) {\n			n->pointers[0] = neighbor->pointers[neighbor->num_keys];\n			tmp = (node *)n->pointers[0];\n			tmp->parent = n;\n			neighbor->pointers[neighbor->num_keys] = NULL;\n			n->keys[0] = k_prime;\n			n->parent->keys[k_prime_index] = neighbor->keys[neighbor->num_keys - 1];\n		}\n		else {\n			n->pointers[0] = neighbor->pointers[neighbor->num_keys - 1];\n			neighbor->pointers[neighbor->num_keys - 1] = NULL;\n			n->keys[0] = neighbor->keys[neighbor->num_keys - 1];\n			n->parent->keys[k_prime_index] = n->keys[0];\n		}\n	}\n\n	/* Case: n is the leftmost child.\n* Take a key-pointer pair from the neighbor to the right.\n* Move the neighbor's leftmost key-pointer pair\n* to n's rightmost position.\n*/\n\n	else {  \n		if (n->is_leaf) {\n			n->keys[n->num_keys] = neighbor->keys[0];\n			n->pointers[n->num_keys] = neighbor->pointers[0];\n			n->parent->keys[k_prime_index] = neighbor->keys[1];\n		}\n		else {\n			n->keys[n->num_keys] = k_prime;\n			n->pointers[n->num_keys + 1] = neighbor->pointers[0];\n			tmp = (node *)n->pointers[n->num_keys + 1];\n			tmp->parent = n;\n			n->parent->keys[k_prime_index] = neighbor->keys[0];\n		}\n		for (i = 0; i < neighbor->num_keys; i++) {\n			neighbor->keys[i] = neighbor->keys[i + 1];\n			neighbor->pointers[i] = neighbor->pointers[i + 1];\n		}\n		if (!n->is_leaf)\n		neighbor->pointers[i] = neighbor->pointers[i + 1];\n	}\n\n	/* n now has one more key and one more pointer;\n* the neighbor has one fewer of each.\n*/\n\n	n->num_keys++;\n	neighbor->num_keys--;\n\n	return root;\n}\n\n/* Deletes an entry from the B+ tree. Removes the record and its key and pointer from the leaf, and then makes all appropriate changes to preserve the B+ tree properties. */\nnode* \ndelete_entry(	node* root, \n				node* n, \n				int key, \n				void* pointer ) \n{\n\n	int min_keys;\n	node * neighbor;\n	int neighbor_index;\n	int k_prime_index, k_prime;\n	int capacity;\n\n	// Remove key and pointer from node.\n\n	n = remove_entry_from_node(n, key, (node *) pointer);\n\n	/* Case:  deletion from the root. \n*/\n\n	if (n == root) \n	return adjust_root(root);\n\n\n	/* Case:  deletion from a node below the root.\n* (Rest of function body.)\n*/\n\n	/* Determine minimum allowable size of node,\n* to be preserved after deletion.\n*/\n\n	min_keys = n->is_leaf ? cut(order - 1) : cut(order) - 1;\n\n	/* Case:  node stays at or above minimum.\n* (The simple case.)\n*/\n\n	if (n->num_keys >= min_keys)\n	return root;\n\n	/* Case:  node falls below minimum.\n* Either coalescence or redistribution\n* is needed.\n*/\n\n	/* Find the appropriate neighbor node with which\n* to coalesce.\n* Also find the key (k_prime) in the parent\n* between the pointer to node n and the pointer\n* to the neighbor.\n*/\n\n	neighbor_index = get_neighbor_index( n );\n	k_prime_index = neighbor_index == -1 ? 0 : neighbor_index;\n	k_prime = n->parent->keys[k_prime_index];\n	neighbor = neighbor_index == -1 ? (node *) n->parent->pointers[1] : \n	(node *)n->parent->pointers[neighbor_index];\n\n	capacity = n->is_leaf ? order : order - 1;\n\n	/* Coalescence. */\n\n	if (neighbor->num_keys + n->num_keys < capacity)\n	return coalesce_nodes(root, n, neighbor, neighbor_index, k_prime);\n\n	/* Redistribution. */\n\n	else\n	return redistribute_nodes(root, n, neighbor, neighbor_index, k_prime_index, k_prime);\n}\n\n/* Master deletion function. */\nnode* \ndeleteVal(	node* root, \n			int key) \n{\n\n	node * key_leaf;\n	record * key_record;\n\n	key_record = find(root, key, false);\n	key_leaf = find_leaf(root, key, false);\n	if (key_record != NULL && key_leaf != NULL) {\n		free(key_record);\n		root = delete_entry(root, key_leaf, key, key_record);\n	}\n	return root;\n}\n\n/*   */\nvoid \ndestroy_tree_nodes(node* root) \n{\n	int i;\n	if (root->is_leaf)\n	for (i = 0; i < root->num_keys; i++)\n	free(root->pointers[i]);\n	else\n	for (i = 0; i < root->num_keys + 1; i++)\n	destroy_tree_nodes((node *) root->pointers[i]);\n	free(root->pointers);\n	free(root->keys);\n	free(root);\n}\n\n/*   */\nnode* \ndestroy_tree(node* root) \n{\n	destroy_tree_nodes(root);\n	return NULL;\n}\n\n//======================================================================================================================================================150\n//	END\n//======================================================================================================================================================150\n\n//========================================================================================================================================================================================================200\n//	MAIN FUNCTION\n//========================================================================================================================================================================================================200\n\nint \nmain(	int argc, \n		char** argv ) \n{\n	// assing default values\n	int cur_arg;\n	int cores_arg =1;\n	char *input_file = NULL;\n	char *command_file = NULL;\n	char *output="output.txt";\n	FILE * pFile;\n\n\n	// go through arguments\n	for(cur_arg=1; cur_arg<argc; cur_arg++){\n	  if(strcmp(argv[cur_arg], "cores")==0){\n	    // check if value provided\n	    if(argc>=cur_arg+1){\n	      // check if value is a number\n	      if(isInteger(argv[cur_arg+1])==1){\n		cores_arg = atoi(argv[cur_arg+1]);\n		if(cores_arg<0){\n		  printf("ERROR: Wrong value to cores parameter, cannot be <=0\n");\n		  return -1;\n		}\n		cur_arg = cur_arg+1;\n	      }\n	      // value is not a number\n	      else{\n		printf("ERROR: Value to cores parameter in not a number\n");\n		return 0;\n	      }\n	    }\n	  }\n	  // check if -file\n	  else if(strcmp(argv[cur_arg], "file")==0){\n	    // check if value provided\n	    if(argc>=cur_arg+1){\n	      input_file = argv[cur_arg+1];\n	      cur_arg = cur_arg+1;\n	      // value is not a number\n	    }\n	    // value not provided\n	    else{\n	      printf("ERROR: Missing value to -file parameter\n");\n	      return -1;\n	    }\n	  }\n	  else if(strcmp(argv[cur_arg], "command")==0){\n	    // check if value provided\n	    if(argc>=cur_arg+1){\n	      command_file = argv[cur_arg+1];\n	      cur_arg = cur_arg+1;\n	      // value is not a number\n	    }\n	    // value not provided\n	    else{\n	      printf("ERROR: Missing value to command parameter\n");\n	      return -1;\n	    }\n	  }\n	}\n	// Print configuration\n	  if((input_file==NULL)||(command_file==NULL))\n	    printf("Usage: ./b+tree file input_file command command_list\n");\n\n	  // For debug\n	  printf("Input File: %s \n", input_file);\n	  printf("Command File: %s \n", command_file);\n\n     FILE * commandFile;\n     long lSize;\n     char * commandBuffer;\n     size_t result;\n\n     commandFile = fopen ( command_file, "rb" );\n     if (commandFile==NULL) {fputs ("Command File error",stderr); exit (1);}\n     \n     // obtain file size:\n     fseek (commandFile , 0 , SEEK_END);\n     lSize = ftell (commandFile);\n     rewind (commandFile);\n\n     // allocate memory to contain the whole file:\n     commandBuffer = (char*) malloc (sizeof(char)*lSize);\n     if (commandBuffer == NULL) {fputs ("Command Buffer memory error",stderr); exit (2);}\n     \n     // copy the file into the buffer:\n     result = fread (commandBuffer,1,lSize,commandFile);\n     if (result != lSize) {fputs ("Command file reading error",stderr); exit (3);}\n\n     /* the whole file is now loaded in the memory buffer. */\n\n  // terminate\n     fclose (commandFile);\n\n     // For Debug\n     char *sPointer=commandBuffer;\n     printf("Command Buffer: \n");\n     printf("%s",commandBuffer);\n     //\n\n\n     pFile = fopen (output,"w+");\n     if (pFile==NULL) \n       fputs ("Fail to open %s !\n",output);\n     fprintf(pFile,"******starting******\n");\n     fclose(pFile);\n\n\n	// ------------------------------------------------------------60\n	// general variables\n	// ------------------------------------------------------------60\n\n	FILE *file_pointer;\n	node *root;\n	root = NULL;\n	record *r;\n	int input;\n	char instruction;\n	order = DEFAULT_ORDER;\n	verbose_output = false;\n\n	//usage_1();  \n	//usage_2();\n\n	// ------------------------------------------------------------60\n	// get input from file, if file provided\n	// ------------------------------------------------------------60\n\n	if (input_file != NULL) {\n\n		printf("Getting input from file %s...\n", argv[1]);\n\n		// open input file\n		file_pointer = fopen(input_file, "r");\n		if (file_pointer == NULL) {\n			perror("Failure to open input file.");\n			exit(EXIT_FAILURE);\n		}\n\n		// get # of numbers in the file\n		fscanf(file_pointer, "%d\n", &input);\n		size = input;\n\n		// save all numbers\n		while (!feof(file_pointer)) {\n			fscanf(file_pointer, "%d\n", &input);\n			root = insert(root, input, input);\n		}\n\n		// close file\n		fclose(file_pointer);\n		//print_tree(root);\n		//printf("Height of tree = %d\n", height(root));\n\n	}\n	else{\n		printf("ERROR: Argument -file missing\n");\n		return 0;\n	}\n\n	// ------------------------------------------------------------60\n	// get tree statistics\n	// ------------------------------------------------------------60\n\n	printf("Transforming data to a GPU suitable structure...\n");\n	long mem_used = transform_to_cuda(root,0);\n	maxheight = height(root);\n	long rootLoc = (long)knodes - (long)mem;\n\n	// ------------------------------------------------------------60\n	// process commands\n	// ------------------------------------------------------------60\n	char *commandPointer=commandBuffer;\n\n	printf("Waiting for command\n");\n	printf("> ");\n	while (sscanf(commandPointer, "%c", &instruction) != EOF) {\n	  commandPointer++;\n		switch (instruction) {\n			// ----------------------------------------40\n			// Insert\n			// ----------------------------------------40\n\n			case 'i':\n			{\n				scanf("%d", &input);\n				while (getchar() != (int)'\n');\n				root = insert(root, input, input);\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// n/a\n			// ----------------------------------------40\n\n			case 'f':\n			{\n			}\n\n			// ----------------------------------------40\n			// find\n			// ----------------------------------------40\n\n			case 'p':\n			{\n				scanf("%d", &input);\n				while (getchar() != (int)'\n');\n				r = find(root, input, instruction == 'p');\n				if (r == NULL)\n				printf("Record not found under key %d.\n", input);\n				else \n				printf("Record found: %d\n",r->value);\n				break;\n			}\n\n			// ----------------------------------------40\n			// delete value\n			// ----------------------------------------40\n\n			case 'd':\n			{\n				scanf("%d", &input);\n				while (getchar() != (int)'\n');\n				root = (node *) deleteVal(root, input);\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// destroy tree\n			// ----------------------------------------40\n\n			case 'x':\n			{\n				while (getchar() != (int)'\n');\n				root = destroy_tree(root);\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// print leaves\n			// ----------------------------------------40\n\n			case 'l':\n			{\n				while (getchar() != (int)'\n');\n				print_leaves(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// print tree\n			// ----------------------------------------40\n\n			case 't':\n			{\n				while (getchar() != (int)'\n');\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// toggle verbose output\n			// ----------------------------------------40\n\n			case 'v':\n			{\n				while (getchar() != (int)'\n');\n				verbose_output = !verbose_output;\n				break;\n			}\n\n			// ----------------------------------------40\n			// quit\n			// ----------------------------------------40\n\n			case 'q':\n			{\n				while (getchar() != (int)'\n');\n				return EXIT_SUCCESS;\n			}\n\n			// ----------------------------------------40\n			// [OpenMP] find K (initK, findK)\n			// ----------------------------------------40\n\n			case 'k':\n			{\n\n				// get # of queries from user\n				int count;\n				sscanf(commandPointer, "%d", &count);\n				while(*commandPointer!=32 && commandPointer!='\n')\n				  commandPointer++;\n\n				printf("\n ******command: k count=%d \n",count);\n\n				if(count > 65535){\n					printf("ERROR: Number of requested querries should be 65,535 at most. (limited by # of CUDA blocks)\n");\n					exit(0);\n				}\n\n				// INPUT: records CPU allocation (setting pointer in mem variable)\n				record *records = (record *)mem;\n				long records_elem = (long)rootLoc / sizeof(record);\n				long records_mem = (long)rootLoc;\n				// printf("records_elem=%d, records_unit_mem=%d, records_mem=%d\n", (int)records_elem, sizeof(record), (int)records_mem);\n\n				// INPUT: knodes CPU allocation (setting pointer in mem variable)\n				knode *knodes = (knode *)((long)mem + (long)rootLoc);\n				long knodes_elem = ((long)(mem_used) - (long)rootLoc) / sizeof(knode);\n				long knodes_mem = (long)(mem_used) - (long)rootLoc;\n				// printf("knodes_elem=%d, knodes_unit_mem=%d, knodes_mem=%d\n", (int)knodes_elem, sizeof(knode), (int)knodes_mem);\n\n				// INPUT: currKnode CPU allocation\n				long *currKnode;\n				currKnode = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset(currKnode, 0, count*sizeof(long));\n\n				// INPUT: offset CPU allocation\n				long *offset;\n				offset = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset(offset, 0, count*sizeof(long));\n\n				// INPUT: keys CPU allocation\n				int *keys;\n				keys = (int *)malloc(count*sizeof(int));\n				// INPUT: keys CPU initialization\n				int i;\n				for(i = 0; i < count; i++){\n					keys[i] = (rand()/(float)RAND_MAX)*size;\n				}\n\n				// OUTPUT: ans CPU allocation\n				record *ans = (record *)malloc(sizeof(record)*count);\n				// OUTPUT: ans CPU initialization\n				for(i = 0; i < count; i++){\n					ans[i].value = -1;\n				}\n\n				// New OpenMP kernel, same algorighm across all versions(OpenMP, CUDA, OpenCL) for comparison purposes\n				kernel_cpu(	cores_arg,\n\n							records,\n							knodes,\n							knodes_elem,\n\n							order,\n							maxheight,\n							count,\n\n							currKnode,\n							offset,\n							keys,\n							ans);\n\n				// Original OpenMP kernel, different algorithm\n				// int j;\n				// for(j = 0; j < count; j++){\n					// find(	root,				// node *\n\n							// keys[j],			// int\n							// false);				// bool\n				// }\n\n\n				pFile = fopen (output,"aw+");\n				if (pFile==NULL)\n				  {\n				    fputs ("Fail to open %s !\n",output);\n				  }\n				\n				fprintf(pFile,"\n ******command: k count=%d \n",count);\n				for(i = 0; i < count; i++){\n				  fprintf(pFile, "%d    %d\n",i, ans[i].value);\n				}\n				fprintf(pFile, " \n");\n                                fclose(pFile);\n\n				// free memory\n				free(currKnode);\n				free(offset);\n				free(keys);\n				free(ans);\n\n				// break out of case\n				break;\n\n			}\n\n			// ----------------------------------------40\n			// find range\n			// ----------------------------------------40\n\n			case 'r':\n			{\n				int start, end;\n				scanf("%d", &start);\n				scanf("%d", &end);\n				if(start > end){\n					input = start;\n					start = end;\n					end = input;\n				}\n				printf("For range %d to %d, ",start,end);\n				list_t * ansList;\n				ansList = findRange(root, start, end);\n				printf("%d records found\n", list_get_length(ansList));\n				//list_iterator_t iter;\n				free(ansList);\n				break;\n			}\n\n			// ----------------------------------------40\n			// [OpenMP] find Range K (initK, findRangeK)\n			// ----------------------------------------40\n\n			case 'j':\n			{\n\n				// get # of queries from user\n				int count;\n				sscanf(commandPointer, "%d", &count);\n				while(*commandPointer!=32 && commandPointer!='\n')\n				  commandPointer++;\n\n				int rSize;\n				sscanf(commandPointer, "%d", &rSize);\n				while(*commandPointer!=32 && commandPointer!='\n')\n				  commandPointer++;\n\n				printf("\n******command: j count=%d, rSize=%d \n",count, rSize);\n\n				if(rSize > size || rSize < 0) {\n					printf("Search range size is larger than data set size %d.\n", (int)size);\n					exit(0);\n				}\n\n				// INPUT: knodes CPU allocation (setting pointer in mem variable)\n				knode *knodes = (knode *)((long)mem + (long)rootLoc);\n				long knodes_elem = ((long)(mem_used) - (long)rootLoc) / sizeof(knode);\n				long knodes_mem = (long)(mem_used) - (long)rootLoc;\n				// printf("knodes_elem=%d, knodes_unit_mem=%d, knodes_mem=%d\n", (int)knodes_elem, sizeof(knode), (int)knodes_mem);\n\n				// INPUT: currKnode CPU allocation\n				long *currKnode;\n				currKnode = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (currKnode, 0, count*sizeof(long));\n\n				// INPUT: offset CPU allocation\n				long *offset;\n				offset = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (offset, 0, count*sizeof(long));\n\n				// INPUT: lastKnode CPU allocation\n				long *lastKnode;\n				lastKnode = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (lastKnode, 0, count*sizeof(long));\n\n				// INPUT: offset_2 CPU allocation\n				long *offset_2;\n				offset_2 = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (offset_2, 0, count*sizeof(long));\n\n				// INPUT: start, end CPU allocation\n				int *start;\n				start = (int *)malloc(count*sizeof(int));\n				int *end;\n				end = (int *)malloc(count*sizeof(int));\n				// INPUT: start, end CPU initialization\n				int i;\n				for(i = 0; i < count; i++){\n					start[i] = (rand()/(float)RAND_MAX)*size;\n					end[i] = start[i]+rSize;\n					if(end[i] >= size){ \n						start[i] = start[i] - (end[i] - size);\n						end[i]= size-1;\n					}\n				}\n\n				// INPUT: recstart, reclenght CPU allocation\n				int *recstart;\n				recstart = (int *)malloc(count*sizeof(int));\n				int *reclength;\n				reclength = (int *)malloc(count*sizeof(int));\n				// OUTPUT: ans CPU initialization\n				for(i = 0; i < count; i++){\n					recstart[i] = 0;\n					reclength[i] = 0;\n				}\n\n				// New kernel, same algorighm across all versions(OpenMP, CUDA, OpenCL) for comparison purposes\n				kernel_cpu_2(	cores_arg,\n\n								knodes,\n								knodes_elem,\n\n								order,\n								maxheight,\n								count,\n\n								currKnode,\n								offset,\n								lastKnode,\n								offset_2,\n								start,\n								end,\n								recstart,\n								reclength);\n\n				// Original [CPU] kernel, different algorithm\n				// int k;\n				// for(k = 0; k < count; k++){\n					// findRange(	root,\n\n								// start[k], \n								// end[k]);\n				// }\n				pFile = fopen (output,"aw+");\n				if (pFile==NULL)\n				  {\n				    fputs ("Fail to open %s !\n",output);\n				  }\n\n				fprintf(pFile,"\n******command: j count=%d, rSize=%d \n",count, rSize);				\n				for(i = 0; i < count; i++){\n				  fprintf(pFile, "%d    %d    %d\n",i, recstart[i],reclength[i]);\n				}\n				fprintf(pFile, " \n");\n                                fclose(pFile);\n\n				// free memory\n				free(currKnode);\n				free(offset);\n				free(lastKnode);\n				free(offset_2);\n				free(start);\n				free(end);\n				free(recstart);\n				free(reclength);\n\n				// break out of case\n				break;\n\n			}\n\n			// ----------------------------------------40\n			// default\n			// ----------------------------------------40\n\n			default:\n			{\n\n				//usage_2();\n				break;\n\n			}\n\n		}\n		printf("> ");\n\n	}\n	printf("\n");\n\n	// ------------------------------------------------------------60\n	// free remaining memory and exit\n	// ------------------------------------------------------------60\n\n	free(mem);\n	return EXIT_SUCCESS;\n\n}\n\n//========================================================================================================================================================================================================200\n//	END\n//========================================================================================================================================================================================================200\n\n// # ifdef __cplusplus\n// }\n// # endif\n