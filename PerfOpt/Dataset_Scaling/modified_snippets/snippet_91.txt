\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n/*\n		File containing routines for determining Hessenberg\n	factorisations.\n*/\n\nstatic	char	rcsid[] = "$Id: hessen.c,v 1.2 1994/01/13 05:36:24 des Exp $";\n\n#include	<stdio.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n\n\n/* Hfactor -- compute Hessenberg factorisation in compact form.\n	-- factorisation performed in situ\n	-- for details of the compact form see QRfactor.c and matrix2.doc */\n#ifndef ANSI_C\nMAT	*Hfactor(A, diag, beta)\nMAT	*A;\nVEC	*diag, *beta;\n#else\nMAT	*Hfactor(MAT *A, VEC *diag, VEC *beta)\n#endif\n{\n	STATIC	VEC	*hh = VNULL, *w = VNULL;\n	int	k, limit;\n\n	if ( ! A || ! diag || ! beta )\n		error(E_NULL,"Hfactor");\n	if ( diag->dim < A->m - 1 || beta->dim < A->m - 1 )\n		error(E_SIZES,"Hfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"Hfactor");\n	limit = A->m - 1;\n\n	hh = v_resize(hh,A->m);\n	w  = v_resize(w,A->n);\n	MEM_STAT_REG(hh,TYPE_VEC);\n	MEM_STAT_REG(w, TYPE_VEC);\n\n	for ( k = 0; k < limit; k++ )\n	  {\n	    /* compute the Householder vector hh */\n	    get_col(A,(unsigned int)k,hh);\n	    /* printf("the %d'th column = ");	v_output(hh); */\n	    hhvec(hh,k+1,&beta->ve[k],hh,&A->me[k+1][k]);\n	    /* diag->ve[k] = hh->ve[k+1]; */\n	    v_set_val(diag,k,v_entry(hh,k+1));\n	    /* printf("H/h vector = ");	v_output(hh); */\n	    /* printf("from the %d'th entry\n",k+1); */\n	    /* printf("beta = %g\n",beta->ve[k]); */\n\n	    /* apply Householder operation symmetrically to A */\n	    _hhtrcols(A,k+1,k+1,hh,v_entry(beta,k),w);\n	    hhtrrows(A,0  ,k+1,hh,v_entry(beta,k));\n	    /* printf("A = ");		m_output(A); */\n	  }\n\n#ifdef THREADSAFE\n	V_FREE(hh);	V_FREE(w);\n#endif\n\n	return (A);\n}\n\n/* makeHQ -- construct the Hessenberg orthogonalising matrix Q;\n	-- i.e. Hess M = Q.M.Q'	*/\n#ifndef ANSI_C\nMAT	*makeHQ(H, diag, beta, Qout)\nMAT	*H, *Qout;\nVEC	*diag, *beta;\n#else\nMAT	*makeHQ(MAT *H, VEC *diag, VEC *beta, MAT *Qout)\n#endif\n{\n	int	i, j, limit;\n	STATIC	VEC	*tmp1 = VNULL, *tmp2 = VNULL;\n\n	if ( H==(MAT *)NULL || diag==(VEC *)NULL || beta==(VEC *)NULL )\n		error(E_NULL,"makeHQ");\n	limit = H->m - 1;\n	if ( diag->dim < limit || beta->dim < limit )\n		error(E_SIZES,"makeHQ");\n	if ( H->m != H->n )\n		error(E_SQUARE,"makeHQ");\n	Qout = m_resize(Qout,H->m,H->m);\n\n	tmp1 = v_resize(tmp1,H->m);\n	tmp2 = v_resize(tmp2,H->m);\n	MEM_STAT_REG(tmp1,TYPE_VEC);\n	MEM_STAT_REG(tmp2,TYPE_VEC);\n\n	for ( i = 0; i < H->m; i++ )\n	{\n		/* tmp1 = i'th basis vector */\n		for ( j = 0; j < H->m; j++ )\n			/* tmp1->ve[j] = 0.0; */\n		    v_set_val(tmp1,j,0.0);\n		/* tmp1->ve[i] = 1.0; */\n		v_set_val(tmp1,i,1.0);\n\n		/* apply H/h transforms in reverse order */\n		for ( j = limit-1; j >= 0; j-- )\n		{\n			get_col(H,(unsigned int)j,tmp2);\n			/* tmp2->ve[j+1] = diag->ve[j]; */\n			v_set_val(tmp2,j+1,v_entry(diag,j));\n			hhtrvec(tmp2,beta->ve[j],j+1,tmp1,tmp1);\n		}\n\n		/* insert into Qout */\n		set_col(Qout,(unsigned int)i,tmp1);\n	}\n\n#ifdef THREADSAFE\n	V_FREE(tmp1);	V_FREE(tmp2);\n#endif\n\n	return (Qout);\n}\n\n/* makeH -- construct actual Hessenberg matrix */\n#ifndef ANSI_C\nMAT	*makeH(H,Hout)\nMAT	*H, *Hout;\n#else\nMAT	*makeH(const MAT *H, MAT *Hout)\n#endif\n{\n	int	i, j, limit;\n\n	if ( H==(MAT *)NULL )\n		error(E_NULL,"makeH");\n	if ( H->m != H->n )\n		error(E_SQUARE,"makeH");\n	Hout = m_resize(Hout,H->m,H->m);\n	Hout = m_copy(H,Hout);\n\n	limit = H->m;\n	for ( i = 1; i < limit; i++ )\n		for ( j = 0; j < i-1; j++ )\n			/* Hout->me[i][j] = 0.0;*/\n		    m_set_val(Hout,i,j,0.0);\n\n	return (Hout);\n}\n\n