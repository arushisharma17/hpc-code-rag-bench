\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains a series of tests for the Meschach matrix\n	library, complex routines\n*/\n\nstatic char rcsid[] = "$Id: $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include 	"zmatrix2.h"\n#include        "matlab.h"\n\n\n#define	errmesg(mesg)	printf("Error: %s error: line %d\n",mesg,__LINE__)\n#define notice(mesg)	printf("# Testing %s...\n",mesg);\n\n/* extern	int	malloc_chain_check(); */\n/* #define MEMCHK() if ( malloc_chain_check(0) ) \\n{ printf("Error in malloc chain: \"%s\", line %d\n", \\n	 __FILE__, __LINE__); exit(0); } */\n#define	MEMCHK()\n\n#define	checkpt()	printf("At line %d in file \"%s\"\n",__LINE__,__FILE__)\n\n/* cmp_perm -- returns 1 if pi1 == pi2, 0 otherwise */\nint	cmp_perm(pi1, pi2)\nPERM	*pi1, *pi2;\n{\n    int		i;\n\n    if ( ! pi1 || ! pi2 )\n	error(E_NULL,"cmp_perm");\n    if ( pi1->size != pi2->size )\n	return 0;\n    for ( i = 0; i < pi1->size; i++ )\n	if ( pi1->pe[i] != pi2->pe[i] )\n	    return 0;\n    return 1;\n}\n\n/* px_rand -- generates sort-of random permutation */\nPERM	*px_rand(pi)\nPERM	*pi;\n{\n    int		i, j, k;\n\n    if ( ! pi )\n	error(E_NULL,"px_rand");\n\n    for ( i = 0; i < 3*pi->size; i++ )\n    {\n	j = (rand() >> 8) % pi->size;\n	k = (rand() >> 8) % pi->size;\n	px_transp(pi,j,k);\n    }\n\n    return pi;\n}\n\n#define	SAVE_FILE	"asx5213a.mat"\n#define	MATLAB_NAME	"alpha"\nchar	name[81] = MATLAB_NAME;\n\nvoid	main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n    ZVEC 	*x = ZVNULL, *y = ZVNULL, *z = ZVNULL, *u = ZVNULL;\n    ZVEC	*diag = ZVNULL;\n    PERM	*pi1 = PNULL, *pi2 = PNULL, *pivot = PNULL;\n    ZMAT	*A = ZMNULL, *B = ZMNULL, *C = ZMNULL, *D = ZMNULL,\n	*Q = ZMNULL;\n    complex	ONE;\n    complex	z1, z2, z3;\n    Real	cond_est, s1, s2, s3;\n    int		i, seed;\n    FILE	*fp;\n    char	*cp;\n\n\n    mem_info_on(TRUE);\n\n    setbuf(stdout,(char *)NULL);\n\n    seed = 1111;\n    if ( argc > 2 )\n    {\n	printf("usage: %s [seed]\n",argv[0]);\n	exit(0);\n    }\n    else if ( argc == 2 )\n	sscanf(argv[1], "%d", &seed);\n\n    /* set seed for rand() */\n    smrand(seed);\n\n    /* print out version information */\n    m_version();\n\n    printf("# Meschach Complex numbers & vectors torture test\n\n");\n    printf("# grep \"^Error\" the output for a listing of errors\n");\n    printf("# Don't panic if you see \"Error\" appearing; \n");\n    printf("# Also check the reported size of error\n");\n    printf("# This program uses randomly generated problems and therefore\n");\n    printf("# may occasionally produce ill-conditioned problems\n");\n    printf("# Therefore check the size of the error compared with MACHEPS\n");\n    printf("# If the error is within 1000*MACHEPS then don't worry\n");\n    printf("# If you get an error of size 0.1 or larger there is \n");\n    printf("# probably a bug in the code or the compilation procedure\n\n");\n    printf("# seed = %d\n",seed);\n\n    printf("\n");\n\n    mem_stat_mark(1);\n\n    notice("complex arithmetic & special functions");\n\n    ONE = zmake(1.0,0.0);\n    printf("# ONE = ");	z_output(ONE);\n    z1.re = mrand();	z1.im = mrand();\n    z2.re = mrand();	z2.im = mrand();\n    z3 = zadd(z1,z2);\n    if ( fabs(z1.re+z2.re-z3.re) + fabs(z1.im+z2.im-z3.im) > 10*MACHEPS )\n	errmesg("zadd");\n    z3 = zsub(z1,z2);\n    if ( fabs(z1.re-z2.re-z3.re) + fabs(z1.im-z2.im-z3.im) > 10*MACHEPS )\n	errmesg("zadd");\n    z3 = zmlt(z1,z2);\n    if ( fabs(z1.re*z2.re - z1.im*z2.im - z3.re) +\n	 fabs(z1.im*z2.re + z1.re*z2.im - z3.im) > 10*MACHEPS )\n	errmesg("zmlt");\n    s1 = zabs(z1);\n    if ( fabs(s1*s1 - (z1.re*z1.re+z1.im*z1.im)) > 10*MACHEPS )\n	errmesg("zabs");\n    if ( zabs(zsub(z1,zmlt(z2,zdiv(z1,z2)))) > 10*MACHEPS ||\n	 zabs(zsub(ONE,zdiv(z1,zmlt(z2,zdiv(z1,z2))))) > 10*MACHEPS )\n	errmesg("zdiv");\n\n    z3 = zsqrt(z1);\n    if ( zabs(zsub(z1,zmlt(z3,z3))) > 10*MACHEPS )\n	errmesg("zsqrt");\n    if ( zabs(zsub(z1,zlog(zexp(z1)))) > 10*MACHEPS )\n	errmesg("zexp/zlog");\n    \n\n    printf("# Check: MACHEPS = %g\n",MACHEPS);\n    /* allocate, initialise, copy and resize operations */\n    /* ZVEC */\n    notice("vector initialise, copy & resize");\n    x = zv_get(12);\n    y = zv_get(15);\n    z = zv_get(12);\n    zv_rand(x);\n    zv_rand(y);\n    z = zv_copy(x,z);\n    if ( zv_norm2(zv_sub(x,z,z)) >= MACHEPS )\n	errmesg("ZVEC copy");\n    zv_copy(x,y);\n    x = zv_resize(x,10);\n    y = zv_resize(y,10);\n    if ( zv_norm2(zv_sub(x,y,z)) >= MACHEPS )\n	errmesg("ZVEC copy/resize");\n    x = zv_resize(x,15);\n    y = zv_resize(y,15);\n    if ( zv_norm2(zv_sub(x,y,z)) >= MACHEPS )\n	errmesg("VZEC resize");\n\n    /* ZMAT */\n    notice("matrix initialise, copy & resize");\n    A = zm_get(8,5);\n    B = zm_get(3,9);\n    C = zm_get(8,5);\n    zm_rand(A);\n    zm_rand(B);\n    C = zm_copy(A,C);\n    if ( zm_norm_inf(zm_sub(A,C,C)) >= MACHEPS )\n	errmesg("ZMAT copy");\n    zm_copy(A,B);\n    A = zm_resize(A,3,5);\n    B = zm_resize(B,3,5);\n    if ( zm_norm_inf(zm_sub(A,B,C)) >= MACHEPS )\n	errmesg("ZMAT copy/resize");\n    A = zm_resize(A,10,10);\n    B = zm_resize(B,10,10);\n    if ( zm_norm_inf(zm_sub(A,B,C)) >= MACHEPS )\n	errmesg("ZMAT resize");\n\n    MEMCHK();\n\n    /* PERM */\n    notice("permutation initialise, inverting & permuting vectors");\n    pi1 = px_get(15);\n    pi2 = px_get(12);\n    px_rand(pi1);\n    zv_rand(x);\n    px_zvec(pi1,x,z);\n    y = zv_resize(y,x->dim);\n    pxinv_zvec(pi1,z,y);\n    if ( zv_norm2(zv_sub(x,y,z)) >= MACHEPS )\n	errmesg("PERMute vector");\n\n    /* testing catch() etc */\n    notice("error handling routines");\n    catch(E_NULL,\n	  catchall(zv_add(ZVNULL,ZVNULL,ZVNULL);\n		     errmesg("tracecatch() failure"),\n		     printf("# tracecatch() caught error\n");\n		     error(E_NULL,"main"));\n	             errmesg("catch() failure"),\n	  printf("# catch() caught E_NULL error\n"));\n\n    /* testing inner products and v_mltadd() etc */\n    notice("inner products and linear combinations");\n    u = zv_get(x->dim);\n    zv_rand(u);\n    zv_rand(x);\n    zv_resize(y,x->dim);\n    zv_rand(y);\n    zv_mltadd(y,x,zneg(zdiv(zin_prod(x,y),zin_prod(x,x))),z);\n    if ( zabs(zin_prod(x,z)) >= 5*MACHEPS*x->dim )\n    {\n	errmesg("zv_mltadd()/zin_prod()");\n	printf("# error norm = %g\n", zabs(zin_prod(x,z)));\n    }\n\n    z1 = zneg(zdiv(zin_prod(x,y),zmake(zv_norm2(x)*zv_norm2(x),0.0)));\n    zv_mlt(z1,x,u);\n    zv_add(y,u,u);\n    if ( zv_norm2(zv_sub(u,z,u)) >= MACHEPS*x->dim )\n    {\n	errmesg("zv_mlt()/zv_norm2()");\n	printf("# error norm = %g\n", zv_norm2(u));\n    }\n\n#ifdef ANSI_C\n    zv_linlist(u,x,z1,y,ONE,VNULL);\n    if ( zv_norm2(zv_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg("zv_linlist()");\n#endif\n#ifdef VARARGS\n    zv_linlist(u,x,z1,y,ONE,VNULL);\n    if ( zv_norm2(zv_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg("zv_linlist()");\n#endif\n\n    MEMCHK();\n\n    /* vector norms */\n    notice("vector norms");\n    x = zv_resize(x,12);\n    zv_rand(x);\n    for ( i = 0; i < x->dim; i++ )\n	if ( zabs(zv_entry(x,i)) >= 0.7 )\n	    zv_set_val(x,i,ONE);\n        else\n	    zv_set_val(x,i,zneg(ONE));\n    s1 = zv_norm1(x);\n    s2 = zv_norm2(x);	\n    s3 = zv_norm_inf(x);\n    if ( fabs(s1 - x->dim) >= MACHEPS*x->dim ||\n	 fabs(s2 - sqrt((double)(x->dim))) >= MACHEPS*x->dim ||\n	 fabs(s3 - 1.0) >= MACHEPS )\n	errmesg("zv_norm1/2/_inf()");\n\n    /* test matrix multiply etc */\n    notice("matrix multiply and invert");\n    A = zm_resize(A,10,10);\n    B = zm_resize(B,10,10);\n    zm_rand(A);\n    zm_inverse(A,B);\n    zm_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_sub_val(C,i,i,ONE);\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("zm_inverse()/zm_mlt()");\n\n    MEMCHK();\n\n    /* ... and adjoints */\n    notice("adjoints and adjoint-multiplies");\n    zm_adjoint(A,A);	/* can do square matrices in situ */\n    zmam_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),ONE));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("zm_adjoint()/zmam_mlt()");\n    zm_adjoint(A,A);\n    zm_adjoint(B,B);\n    zmma_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),ONE));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("zm_adjoint()/zmma_mlt()");\n    zsm_mlt(zmake(3.71,2.753),B,B);\n    zmma_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),zmake(3.71,-2.753)));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("szm_mlt()/zmma_mlt()");\n    zm_adjoint(B,B);\n    zsm_mlt(zdiv(ONE,zmake(3.71,-2.753)),B,B);\n\n    MEMCHK();\n\n    /* ... and matrix-vector multiplies */\n    notice("matrix-vector multiplies");\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,A->m);\n    z = zv_resize(z,A->m);\n    u = zv_resize(u,A->n);\n    zv_rand(x);\n    zv_rand(y);\n    zmv_mlt(A,x,z);\n    z1 = zin_prod(y,z);\n    zvm_mlt(A,y,u);\n    z2 = zin_prod(u,x);\n    if ( zabs(zsub(z1,z2)) >= (MACHEPS*x->dim)*x->dim )\n    {\n	errmesg("zmv_mlt()/zvm_mlt()");\n	printf("# difference between inner products is %g\n",\n	       zabs(zsub(z1,z2)));\n    }\n    zmv_mlt(B,z,u);\n    if ( zv_norm2(zv_sub(u,x,u)) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("zmv_mlt()/zvm_mlt()");\n\n    MEMCHK();\n\n    /* get/set row/col */\n    notice("getting and setting rows and cols");\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,B->m);\n    x = zget_row(A,3,x);\n    y = zget_col(B,3,y);\n    if ( zabs(zsub(_zin_prod(x,y,0,Z_NOCONJ),ONE)) >=\n	MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("zget_row()/zget_col()");\n    zv_mlt(zmake(-1.0,0.0),x,x);\n    zv_mlt(zmake(-1.0,0.0),y,y);\n    zset_row(A,3,x);\n    zset_col(B,3,y);\n    zm_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),ONE));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg("zset_row()/zset_col()");\n\n    MEMCHK();\n\n    /* matrix norms */\n    notice("matrix norms");\n    A = zm_resize(A,11,15);\n    zm_rand(A);\n    s1 = zm_norm_inf(A);\n    B = zm_adjoint(A,B);\n    s2 = zm_norm1(B);\n    if ( fabs(s1 - s2) >= MACHEPS*A->m )\n	errmesg("zm_norm1()/zm_norm_inf()");\n    C = zmam_mlt(A,A,C);\n    z1.re = z1.im = 0.0;\n    for ( i = 0; i < C->m && i < C->n; i++ )\n	z1 = zadd(z1,zm_entry(C,i,i));\n    if ( fabs(sqrt(z1.re) - zm_norm_frob(A)) >= MACHEPS*A->m*A->n )\n	errmesg("zm_norm_frob");\n\n    MEMCHK();\n    \n    /* permuting rows and columns */\n    /******************************\n    notice("permuting rows & cols");\n    A = zm_resize(A,11,15);\n    B = zm_resize(B,11,15);\n    pi1 = px_resize(pi1,A->m);\n    px_rand(pi1);\n    x = zv_resize(x,A->n);\n    y = zmv_mlt(A,x,y);\n    px_rows(pi1,A,B);\n    px_zvec(pi1,y,z);\n    zmv_mlt(B,x,u);\n    if ( zv_norm2(zv_sub(z,u,u)) >= MACHEPS*A->m )\n	errmesg("px_rows()");\n    pi1 = px_resize(pi1,A->n);\n    px_rand(pi1);\n    px_cols(pi1,A,B);\n    pxinv_zvec(pi1,x,z);\n    zmv_mlt(B,z,u);\n    if ( zv_norm2(zv_sub(y,u,u)) >= MACHEPS*A->n )\n	errmesg("px_cols()");\n    ******************************/\n\n    MEMCHK();\n\n    /* MATLAB save/load */\n    notice("MATLAB save/load");\n    A = zm_resize(A,12,11);\n    if ( (fp=fopen(SAVE_FILE,"w")) == (FILE *)NULL )\n	printf("Cannot perform MATLAB save/load test\n");\n    else\n    {\n	zm_rand(A);\n	zm_save(fp, A, name);\n	fclose(fp);\n	if ( (fp=fopen(SAVE_FILE,"r")) == (FILE *)NULL )\n	    printf("Cannot open save file \"%s\"\n",SAVE_FILE);\n	else\n	{\n	    ZM_FREE(B);\n	    B = zm_load(fp,&cp);\n	    if ( strcmp(name,cp) || zm_norm1(zm_sub(A,B,C)) >=\n		 MACHEPS*A->m )\n	    {\n		errmesg("zm_load()/zm_save()");\n		printf("# orig. name = %s, restored name = %s\n", name, cp);\n		printf("# orig. A =\n");	zm_output(A);\n		printf("# restored A =\n");	zm_output(B);\n	    }\n	}\n    }\n\n    MEMCHK();\n\n    /* Now, onto matrix factorisations */\n    A = zm_resize(A,10,10);\n    B = zm_resize(B,A->m,A->n);\n    zm_copy(A,B);\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,A->m);\n    z = zv_resize(z,A->n);\n    u = zv_resize(u,A->m);\n    zv_rand(x);\n    zmv_mlt(B,x,y);\n    z = zv_copy(x,z);\n\n    notice("LU factor/solve");\n    pivot = px_get(A->m);\n    zLUfactor(A,pivot);\n    tracecatch(zLUsolve(A,pivot,y,x),"main");\n    tracecatch(cond_est = zLUcondest(A,pivot),"main");\n    printf("# cond(A) approx= %g\n", cond_est);\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est)\n    {\n	errmesg("zLUfactor()/zLUsolve()");\n	printf("# LU solution error = %g [cf MACHEPS = %g]\n",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n\n\n    zv_copy(y,x);\n    tracecatch(zLUsolve(A,pivot,x,x),"main");\n    tracecatch(cond_est = zLUcondest(A,pivot),"main");\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est)\n    {\n	errmesg("zLUfactor()/zLUsolve()");\n	printf("# LU solution error = %g [cf MACHEPS = %g]\n",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n\n    zvm_mlt(B,z,y);\n    zv_copy(y,x);\n    tracecatch(zLUAsolve(A,pivot,x,x),"main");\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est)\n    {\n	errmesg("zLUfactor()/zLUAsolve()");\n	printf("# LU solution error = %g [cf MACHEPS = %g]\n",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* QR factorisation */\n    zm_copy(B,A);\n    zmv_mlt(B,z,y);\n    notice("QR factor/solve:");\n    diag = zv_get(A->m);\n    zQRfactor(A,diag);\n    zQRsolve(A,diag,y,x);\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est )\n    {\n	errmesg("zQRfactor()/zQRsolve()");\n	printf("# QR solution error = %g [cf MACHEPS = %g]\n",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n    printf("# QR cond(A) approx= %g\n", zQRcondest(A));\n    Q = zm_get(A->m,A->m);\n    zmakeQ(A,diag,Q);\n    zmakeR(A,A);\n    zm_mlt(Q,A,C);\n    zm_sub(B,C,C);\n    if ( zm_norm1(C) >= MACHEPS*zm_norm1(Q)*zm_norm1(B) )\n    {\n	errmesg("zQRfactor()/zmakeQ()/zmakeR()");\n	printf("# QR reconstruction error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(C), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now try with a non-square matrix */\n    A = zm_resize(A,15,7);\n    zm_rand(A);\n    B = zm_copy(A,B);\n    diag = zv_resize(diag,A->n);\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,A->m);\n    zv_rand(y);\n    zQRfactor(A,diag);\n    x = zQRsolve(A,diag,y,x);\n    /* z is the residual vector */\n    zmv_mlt(B,x,z);	zv_sub(z,y,z);\n    /* check B*.z = 0 */\n    zvm_mlt(B,z,u);\n    if ( zv_norm2(u) >= 100*MACHEPS*zm_norm1(B)*zv_norm2(y) )\n    {\n	errmesg("zQRfactor()/zQRsolve()");\n	printf("# QR solution error = %g [cf MACHEPS = %g]\n",\n	       zv_norm2(u), MACHEPS);\n    }\n    Q = zm_resize(Q,A->m,A->m);\n    zmakeQ(A,diag,Q);\n    zmakeR(A,A);\n    zm_mlt(Q,A,C);\n    zm_sub(B,C,C);\n    if ( zm_norm1(C) >= MACHEPS*zm_norm1(Q)*zm_norm1(B) )\n    {\n	errmesg("zQRfactor()/zmakeQ()/zmakeR()");\n	printf("# QR reconstruction error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(C), MACHEPS);\n    }\n    D = zm_get(A->m,Q->m);\n    zmam_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	zm_set_val(D,i,i,zsub(zm_entry(D,i,i),ONE));\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q) )\n    {\n	errmesg("QRfactor()/makeQ()/makeR()");\n	printf("# QR orthogonality error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* QRCP factorisation */\n    zm_copy(B,A);\n    notice("QR factor/solve with column pivoting");\n    pivot = px_resize(pivot,A->n);\n    zQRCPfactor(A,diag,pivot);\n    z = zv_resize(z,A->n);\n    zQRCPsolve(A,diag,pivot,y,z);\n    /* pxinv_zvec(pivot,z,x); */\n    /* now compute residual (z) vector */\n    zmv_mlt(B,x,z);	zv_sub(z,y,z);\n    /* check B^T.z = 0 */\n    zvm_mlt(B,z,u);\n    if ( zv_norm2(u) >= MACHEPS*zm_norm1(B)*zv_norm2(y) )\n    {\n	errmesg("QRCPfactor()/QRsolve()");\n	printf("# QR solution error = %g [cf MACHEPS = %g]\n",\n	       zv_norm2(u), MACHEPS);\n    }\n\n    Q = zm_resize(Q,A->m,A->m);\n    zmakeQ(A,diag,Q);\n    zmakeR(A,A);\n    zm_mlt(Q,A,C);\n    ZM_FREE(D);\n    D = zm_get(B->m,B->n);\n    /******************************\n    px_cols(pivot,C,D);\n    zm_sub(B,D,D);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm1(B) )\n    {\n	errmesg("QRCPfactor()/makeQ()/makeR()");\n	printf("# QR reconstruction error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(D), MACHEPS);\n    }\n    ******************************/\n\n    /* Now check eigenvalue/SVD routines */\n    notice("complex Schur routines");\n    A = zm_resize(A,11,11);\n    B = zm_resize(B,A->m,A->n);\n    C = zm_resize(C,A->m,A->n);\n    D = zm_resize(D,A->m,A->n);\n    Q = zm_resize(Q,A->m,A->n);\n\n    MEMCHK();\n\n    /* now test complex Schur decomposition */\n    /* zm_copy(A,B); */\n    ZM_FREE(A);\n    A = zm_get(11,11);\n    zm_rand(A);\n    B = zm_copy(A,B);\n    MEMCHK();\n\n    B = zschur(B,Q);\n    checkpt();\n\n    zm_mlt(Q,B,C);\n    zmma_mlt(C,Q,D);\n    MEMCHK();\n    zm_sub(A,D,D);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q)*zm_norm1(B)*5 )\n    {\n	errmesg("zschur()");\n	printf("# Schur reconstruction error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(D), MACHEPS);\n    }\n\n    /* orthogonality check */\n    zmma_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	zm_set_val(D,i,i,zsub(zm_entry(D,i,i),ONE));\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q)*10 )\n    {\n	errmesg("zschur()");\n	printf("# Schur orthogonality error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now test SVD */\n    /******************************\n    A = zm_resize(A,11,7);\n    zm_rand(A);\n    U = zm_get(A->n,A->n);\n    Q = zm_resize(Q,A->m,A->m);\n    u = zv_resize(u,max(A->m,A->n));\n    svd(A,Q,U,u);\n    ******************************/\n    /* check reconstruction of A */\n    /******************************\n    D = zm_resize(D,A->m,A->n);\n    C = zm_resize(C,A->m,A->n);\n    zm_zero(D);\n    for ( i = 0; i < min(A->m,A->n); i++ )\n	zm_set_val(D,i,i,v_entry(u,i));\n    zmam_mlt(Q,D,C);\n    zm_mlt(C,U,D);\n    zm_sub(A,D,D);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(U)*zm_norm_inf(Q)*zm_norm1(A) )\n    {\n	errmesg("svd()");\n	printf("# SVD reconstruction error = %g [cf MACHEPS = %g]\n",\n	       zm_norm1(D), MACHEPS);\n    }\n    ******************************/\n    /* check orthogonality of Q and U */\n    /******************************\n    D = zm_resize(D,Q->n,Q->n);\n    zmam_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q)*5 )\n    {\n	errmesg("svd()");\n	printf("# SVD orthognality error (Q) = %g [cf MACHEPS = %g\n",\n	       zm_norm1(D), MACHEPS);\n    }\n    D = zm_resize(D,U->n,U->n);\n    zmam_mlt(U,U,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(U)*zm_norm_inf(U)*5 )\n    {\n	errmesg("svd()");\n	printf("# SVD orthognality error (U) = %g [cf MACHEPS = %g\n",\n	       zm_norm1(D), MACHEPS);\n    }\n    for ( i = 0; i < u->dim; i++ )\n	if ( v_entry(u,i) < 0 || (i < u->dim-1 &&\n				  v_entry(u,i+1) > v_entry(u,i)) )\n	    break;\n    if ( i < u->dim )\n    {\n	errmesg("svd()");\n	printf("# SVD sorting error\n");\n    }\n    ******************************/\n\n    ZV_FREE(x);	ZV_FREE(y);	ZV_FREE(z);\n    ZV_FREE(u);	ZV_FREE(diag);\n    PX_FREE(pi1);	PX_FREE(pi2);	PX_FREE(pivot);\n    ZM_FREE(A);	ZM_FREE(B);	ZM_FREE(C);\n    ZM_FREE(D);	ZM_FREE(Q);\n\n    mem_stat_free(1);\n\n    MEMCHK();\n    printf("# Finished torture test for complex numbers/vectors/matrices\n");\n    mem_info();\n}\n\n