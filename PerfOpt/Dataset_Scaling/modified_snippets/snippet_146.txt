#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n\n#define MAX_ARGS 10\n#define REC_LENGTH 49	// size of a record in db\n#define REC_WINDOW 10	// number of records to read at a time\n#define LATITUDE_POS 28	// location of latitude coordinates in input record\n#define OPEN 10000	// initial value of nearest neighbors\nstruct neighbor {\n	char entry[REC_LENGTH];\n	double dist;\n};\n\n/**\n* This program finds the k-nearest neighbors\n* Usage:	./nn <filelist> <num> <target latitude> <target longitude>\n*			filelist: File with the filenames to the records\n*			num: Number of nearest neighbors to find\n*			target lat: Latitude coordinate for distance calculations\n*			target long: Longitude coordinate for distance calculations\n* The filelist and data are generated by hurricane_gen.c\n* REC_WINDOW has been arbitrarily assigned; A larger value would allow more work for the threads\n*/\nint main(int argc, char* argv[]) {\n	long long time0 = clock();\n    FILE   *flist,*fp;\n	int    i=0,j=0, k=0, rec_count=0, done=0;\n	char   sandbox[REC_LENGTH * REC_WINDOW], *rec_iter,*rec_iter2, dbname[64];\n	struct neighbor *neighbors = NULL;\n	float target_lat, target_long, tmp_lat=0, tmp_long=0;\n\n	if(argc < 5) {\n		fprintf(stderr, "Invalid set of arguments\n");\n		exit(-1);\n	}\n\n	flist = fopen(argv[1], "r");\n	if(!flist) {\n		printf("error opening flist\n");\n		exit(1);\n	}\n\n	k = atoi(argv[2]);\n	target_lat = atof(argv[3]);\n	target_long = atof(argv[4]);\n\n	neighbors = malloc(k*sizeof(struct neighbor));\n\n	if(neighbors == NULL) {\n		fprintf(stderr, "no room for neighbors\n");\n		exit(0);\n	}\n\n	for( j = 0 ; j < k ; j++ ) { //Initialize list of nearest neighbors to very large dist\n		neighbors[j].dist = OPEN;\n	}\n\n	/**** main processing ****/  \n	if(fscanf(flist, "%s\n", dbname) != 1) {\n		fprintf(stderr, "error reading filelist\n");\n		exit(0);\n	}\n\n	fp = fopen(dbname, "r");\n	if(!fp) {\n		printf("error opening flist\n");\n		exit(1);\n	}\n\n	float *z;\n	z  = (float *) malloc(REC_WINDOW * sizeof(float));\n\n	while(!done) {\n		//Read in REC_WINDOW number of records\n		rec_count = fread(sandbox, REC_LENGTH, REC_WINDOW, fp);\n		if( rec_count != REC_WINDOW ) {\n			if(!ferror(flist)) {// an eof occured\n				fclose(fp);\n\n				if(feof(flist))\n		  			done = 1;\n				else {\n	 				if(fscanf(flist, "%s\n", dbname) != 1) {\n	    					fprintf(stderr, "error reading filelist\n");\n	    					exit(0);\n					}\n\n	  				fp = fopen(dbname, "r");\n\n	  				if(!fp) {\n					    printf("error opening a db\n");\n					    exit(1);\n	  				}\n				}\n			} else {\n				perror("Error");\n				exit(0);\n			}\n		}\n\n		/* Launch threads to  */\n        // Lingjie Zhang modificated on 11/08/2015\n        // original code \n		// #pragma omp parallel for shared(z, target_lat, target_long) private(i, rec_iter, tmp_lat, tmp_long)\n		// for( i = 0 ; i < rec_count ; i++ ) {\n			// rec_iter = sandbox+(i * REC_LENGTH + LATITUDE_POS - 1);\n			// sscanf(rec_iter, "%f %f", &tmp_lat, &tmp_long);\n			// z[i] = sqrt(( (tmp_lat-target_lat) * (tmp_lat-target_lat) )+( (tmp_long-target_long) * (tmp_long-target_long) ));\n		// } /* omp end parallel */\n		// #pragma omp barrier\n       \n        #pragma omp parallel for shared (z, target_lat, target_long) private(i,rec_iter)\n        for (i = 0; i < rec_count; i++){\n			rec_iter = sandbox+(i * REC_LENGTH + LATITUDE_POS - 1);\n            float tmp_lat = atof(rec_iter);\n            float tmp_long = atof(rec_iter+5);\n			z[i] = sqrt(( (tmp_lat-target_lat) * (tmp_lat-target_lat) )+( (tmp_long-target_long) * (tmp_long-target_long) ));\n        }\n        #pragma omp barrier\n        // end of Lingjie Zhang's modification\n\n		\n        for( i = 0 ; i < rec_count ; i++ ) {\n			float max_dist = -1;\n			int max_idx = 0;\n			// find a neighbor with greatest dist and take his spot if allowed!\n			for( j = 0 ; j < k ; j++ ) {\n				if( neighbors[j].dist > max_dist ) {\n					max_dist = neighbors[j].dist;\n					max_idx = j;\n				}\n			}\n			// compare each record with max value to find the nearest neighbor\n			if( z[i] < neighbors[max_idx].dist ) {\n				sandbox[(i+1)*REC_LENGTH-1] = '\0';\n			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);\n			  	neighbors[max_idx].dist = z[i];\n			}\n		}\n	}//End while loop\n\n	fprintf(stderr, "The %d nearest neighbors are:\n", k);\n	for( j = 0 ; j < k ; j++ ) {\n		if( !(neighbors[j].dist == OPEN) )\n			fprintf(stderr, "%s --> %f\n", neighbors[j].entry, neighbors[j].dist);\n	}\n\n	fclose(flist);\n	\n\n    long long time1 = clock();\n    printf("total time : %15.12f s", (float) (time1 - time0) / 1000000);\n    return 0;\n}\n\n