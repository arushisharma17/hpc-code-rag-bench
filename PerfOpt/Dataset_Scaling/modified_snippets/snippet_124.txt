\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* vecop.c 1.3 8/18/87 */\n\n#include	<stdio.h>\n#include	"matrix.h"\n\nstatic	char	rcsid[] = "$Id: vecop.c,v 1.5 1996/08/20 18:18:10 stewart Exp $";\n\n\n/* _in_prod -- inner product of two vectors from i0 downwards\n	-- that is, returns a(i0:dim)^T.b(i0:dim) */\n#ifndef ANSI_C\ndouble	_in_prod(a,b,i0)\nVEC	*a,*b;\nunsigned int	i0;\n#else\ndouble	_in_prod(const VEC *a, const VEC *b, unsigned int i0)\n#endif\n{\n	unsigned int	limit;\n	/* Real	*a_v, *b_v; */\n	/* register Real	sum; */\n\n	if ( a==(VEC *)NULL || b==(VEC *)NULL )\n		error(E_NULL,"_in_prod");\n	limit = min(a->dim,b->dim);\n	if ( i0 > limit )\n		error(E_BOUNDS,"_in_prod");\n\n	return __ip__(&(a->ve[i0]),&(b->ve[i0]),(int)(limit-i0));\n	/*****************************************\n	a_v = &(a->ve[i0]);		b_v = &(b->ve[i0]);\n	for ( i=i0; i<limit; i++ )\n		sum += a_v[i]*b_v[i];\n		sum += (*a_v++)*(*b_v++);\n\n	return (double)sum;\n	******************************************/\n}\n\n/* sv_mlt -- scalar-vector multiply -- out <- scalar*vector \n	-- may be in-situ */\n#ifndef ANSI_C\nVEC	*sv_mlt(scalar,vector,out)\ndouble	scalar;\nVEC	*vector,*out;\n#else\nVEC	*sv_mlt(double scalar, const VEC *vector, VEC *out)\n#endif\n{\n	/* unsigned int	dim, i; */\n	/* Real	*out_ve, *vec_ve; */\n\n	if ( vector==(VEC *)NULL )\n		error(E_NULL,"sv_mlt");\n	if ( out==(VEC *)NULL || out->dim != vector->dim )\n		out = v_resize(out,vector->dim);\n	if ( scalar == 0.0 )\n		return v_zero(out);\n	if ( scalar == 1.0 )\n		return v_copy(vector,out);\n\n	__smlt__(vector->ve,(double)scalar,out->ve,(int)(vector->dim));\n	/**************************************************\n	dim = vector->dim;\n	out_ve = out->ve;	vec_ve = vector->ve;\n	for ( i=0; i<dim; i++ )\n		out->ve[i] = scalar*vector->ve[i];\n		(*out_ve++) = scalar*(*vec_ve++);\n	**************************************************/\n	return (out);\n}\n\n/* v_add -- vector addition -- out <- v1+v2 -- may be in-situ */\n#ifndef ANSI_C\nVEC	*v_add(vec1,vec2,out)\nVEC	*vec1,*vec2,*out;\n#else\nVEC	*v_add(const VEC *vec1, const VEC *vec2, VEC *out)\n#endif\n{\n	unsigned int	dim;\n	/* Real	*out_ve, *vec1_ve, *vec2_ve; */\n\n	if ( vec1==(VEC *)NULL || vec2==(VEC *)NULL )\n		error(E_NULL,"v_add");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,"v_add");\n	if ( out==(VEC *)NULL || out->dim != vec1->dim )\n		out = v_resize(out,vec1->dim);\n	dim = vec1->dim;\n	__add__(vec1->ve,vec2->ve,out->ve,(int)dim);\n	/************************************************************\n	out_ve = out->ve;	vec1_ve = vec1->ve;	vec2_ve = vec2->ve;\n	for ( i=0; i<dim; i++ )\n		out->ve[i] = vec1->ve[i]+vec2->ve[i];\n		(*out_ve++) = (*vec1_ve++) + (*vec2_ve++);\n	************************************************************/\n\n	return (out);\n}\n\n/* v_mltadd -- scalar/vector multiplication and addition\n		-- out = v1 + scale.v2		*/\n#ifndef ANSI_C\nVEC	*v_mltadd(v1,v2,scale,out)\nVEC	*v1,*v2,*out;\ndouble	scale;\n#else\nVEC	*v_mltadd(const VEC *v1, const VEC *v2, double scale, VEC *out)\n#endif\n{\n	/* register unsigned int	dim, i; */\n	/* Real	*out_ve, *v1_ve, *v2_ve; */\n\n	if ( v1==(VEC *)NULL || v2==(VEC *)NULL )\n		error(E_NULL,"v_mltadd");\n	if ( v1->dim != v2->dim )\n		error(E_SIZES,"v_mltadd");\n	if ( scale == 0.0 )\n		return v_copy(v1,out);\n	if ( scale == 1.0 )\n		return v_add(v1,v2,out);\n\n	if ( v2 != out )\n	{\n	    tracecatch(out = v_copy(v1,out),"v_mltadd");\n\n	    /* dim = v1->dim; */\n	    __mltadd__(out->ve,v2->ve,scale,(int)(v1->dim));\n	}\n	else\n	{\n	    tracecatch(out = sv_mlt(scale,v2,out),"v_mltadd");\n	    out = v_add(v1,out,out);\n	}\n	/************************************************************\n	out_ve = out->ve;	v1_ve = v1->ve;		v2_ve = v2->ve;\n	for ( i=0; i < dim ; i++ )\n		out->ve[i] = v1->ve[i] + scale*v2->ve[i];\n		(*out_ve++) = (*v1_ve++) + scale*(*v2_ve++);\n	************************************************************/\n\n	return (out);\n}\n\n/* v_sub -- vector subtraction -- may be in-situ */\n#ifndef ANSI_C\nVEC	*v_sub(vec1,vec2,out)\nVEC	*vec1,*vec2,*out;\n#else\nVEC	*v_sub(const VEC *vec1, const VEC *vec2, VEC *out)\n#endif\n{\n	/* unsigned int	i, dim; */\n	/* Real	*out_ve, *vec1_ve, *vec2_ve; */\n\n	if ( vec1==(VEC *)NULL || vec2==(VEC *)NULL )\n		error(E_NULL,"v_sub");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,"v_sub");\n	if ( out==(VEC *)NULL || out->dim != vec1->dim )\n		out = v_resize(out,vec1->dim);\n\n	__sub__(vec1->ve,vec2->ve,out->ve,(int)(vec1->dim));\n	/************************************************************\n	dim = vec1->dim;\n	out_ve = out->ve;	vec1_ve = vec1->ve;	vec2_ve = vec2->ve;\n	for ( i=0; i<dim; i++ )\n		out->ve[i] = vec1->ve[i]-vec2->ve[i];\n		(*out_ve++) = (*vec1_ve++) - (*vec2_ve++);\n	************************************************************/\n\n	return (out);\n}\n\n/* v_map -- maps function f over components of x: out[i] = f(x[i])\n	-- v_map sets out[i] = f(params,x[i]) */\n#ifndef ANSI_C\nVEC	*v_map(f,x,out)\ndouble	(*f)();\nVEC	*x, *out;\n#else\n#ifdef PROTOTYPES_IN_STRUCT\nVEC	*v_map(double (*f)(double), const VEC *x, VEC *out)\n#else\nVEC	*v_map(double (*f)(), const VEC *x, VEC *out)\n#endif\n#endif\n{\n	Real	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,"v_map");\n	if ( ! out || out->dim != x->dim )\n		out = v_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		*out_ve++ = (*f)(*x_ve++);\n\n	return out;\n}\n\n/* _v_map -- sets out[i] <- f(params, x[i]), i = 0, 1, .., dim-1 */\n#ifndef ANSI_C\nVEC	*_v_map(f,params,x,out)\ndouble	(*f)();\nvoid	*params;\nVEC	*x, *out;\n#else\n#ifdef PROTOTYPES_IN_STRUCT\nVEC	*_v_map(double (*f)(void *,double), void *params, const VEC *x, VEC *out)\n#else\nVEC	*_v_map(double (*f)(), void *params, const VEC *x, VEC *out)\n#endif\n#endif\n{\n	Real	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,"_v_map");\n	if ( ! out || out->dim != x->dim )\n		out = v_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		*out_ve++ = (*f)(params,*x_ve++);\n\n	return out;\n}\n\n/* v_lincomb -- returns sum_i a[i].v[i], a[i] real, v[i] vectors */\n#ifndef ANSI_C\nVEC	*v_lincomb(n,v,a,out)\nint	n;	/* number of a's and v's */\nReal	a[];\nVEC	*v[], *out;\n#else\nVEC	*v_lincomb(int n, const VEC *v[], const Real a[], VEC *out)\n#endif\n{\n	int	i;\n\n	if ( ! a || ! v )\n		error(E_NULL,"v_lincomb");\n	if ( n <= 0 )\n		return VNULL;\n\n	for ( i = 1; i < n; i++ )\n		if ( out == v[i] )\n		    error(E_INSITU,"v_lincomb");\n\n	out = sv_mlt(a[0],v[0],out);\n	for ( i = 1; i < n; i++ )\n	{\n		if ( ! v[i] )\n			error(E_NULL,"v_lincomb");\n		if ( v[i]->dim != out->dim )\n			error(E_SIZES,"v_lincomb");\n		out = v_mltadd(out,v[i],a[i],out);\n	}\n\n	return out;\n}\n\n\n\n#ifdef ANSI_C\n\n/* v_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      v_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (VEC *) and ai are numbers (double)\n*/\nVEC  *v_linlist(VEC *out,VEC *v1,double a1,...)\n{\n   va_list ap;\n   VEC *par;\n   double a_par;\n\n   if ( ! v1 )\n     return VNULL;\n   \n   va_start(ap, a1);\n   out = sv_mlt(a1,v1,out);\n   \n   while (par = va_arg(ap,VEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,double);\n      if (a_par == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,"v_linlist");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,"v_linlist");\n\n      if (a_par == 1.0)\n	out = v_add(out,par,out);\n      else if (a_par == -1.0)\n	out = v_sub(out,par,out);\n      else\n	out = v_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n \n#elif VARARGS\n\n\n/* v_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      v_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (VEC *) and ai are numbers (double)\n*/\nVEC  *v_linlist(va_alist) va_dcl\n{\n   va_list ap;\n   VEC *par, *out;\n   double a_par;\n\n   va_start(ap);\n   out = va_arg(ap,VEC *);\n   par = va_arg(ap,VEC *);\n   if ( ! par ) {\n      va_end(ap);\n      return VNULL;\n   }\n   \n   a_par = va_arg(ap,double);\n   out = sv_mlt(a_par,par,out);\n   \n   while (par = va_arg(ap,VEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,double);\n      if (a_par == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,"v_linlist");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,"v_linlist");\n\n      if (a_par == 1.0)\n	out = v_add(out,par,out);\n      else if (a_par == -1.0)\n	out = v_sub(out,par,out);\n      else\n	out = v_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n\n#endif\n  \n\n\n\n\n/* v_star -- computes componentwise (Hadamard) product of x1 and x2\n	-- result out is returned */\n#ifndef ANSI_C\nVEC	*v_star(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_star(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,"v_star");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,"v_star");\n    out = v_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n	out->ve[i] = x1->ve[i] * x2->ve[i];\n\n    return out;\n}\n\n/* v_slash -- computes componentwise ratio of x2 and x1\n	-- out[i] = x2[i] / x1[i]\n	-- if x1[i] == 0 for some i, then raise E_SING error\n	-- result out is returned */\n#ifndef ANSI_C\nVEC	*v_slash(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_slash(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n    Real	tmp;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,"v_slash");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,"v_slash");\n    out = v_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	tmp = x1->ve[i];\n	if ( tmp == 0.0 )\n	    error(E_SING,"v_slash");\n	out->ve[i] = x2->ve[i] / tmp;\n    }\n\n    return out;\n}\n\n/* v_min -- computes minimum component of x, which is returned\n	-- also sets min_idx to the index of this minimum */\n#ifndef ANSI_C\ndouble	v_min(x, min_idx)\nVEC	*x;\nint	*min_idx;\n#else\ndouble	v_min(const VEC *x, int *min_idx)\n#endif\n{\n    int		i, i_min;\n    Real	min_val, tmp;\n\n    if ( ! x )\n	error(E_NULL,"v_min");\n    if ( x->dim <= 0 )\n	error(E_SIZES,"v_min");\n    i_min = 0;\n    min_val = x->ve[0];\n    for ( i = 1; i < x->dim; i++ )\n    {\n	tmp = x->ve[i];\n	if ( tmp < min_val )\n	{\n	    min_val = tmp;\n	    i_min = i;\n	}\n    }\n\n    if ( min_idx != NULL )\n	*min_idx = i_min;\n    return min_val;\n}\n\n/* v_max -- computes maximum component of x, which is returned\n	-- also sets max_idx to the index of this maximum */\n#ifndef ANSI_C\ndouble	v_max(x, max_idx)\nVEC	*x;\nint	*max_idx;\n#else\ndouble	v_max(const VEC *x, int *max_idx)\n#endif\n{\n    int		i, i_max;\n    Real	max_val, tmp;\n\n    if ( ! x )\n	error(E_NULL,"v_max");\n    if ( x->dim <= 0 )\n	error(E_SIZES,"v_max");\n    i_max = 0;\n    max_val = x->ve[0];\n    for ( i = 1; i < x->dim; i++ )\n    {\n	tmp = x->ve[i];\n	if ( tmp > max_val )\n	{\n	    max_val = tmp;\n	    i_max = i;\n	}\n    }\n\n    if ( max_idx != NULL )\n	*max_idx = i_max;\n    return max_val;\n}\n\n#define	MAX_STACK	60\n\n\n/* v_sort -- sorts vector x, and generates permutation that gives the order\n	of the components; x = [1.3, 3.7, 0.5] -> [0.5, 1.3, 3.7] and\n	the permutation is order = [2, 0, 1].\n	-- if order is NULL on entry then it is ignored\n	-- the sorted vector x is returned */\n#ifndef ANSI_C\nVEC	*v_sort(x, order)\nVEC	*x;\nPERM	*order;\n#else\nVEC	*v_sort(VEC *x, PERM *order)\n#endif\n{\n    Real	*x_ve, tmp, v;\n    /* int		*order_pe; */\n    int		dim, i, j, l, r, tmp_i;\n    int		stack[MAX_STACK], sp;\n\n    if ( ! x )\n	error(E_NULL,"v_sort");\n    if ( order != PNULL && order->size != x->dim )\n	order = px_resize(order, x->dim);\n\n    x_ve = x->ve;\n    dim = x->dim;\n    if ( order != PNULL )\n	px_ident(order);\n\n    if ( dim <= 1 )\n	return x;\n\n    /* using quicksort algorithm in Sedgewick,\n       "Algorithms in C", Ch. 9, pp. 118--122 (1990) */\n    sp = 0;\n    l = 0;	r = dim-1;	v = x_ve[0];\n    for ( ; ; )\n    {\n	while ( r > l )\n	{\n	    /* "i = partition(x_ve,l,r);" */\n	    v = x_ve[r];\n	    i = l-1;\n	    j = r;\n	    for ( ; ; )\n	    {\n		while ( x_ve[++i] < v )\n		    ;\n		--j;\n		while ( x_ve[j] > v && j != 0 )\n		    --j;\n		if ( i >= j )	break;\n		\n		tmp = x_ve[i];\n		x_ve[i] = x_ve[j];\n		x_ve[j] = tmp;\n		if ( order != PNULL )\n		{\n		    tmp_i = order->pe[i];\n		    order->pe[i] = order->pe[j];\n		    order->pe[j] = tmp_i;\n		}\n	    }\n	    tmp = x_ve[i];\n	    x_ve[i] = x_ve[r];\n	    x_ve[r] = tmp;\n	    if ( order != PNULL )\n	    {\n		tmp_i = order->pe[i];\n		order->pe[i] = order->pe[r];\n		order->pe[r] = tmp_i;\n	    }\n\n	    if ( i-l > r-i )\n	    {   stack[sp++] = l;   stack[sp++] = i-1;   l = i+1;   }\n	    else\n	    {   stack[sp++] = i+1;   stack[sp++] = r;   r = i-1;   }\n	}\n\n	/* recursion elimination */\n	if ( sp == 0 )\n	    break;\n	r = stack[--sp];\n	l = stack[--sp];\n    }\n\n    return x;\n}\n\n/* v_sum -- returns sum of entries of a vector */\n#ifndef ANSI_C\ndouble	v_sum(x)\nVEC	*x;\n#else\ndouble	v_sum(const VEC *x)\n#endif\n{\n    int		i;\n    Real	sum;\n\n    if ( ! x )\n	error(E_NULL,"v_sum");\n\n    sum = 0.0;\n    for ( i = 0; i < x->dim; i++ )\n	sum += x->ve[i];\n\n    return sum;\n}\n\n/* v_conv -- computes convolution product of two vectors */\n#ifndef ANSI_C\nVEC	*v_conv(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_conv(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,"v_conv");\n    if ( x1 == out || x2 == out )\n	error(E_INSITU,"v_conv");\n    if ( x1->dim == 0 || x2->dim == 0 )\n	return out = v_resize(out,0);\n\n    out = v_resize(out,x1->dim + x2->dim - 1);\n    v_zero(out);\n    for ( i = 0; i < x1->dim; i++ )\n	__mltadd__(&(out->ve[i]),x2->ve,x1->ve[i],x2->dim);\n\n    return out;\n}\n\n/* v_pconv -- computes a periodic convolution product\n	-- the period is the dimension of x2 */\n#ifndef ANSI_C\nVEC	*v_pconv(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_pconv(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,"v_pconv");\n    if ( x1 == out || x2 == out )\n	error(E_INSITU,"v_pconv");\n    out = v_resize(out,x2->dim);\n    if ( x2->dim == 0 )\n	return out;\n\n    v_zero(out);\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	__mltadd__(&(out->ve[i]),x2->ve,x1->ve[i],x2->dim - i);\n	if ( i > 0 )\n	    __mltadd__(out->ve,&(x2->ve[x2->dim - i]),x1->ve[i],i);\n    }\n\n    return out;\n}\n