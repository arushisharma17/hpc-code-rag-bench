////////////////////////////////////////////////////////////////////////////////\n// int solver( fp (*f)(fp, fp), fp y[],        //\n//       fp x, fp h, fp xmax, fp *h_next, fp tolerance )  //\n//                                                                            //\n//  Description:                                                              //\n//     This function solves the differential equation y'=f(x,y) with the      //\n//     initial condition y(x) = y[0].  The value at xmax is returned in y[1]. //\n//     The function returns 0 if successful or -1 if it fails.                //\n//                                                                            //\n//  Arguments:                                                                //\n//     fp *f  Pointer to the function which returns the slope at (x,y) of //\n//                integral curve of the differential equation y' = f(x,y)     //\n//                which passes through the point (x0,y0) corresponding to the //\n//                initial condition y(x0) = y0.                               //\n//     fp y[] On input y[0] is the initial value of y at x, on output     //\n//                y[1] is the solution at xmax.                               //\n//     fp x   The initial value of x.                                     //\n//     fp h   Initial step size.                                          //\n//     fp xmax The endpoint of x.                                         //\n//     fp *h_next   A pointer to the estimated step size for successive   //\n//                      calls to solver.                       //\n//     fp tolerance The tolerance of y(xmax), i.e. a solution is sought   //\n//                so that the relative error < tolerance.                     //\n//                                                                            //\n//  Return Values:                                                            //\n//     0   The solution of y' = f(x,y) from x to xmax is stored y[1] and      //\n//         h_next has the value to the next size to try.                      //\n//    -1   The solution of y' = f(x,y) from x to xmax failed.                 //\n//    -2   Failed because either xmax < x or the step size h <= 0.            //\n//    -3   Memory limit allocated for results was reached                                //\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//	Summary of changes by Lukasz G. Szafaryn:\n\n//	1) The original code was obtained from: Mathematics Source Library (http://mymathlib.webtrellis.net/index.html)\n// 2) This solver and particular solving algorithm used with it (embedded_fehlberg_7_8) were adapted to work with a set of equations, not just one like in original version.\n\n//	3) In order for solver to provide deterministic number of steps (needed for particular amount of memore previousely allocated for results), every next step is incremented by 1 time unit (h_init).\n//	4) Function assumes that time interval starts at 0 (xmin) and ends at integer value (xmax) specified by the uses as a parameter on command line.\n// 5) The appropriate amount of memory is previousely allocated for that range (y).\n\n//	5) This setup in 3) - 5) allows solver to adjust the step ony from current time instance to current time instance + 0.9. The next time instance is current time instance + 1;\n\n//	6) Solver also takes parameters (params) that it then passes to the equations.\n\n//	7) The original solver cannot handle cases when equations return NAN and INF values due to discontinuities and /0. That is why equations provided by user need to make sure that no NAN and INF are returned.\n\n//	Last update: 15 DEC 09\n////////////////////////////////////////////////////////////////////////////////\n\n//======================================================================================================================================================\n//======================================================================================================================================================\n//		INCLUDE\n//======================================================================================================================================================\n//======================================================================================================================================================\n\n#include <math.h>\n\n#define max(x,y) ( (x) < (y) ? (y) : (x) )\n#define min(x,y) ( (x) < (y) ? (x) : (y) )\n\n#define ATTEMPTS 12\n#define MIN_SCALE_FACTOR 0.125\n#define MAX_SCALE_FACTOR 4.0\n\n//======================================================================================================================================================\n//======================================================================================================================================================\n//		SOLVER FUNCTION\n//======================================================================================================================================================\n//======================================================================================================================================================\n\nint solver(	fp** y,\n					fp* x,\n					int xmax,\n					fp* params,\n					int mode) {\n\n	//========================================================================================================================\n	//	VARIABLES\n	//========================================================================================================================\n\n	// solver parameters\n	fp err_exponent;\n	fp last_interval;\n	int error;\n	int outside;\n	fp h;\n	fp h_init;\n	fp tolerance;\n	int xmin;\n\n	// memory\n	fp scale_min;\n	fp scale_fina;\n	fp* err= (fp *) malloc(EQUATIONS* sizeof(fp));\n	fp* scale= (fp *) malloc(EQUATIONS* sizeof(fp));\n	fp* yy= (fp *) malloc(EQUATIONS* sizeof(fp));\n\n	// counters\n	int i, j, k;\n\n	//========================================================================================================================\n	//		INITIAL SETUP\n	//========================================================================================================================\n\n	// solver parameters\n	err_exponent = 1.0 / 7.0;\n	last_interval = 0;\n	h_init = 1;\n	h = h_init;\n	xmin = 0;\n	tolerance = 10 / (fp)(xmax-xmin);\n\n	// save value for initial time instance\n	x[0] = 0;\n\n	//========================================================================================================================\n	//		CHECKING\n	//========================================================================================================================\n\n	// Verify that the step size is positive and that the upper endpoint of integration is greater than the initial enpoint.               //\n	if (xmax < xmin || h <= 0.0){\n		return -2;\n	}\n\n	// If the upper endpoint of the independent variable agrees with the initial value of the independent variable.  Set the value of the dependent variable and return success. //\n	if (xmax == xmin){\n		return 0; \n	}\n\n	// Insure that the step size h is not larger than the length of the integration interval.                                            //\n	if (h > (xmax - xmin) ) { \n		h = (fp)xmax - (fp)xmin; \n		last_interval = 1;\n	}\n\n	//========================================================================================================================\n	//		SOLVING\n	//========================================================================================================================\n\n	for(k=1; k<=xmax; k++) {											// start after initial value\n\n		x[k] = k-1;\n		h = h_init;\n\n		//==========================================================================================\n		//		REINITIALIZE VARIABLES\n		//==========================================================================================\n\n		scale_fina = 1.0;\n\n		//==========================================================================================\n		//		MAKE ATTEMPTS TO MINIMIZE ERROR\n		//==========================================================================================\n\n		// make attempts to minimize error\n		for (j = 0; j < ATTEMPTS; j++) {\n\n			//============================================================\n			//		REINITIALIZE VARIABLES\n			//============================================================\n\n			error = 0;\n			outside = 0;\n			scale_min = MAX_SCALE_FACTOR;\n\n			//============================================================\n			//		EVALUATE ALL EQUATIONS\n			//============================================================\n\n			embedded_fehlberg_7_8(	x[k],\n														h,\n														y[k-1],\n														y[k],\n														err,\n														params,\n														mode);\n\n			//============================================================\n			//		IF THERE WAS NO ERROR FOR ANY OF EQUATIONS, SET SCALE AND LEAVE THE LOOP\n			//============================================================\n\n			for(i=0; i<EQUATIONS; i++){\n				if(err[i] > 0){\n					error = 1;\n				}\n			}\n			if (error != 1) {\n				scale_fina = MAX_SCALE_FACTOR; \n				break;\n			}\n\n			//============================================================\n			//		FIGURE OUT SCALE AS THE MINIMUM OF COMPONENT SCALES\n			//============================================================\n\n			for(i=0; i<EQUATIONS; i++){\n				if(y[k-1][i] == 0.0){\n					yy[i] = tolerance;\n				}\n				else{\n					yy[i] = fabs(y[k-1][i]);\n				}\n				scale[i] = 0.8 * pow( tolerance * yy[i] / err[i] , err_exponent );\n				if(scale[i]<scale_min){\n					scale_min = scale[i];\n				}\n			}\n			scale_fina = min( max(scale_min,MIN_SCALE_FACTOR), MAX_SCALE_FACTOR);\n\n			//============================================================\n			//		IF WITHIN TOLERANCE, FINISH ATTEMPTS...\n			//============================================================\n\n			for(i=0; i<EQUATIONS; i++){\n				if ( err[i] > ( tolerance * yy[i] ) ){\n					outside = 1;\n				}\n			}\n			if (outside == 0){\n				break;\n			}\n\n			//============================================================\n			//		...OTHERWISE, ADJUST STEP FOR NEXT ATTEMPT\n			//============================================================\n\n			// scale next step in a default way\n			h = h * scale_fina;\n\n			// limit step to 0.9, because when it gets close to 1, it no longer makes sense, as 1 is already the next time instance (added to original algorithm)\n			if (h >= 0.9) {\n				h = 0.9;\n			}\n\n			// if instance+step exceeds range limit, limit to that range\n			if ( x[k] + h > (fp)xmax ){\n				h = (fp)xmax - x[k];\n			}\n\n			// if getting closer to range limit, decrease step\n			else if ( x[k] + h + 0.5 * h > (fp)xmax ){\n				h = 0.5 * h;\n			}\n\n		}\n\n		//==========================================================================================\n		//		SAVE TIME INSTANCE THAT SOLVER ENDED UP USING\n		//==========================================================================================\n\n		x[k] = x[k] + h;\n\n		//==========================================================================================\n		//		IF MAXIMUM NUMBER OF ATTEMPTS REACHED AND CANNOT GIVE SOLUTION, EXIT PROGRAM WITH ERROR\n		//==========================================================================================\n\n		if ( j >= ATTEMPTS ) {\n			return -1; \n		}\n\n	}\n\n	//========================================================================================================================\n	//		FREE MEMORY\n	//========================================================================================================================\n\n	free(err);\n	free(scale);\n	free(yy);\n\n	//========================================================================================================================\n	//		FINAL RETURN\n	//========================================================================================================================\n\n	return 0;\n\n//======================================================================================================================================================\n//======================================================================================================================================================\n//		END OF SOLVER FUNCTION\n//======================================================================================================================================================\n//======================================================================================================================================================\n\n} \n