\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains routines for import/exporting complex data\n	to/from MATLAB. The main routines are:\n			ZMAT *zm_save(FILE *fp,ZMAT *A,char *name)\n			ZVEC *zv_save(FILE *fp,ZVEC *x,char *name)\n			complex z_save(FILE *fp,complex z,char *name)\n			ZMAT *zm_load(FILE *fp,char **name)\n*/\n\n#include        <stdio.h>\n#include        "zmatrix.h"\n#include	"matlab.h"\n\nstatic char rcsid[] = "$Id: zmatlab.c,v 1.2 1995/02/14 20:13:27 des Exp $";\n\n/* zm_save -- save matrix in ".mat" file for MATLAB\n   -- returns matrix to be saved */\nZMAT    *zm_save(fp,A,name)\nFILE    *fp;\nZMAT    *A;\nchar    *name;\n{\n    int     i, j;\n    matlab  mat;\n    \n    if ( ! A )\n	error(E_NULL,"zm_save");\n    \n    mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n    mat.m = A->m;\n    mat.n = A->n;\n    mat.imag = TRUE;\n    mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n    \n    /* write header */\n    fwrite(&mat,sizeof(matlab),1,fp);\n    /* write name */\n    if ( name == (char *)NULL )\n	fwrite("",sizeof(char),1,fp);\n    else\n	fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n    /* write actual data */\n#if ORDER == ROW_ORDER\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < A->n; j++ )\n	    fwrite(&(A->me[i][j].re),sizeof(Real),1,fp);\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < A->n; j++ )\n	    fwrite(&(A->me[i][j].im),sizeof(Real),1,fp);\n#else /* column major order: ORDER == COL_ORDER */\n    for ( j = 0; j < A->n; j++ )\n	for ( i = 0; i < A->m; i++ )\n	    fwrite(&(A->me[i][j].re),sizeof(Real),1,fp);\n    for ( j = 0; j < A->n; j++ )\n	for ( i = 0; i < A->m; i++ )\n	    fwrite(&(A->me[i][j].im),sizeof(Real),1,fp);\n#endif\n    \n    return A;\n}\n\n\n/* zv_save -- save vector in ".mat" file for MATLAB\n   -- saves it as a row vector\n   -- returns vector to be saved */\nZVEC    *zv_save(fp,x,name)\nFILE    *fp;\nZVEC    *x;\nchar    *name;\n{\n    int	i, j;\n    matlab  mat;\n    \n    if ( ! x )\n	error(E_NULL,"zv_save");\n    \n    mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n    mat.m = x->dim;\n    mat.n = 1;\n    mat.imag = TRUE;\n    mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n    \n    /* write header */\n    fwrite(&mat,sizeof(matlab),1,fp);\n    /* write name */\n    if ( name == (char *)NULL )\n	fwrite("",sizeof(char),1,fp);\n    else\n	fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n    /* write actual data */\n    for ( i = 0; i < x->dim; i++ )\n	fwrite(&(x->ve[i].re),sizeof(Real),1,fp);\n    for ( i = 0; i < x->dim; i++ )\n	fwrite(&(x->ve[i].im),sizeof(Real),1,fp);\n    \n    return x;\n}\n\n/* z_save -- saves complex number in ".mat" file for MATLAB\n	-- returns complex number to be saved */\ncomplex	z_save(fp,z,name)\nFILE	*fp;\ncomplex	z;\nchar	*name;\n{\n    matlab  mat;\n    \n    mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n    mat.m = 1;\n    mat.n = 1;\n    mat.imag = TRUE;\n    mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n    \n    /* write header */\n    fwrite(&mat,sizeof(matlab),1,fp);\n    /* write name */\n    if ( name == (char *)NULL )\n	fwrite("",sizeof(char),1,fp);\n    else\n	fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n    /* write actual data */\n    fwrite(&z,sizeof(complex),1,fp);\n    \n    return z;\n}\n\n\n\n/* zm_load -- loads in a ".mat" file variable as produced by MATLAB\n   -- matrix returned; imaginary parts ignored */\nZMAT    *zm_load(fp,name)\nFILE    *fp;\nchar    **name;\n{\n    ZMAT     *A;\n    int     i;\n    int     m_flag, o_flag, p_flag, t_flag;\n    float   f_temp;\n    double  d_temp;\n    matlab  mat;\n    \n    if ( fread(&mat,sizeof(matlab),1,fp) != 1 )\n	error(E_FORMAT,"zm_load");\n    if ( mat.type >= 10000 )	/* don't load a sparse matrix! */\n	error(E_FORMAT,"zm_load");\n    m_flag = (mat.type/1000) % 10;\n    o_flag = (mat.type/100) % 10;\n    p_flag = (mat.type/10) % 10;\n    t_flag = (mat.type) % 10;\n    if ( m_flag != MACH_ID )\n	error(E_FORMAT,"zm_load");\n    if ( t_flag != 0 )\n	error(E_FORMAT,"zm_load");\n    if ( p_flag != DOUBLE_PREC && p_flag != SINGLE_PREC )\n	error(E_FORMAT,"zm_load");\n    *name = (char *)malloc((unsigned)(mat.namlen)+1);\n    if ( fread(*name,sizeof(char),(unsigned)(mat.namlen),fp) == 0 )\n	error(E_FORMAT,"zm_load");\n    A = zm_get((unsigned)(mat.m),(unsigned)(mat.n));\n    for ( i = 0; i < A->m*A->n; i++ )\n    {\n	if ( p_flag == DOUBLE_PREC )\n	    fread(&d_temp,sizeof(double),1,fp);\n	else\n	{\n	    fread(&f_temp,sizeof(float),1,fp);\n	    d_temp = f_temp;\n	}\n	if ( o_flag == ROW_ORDER )\n	    A->me[i / A->n][i % A->n].re = d_temp;\n	else if ( o_flag == COL_ORDER )\n	    A->me[i % A->m][i / A->m].re = d_temp;\n	else\n	    error(E_FORMAT,"zm_load");\n    }\n    \n    if ( mat.imag )         /* skip imaginary part */\n	for ( i = 0; i < A->m*A->n; i++ )\n	{\n	    if ( p_flag == DOUBLE_PREC )\n		fread(&d_temp,sizeof(double),1,fp);\n	    else\n	    {\n		fread(&f_temp,sizeof(float),1,fp);\n		d_temp = f_temp;\n	    }\n	    if ( o_flag == ROW_ORDER )\n		A->me[i / A->n][i % A->n].im = d_temp;\n	    else if ( o_flag == COL_ORDER )\n		A->me[i % A->m][i / A->m].im = d_temp;\n	    else\n		error(E_FORMAT,"zm_load");\n	}\n    \n    return A;\n}\n\n