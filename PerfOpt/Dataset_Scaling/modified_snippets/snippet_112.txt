\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n/*\n		Files for matrix computations\n\n	Givens operations file. Contains routines for calculating and\n	applying givens rotations for/to vectors and also to matrices by\n	row and by column.\n*/\n\n/* givens.c 1.2 11/25/87 */\nstatic	char	rcsid[] = "$Id: givens.c,v 1.3 1995/03/27 15:41:15 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n/* givens -- returns c,s parameters for Givens rotation to\n		eliminate y in the vector [ x y ]' */\n#ifndef ANSI_C\nvoid	givens(x,y,c,s)\ndouble  x,y;\nReal	*c,*s;\n#else\nvoid	givens(double x, double y, Real *c, Real *s)\n#endif\n{\n	Real	norm;\n\n	norm = sqrt(x*x+y*y);\n	if ( norm == 0.0 )\n	{	*c = 1.0;	*s = 0.0;	}	/* identity */\n	else\n	{	*c = x/norm;	*s = y/norm;	}\n}\n\n/* rot_vec -- apply Givens rotation to x's i & k components */\n#ifndef ANSI_C\nVEC	*rot_vec(x,i,k,c,s,out)\nVEC	*x,*out;\nunsigned int	i,k;\ndouble	c,s;\n#else\nVEC	*rot_vec(const VEC *x,unsigned int i,unsigned int k, double c,double s,\n		 VEC *out)\n#endif\n{\n	Real	temp;\n\n	if ( x==VNULL )\n		error(E_NULL,"rot_vec");\n	if ( i >= x->dim || k >= x->dim )\n		error(E_RANGE,"rot_vec");\n	out = v_copy(x,out);\n\n	/* temp = c*out->ve[i] + s*out->ve[k]; */\n	temp = c*v_entry(out,i) + s*v_entry(out,k);\n	/* out->ve[k] = -s*out->ve[i] + c*out->ve[k]; */\n	v_set_val(out,k,-s*v_entry(out,i)+c*v_entry(out,k));\n	/* out->ve[i] = temp; */\n	v_set_val(out,i,temp);\n\n	return (out);\n}\n\n/* rot_rows -- premultiply mat by givens rotation described by c,s */\n#ifndef ANSI_C\nMAT	*rot_rows(mat,i,k,c,s,out)\nMAT	*mat,*out;\nunsigned int	i,k;\ndouble	c,s;\n#else\nMAT	*rot_rows(const MAT *mat, unsigned int i, unsigned int k,\n		  double c, double s, MAT *out)\n#endif\n{\n	unsigned int	j;\n	Real	temp;\n\n	if ( mat==(MAT *)NULL )\n		error(E_NULL,"rot_rows");\n	if ( i >= mat->m || k >= mat->m )\n		error(E_RANGE,"rot_rows");\n	if ( mat != out )\n		out = m_copy(mat,m_resize(out,mat->m,mat->n));\n\n	for ( j=0; j<mat->n; j++ )\n	{\n		/* temp = c*out->me[i][j] + s*out->me[k][j]; */\n		temp = c*m_entry(out,i,j) + s*m_entry(out,k,j);\n		/* out->me[k][j] = -s*out->me[i][j] + c*out->me[k][j]; */\n		m_set_val(out,k,j, -s*m_entry(out,i,j) + c*m_entry(out,k,j));\n		/* out->me[i][j] = temp; */\n		m_set_val(out,i,j, temp);\n	}\n\n	return (out);\n}\n\n/* rot_cols -- postmultiply mat by givens rotation described by c,s */\n#ifndef ANSI_C\nMAT	*rot_cols(mat,i,k,c,s,out)\nMAT	*mat,*out;\nunsigned int	i,k;\ndouble	c,s;\n#else\nMAT	*rot_cols(const MAT *mat,unsigned int i,unsigned int k,\n		  double c, double s, MAT *out)\n#endif\n{\n	unsigned int	j;\n	Real	temp;\n\n	if ( mat==(MAT *)NULL )\n		error(E_NULL,"rot_cols");\n	if ( i >= mat->n || k >= mat->n )\n		error(E_RANGE,"rot_cols");\n	if ( mat != out )\n		out = m_copy(mat,m_resize(out,mat->m,mat->n));\n\n	for ( j=0; j<mat->m; j++ )\n	{\n		/* temp = c*out->me[j][i] + s*out->me[j][k]; */\n		temp = c*m_entry(out,j,i) + s*m_entry(out,j,k);\n		/* out->me[j][k] = -s*out->me[j][i] + c*out->me[j][k]; */\n		m_set_val(out,j,k, -s*m_entry(out,j,i) + c*m_entry(out,j,k));\n		/* out->me[j][i] = temp; */\n		m_set_val(out,j,i,temp);\n	}\n\n	return (out);\n}\n\n