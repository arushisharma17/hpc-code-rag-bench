\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Conjugate gradient routines file\n	Uses sparse matrix input & sparse Cholesky factorisation in pccg().\n\n	All the following routines use routines to define a matrix\n		rather than use any explicit representation\n		(with the exeception of the pccg() pre-conditioner)\n	The matrix A is defined by\n\n		VEC *(*A)(void *params, VEC *x, VEC *y)\n\n	where y = A.x on exit, and y is returned. The params argument is\n	intended to make it easier to re-use & modify such routines.\n\n	If we have a sparse matrix data structure\n		SPMAT	*A_mat;\n	then these can be used by passing sp_mv_mlt as the function, and\n	A_mat as the param.\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include	"sparse.h"\nstatic char	rcsid[] = "$Id: conjgrad.c,v 1.4 1994/01/13 05:36:45 des Exp $";\n\n\n/* #define	MAX_ITER	10000 */\nstatic	int	max_iter = 10000;\nint	cg_num_iters;\n\n/* matrix-as-routine type definition */\n/* #ifdef ANSI_C */\n/* typedef VEC	*(*MTX_FN)(void *params, VEC *x, VEC *out); */\n/* #else */\ntypedef VEC	*(*MTX_FN)();\n/* #endif */\n#ifdef ANSI_C\nVEC	*spCHsolve(SPMAT *,VEC *,VEC *);\n#else\nVEC	*spCHsolve();\n#endif\n\n/* cg_set_maxiter -- sets maximum number of iterations if numiter > 1\n	-- just returns current max_iter otherwise\n	-- returns old maximum */\nint	cg_set_maxiter(numiter)\nint	numiter;\n{\n	int	temp;\n\n	if ( numiter < 2 )\n	    return max_iter;\n	temp = max_iter;\n	max_iter = numiter;\n	return temp;\n}\n\n\n/* pccg -- solves A.x = b using pre-conditioner M\n			(assumed factored a la spCHfctr())\n	-- results are stored in x (if x != NULL), which is returned */\nVEC	*pccg(A,A_params,M_inv,M_params,b,eps,x)\nMTX_FN	A, M_inv;\nVEC	*b, *x;\ndouble	eps;\nvoid	*A_params, *M_params;\n{\n	VEC	*r = VNULL, *p = VNULL, *q = VNULL, *z = VNULL;\n	int	k;\n	Real	alpha, beta, ip, old_ip, norm_b;\n\n	if ( ! A || ! b )\n		error(E_NULL,"pccg");\n	if ( x == b )\n		error(E_INSITU,"pccg");\n	x = v_resize(x,b->dim);\n	if ( eps <= 0.0 )\n		eps = MACHEPS;\n\n	r = v_get(b->dim);\n	p = v_get(b->dim);\n	q = v_get(b->dim);\n	z = v_get(b->dim);\n\n	norm_b = v_norm2(b);\n\n	v_zero(x);\n	r = v_copy(b,r);\n	old_ip = 0.0;\n	for ( k = 0; ; k++ )\n	{\n		if ( v_norm2(r) < eps*norm_b )\n			break;\n		if ( k > max_iter )\n		    error(E_ITER,"pccg");\n		if ( M_inv )\n		    (*M_inv)(M_params,r,z);\n		else\n		    v_copy(r,z);	/* M == identity */\n		ip = in_prod(z,r);\n		if ( k )	/* if ( k > 0 ) ... */\n		{\n		    beta = ip/old_ip;\n		    p = v_mltadd(z,p,beta,p);\n		}\n		else		/* if ( k == 0 ) ... */\n		{\n		    beta = 0.0;\n		    p = v_copy(z,p);\n		    old_ip = 0.0;\n		}\n		q = (*A)(A_params,p,q);\n		alpha = ip/in_prod(p,q);\n		x = v_mltadd(x,p,alpha,x);\n		r = v_mltadd(r,q,-alpha,r);\n		old_ip = ip;\n	}\n	cg_num_iters = k;\n\n	V_FREE(p);\n	V_FREE(q);\n	V_FREE(r);\n	V_FREE(z);\n\n	return x;\n}\n\n/* sp_pccg -- a simple interface to pccg() which uses sparse matrix\n		data structures\n	-- assumes that LLT contains the Cholesky factorisation of the\n		actual pre-conditioner */\nVEC	*sp_pccg(A,LLT,b,eps,x)\nSPMAT	*A, *LLT;\nVEC	*b, *x;\ndouble	eps;\n{	return pccg(sp_mv_mlt,A,spCHsolve,LLT,b,eps,x);		}\n\n\n/*\n	Routines for performing the CGS (Conjugate Gradient Squared)\n	algorithm of P. Sonneveld:\n	    "CGS, a fast Lanczos-type solver for nonsymmetric linear\n		systems", SIAM J. Sci. & Stat. Comp. v. 10, pp. 36--52\n*/\n\n/* cgs -- uses CGS to compute a solution x to A.x=b\n	-- the matrix A is not passed explicitly, rather a routine\n		A is passed where A(x,Ax,params) computes\n		Ax = A.x\n	-- the computed solution is passed */\nVEC	*cgs(A,A_params,b,r0,tol,x)\nMTX_FN	A;\nVEC	*x, *b;\nVEC	*r0;		/* tilde r0 parameter -- should be random??? */\ndouble	tol;		/* error tolerance used */\nvoid	*A_params;\n{\n	VEC	*p, *q, *r, *u, *v, *tmp1, *tmp2;\n	Real	alpha, beta, norm_b, rho, old_rho, sigma;\n	int	iter;\n\n	if ( ! A || ! x || ! b || ! r0 )\n		error(E_NULL,"cgs");\n	if ( x->dim != b->dim || r0->dim != x->dim )\n		error(E_SIZES,"cgs");\n	if ( tol <= 0.0 )\n		tol = MACHEPS;\n\n	p = v_get(x->dim);\n	q = v_get(x->dim);\n	r = v_get(x->dim);\n	u = v_get(x->dim);\n	v = v_get(x->dim);\n	tmp1 = v_get(x->dim);\n	tmp2 = v_get(x->dim);\n\n	norm_b = v_norm2(b);\n	(*A)(A_params,x,tmp1);\n	v_sub(b,tmp1,r);\n	v_zero(p);	v_zero(q);\n	old_rho = 1.0;\n\n	iter = 0;\n	while ( v_norm2(r) > tol*norm_b )\n	{\n		if ( ++iter > max_iter ) break;\n		/*    error(E_ITER,"cgs");  */\n		rho = in_prod(r0,r);\n		if ( old_rho == 0.0 )\n		    error(E_SING,"cgs");\n		beta = rho/old_rho;\n		v_mltadd(r,q,beta,u);\n		v_mltadd(q,p,beta,tmp1);\n		v_mltadd(u,tmp1,beta,p);\n\n		(*A)(A_params,p,v);\n\n		sigma = in_prod(r0,v);\n		if ( sigma == 0.0 )\n		    error(E_SING,"cgs");\n		alpha = rho/sigma;\n		v_mltadd(u,v,-alpha,q);\n		v_add(u,q,tmp1);\n\n		(*A)(A_params,tmp1,tmp2);\n\n		v_mltadd(r,tmp2,-alpha,r);\n		v_mltadd(x,tmp1,alpha,x);\n\n		old_rho = rho;\n	}\n	cg_num_iters = iter;\n\n	V_FREE(p);	V_FREE(q);	V_FREE(r);\n	V_FREE(u);	V_FREE(v);\n	V_FREE(tmp1);	V_FREE(tmp2);\n\n	return x;\n}\n\n/* sp_cgs -- simple interface for SPMAT data structures */\nVEC	*sp_cgs(A,b,r0,tol,x)\nSPMAT	*A;\nVEC	*b, *r0, *x;\ndouble	tol;\n{	return cgs(sp_mv_mlt,A,b,r0,tol,x);	}\n\n/*\n	Routine for performing LSQR -- the least squares QR algorithm\n	of Paige and Saunders:\n		"LSQR: an algorithm for sparse linear equations and\n		sparse least squares", ACM Trans. Math. Soft., v. 8\n		pp. 43--71 (1982)\n*/\n/* lsqr -- sparse CG-like least squares routine:\n	-- finds min_x ||A.x-b||_2 using A defined through A & AT\n	-- returns x (if x != NULL) */\nVEC	*lsqr(A,AT,A_params,b,tol,x)\nMTX_FN	A, AT;	/* AT is A transposed */\nVEC	*x, *b;\ndouble	tol;		/* error tolerance used */\nvoid	*A_params;\n{\n	VEC	*u, *v, *w, *tmp;\n	Real	alpha, beta, norm_b, phi, phi_bar,\n				rho, rho_bar, rho_max, theta;\n	Real	s, c;	/* for Givens' rotations */\n	int	iter, m, n;\n\n	if ( ! b || ! x )\n		error(E_NULL,"lsqr");\n	if ( tol <= 0.0 )\n		tol = MACHEPS;\n\n	m = b->dim;	n = x->dim;\n	u = v_get((unsigned int)m);\n	v = v_get((unsigned int)n);\n	w = v_get((unsigned int)n);\n	tmp = v_get((unsigned int)n);\n	norm_b = v_norm2(b);\n\n	v_zero(x);\n	beta = v_norm2(b);\n	if ( beta == 0.0 )\n		return x;\n	sv_mlt(1.0/beta,b,u);\n	tracecatch((*AT)(A_params,u,v),"lsqr");\n	alpha = v_norm2(v);\n	if ( alpha == 0.0 )\n		return x;\n	sv_mlt(1.0/alpha,v,v);\n	v_copy(v,w);\n	phi_bar = beta;		rho_bar = alpha;\n\n	rho_max = 1.0;\n	iter = 0;\n	do {\n		if ( ++iter > max_iter )\n		    error(E_ITER,"lsqr");\n\n		tmp = v_resize(tmp,m);\n		tracecatch((*A) (A_params,v,tmp),"lsqr");\n\n		v_mltadd(tmp,u,-alpha,u);\n		beta = v_norm2(u);	sv_mlt(1.0/beta,u,u);\n\n		tmp = v_resize(tmp,n);\n		tracecatch((*AT)(A_params,u,tmp),"lsqr");\n		v_mltadd(tmp,v,-beta,v);\n		alpha = v_norm2(v);	sv_mlt(1.0/alpha,v,v);\n\n		rho = sqrt(rho_bar*rho_bar+beta*beta);\n		if ( rho > rho_max )\n		    rho_max = rho;\n		c   = rho_bar/rho;\n		s   = beta/rho;\n		theta   =  s*alpha;\n		rho_bar = -c*alpha;\n		phi     =  c*phi_bar;\n		phi_bar =  s*phi_bar;\n\n		/* update x & w */\n		if ( rho == 0.0 )\n		    error(E_SING,"lsqr");\n		v_mltadd(x,w,phi/rho,x);\n		v_mltadd(v,w,-theta/rho,w);\n	} while ( fabs(phi_bar*alpha*c) > tol*norm_b/rho_max );\n\n	cg_num_iters = iter;\n\n	V_FREE(tmp);	V_FREE(u);	V_FREE(v);	V_FREE(w);\n\n	return x;\n}\n\n/* sp_lsqr -- simple interface for SPMAT data structures */\nVEC	*sp_lsqr(A,b,tol,x)\nSPMAT	*A;\nVEC	*b, *x;\ndouble	tol;\n{	return lsqr(sp_mv_mlt,sp_vm_mlt,A,b,tol,x);	}\n\n