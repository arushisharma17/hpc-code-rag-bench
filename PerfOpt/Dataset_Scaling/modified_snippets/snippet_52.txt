#include "track_ellipse.h"\n\n\nvoid ellipsetrack(avi_t *video, double *xc0, double *yc0, int Nc, int R, int Np, int Nf) {\n	/*\n	% ELLIPSETRACK tracks cells in the movie specified by 'video', at\n	%  locations 'xc0'/'yc0' with radii R using an ellipse with Np discrete\n	%  points, starting at frame number one and stopping at frame number 'Nf'.\n	%\n	% INPUTS:\n	%   video.......pointer to avi video object\n	%   xc0,yc0.....initial center location (Nc entries)\n	%   Nc..........number of cells\n	%   R...........initial radius\n	%   Np..........nbr of snaxels points per snake\n	%   Nf..........nbr of frames in which to track\n	%\n	% Matlab code written by: DREW GILLIAM (based on code by GANG DONG /\n	%                                                        NILANJAN RAY)\n	% Ported to C by: MICHAEL BOYER\n	*/\n	\n	int i, j;\n	\n	// Compute angle parameter\n	double *t = (double *) malloc(sizeof(double) * Np);\n	double increment = (2.0 * PI) / (double) Np;\n	for (i = 0; i < Np; i++) {\n		t[i] =  increment * (double) i ;\n	}\n\n	// Allocate space for a snake for each cell in each frame\n	double **xc = alloc_2d_double(Nc, Nf + 1);\n	double **yc = alloc_2d_double(Nc, Nf + 1);\n	double ***r = alloc_3d_double(Nc, Np, Nf + 1);\n	double ***x = alloc_3d_double(Nc, Np, Nf + 1);\n	double ***y = alloc_3d_double(Nc, Np, Nf + 1);\n	\n	// Save the first snake for each cell\n	for (i = 0; i < Nc; i++) {\n		xc[i][0] = xc0[i];\n		yc[i][0] = yc0[i];\n		for (j = 0; j < Np; j++) {\n			r[i][j][0] = (double) R;\n		}\n	}\n	\n	// Generate ellipse points for each cell\n	for (i = 0; i < Nc; i++) {\n		for (j = 0; j < Np; j++) {\n			x[i][j][0] = xc[i][0] + (r[i][j][0] * cos(t[j]));\n			y[i][j][0] = yc[i][0] + (r[i][j][0] * sin(t[j]));\n		}\n	}\n	\n	// Keep track of the total time spent on computing\n	//  the MGVF matrix and evolving the snakes\n	long long  MGVF_time = 0;\n	long long snake_time = 0;\n	\n	\n	// Process each frame\n	int frame_num, cell_num;\n	for (frame_num = 1; frame_num <= Nf; frame_num++) {	 \n		printf("\rProcessing frame %d / %d", frame_num, Nf);\n		fflush(stdout);\n		\n		// Get the current video frame and its dimensions\n		MAT *I = get_frame(video, frame_num, 0, 1);\n		int Ih = I->m;\n		int Iw = I->n;\n	    \n	    // Set the current positions equal to the previous positions		\n		for (i = 0; i < Nc; i++) {\n			xc[i][frame_num] = xc[i][frame_num - 1];\n			yc[i][frame_num] = yc[i][frame_num - 1];\n			for (j = 0; j < Np; j++) {\n				r[i][j][frame_num] = r[i][j][frame_num - 1];\n			}\n		}\n		\n		// Split the work among multiple threads, if OPEN is defined\n		#ifdef OPEN\n		#pragma omp parallel for num_threads(omp_num_threads) private(i, j)\n		#endif\n		// Track each cell\n		for (cell_num = 0; cell_num < Nc; cell_num++) {\n			// Make copies of the current cell's location\n			double xci = xc[cell_num][frame_num];\n			double yci = yc[cell_num][frame_num];\n			double *ri = (double *) malloc(sizeof(double) * Np);\n			for (j = 0; j < Np; j++) {\n				ri[j] = r[cell_num][j][frame_num];\n			}\n			\n			// Add up the last ten y-values for this cell\n			//  (or fewer if there are not yet ten previous frames)\n			double ycavg = 0.0;\n			for (i = (frame_num > 10 ? frame_num - 10 : 0); i < frame_num; i++) {\n				ycavg += yc[cell_num][i];\n			}\n			// Compute the average of the last ten y-values\n			//  (this represents the expected y-location of the cell)\n			ycavg = ycavg / (double) (frame_num > 10 ? 10 : frame_num);\n			\n			// Determine the range of the subimage surrounding the current position\n			int u1 = max(xci - 4.0 * R + 0.5, 0 );\n			int u2 = min(xci + 4.0 * R + 0.5, Iw - 1);\n			int v1 = max(yci - 2.0 * R + 1.5, 0 );    \n			int v2 = min(yci + 2.0 * R + 1.5, Ih - 1);\n			\n			// Extract the subimage\n			MAT *Isub = m_get(v2 - v1 + 1, u2 - u1 + 1);\n			for (i = v1; i <= v2; i++) {\n				for (j = u1; j <= u2; j++) {\n					m_set_val(Isub, i - v1, j - u1, m_get_val(I, i, j));\n				}\n			}\n			\n	        // Compute the subimage gradient magnitude			\n			MAT *Ix = gradient_x(Isub);\n			MAT *Iy = gradient_y(Isub);\n			MAT *IE = m_get(Isub->m, Isub->n);\n			for (i = 0; i < Isub->m; i++) {\n				for (j = 0; j < Isub->n; j++) {\n					double temp_x = m_get_val(Ix, i, j);\n					double temp_y = m_get_val(Iy, i, j);\n					m_set_val(IE, i, j, sqrt((temp_x * temp_x) + (temp_y * temp_y)));\n				}\n			}\n			\n			// Compute the motion gradient vector flow (MGVF) edgemaps\n			long long MGVF_start_time = get_time();\n			MAT *IMGVF = MGVF(IE, 1, 1);\n			MGVF_time += get_time() - MGVF_start_time;\n			\n			// Determine the position of the cell in the subimage			\n			xci = xci - (double) u1;\n			yci = yci - (double) (v1 - 1);\n			ycavg = ycavg - (double) (v1 - 1);\n			\n			// Evolve the snake\n			long long snake_start_time = get_time();\n			ellipseevolve(IMGVF, &xci, &yci, ri, t, Np, (double) R, ycavg);\n			snake_time += get_time() - snake_start_time;\n			\n			// Compute the cell's new position in the full image\n			xci = xci + u1;\n			yci = yci + (v1 - 1);\n			\n			// Store the new location of the cell and the snake\n			xc[cell_num][frame_num] = xci;\n			yc[cell_num][frame_num] = yci;\n			for (j = 0; j < Np; j++) {\n				r[cell_num][j][frame_num] = ri[j];\n				x[cell_num][j][frame_num] = xc[cell_num][frame_num] + (ri[j] * cos(t[j]));\n				y[cell_num][j][frame_num] = yc[cell_num][frame_num] + (ri[j] * sin(t[j]));\n			}\n			\n			// Output the updated center of each cell\n			//printf("%d,%f,%f\n", cell_num, xci[cell_num], yci[cell_num]);\n			\n			// Free temporary memory\n			m_free(IMGVF);\n			free(ri);\n	    }\n\n#ifdef OUTPUT\n		if (frame_num == Nf)\n		  {\n		    FILE * pFile;\n		    pFile = fopen ("result.txt","w+");\n	\n		    for (cell_num = 0; cell_num < Nc; cell_num++)		\n		      fprintf(pFile,"\n%d,%f,%f", cell_num, xc[cell_num][Nf], yc[cell_num][Nf]);\n\n		    fclose (pFile);\n		  }\n		\n#endif\n	\n	\n		// Output a new line to visually distinguish the output from different frames\n		//printf("\n");\n	}\n	\n	// Free temporary memory\n	free(t);\n	free_2d_double(xc);\n	free_2d_double(yc);\n	free_3d_double(r);\n	free_3d_double(x);\n	free_3d_double(y);\n	\n	// Report average processing time per frame\n	printf("\n\nTracking runtime (average per frame):\n");\n	printf("------------------------------------\n");\n	printf("MGVF computation: %.5f seconds\n", ((float) (MGVF_time)) / (float) (1000*1000*Nf));\n	printf(" Snake evolution: %.5f seconds\n", ((float) (snake_time)) / (float) (1000*1000*Nf));\n}\n\n\nMAT *MGVF(MAT *I, double vx, double vy) {\n	/*\n	% MGVF calculate the motion gradient vector flow (MGVF) \n	%  for the image 'I'\n	%\n	% Based on the algorithm in:\n	%  Motion gradient vector flow: an external force for tracking rolling \n	%   leukocytes with shape and size constrained active contours\n	%  Ray, N. and Acton, S.T.\n	%  IEEE Transactions on Medical Imaging\n	%  Volume: 23, Issue: 12, December 2004 \n	%  Pages: 1466 - 1478\n	%\n	% INPUTS\n	%   I...........image\n	%   vx,vy.......velocity vector\n	%   \n	% OUTPUT\n	%   IMGVF.......MGVF vector field as image\n	%\n	% Matlab code written by: DREW GILLIAM (based on work by GANG DONG /\n	%                                                        NILANJAN RAY)\n	% Ported to C by: MICHAEL BOYER\n	*/\n\n	// Constants\n	double converge = 0.00001;\n	double mu = 0.5;\n	double epsilon = 0.0000000001;\n	double lambda = 8.0 * mu + 1.0;\n	// Smallest positive value expressable in double-precision\n	double eps = pow(2.0, -52.0);\n	// Maximum number of iterations to compute the MGVF matrix\n	int iterations = 500;\n	\n	// Find the maximum and minimum values in I\n	int m = I->m, n = I->n, i, j;\n	double Imax = m_get_val(I, 0, 0);\n	double Imin = m_get_val(I, 0, 0);\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double temp = m_get_val(I, i, j);\n			if (temp > Imax) Imax = temp;\n			else if (temp < Imin) Imin = temp;\n		}\n	}\n	\n	// Normalize the image I\n	double scale = 1.0 / (Imax - Imin + eps);\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double old_val = m_get_val(I, i, j);\n			m_set_val(I, i, j, (old_val - Imin) * scale);\n		}\n	}\n\n	// Initialize the output matrix IMGVF with values from I\n	MAT *IMGVF = m_get(m, n);\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			m_set_val(IMGVF, i, j, m_get_val(I, i, j));\n		}\n	}\n	\n	// Precompute row and column indices for the\n	//  neighbor difference computation below\n	int *rowU = (int *) malloc(sizeof(int) * m);\n	int *rowD = (int *) malloc(sizeof(int) * m);\n	int *colL = (int *) malloc(sizeof(int) * n);\n	int *colR = (int *) malloc(sizeof(int) * n);\n	rowU[0] = 0;\n	rowD[m - 1] = m - 1;\n	for (i = 1; i < m; i++) {\n		rowU[i] = i - 1;\n		rowD[i - 1] = i;\n	}\n	colL[0] = 0;\n	colR[n - 1] = n - 1;\n	for (j = 1; j < n; j++) {\n		colL[j] = j - 1;\n		colR[j - 1] = j;\n	}\n	\n	// Allocate matrices used in the while loop below\n	MAT *U    = m_get(m, n), *D    = m_get(m, n), *L    = m_get(m, n), *R    = m_get(m, n);\n	MAT *UR   = m_get(m, n), *DR   = m_get(m, n), *UL   = m_get(m, n), *DL   = m_get(m, n);\n	MAT *UHe  = m_get(m, n), *DHe  = m_get(m, n), *LHe  = m_get(m, n), *RHe  = m_get(m, n);\n	MAT *URHe = m_get(m, n), *DRHe = m_get(m, n), *ULHe = m_get(m, n), *DLHe = m_get(m, n);\n\n	\n	// Precompute constants to avoid division in the for loops below\n	double mu_over_lambda = mu / lambda;\n	double one_over_lambda = 1.0 / lambda;\n	\n	// Compute the MGVF\n	int iter = 0;\n	double mean_diff = 1.0;\n	while ((iter < iterations) && (mean_diff > converge)) { \n	    \n	    // Compute the difference between each pixel and its eight neighbors\n		for (i = 0; i < m; i++) {\n			for (j = 0; j < n; j++) {\n				double subtrahend = m_get_val(IMGVF, i, j);\n				m_set_val(U, i, j, m_get_val(IMGVF, rowU[i], j) - subtrahend);\n				m_set_val(D, i, j, m_get_val(IMGVF, rowD[i], j) - subtrahend);\n				m_set_val(L, i, j, m_get_val(IMGVF, i, colL[j]) - subtrahend);\n				m_set_val(R, i, j, m_get_val(IMGVF, i, colR[j]) - subtrahend);\n				m_set_val(UR, i, j, m_get_val(IMGVF, rowU[i], colR[j]) - subtrahend);\n				m_set_val(DR, i, j, m_get_val(IMGVF, rowD[i], colR[j]) - subtrahend);\n				m_set_val(UL, i, j, m_get_val(IMGVF, rowU[i], colL[j]) - subtrahend);\n				m_set_val(DL, i, j, m_get_val(IMGVF, rowD[i], colL[j]) - subtrahend);\n			}\n		}\n		\n	    // Compute the regularized heaviside version of the matrices above\n		heaviside( UHe,  U, -vy,      epsilon);\n		heaviside( DHe,  D,  vy,      epsilon);\n		heaviside( LHe,  L, -vx,      epsilon);\n		heaviside( RHe,  R,  vx,      epsilon);\n		heaviside(URHe, UR,  vx - vy, epsilon);\n		heaviside(DRHe, DR,  vx + vy, epsilon);\n		heaviside(ULHe, UL, -vx - vy, epsilon);\n		heaviside(DLHe, DL,  vy - vx, epsilon);\n		\n		// Update the IMGVF matrix\n		double total_diff = 0.0;\n		for (i = 0; i < m; i++) {\n			for (j = 0; j < n; j++) {\n				// Store the old value so we can compute the difference later\n				double old_val = m_get_val(IMGVF, i, j);\n				\n				// Compute IMGVF += (mu / lambda)(UHe .*U  + DHe .*D  + LHe .*L  + RHe .*R +\n				//                                URHe.*UR + DRHe.*DR + ULHe.*UL + DLHe.*DL);\n				double vU  = m_get_val(UHe,  i, j) * m_get_val(U,  i, j);\n				double vD  = m_get_val(DHe,  i, j) * m_get_val(D,  i, j);\n				double vL  = m_get_val(LHe,  i, j) * m_get_val(L,  i, j);\n				double vR  = m_get_val(RHe,  i, j) * m_get_val(R,  i, j);\n				double vUR = m_get_val(URHe, i, j) * m_get_val(UR, i, j);\n				double vDR = m_get_val(DRHe, i, j) * m_get_val(DR, i, j);\n				double vUL = m_get_val(ULHe, i, j) * m_get_val(UL, i, j);\n				double vDL = m_get_val(DLHe, i, j) * m_get_val(DL, i, j);				\n				double vHe = old_val + mu_over_lambda * (vU + vD + vL + vR + vUR + vDR + vUL + vDL);\n				\n				// Compute IMGVF -= (1 / lambda)(I .* (IMGVF - I))\n				double vI = m_get_val(I, i, j);\n				double new_val = vHe - (one_over_lambda * vI * (vHe - vI));\n				m_set_val(IMGVF, i, j, new_val);\n				\n				// Keep track of the absolute value of the differences\n				//  between this iteration and the previous one\n				total_diff += fabs(new_val - old_val);\n			}\n		}\n		\n		// Compute the mean absolute difference between this iteration\n		//  and the previous one to check for convergence\n		mean_diff = total_diff / (double) (m * n);\n	    \n		iter++;\n	}\n	\n	// Free memory\n	free(rowU); free(rowD); free(colL); free(colR);\n	m_free(U);    m_free(D);    m_free(L);    m_free(R);\n	m_free(UR);   m_free(DR);   m_free(UL);   m_free(DL);\n	m_free(UHe);  m_free(DHe);  m_free(LHe);  m_free(RHe);\n	m_free(URHe); m_free(DRHe); m_free(ULHe); m_free(DLHe);\n\n	return IMGVF;\n}\n\n\n// Regularized version of the Heaviside step function,\n//  parameterized by a small positive number 'e'\nvoid heaviside(MAT *H, MAT *z, double v, double e) {\n	int m = z->m, n = z->n, i, j;\n	\n	// Precompute constants to avoid division in the for loops below\n	double one_over_pi = 1.0 / PI;\n	double one_over_e = 1.0 / e;\n	\n	// Compute H = (1 / pi) * atan((z * v) / e) + 0.5\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double z_val = m_get_val(z, i, j) * v;\n			double H_val = one_over_pi * atan(z_val * one_over_e) + 0.5;\n			m_set_val(H, i, j, H_val);\n		}\n	}\n	\n	// A simpler, faster approximation of the Heaviside function\n	/* for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double z_val = m_get_val(z, i, j) * v;\n			double H_val = 0.5;\n			if (z_val < -0.0001) H_val = 0.0;\n			else if (z_val > 0.0001) H_val = 1.0;\n			m_set_val(H, i, j, H_val);\n		}\n	} */\n}\n\n\nvoid ellipseevolve(MAT *f, double *xc0, double *yc0, double *r0, double *t, int Np, double Er, double Ey) {\n	/*\n	% ELLIPSEEVOLVE evolves a parametric snake according\n	%  to some energy constraints.\n	%\n	% INPUTS:\n	%   f............potential surface\n	%   xc0,yc0......initial center position\n	%   r0,t.........initial radii & angle vectors (with Np elements each)\n	%   Np...........number of snaxel points per snake\n	%   Er...........expected radius\n	%   Ey...........expected y position\n	%\n	% OUTPUTS\n	%   xc0,yc0.......final center position\n	%   r0...........final radii\n	%\n	% Matlab code written by: DREW GILLIAM (based on work by GANG DONG /\n	%                                                        NILANJAN RAY)\n	% Ported to C by: MICHAEL BOYER\n	*/\n	\n	\n	// Constants\n	double deltax = 0.2;\n	double deltay = 0.2;\n	double deltar = 0.2; \n	double converge = 0.1;\n	double lambdaedge = 1;\n	double lambdasize = 0.2;\n	double lambdapath = 0.05;\n	int iterations = 1000;      // maximum number of iterations\n\n	int i, j;\n\n	// Initialize variables\n	double xc = *xc0;\n	double yc = *yc0;\n	double *r = (double *) malloc(sizeof(double) * Np);\n	for (i = 0; i < Np; i++) r[i] = r0[i];\n	\n	// Compute the x- and y-gradients of the MGVF matrix\n	MAT *fx = gradient_x(f);\n	MAT *fy = gradient_y(f);\n	\n	// Normalize the gradients\n	int fh = f->m, fw = f->n;\n	for (i = 0; i < fh; i++) {\n		for (j = 0; j < fw; j++) {\n			double temp_x = m_get_val(fx, i, j);\n			double temp_y = m_get_val(fy, i, j);\n			double fmag = sqrt((temp_x * temp_x) + (temp_y * temp_y));\n			m_set_val(fx, i, j, temp_x / fmag);\n			m_set_val(fy, i, j, temp_y / fmag);\n		}\n	}\n	\n	double *r_old = (double *) malloc(sizeof(double) * Np);\n	VEC *x = v_get(Np);\n	VEC *y = v_get(Np);\n	\n	\n	// Evolve the snake\n	int iter = 0;\n	double snakediff = 1.0;\n	while (iter < iterations && snakediff > converge) {\n		\n		// Save the values from the previous iteration\n		double xc_old = xc, yc_old = yc;\n		for (i = 0; i < Np; i++) {\n			r_old[i] = r[i];\n		}\n		\n		// Compute the locations of the snaxels\n		for (i = 0; i < Np; i++) {\n			v_set_val(x, i, xc + r[i] * cos(t[i]));\n			v_set_val(y, i, yc + r[i] * sin(t[i]));\n		}\n		\n		// See if any of the points in the snake are off the edge of the image\n		double min_x = v_get_val(x, 0), max_x = v_get_val(x, 0);\n		double min_y = v_get_val(y, 0), max_y = v_get_val(y, 0);\n		for (i = 1; i < Np; i++) {\n			double x_i = v_get_val(x, i);\n			if (x_i < min_x) min_x = x_i;\n			else if (x_i > max_x) max_x = x_i;\n			double y_i = v_get_val(y, i);\n			if (y_i < min_y) min_y = y_i;\n			else if (y_i > max_y) max_y = y_i;\n		}\n		if (min_x < 0.0 || max_x > (double) fw - 1.0 || min_y < 0 || max_y > (double) fh - 1.0) break;\n		\n		\n		// Compute the length of the snake		\n		double L = 0.0;\n		for (i = 0; i < Np - 1; i++) {\n			double diff_x = v_get_val(x, i + 1) - v_get_val(x, i);\n			double diff_y = v_get_val(y, i + 1) - v_get_val(y, i);\n			L += sqrt((diff_x * diff_x) + (diff_y * diff_y));\n		}\n		double diff_x = v_get_val(x, 0) - v_get_val(x, Np - 1);\n		double diff_y = v_get_val(y, 0) - v_get_val(y, Np - 1);\n		L += sqrt((diff_x * diff_x) + (diff_y * diff_y));\n		\n		// Compute the potential surface at each snaxel\n		MAT *vf  = linear_interp2(f,  x, y);\n		MAT *vfx = linear_interp2(fx, x, y);\n		MAT *vfy = linear_interp2(fy, x, y);\n		\n		// Compute the average potential surface around the snake\n		double vfmean  = sum_m(vf ) / L;\n		double vfxmean = sum_m(vfx) / L;\n		double vfymean = sum_m(vfy) / L;\n		\n		// Compute the radial potential surface		\n		int m = vf->m, n = vf->n;\n		MAT *vfr = m_get(m, n);\n		for (i = 0; i < n; i++) {\n			double vf_val  = m_get_val(vf,  0, i);\n			double vfx_val = m_get_val(vfx, 0, i);\n			double vfy_val = m_get_val(vfy, 0, i);\n			double x_val = v_get_val(x, i);\n			double y_val = v_get_val(y, i);\n			double new_val = (vf_val + vfx_val * (x_val - xc) + vfy_val * (y_val - yc) - vfmean) / L;\n			m_set_val(vfr, 0, i, new_val);\n		}		\n		\n		// Update the snake center and snaxels\n		xc =  xc + (deltax * lambdaedge * vfxmean);\n		yc = (yc + (deltay * lambdaedge * vfymean) + (deltay * lambdapath * Ey)) / (1.0 + deltay * lambdapath);\n		double r_diff = 0.0;\n		for (i = 0; i < Np; i++) {\n			r[i] = (r[i] + (deltar * lambdaedge * m_get_val(vfr, 0, i)) + (deltar * lambdasize * Er)) /\n			       (1.0 + deltar * lambdasize);\n			r_diff += fabs(r[i] - r_old[i]);\n		}\n		\n		// Test for convergence\n		snakediff = fabs(xc - xc_old) + fabs(yc - yc_old) + r_diff;\n		\n		// Free temporary matrices\n		m_free(vf);\n		m_free(vfx);\n		m_free(vfy);\n		m_free(vfr);\n	    \n		iter++;\n	}\n	\n	// Set the return values\n	*xc0 = xc;\n	*yc0 = yc;\n	for (i = 0; i < Np; i++)\n		r0[i] = r[i];\n	\n	// Free memory\n	free(r); free(r_old);\n	v_free( x); v_free( y);\n	m_free(fx); m_free(fy);\n}\n	\n\n// Returns the sum of all of the elements in the specified matrix\ndouble sum_m(MAT *matrix) {\n	if (matrix == NULL) return 0.0;	\n	\n	int i, j;\n	double sum = 0.0;\n	for (i = 0; i < matrix->m; i++)\n		for (j = 0; j < matrix->n; j++)\n			sum += m_get_val(matrix, i, j);\n	\n	return sum;\n}\n\n\n// Returns the sum of all of the elements in the specified vector\ndouble sum_v(VEC *vector) {\n	if (vector == NULL) return 0.0;	\n	\n	int i;\n	double sum = 0.0;\n	for (i = 0; i < vector->dim; i++)\n		sum += v_get_val(vector, i);\n	\n	return sum;\n}\n\n\n// Creates a zeroed x-by-y matrix of doubles\ndouble **alloc_2d_double(int x, int y) {\n	if (x < 1 || y < 1) return NULL;\n	\n	// Allocate the data and the pointers to the data\n	double *data = (double *) calloc(x * y, sizeof(double));\n	double **pointers = (double **) malloc(sizeof(double *) * x);\n	\n	// Make the pointers point to the data\n	int i;\n	for (i = 0; i < x; i++) {\n		pointers[i] = data + (i * y);\n	}\n	\n	return pointers;\n}\n\n\n// Creates a zeroed x-by-y-by-z matrix of doubles\ndouble ***alloc_3d_double(int x, int y, int z) {\n	if (x < 1 || y < 1 || z < 1) return NULL;\n	\n	// Allocate the data and the two levels of pointers\n	double *data = (double *) calloc(x * y * z, sizeof(double));\n	double **pointers_to_data = (double **) malloc(sizeof(double *) * x * y);\n	double ***pointers_to_pointers = (double ***) malloc(sizeof(double **) * x);\n	\n	// Make the pointers point to the data\n	int i;\n	for (i = 0; i < x * y; i++) pointers_to_data[i] = data + (i * z);\n	for (i = 0; i < x; i++) pointers_to_pointers[i] = pointers_to_data + (i * y);\n	\n	return pointers_to_pointers;\n}\n\n\n// Frees a 2d matrix generated by the alloc_2d_double function\nvoid free_2d_double(double **p) {\n	if (p != NULL) {\n		if (p[0] != NULL) free(p[0]);\n		free(p);\n	}\n}\n\n\n// Frees a 3d matrix generated by the alloc_3d_double function\nvoid free_3d_double(double ***p) {\n	if (p != NULL) {\n		if (p[0] != NULL) {\n			if (p[0][0] != NULL) free(p[0][0]);\n			free(p[0]);\n		}\n		free(p);\n	}\n}\n