\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File containing routines for symmetric eigenvalue problems\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n\nstatic char rcsid[] = "$Id: symmeig.c,v 1.6 1995/03/27 15:45:55 des Exp $";\n\n\n\n#define	SQRT2	1.4142135623730949\n#define	sgn(x)	( (x) >= 0 ? 1 : -1 )\n\n/* trieig -- finds eigenvalues of symmetric tridiagonal matrices\n	-- matrix represented by a pair of vectors a (diag entries)\n		and b (sub- & super-diag entries)\n	-- eigenvalues in a on return */\n#ifndef ANSI_C\nVEC	*trieig(a,b,Q)\nVEC	*a, *b;\nMAT	*Q;\n#else\nVEC	*trieig(VEC *a, VEC *b, MAT *Q)\n#endif\n{\n	int	i, i_min, i_max, n, split;\n	Real	*a_ve, *b_ve;\n	Real	b_sqr, bk, ak1, bk1, ak2, bk2, z;\n	Real	c, c2, cs, s, s2, d, mu;\n\n	if ( ! a || ! b )\n		error(E_NULL,"trieig");\n	if ( a->dim != b->dim + 1 || ( Q && Q->m != a->dim ) )\n		error(E_SIZES,"trieig");\n	if ( Q && Q->m != Q->n )\n		error(E_SQUARE,"trieig");\n\n	n = a->dim;\n	a_ve = a->ve;		b_ve = b->ve;\n\n	i_min = 0;\n	while ( i_min < n )		/* outer while loop */\n	{\n		/* find i_max to suit;\n			submatrix i_min..i_max should be irreducible */\n		i_max = n-1;\n		for ( i = i_min; i < n-1; i++ )\n		    if ( b_ve[i] == 0.0 )\n		    {	i_max = i;	break;	}\n		if ( i_max <= i_min )\n		{\n		    /* printf("# i_min = %d, i_max = %d\n",i_min,i_max); */\n		    i_min = i_max + 1;\n		    continue;	/* outer while loop */\n		}\n\n		/* printf("# i_min = %d, i_max = %d\n",i_min,i_max); */\n\n		/* repeatedly perform QR method until matrix splits */\n		split = FALSE;\n		while ( ! split )		/* inner while loop */\n		{\n\n		    /* find Wilkinson shift */\n		    d = (a_ve[i_max-1] - a_ve[i_max])/2;\n		    b_sqr = b_ve[i_max-1]*b_ve[i_max-1];\n		    mu = a_ve[i_max] - b_sqr/(d + sgn(d)*sqrt(d*d+b_sqr));\n		    /* printf("# Wilkinson shift = %g\n",mu); */\n\n		    /* initial Givens' rotation */\n		    givens(a_ve[i_min]-mu,b_ve[i_min],&c,&s);\n		    s = -s;\n		    /* printf("# c = %g, s = %g\n",c,s); */\n		    if ( fabs(c) < SQRT2 )\n		    {	c2 = c*c;	s2 = 1-c2;	}\n		    else\n		    {	s2 = s*s;	c2 = 1-s2;	}\n		    cs = c*s;\n		    ak1 = c2*a_ve[i_min]+s2*a_ve[i_min+1]-2*cs*b_ve[i_min];\n		    bk1 = cs*(a_ve[i_min]-a_ve[i_min+1]) +\n						(c2-s2)*b_ve[i_min];\n		    ak2 = s2*a_ve[i_min]+c2*a_ve[i_min+1]+2*cs*b_ve[i_min];\n		    bk2 = ( i_min < i_max-1 ) ? c*b_ve[i_min+1] : 0.0;\n		    z  = ( i_min < i_max-1 ) ? -s*b_ve[i_min+1] : 0.0;\n		    a_ve[i_min] = ak1;\n		    a_ve[i_min+1] = ak2;\n		    b_ve[i_min] = bk1;\n		    if ( i_min < i_max-1 )\n			b_ve[i_min+1] = bk2;\n		    if ( Q )\n			rot_cols(Q,i_min,i_min+1,c,-s,Q);\n		    /* printf("# z = %g\n",z); */\n		    /* printf("# a [temp1] =\n");	v_output(a); */\n		    /* printf("# b [temp1] =\n");	v_output(b); */\n\n		    for ( i = i_min+1; i < i_max; i++ )\n		    {\n			/* get Givens' rotation for sub-block -- k == i-1 */\n			givens(b_ve[i-1],z,&c,&s);\n			s = -s;\n			/* printf("# c = %g, s = %g\n",c,s); */\n\n			/* perform Givens' rotation on sub-block */\n		        if ( fabs(c) < SQRT2 )\n		        {	c2 = c*c;	s2 = 1-c2;	}\n		        else\n		        {	s2 = s*s;	c2 = 1-s2;	}\n		        cs = c*s;\n			bk  = c*b_ve[i-1] - s*z;\n			ak1 = c2*a_ve[i]+s2*a_ve[i+1]-2*cs*b_ve[i];\n			bk1 = cs*(a_ve[i]-a_ve[i+1]) +\n						(c2-s2)*b_ve[i];\n			ak2 = s2*a_ve[i]+c2*a_ve[i+1]+2*cs*b_ve[i];\n			bk2 = ( i+1 < i_max ) ? c*b_ve[i+1] : 0.0;\n			z  = ( i+1 < i_max ) ? -s*b_ve[i+1] : 0.0;\n			a_ve[i] = ak1;	a_ve[i+1] = ak2;\n			b_ve[i] = bk1;\n			if ( i < i_max-1 )\n			    b_ve[i+1] = bk2;\n			if ( i > i_min )\n			    b_ve[i-1] = bk;\n			if ( Q )\n			    rot_cols(Q,i,i+1,c,-s,Q);\n		        /* printf("# a [temp2] =\n");	v_output(a); */\n		        /* printf("# b [temp2] =\n");	v_output(b); */\n		    }\n\n		    /* test to see if matrix should be split */\n		    for ( i = i_min; i < i_max; i++ )\n			if ( fabs(b_ve[i]) < MACHEPS*\n					(fabs(a_ve[i])+fabs(a_ve[i+1])) )\n			{   b_ve[i] = 0.0;	split = TRUE;	}\n\n		    /* printf("# a =\n");	v_output(a); */\n		    /* printf("# b =\n");	v_output(b); */\n		}\n	}\n\n	return a;\n}\n\n/* symmeig -- computes eigenvalues of a dense symmetric matrix\n	-- A **must** be symmetric on entry\n	-- eigenvalues stored in out\n	-- Q contains orthogonal matrix of eigenvectors\n	-- returns vector of eigenvalues */\n#ifndef ANSI_C\nVEC	*symmeig(A,Q,out)\nMAT	*A, *Q;\nVEC	*out;\n#else\nVEC	*symmeig(const MAT *A, MAT *Q, VEC *out)\n#endif\n{\n	int	i;\n	STATIC MAT	*tmp = MNULL;\n	STATIC VEC	*b   = VNULL, *diag = VNULL, *beta = VNULL;\n\n	if ( ! A )\n		error(E_NULL,"symmeig");\n	if ( A->m != A->n )\n		error(E_SQUARE,"symmeig");\n	if ( ! out || out->dim != A->m )\n		out = v_resize(out,A->m);\n\n	tmp  = m_resize(tmp,A->m,A->n);\n	tmp  = m_copy(A,tmp);\n	b    = v_resize(b,A->m - 1);\n	diag = v_resize(diag,(unsigned int)A->m);\n	beta = v_resize(beta,(unsigned int)A->m);\n	MEM_STAT_REG(tmp,TYPE_MAT);\n	MEM_STAT_REG(b,TYPE_VEC);\n	MEM_STAT_REG(diag,TYPE_VEC);\n	MEM_STAT_REG(beta,TYPE_VEC);\n\n	Hfactor(tmp,diag,beta);\n	if ( Q )\n		makeHQ(tmp,diag,beta,Q);\n\n	for ( i = 0; i < A->m - 1; i++ )\n	{\n		out->ve[i] = tmp->me[i][i];\n		b->ve[i] = tmp->me[i][i+1];\n	}\n	out->ve[i] = tmp->me[i][i];\n	trieig(out,b,Q);\n\n#ifdef	THREADSAFE\n	M_FREE(tmp);	V_FREE(b);	V_FREE(diag);	V_FREE(beta);\n#endif\n	return out;\n}\n\n