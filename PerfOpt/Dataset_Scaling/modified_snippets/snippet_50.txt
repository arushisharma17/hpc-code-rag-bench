#include "find_ellipse.h"\n#include "track_ellipse.h"\n\nint omp_num_threads = 1;\n\nint main(int argc, char ** argv) {\n\n	// Keep track of the start time of the program\n  long long program_start_time = get_time();\n	\n	// Let the user specify the number of frames to process\n	int num_frames = 1;\n	\n	if (argc !=4){\n		fprintf(stderr, "usage: %s <num of frames> <num of threads><input file>", argv[0]);\n		exit(1);\n	}\n	\n	if (argc > 1){\n		num_frames = atoi(argv[1]);\n		omp_num_threads = atoi(argv[2]);\n		}\n	printf("Num of threads: %d\n", omp_num_threads);\n	// Open video file\n	char *video_file_name;\n	video_file_name = argv[3];\n	\n	avi_t *cell_file = AVI_open_input_file(video_file_name, 1);\n	if (cell_file == NULL)	{\n		AVI_print_error("Error with AVI_open_input_file");\n		return -1;\n	}\n	\n	int i, j, *crow, *ccol, pair_counter = 0, x_result_len = 0, Iter = 20, ns = 4, k_count = 0, n;\n	MAT *cellx, *celly, *A;\n	double *GICOV_spots, *t, *G, *x_result, *y_result, *V, *QAX_CENTERS, *QAY_CENTERS;\n	double threshold = 1.8, radius = 10.0, delta = 3.0, dt = 0.01, b = 5.0;\n	\n	// Extract a cropped version of the first frame from the video file\n	MAT *image_chopped = get_frame(cell_file, 0, 1, 0);\n	printf("Detecting cells in frame 0\n");\n	\n	// Get gradient matrices in x and y directions\n	MAT *grad_x = gradient_x(image_chopped);\n	MAT *grad_y = gradient_y(image_chopped);\n	\n	m_free(image_chopped);\n	\n	// Get GICOV matrix corresponding to image gradients\n	long long GICOV_start_time = get_time();\n	MAT *gicov = ellipsematching(grad_x, grad_y);\n	\n	// Square GICOV values\n	MAT *max_gicov = m_get(gicov->m, gicov->n);\n	for (i = 0; i < gicov->m; i++) {\n		for (j = 0; j < gicov->n; j++) {\n			double val = m_get_val(gicov, i, j);\n			m_set_val(max_gicov, i, j, val * val);\n		}\n	}\n	\n	long long GICOV_end_time = get_time();\n	\n	// Dilate the GICOV matrix\n	long long dilate_start_time = get_time();\n	MAT *strel = structuring_element(12);\n	MAT *img_dilated = dilate_f(max_gicov, strel);\n	long long dilate_end_time = get_time();\n	\n	// Find possible matches for cell centers based on GICOV and record the rows/columns in which they are found\n	pair_counter = 0;\n	crow = (int *) malloc(max_gicov->m * max_gicov->n * sizeof(int));\n	ccol = (int *) malloc(max_gicov->m * max_gicov->n * sizeof(int));\n	for (i = 0; i < max_gicov->m; i++) {\n		for (j = 0; j < max_gicov->n; j++) {\n			if (!(m_get_val(max_gicov,i,j) == 0.0) && (m_get_val(img_dilated,i,j) == m_get_val(max_gicov,i,j))) {\n				crow[pair_counter] = i;\n				ccol[pair_counter] = j;\n				pair_counter++;\n			}\n		}\n	}\n	\n	GICOV_spots = (double *) malloc(sizeof(double)*pair_counter);\n	for (i = 0; i < pair_counter; i++)\n		GICOV_spots[i] = m_get_val(gicov, crow[i], ccol[i]);\n	\n	G = (double *) calloc(pair_counter, sizeof(double));\n	x_result = (double *) calloc(pair_counter, sizeof(double));\n	y_result = (double *) calloc(pair_counter, sizeof(double));\n	\n	x_result_len = 0;\n	for (i = 0; i < pair_counter; i++) {\n		if ((crow[i] > 29) && (crow[i] < BOTTOM - TOP + 39)) {\n			x_result[x_result_len] = ccol[i];\n			y_result[x_result_len] = crow[i] - 40;\n			G[x_result_len] = GICOV_spots[i];\n			x_result_len++;\n		}\n	}\n	\n	// Make an array t which holds each "time step" for the possible cells\n	t = (double *) malloc(sizeof(double) * 36);\n	for (i = 0; i < 36; i++) {\n		t[i] = (double)i * 2.0 * PI / 36.0;\n	}\n	\n	// Store cell boundaries (as simple circles) for all cells\n	cellx = m_get(x_result_len, 36);\n	celly = m_get(x_result_len, 36);\n	for(i = 0; i < x_result_len; i++) {\n		for(j = 0; j < 36; j++) {\n			m_set_val(cellx, i, j, x_result[i] + radius * cos(t[j]));\n			m_set_val(celly, i, j, y_result[i] + radius * sin(t[j]));\n		}\n	}\n	\n	A = TMatrix(9,4);\n\n	\n	V = (double *) malloc(sizeof(double) * pair_counter);\n	QAX_CENTERS = (double * )malloc(sizeof(double) * pair_counter);\n	QAY_CENTERS = (double *) malloc(sizeof(double) * pair_counter);\n	memset(V, 0, sizeof(double) * pair_counter);\n	memset(QAX_CENTERS, 0, sizeof(double) * pair_counter);\n	memset(QAY_CENTERS, 0, sizeof(double) * pair_counter);\n\n	// For all possible results, find the ones that are feasibly leukocytes and store their centers\n	k_count = 0;\n	for (n = 0; n < x_result_len; n++) {\n		if ((G[n] < -1 * threshold) || G[n] > threshold) {\n			MAT * x, *y;\n			VEC * x_row, * y_row;\n			x = m_get(1, 36);\n			y = m_get(1, 36);\n\n			x_row = v_get(36);\n			y_row = v_get(36);\n\n			// Get current values of possible cells from cellx/celly matrices\n			x_row = get_row(cellx, n, x_row);\n			y_row = get_row(celly, n, y_row);\n			uniformseg(x_row, y_row, x, y);\n\n			// Make sure that the possible leukocytes are not too close to the edge of the frame\n			if ((m_min(x) > b) && (m_min(y) > b) && (m_max(x) < cell_file->width - b) && (m_max(y) < cell_file->height - b)) {\n				MAT * Cx, * Cy, *Cy_temp, * Ix1, * Iy1;\n				VEC  *Xs, *Ys, *W, *Nx, *Ny, *X, *Y;\n				Cx = m_get(1, 36);\n				Cy = m_get(1, 36);\n				Cx = mmtr_mlt(A, x, Cx);\n				Cy = mmtr_mlt(A, y, Cy);\n				\n				Cy_temp = m_get(Cy->m, Cy->n);\n				\n				for (i = 0; i < 9; i++)\n					m_set_val(Cy, i, 0, m_get_val(Cy, i, 0) + 40.0);\n					\n				// Iteratively refine the snake/spline\n				for (i = 0; i < Iter; i++) {\n					int typeofcell;\n					\n					if(G[n] > 0.0) typeofcell = 0;\n					else typeofcell = 1;\n					\n					splineenergyform01(Cx, Cy, grad_x, grad_y, ns, delta, 2.0 * dt, typeofcell);\n				}\n				\n				X = getsampling(Cx, ns);\n				for (i = 0; i < Cy->m; i++)\n					m_set_val(Cy_temp, i, 0, m_get_val(Cy, i, 0) - 40.0);\n				Y = getsampling(Cy_temp, ns);\n				\n				Ix1 = linear_interp2(grad_x, X, Y);\n				Iy1 = linear_interp2(grad_x, X, Y);\n				Xs = getfdriv(Cx, ns);\n				Ys = getfdriv(Cy, ns);\n				\n				Nx = v_get(Ys->dim);\n				for (i = 0; i < Ys->dim; i++)\n					v_set_val(Nx, i, v_get_val(Ys, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n					\n				Ny = v_get(Xs->dim);\n				for (i = 0; i < Xs->dim; i++)\n					v_set_val(Ny, i, -1.0 * v_get_val(Xs, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n					\n				W = v_get(Nx->dim);\n				for (i = 0; i < Nx->dim; i++)\n					v_set_val(W, i, m_get_val(Ix1, 0, i) * v_get_val(Nx, i) + m_get_val(Iy1, 0, i) * v_get_val(Ny, i));\n					\n				V[n] = mean(W) / std_dev(W);\n				\n				//get means of X and Y values for all "snaxels" of the spline contour, thus finding the cell centers\n				QAX_CENTERS[k_count] = mean(X);\n				QAY_CENTERS[k_count] = mean(Y) + TOP;\n				\n				k_count++;\n				\n				// Free memory\n				v_free(W);\n				v_free(Ny);\n				v_free(Nx);\n				v_free(Ys);\n				v_free(Xs);\n				m_free(Iy1);\n				m_free(Ix1);\n				v_free(Y);\n				v_free(X);\n				m_free(Cy_temp);\n				m_free(Cy);\n				m_free(Cx);				\n			}\n			\n			// Free memory\n			v_free(y_row);\n			v_free(x_row);\n			m_free(y);\n			m_free(x);\n		}\n	}\n\n	// Free memory\n	free(V);\n	free(ccol);\n	free(crow);\n	free(GICOV_spots);\n	free(t);\n	free(G);\n	free(x_result);\n	free(y_result);\n	m_free(A);\n	m_free(celly);\n	m_free(cellx);\n	m_free(img_dilated);\n	m_free(max_gicov);\n	m_free(gicov);\n	m_free(grad_y);\n	m_free(grad_x);\n	\n	// Report the total number of cells detected\n	printf("Cells detected: %d\n\n", k_count);\n	\n	// Report the breakdown of the detection runtime\n	printf("Detection runtime\n");\n	printf("-----------------\n");\n	printf("GICOV computation: %.5f seconds\n", ((float) (GICOV_end_time - GICOV_start_time)) / (1000*1000));\n	printf("   GICOV dilation: %.5f seconds\n", ((float) (dilate_end_time - dilate_start_time)) / (1000*1000));\n	printf("            Total: %.5f seconds\n", ((float) (get_time() - program_start_time)) / (1000*1000));\n	\n	// Now that the cells have been detected in the first frame,\n	//  track the ellipses through subsequent frames\n	if (num_frames > 1) printf("\nTracking cells across %d frames\n", num_frames);\n	else                printf("\nTracking cells across 1 frame\n");\n	long long tracking_start_time = get_time();\n	int num_snaxels = 20;\n	ellipsetrack(cell_file, QAX_CENTERS, QAY_CENTERS, k_count, radius, num_snaxels, num_frames);\n	printf("           Total: %.5f seconds\n", ((float) (get_time() - tracking_start_time)) / (float) (1000*1000*num_frames));\n	\n	// Report total program execution time\n    printf("\nTotal application run time: %.5f seconds\n", ((float) (get_time() - program_start_time)) / (1000*1000));\n\n	return 0;\n}\n