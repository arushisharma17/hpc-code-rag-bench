#define LIMIT -999\n//#define TRACE\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#define OPENMP\n//#define NUM_THREAD 4\n\n#define BLOCK_SIZE 16\n\n////////////////////////////////////////////////////////////////////////////////\n// declaration, forward\nvoid runTest( int argc, char** argv);\n\n// Returns the current system time in microseconds \nlong long get_time()\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * 1000000) + tv.tv_usec;\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\nint maximum( int a,\n		 int b,\n		 int c){\n\n	int k;\n	if( a <= b )\n		k = b;\n	else \n	k = a;\n\n	if( k <=c )\n	return(c);\n	else\n	return(k);\n}\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n\n\nint blosum62[24][24] = {\n{ 4, -1, -2, -2,  0, -1, -1,  0, -2, -1, -1, -1, -1, -2, -1,  1,  0, -3, -2,  0, -2, -1,  0, -4},\n{-1,  5,  0, -2, -3,  1,  0, -2,  0, -3, -2,  2, -1, -3, -2, -1, -1, -3, -2, -3, -1,  0, -1, -4},\n{-2,  0,  6,  1, -3,  0,  0,  0,  1, -3, -3,  0, -2, -3, -2,  1,  0, -4, -2, -3,  3,  0, -1, -4},\n{-2, -2,  1,  6, -3,  0,  2, -1, -1, -3, -4, -1, -3, -3, -1,  0, -1, -4, -3, -3,  4,  1, -1, -4},\n{ 0, -3, -3, -3,  9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2, -4},\n{-1,  1,  0,  0, -3,  5,  2, -2,  0, -3, -2,  1,  0, -3, -1,  0, -1, -2, -1, -2,  0,  3, -1, -4},\n{-1,  0,  0,  2, -4,  2,  5, -2,  0, -3, -3,  1, -2, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},\n{ 0, -2,  0, -1, -3, -2, -2,  6, -2, -4, -4, -2, -3, -3, -2,  0, -2, -2, -3, -3, -1, -2, -1, -4},\n{-2,  0,  1, -1, -3,  0,  0, -2,  8, -3, -3, -1, -2, -1, -2, -1, -2, -2,  2, -3,  0,  0, -1, -4},\n{-1, -3, -3, -3, -1, -3, -3, -4, -3,  4,  2, -3,  1,  0, -3, -2, -1, -3, -1,  3, -3, -3, -1, -4},\n{-1, -2, -3, -4, -1, -2, -3, -4, -3,  2,  4, -2,  2,  0, -3, -2, -1, -2, -1,  1, -4, -3, -1, -4},\n{-1,  2,  0, -1, -3,  1,  1, -2, -1, -3, -2,  5, -1, -3, -1,  0, -1, -3, -2, -2,  0,  1, -1, -4},\n{-1, -1, -2, -3, -1,  0, -2, -3, -2,  1,  2, -1,  5,  0, -2, -1, -1, -1, -1,  1, -3, -1, -1, -4},\n{-2, -3, -3, -3, -2, -3, -3, -3, -1,  0,  0, -3,  0,  6, -4, -2, -2,  1,  3, -1, -3, -3, -1, -4},\n{-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4,  7, -1, -1, -4, -3, -2, -2, -1, -2, -4},\n{ 1, -1,  1,  0, -1,  0,  0,  0, -1, -2, -2,  0, -1, -2, -1,  4,  1, -3, -2, -2,  0,  0,  0, -4},\n{ 0, -1,  0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1,  1,  5, -2, -2,  0, -1, -1,  0, -4},\n{-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1,  1, -4, -3, -2, 11,  2, -3, -4, -3, -2, -4},\n{-2, -2, -2, -3, -2, -1, -2, -3,  2, -1, -1, -2, -1,  3, -3, -2, -2,  2,  7, -1, -3, -2, -1, -4},\n{ 0, -3, -3, -3, -1, -2, -2, -3, -3,  3,  1, -2,  1, -1, -2, -2,  0, -3, -1,  4, -3, -2, -1, -4},\n{-2, -1,  3,  4, -3,  0,  1, -1,  0, -3, -4,  0, -3, -3, -2,  0, -1, -4, -3, -3,  4,  1, -1, -4},\n{-1,  0,  0,  1, -3,  3,  4, -2,  0, -3, -3,  1, -1, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},\n{ 0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2,  0,  0, -2, -1, -1, -1, -1, -1, -4},\n{-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,  1}\n};\n\ndouble gettime() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return t.tv_sec+t.tv_usec*1e-6;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Program main\n////////////////////////////////////////////////////////////////////////////////\nint\nmain( int argc, char** argv) \n{\n    runTest( argc, argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid usage(int argc, char **argv)\n{\n	fprintf(stderr, "Usage: %s <max_rows/max_cols> <penalty> <num_threads>\n", argv[0]);\n	fprintf(stderr, "\t<dimension>      - x and y dimensions\n");\n	fprintf(stderr, "\t<penalty>        - penalty(positive integer)\n");\n	fprintf(stderr, "\t<num_threads>    - no. of threads\n");\n	exit(1);\n}\n\nvoid nw_optimized(int *input_itemsets, int *output_itemsets, int *referrence,\n        int max_rows, int max_cols, int penalty)\n{\n#ifdef OMP_OFFLOAD\n    int transfer_size = max_rows * max_cols;\n    #pragma omp target data map(to: max_cols, penalty, referrence[0:transfer_size]) map(input_itemsets[0:transfer_size])\n    {\n\n    #pragma omp target \n#endif\n    for( int blk = 1; blk <= (max_cols-1)/BLOCK_SIZE; blk++ )\n    {\n#ifdef OPENMP\n#pragma omp parallel for schedule(static) shared(input_itemsets, referrence) firstprivate(blk, max_rows, max_cols, penalty)\n#endif\n        for( int b_index_x = 0; b_index_x < blk; ++b_index_x)\n        {\n            int b_index_y = blk - 1 - b_index_x;\n            int input_itemsets_l[(BLOCK_SIZE + 1) *(BLOCK_SIZE+1)] __attribute__ ((aligned (64)));\n            int reference_l[BLOCK_SIZE * BLOCK_SIZE] __attribute__ ((aligned (64)));\n\n            // Copy referrence to local memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    reference_l[i*BLOCK_SIZE + j] = referrence[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1];\n                }\n            }\n\n            // Copy input_itemsets to local memory\n            for ( int i = 0; i < BLOCK_SIZE + 1; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i) + b_index_x*BLOCK_SIZE +  j];\n                }\n            }\n\n            // Compute\n            for ( int i = 1; i < BLOCK_SIZE + 1; ++i )\n            {\n                for ( int j = 1; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = maximum( input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j - 1] + reference_l[(i - 1)*BLOCK_SIZE + j - 1],\n                            input_itemsets_l[i*(BLOCK_SIZE + 1) + j - 1] - penalty,\n                            input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j] - penalty);\n                }\n            }\n\n            // Copy results to global memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1] = input_itemsets_l[(i + 1)*(BLOCK_SIZE+1) + j + 1];\n                }\n            }\n            \n        }\n    }    \n        \n    printf("Processing bottom-right matrix\n");\n\n#ifdef OMP_OFFLOAD\n    #pragma omp target\n#endif\n    for ( int blk = 2; blk <= (max_cols-1)/BLOCK_SIZE; blk++ )\n    {\n#ifdef OPENMP\n#pragma omp parallel for schedule(static) shared(input_itemsets, referrence) firstprivate(blk, max_rows, max_cols, penalty)\n#endif\n        for( int b_index_x = blk - 1; b_index_x < (max_cols-1)/BLOCK_SIZE; ++b_index_x)\n        {\n            int b_index_y = (max_cols-1)/BLOCK_SIZE + blk - 2 - b_index_x;\n\n            int input_itemsets_l[(BLOCK_SIZE + 1) *(BLOCK_SIZE+1)] __attribute__ ((aligned (64)));\n            int reference_l[BLOCK_SIZE * BLOCK_SIZE] __attribute__ ((aligned (64)));\n \n            // Copy referrence to local memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    reference_l[i*BLOCK_SIZE + j] = referrence[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1];\n                }\n            }\n\n            // Copy input_itemsets to local memory\n            for ( int i = 0; i < BLOCK_SIZE + 1; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i) + b_index_x*BLOCK_SIZE +  j];\n                }\n            }\n\n            // Compute\n            for ( int i = 1; i < BLOCK_SIZE + 1; ++i )\n            {\n                for ( int j = 1; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = maximum( input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j - 1] + reference_l[(i - 1)*BLOCK_SIZE + j - 1],\n                            input_itemsets_l[i*(BLOCK_SIZE + 1) + j - 1] - penalty,\n                            input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j] - penalty);\n                }\n            }\n\n            // Copy results to global memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1] = input_itemsets_l[(i + 1)*(BLOCK_SIZE+1) + j +1];\n                }\n            }\n        }\n    }\n\n#ifdef OMP_OFFLOAD\n    }\n#endif\n   \n}\n\n////////////////////////////////////////////////////////////////////////////////\n//! Run a simple test for CUDA\n////////////////////////////////////////////////////////////////////////////////\nvoid\nrunTest( int argc, char** argv) \n{\n    int max_rows, max_cols, penalty;\n    int *input_itemsets, *output_itemsets, *referrence;\n    //int *matrix_cuda, *matrix_cuda_out, *referrence_cuda;\n    //int size;\n    int omp_num_threads;\n\n\n    // the lengths of the two sequences should be able to divided by 16.\n    // And at current stage  max_rows needs to equal max_cols\n    if (argc == 4)\n    {\n        max_rows = atoi(argv[1]);\n        max_cols = atoi(argv[1]);\n        penalty = atoi(argv[2]);\n        omp_num_threads = atoi(argv[3]);\n    }\n    else{\n        usage(argc, argv);\n    }\n\n    max_rows = max_rows + 1;\n    max_cols = max_cols + 1;\n    referrence = (int *)malloc( max_rows * max_cols * sizeof(int) );\n    input_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );\n    output_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );\n\n\n    if (!input_itemsets)\n        fprintf(stderr, "error: can not allocate memory");\n\n    srand ( 7 );\n\n    for (int i = 0 ; i < max_cols; i++){\n        for (int j = 0 ; j < max_rows; j++){\n            input_itemsets[i*max_cols+j] = 0;\n        }\n    }\n\n    printf("Start Needleman-Wunsch\n");\n\n    for( int i=1; i< max_rows ; i++){    //please define your own sequence. \n        input_itemsets[i*max_cols] = rand() % 10 + 1;\n    }\n    for( int j=1; j< max_cols ; j++){    //please define your own sequence.\n        input_itemsets[j] = rand() % 10 + 1;\n    }\n\n\n    for (int i = 1 ; i < max_cols; i++){\n        for (int j = 1 ; j < max_rows; j++){\n            referrence[i*max_cols+j] = blosum62[input_itemsets[i*max_cols]][input_itemsets[j]];\n        }\n    }\n\n    for( int i = 1; i< max_rows ; i++)\n        input_itemsets[i*max_cols] = -i * penalty;\n    for( int j = 1; j< max_cols ; j++)\n        input_itemsets[j] = -j * penalty;\n\n\n\n    //Compute top-left matrix \n    printf("Num of threads: %d\n", omp_num_threads);\n    printf("Processing top-left matrix\n");\n   \n    long long start_time = get_time();\n\n    nw_optimized( input_itemsets, output_itemsets, referrence,\n        max_rows, max_cols, penalty );\n\n    long long end_time = get_time();\n\n    printf("Total time: %.3f seconds\n", ((float) (end_time - start_time)) / (1000*1000));\n\n#define TRACEBACK\n#ifdef TRACEBACK\n\n    FILE *fpo = fopen("result.txt","w");\n    fprintf(fpo, "print traceback value GPU:\n");\n\n    for (int i = max_rows - 2,  j = max_rows - 2; i>=0, j>=0;){\n        int nw, n, w, traceback;\n        if ( i == max_rows - 2 && j == max_rows - 2 )\n            fprintf(fpo, "%d ", input_itemsets[ i * max_cols + j]); //print the first element\n        if ( i == 0 && j == 0 )\n            break;\n        if ( i > 0 && j > 0 ){\n            nw = input_itemsets[(i - 1) * max_cols + j - 1];\n            w  = input_itemsets[ i * max_cols + j - 1 ];\n            n  = input_itemsets[(i - 1) * max_cols + j];\n        }\n        else if ( i == 0 ){\n            nw = n = LIMIT;\n            w  = input_itemsets[ i * max_cols + j - 1 ];\n        }\n        else if ( j == 0 ){\n            nw = w = LIMIT;\n            n  = input_itemsets[(i - 1) * max_cols + j];\n        }\n        else{\n        }\n\n        //traceback = maximum(nw, w, n);\n        int new_nw, new_w, new_n;\n        new_nw = nw + referrence[i * max_cols + j];\n        new_w = w - penalty;\n        new_n = n - penalty;\n\n        traceback = maximum(new_nw, new_w, new_n);\n        if(traceback == new_nw)\n            traceback = nw;\n        if(traceback == new_w)\n            traceback = w;\n        if(traceback == new_n)\n            traceback = n;\n\n        fprintf(fpo, "%d ", traceback);\n\n        if(traceback == nw )\n        {i--; j--; continue;}\n\n        else if(traceback == w )\n        {j--; continue;}\n\n        else if(traceback == n )\n        {i--; continue;}\n\n        else\n            ;\n    }\n\n    fclose(fpo);\n\n#endif\n\n    free(referrence);\n    free(input_itemsets);\n    free(output_itemsets);\n\n}\n\n\n\n