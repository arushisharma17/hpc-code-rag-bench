#include <stdio.h>\n#include <time.h>\n#include <assert.h>\n#include <stdlib.h> \n#include <math.h> \n#include <sys/time.h>\n#include <string.h>\n\n#define STR_SIZE (256)\n#define MAX_PD	(3.0e6)\n/* required precision in degrees	*/\n#define PRECISION	0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n/* capacitance fitting factor	*/\n#define FACTOR_CHIP	0.5\n\n\n/* chip parameters	*/\nfloat t_chip = 0.0005;\nfloat chip_height = 0.016; float chip_width = 0.016; \n/* ambient temperature, assuming no package at all	*/\nfloat amb_temp = 80.0;\n\nvoid fatal(char *s)\n{\n    fprintf(stderr, "Error: %s\n", s);\n}\n\nvoid readinput(float *vect, int grid_rows, int grid_cols, int layers, char *file) {\n    int i,j,k;\n    FILE *fp;\n    char str[STR_SIZE];\n    float val;\n\n    if( (fp  = fopen(file, "r" )) ==0 )\n      fatal( "The file was not opened" );\n\n\n    for (i=0; i <= grid_rows-1; i++) \n      for (j=0; j <= grid_cols-1; j++)\n        for (k=0; k <= layers-1; k++)\n          {\n            if (fgets(str, STR_SIZE, fp) == NULL) fatal("Error reading file\n");\n            if (feof(fp))\n              fatal("not enough lines in file");\n            if ((sscanf(str, "%f", &val) != 1))\n              fatal("invalid file format");\n            vect[i*grid_cols+j+k*grid_rows*grid_cols] = val;\n          }\n\n    fclose(fp);	\n\n}\n\n\nvoid writeoutput(float *vect, int grid_rows, int grid_cols, int layers, char *file) {\n\n    int i,j,k, index=0;\n    FILE *fp;\n    char str[STR_SIZE];\n\n    if( (fp = fopen(file, "w" )) == 0 )\n      printf( "The file was not opened\n" );\n\n    for (i=0; i < grid_rows; i++) \n      for (j=0; j < grid_cols; j++)\n        for (k=0; k < layers; k++)\n          {\n            sprintf(str, "%d\t%g\n", index, vect[i*grid_cols+j+k*grid_rows*grid_cols]);\n            fputs(str,fp);\n            index++;\n          }\n\n    fclose(fp);	\n}\n\n\n\nvoid computeTempCPU(float *pIn, float* tIn, float *tOut, \n        int nx, int ny, int nz, float Cap, \n        float Rx, float Ry, float Rz, \n        float dt, int numiter) \n{   float ce, cw, cn, cs, ct, cb, cc;\n    float stepDivCap = dt / Cap;\n    ce = cw =stepDivCap/ Rx;\n    cn = cs =stepDivCap/ Ry;\n    ct = cb =stepDivCap/ Rz;\n\n    cc = 1.0 - (2.0*ce + 2.0*cn + 3.0*ct);\n\n    int c,w,e,n,s,b,t;\n    int x,y,z;\n    int i = 0;\n    do{\n        for(z = 0; z < nz; z++)\n            for(y = 0; y < ny; y++)\n                for(x = 0; x < nx; x++)\n                {\n                    c = x + y * nx + z * nx * ny;\n\n                    w = (x == 0) ? c      : c - 1;\n                    e = (x == nx - 1) ? c : c + 1;\n                    n = (y == 0) ? c      : c - nx;\n                    s = (y == ny - 1) ? c : c + nx;\n                    b = (z == 0) ? c      : c - nx * ny;\n                    t = (z == nz - 1) ? c : c + nx * ny;\n\n\n                    tOut[c] = tIn[c]*cc + tIn[n]*cn + tIn[s]*cs + tIn[e]*ce + tIn[w]*cw + tIn[t]*ct + tIn[b]*cb + (dt/Cap) * pIn[c] + ct*amb_temp;\n                }\n        float *temp = tIn;\n        tIn = tOut;\n        tOut = temp; \n        i++;\n    }\n    while(i < numiter);\n\n}\n\nfloat accuracy(float *arr1, float *arr2, int len)\n{\n    float err = 0.0; \n    int i;\n    for(i = 0; i < len; i++)\n    {\n        err += (arr1[i]-arr2[i]) * (arr1[i]-arr2[i]);\n    }\n\n    return (float)sqrt(err/len);\n\n\n}\nvoid computeTempOMP(float *pIn, float* tIn, float *tOut, \n        int nx, int ny, int nz, float Cap, \n        float Rx, float Ry, float Rz, \n        float dt, int numiter) \n{  \n\n    float ce, cw, cn, cs, ct, cb, cc;\n\n    float stepDivCap = dt / Cap;\n    ce = cw =stepDivCap/ Rx;\n    cn = cs =stepDivCap/ Ry;\n    ct = cb =stepDivCap/ Rz;\n\n    cc = 1.0 - (2.0*ce + 2.0*cn + 3.0*ct);\n\n\n#pragma omp parallel\n    {\n        int count = 0;\n        float *tIn_t = tIn;\n        float *tOut_t = tOut;\n\n#pragma omp master\n        printf("%d threads running\n", omp_get_num_threads());\n\n        do {\n            int z; \n#pragma omp for \n            for (z = 0; z < nz; z++) {\n                int y;\n                for (y = 0; y < ny; y++) {\n                    int x;\n                    for (x = 0; x < nx; x++) {\n                        int c, w, e, n, s, b, t;\n                        c =  x + y * nx + z * nx * ny;\n                        w = (x == 0)    ? c : c - 1;\n                        e = (x == nx-1) ? c : c + 1;\n                        n = (y == 0)    ? c : c - nx;\n                        s = (y == ny-1) ? c : c + nx;\n                        b = (z == 0)    ? c : c - nx * ny;\n                        t = (z == nz-1) ? c : c + nx * ny;\n                        tOut_t[c] = cc * tIn_t[c] + cw * tIn_t[w] + ce * tIn_t[e]\n                            + cs * tIn_t[s] + cn * tIn_t[n] + cb * tIn_t[b] + ct * tIn_t[t]+(dt/Cap) * pIn[c] + ct*amb_temp;\n                    }\n                }\n            }\n            float *t = tIn_t;\n            tIn_t = tOut_t;\n            tOut_t = t; \n            count++;\n        } while (count < numiter);\n    } \n    return; \n} \n\nvoid usage(int argc, char **argv)\n{\n    fprintf(stderr, "Usage: %s <rows/cols> <layers> <iterations> <powerFile> <tempFile> <outputFile>\n", argv[0]);\n    fprintf(stderr, "\t<rows/cols>  - number of rows/cols in the grid (positive integer)\n");\n    fprintf(stderr, "\t<layers>  - number of layers in the grid (positive integer)\n");\n\n    fprintf(stderr, "\t<iteration> - number of iterations\n");\n    fprintf(stderr, "\t<powerFile>  - name of the file containing the initial power values of each cell\n");\n    fprintf(stderr, "\t<tempFile>  - name of the file containing the initial temperature values of each cell\n");\n    fprintf(stderr, "\t<outputFile - output file\n");\n    exit(1);\n}\n\n\n\nint main(int argc, char** argv)\n{\n    if (argc != 7)\n    {\n        usage(argc,argv);\n    }\n\n    char *pfile, *tfile, *ofile;// *testFile;\n    int iterations = atoi(argv[3]);\n\n    pfile = argv[4];\n    tfile = argv[5];\n    ofile = argv[6];\n    //testFile = argv[7];\n    int numCols = atoi(argv[1]);\n    int numRows = atoi(argv[1]);\n    int layers = atoi(argv[2]);\n\n    /* calculating parameters*/\n\n    float dx = chip_height/numRows;\n    float dy = chip_width/numCols;\n    float dz = t_chip/layers;\n\n    float Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * dx * dy;\n    float Rx = dy / (2.0 * K_SI * t_chip * dx);\n    float Ry = dx / (2.0 * K_SI * t_chip * dy);\n    float Rz = dz / (K_SI * dx * dy);\n\n    // cout << Rx << " " << Ry << " " << Rz << endl;\n    float max_slope = MAX_PD / (FACTOR_CHIP * t_chip * SPEC_HEAT_SI);\n    float dt = PRECISION / max_slope;\n\n\n    float *powerIn, *tempOut, *tempIn, *tempCopy;// *pCopy;\n    //    float *d_powerIn, *d_tempIn, *d_tempOut;\n    int size = numCols * numRows * layers;\n\n    powerIn = (float*)calloc(size, sizeof(float));\n    tempCopy = (float*)malloc(size * sizeof(float));\n    tempIn = (float*)calloc(size,sizeof(float));\n    tempOut = (float*)calloc(size, sizeof(float));\n    //pCopy = (float*)calloc(size,sizeof(float));\n    float* answer = (float*)calloc(size, sizeof(float));\n\n    // outCopy = (float*)calloc(size, sizeof(float));\n    readinput(powerIn,numRows, numCols, layers,pfile);\n    readinput(tempIn, numRows, numCols, layers, tfile);\n\n    memcpy(tempCopy,tempIn, size * sizeof(float));\n\n    struct timeval start, stop;\n    float time;\n    gettimeofday(&start,NULL);\n    computeTempOMP(powerIn, tempIn, tempOut, numCols, numRows, layers, Cap, Rx, Ry, Rz, dt,iterations);\n    gettimeofday(&stop,NULL);\n    time = (stop.tv_usec-start.tv_usec)*1.0e-6 + stop.tv_sec - start.tv_sec;\n    computeTempCPU(powerIn, tempCopy, answer, numCols, numRows, layers, Cap, Rx, Ry, Rz, dt,iterations);\n\n    float acc = accuracy(tempOut,answer,numRows*numCols*layers);\n    printf("Time: %.3f (s)\n",time);\n    printf("Accuracy: %e\n",acc);\n    writeoutput(tempOut,numRows, numCols, layers, ofile);\n    free(tempIn);\n    free(tempOut); free(powerIn);\n    return 0;\n}	\n\n\n