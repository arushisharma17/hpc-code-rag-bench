// srad.cpp : Defines the entry point for the console application.\n//\n\n//#define OUTPUT\n\n\n#define OPEN\n#define	ITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\n\nvoid random_matrix(float *I, int rows, int cols);\n\nvoid usage(int argc, char **argv)\n{\n	fprintf(stderr, "Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\n", argv[0]);\n	fprintf(stderr, "\t<rows>   - number of rows\n");\n	fprintf(stderr, "\t<cols>    - number of cols\n");\n	fprintf(stderr, "\t<y1> 	 - y1 value of the speckle\n");\n	fprintf(stderr, "\t<y2>      - y2 value of the speckle\n");\n	fprintf(stderr, "\t<x1>       - x1 value of the speckle\n");\n	fprintf(stderr, "\t<x2>       - x2 value of the speckle\n");\n	fprintf(stderr, "\t<no. of threads>  - no. of threads\n");\n	fprintf(stderr, "\t<lamda>   - lambda (0,1)\n");\n	fprintf(stderr, "\t<no. of iter>   - number of iterations\n");\n	\n	exit(1);\n}\n\nint main(int argc, char* argv[])\n{   \n	int rows, cols, size_I, size_R, niter = 10, iter, k;\n    float *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n	float Jc, G2, L, num, den, qsqr;\n	int *iN,*iS,*jE,*jW;\n	float *dN,*dS,*dW,*dE;\n	int r1, r2, c1, c2;\n	float cN,cS,cW,cE;\n	float *c, D;\n	float lambda;\n	int i, j;\n    int nthreads;\n\n	if (argc == 10)\n	{\n		rows = atoi(argv[1]); //number of rows in the domain\n		cols = atoi(argv[2]); //number of cols in the domain\n		if ((rows%16!=0) || (cols%16!=0)){\n			fprintf(stderr, "rows and cols must be multiples of 16\n");\n			exit(1);\n		}\n		r1   = atoi(argv[3]); //y1 position of the speckle\n		r2   = atoi(argv[4]); //y2 position of the speckle\n		c1   = atoi(argv[5]); //x1 position of the speckle\n		c2   = atoi(argv[6]); //x2 position of the speckle\n		nthreads = atoi(argv[7]); // number of threads\n		lambda = atof(argv[8]); //Lambda value\n		niter = atoi(argv[9]); //number of iterations\n	}\n    else{\n		usage(argc, argv);\n    }\n\n\n	size_I = cols * rows;\n    size_R = (r2-r1+1)*(c2-c1+1);   \n\n	I = (float *)malloc( size_I * sizeof(float) );\n    J = (float *)malloc( size_I * sizeof(float) );\n	c  = (float *)malloc(sizeof(float)* size_I) ;\n\n    iN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n    iS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n    jW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n    jE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\n\n	dN = (float *)malloc(sizeof(float)* size_I) ;\n    dS = (float *)malloc(sizeof(float)* size_I) ;\n    dW = (float *)malloc(sizeof(float)* size_I) ;\n    dE = (float *)malloc(sizeof(float)* size_I) ;    \n    \n\n    for (int i=0; i< rows; i++) {\n        iN[i] = i-1;\n        iS[i] = i+1;\n    }    \n    for (int j=0; j< cols; j++) {\n        jW[j] = j-1;\n        jE[j] = j+1;\n    }\n    iN[0]    = 0;\n    iS[rows-1] = rows-1;\n    jW[0]    = 0;\n    jE[cols-1] = cols-1;\n	\n	printf("Randomizing the input matrix\n");\n\n    random_matrix(I, rows, cols);\n\n    for (k = 0;  k < size_I; k++ ) {\n     	J[k] = (float)exp(I[k]) ;\n    }\n   \n	printf("Start the SRAD main loop\n");\n\n#ifdef ITERATION\n	for (iter=0; iter< niter; iter++){\n#endif        \n		sum=0; sum2=0;     \n		for (i=r1; i<=r2; i++) {\n            for (j=c1; j<=c2; j++) {\n                tmp   = J[i * cols + j];\n                sum  += tmp ;\n                sum2 += tmp*tmp;\n            }\n        }\n        meanROI = sum / size_R;\n        varROI  = (sum2 / size_R) - meanROI*meanROI;\n        q0sqr   = varROI / (meanROI*meanROI);\n		\n\n#ifdef OPEN\n		omp_set_num_threads(nthreads);\n		#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n		for (int i = 0 ; i < rows ; i++) {\n            for (int j = 0; j < cols; j++) { \n		\n				k = i * cols + j;\n				Jc = J[k];\n \n				// directional derivates\n                dN[k] = J[iN[i] * cols + j] - Jc;\n                dS[k] = J[iS[i] * cols + j] - Jc;\n                dW[k] = J[i * cols + jW[j]] - Jc;\n                dE[k] = J[i * cols + jE[j]] - Jc;\n			\n                G2 = (dN[k]*dN[k] + dS[k]*dS[k] \n                    + dW[k]*dW[k] + dE[k]*dE[k]) / (Jc*Jc);\n\n   		        L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;\n\n				num  = (0.5*G2) - ((1.0/16.0)*(L*L)) ;\n                den  = 1 + (.25*L);\n                qsqr = num/(den*den);\n \n                // diffusion coefficent (equ 33)\n                den = (qsqr-q0sqr) / (q0sqr * (1+q0sqr)) ;\n                c[k] = 1.0 / (1.0+den) ;\n                \n                // saturate diffusion coefficent\n                if (c[k] < 0) {c[k] = 0;}\n                else if (c[k] > 1) {c[k] = 1;}\n   \n		}\n  \n    }\n#ifdef OPEN\n		omp_set_num_threads(nthreads);\n		#pragma omp parallel for shared(J, c, rows, cols, lambda) private(i, j, k, D, cS, cN, cW, cE)\n#endif \n		for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {        \n\n                // current index\n                k = i * cols + j;\n                \n                // diffusion coefficent\n					cN = c[k];\n					cS = c[iS[i] * cols + j];\n					cW = c[k];\n					cE = c[i * cols + jE[j]];\n\n                // divergence (equ 58)\n                D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];\n                \n                // image update (equ 61)\n                J[k] = J[k] + 0.25*lambda*D;\n                #ifdef OUTPUT\n                //printf("%.5f ", J[k]); \n                #endif //output\n            }\n	            #ifdef OUTPUT\n                //printf("\n"); \n                #endif //output\n	     }\n\n#ifdef ITERATION\n	}\n#endif\n\n\n#ifdef OUTPUT\n	  for( int i = 0 ; i < rows ; i++){\n		for ( int j = 0 ; j < cols ; j++){\n\n         printf("%.5f ", J[i * cols + j]); \n    \n		}\n         printf("\n"); \n   }\n#endif \n\n	printf("Computation Done\n");\n\n	free(I);\n	free(J);\n	free(iN); free(iS); free(jW); free(jE);\n    free(dN); free(dS); free(dW); free(dE);\n\n	free(c);\n	return 0;\n}\n\n\n\n\nvoid random_matrix(float *I, int rows, int cols){\n\n	srand(7);\n	\n	for( int i = 0 ; i < rows ; i++){\n		for ( int j = 0 ; j < cols ; j++){\n		 I[i * cols + j] = rand()/(float)RAND_MAX ;\n		 #ifdef OUTPUT\n         //printf("%g ", I[i * cols + j]); \n         #endif \n		}\n		 #ifdef OUTPUT\n         //printf("\n"); \n         #endif \n	}\n\n}\n\n