// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu\n// This code is from the AIAA-2009-4001 paper\n\n#include <iostream>\n#include <fstream>\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\n#include <cmath>\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n\n#include <omp.h>\n\nstruct float3 { float x, y, z; };\n\n#ifndef block_length\n	#ifdef _OPENMP\n	#error "you need to define block_length"\n	#else\n	#define block_length 1\n	#endif\n#endif\n\n/*\n * Options\n *\n */\n#define GAMMA 1.4\n#define iterations 2000\n\n#define NDIM 3\n#define NNB 4\n\n#define RK 3	// 3rd order RK\n#define ff_mach 1.2\n#define deg_angle_of_attack 0.0f\n\n/*\n * not options\n */\n#define VAR_DENSITY 0\n#define VAR_MOMENTUM  1\n#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)\n#define NVAR (VAR_DENSITY_ENERGY+1)\n\n\n#ifdef restrict\n#define __restrict restrict\n#else\n#define __restrict \n#endif\n\n/*\n * Generic functions\n */\ntemplate <typename T>\nT* alloc(int N)\n{\n	return new T[N];\n}\n\ntemplate <typename T>\nvoid dealloc(T* array)\n{\n	delete[] array;\n}\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\ntemplate <typename T>\nvoid copy(T* dst, T* src, int N)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < N; i++)\n	{\n		dst[i] = src[i];\n	}\n}\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n\n\nvoid dump(float* variables, int nel, int nelr)\n{\n\n\n	{\n		std::ofstream file("density");\n		file << nel << " " << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i + VAR_DENSITY*nelr] << std::endl;\n	}\n\n\n	{\n		std::ofstream file("momentum");\n		file << nel << " " << nelr << std::endl;\n		for(int i = 0; i < nel; i++)\n		{\n			for(int j = 0; j != NDIM; j++) file << variables[i + (VAR_MOMENTUM+j)*nelr] << " ";\n			file << std::endl;\n		}\n	}\n\n	{\n		std::ofstream file("density_energy");\n		file << nel << " " << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i + VAR_DENSITY_ENERGY*nelr] << std::endl;\n	}\n\n}\n\nvoid initialize_variables(int nelr, float* variables, float* ff_variable)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		for(int j = 0; j < NVAR; j++) variables[i + j*nelr] = ff_variable[j];\n	}\n}\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\ninline void compute_flux_contribution(float& density, float3& momentum, float& density_energy, float& pressure, float3& velocity, float3& fc_momentum_x, float3& fc_momentum_y, float3& fc_momentum_z, float3& fc_density_energy)\n{\n	fc_momentum_x.x = velocity.x*momentum.x + pressure;\n	fc_momentum_x.y = velocity.x*momentum.y;\n	fc_momentum_x.z = velocity.x*momentum.z;\n\n	fc_momentum_y.x = fc_momentum_x.y;\n	fc_momentum_y.y = velocity.y*momentum.y + pressure;\n	fc_momentum_y.z = velocity.y*momentum.z;\n\n	fc_momentum_z.x = fc_momentum_x.z;\n	fc_momentum_z.y = fc_momentum_y.z;\n	fc_momentum_z.z = velocity.z*momentum.z + pressure;\n\n	float de_p = density_energy+pressure;\n	fc_density_energy.x = velocity.x*de_p;\n	fc_density_energy.y = velocity.y*de_p;\n	fc_density_energy.z = velocity.z*de_p;\n}\n\ninline void compute_velocity(float& density, float3& momentum, float3& velocity)\n{\n	velocity.x = momentum.x / density;\n	velocity.y = momentum.y / density;\n	velocity.z = momentum.z / density;\n}\n\ninline float compute_speed_sqd(float3& velocity)\n{\n	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;\n}\n\ninline float compute_pressure(float& density, float& density_energy, float& speed_sqd)\n{\n	return (float(GAMMA)-float(1.0f))*(density_energy - float(0.5f)*density*speed_sqd);\n}\n\ninline float compute_speed_of_sound(float& density, float& pressure)\n{\n	return std::sqrt(float(GAMMA)*pressure/density);\n}\n\n\nvoid compute_step_factor(int nelr, float* __restrict variables, float* areas, float* __restrict step_factors)\n{\n	#pragma omp parallel for default(shared) schedule(auto)\n        for(int blk = 0; blk < nelr/block_length; ++blk)\n        {\n            int b_start = blk*block_length;\n            int b_end = (blk+1)*block_length > nelr ? nelr : (blk+1)*block_length;\n#pragma omp simd\n	for(int i = b_start; i < b_end; i++)\n	{\n		float density = variables[i + VAR_DENSITY*nelr];\n\n		float3 momentum;\n		momentum.x = variables[i + (VAR_MOMENTUM+0)*nelr];\n		momentum.y = variables[i + (VAR_MOMENTUM+1)*nelr];\n		momentum.z = variables[i + (VAR_MOMENTUM+2)*nelr];\n\n		float density_energy = variables[i + VAR_DENSITY_ENERGY*nelr];\n		float3 velocity;	   compute_velocity(density, momentum, velocity);\n		float speed_sqd      = compute_speed_sqd(velocity);\n		float pressure       = compute_pressure(density, density_energy, speed_sqd);\n		float speed_of_sound = compute_speed_of_sound(density, pressure);\n\n		// dt = float(0.5f) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once\n		step_factors[i] = float(0.5f) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));\n	}\n        }\n}\n\n\n/*\n *\n *\n*/\n\nvoid compute_flux(int nelr, int* elements_surrounding_elements, float* normals, float* variables, float* fluxes, float* ff_variable, float3 ff_flux_contribution_momentum_x, float3 ff_flux_contribution_momentum_y, float3 ff_flux_contribution_momentum_z, float3 ff_flux_contribution_density_energy)\n{\n	const float smoothing_coefficient = float(0.2f);\n\n	#pragma omp parallel for default(shared) schedule(auto)\n        for(int blk = 0; blk < nelr/block_length; ++blk)\n        {\n            int b_start = blk*block_length;\n            int b_end = (blk+1)*block_length > nelr ? nelr : (blk+1)*block_length;\n#pragma omp simd\n	for(int i = b_start; i < b_end; ++i)\n	{\n                float density_i = variables[i + VAR_DENSITY*nelr];\n		float3 momentum_i;\n		momentum_i.x = variables[i + (VAR_MOMENTUM+0)*nelr];\n		momentum_i.y = variables[i + (VAR_MOMENTUM+1)*nelr];\n		momentum_i.z = variables[i + (VAR_MOMENTUM+2)*nelr];\n\n		float density_energy_i = variables[i + VAR_DENSITY_ENERGY*nelr];\n\n		float3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);\n		float speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		float speed_i                              = std::sqrt(speed_sqd_i);\n		float pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		float speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		float3 flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z;\n		float3 flux_contribution_i_density_energy;\n		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z, flux_contribution_i_density_energy);\n\n		float flux_i_density = float(0.0f);\n		float3 flux_i_momentum;\n		flux_i_momentum.x = float(0.0f);\n		flux_i_momentum.y = float(0.0f);\n		flux_i_momentum.z = float(0.0f);\n		float flux_i_density_energy = float(0.0f);\n\n		float3 velocity_nb;\n		float density_nb, density_energy_nb;\n		float3 momentum_nb;\n		float3 flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z;\n		float3 flux_contribution_nb_density_energy;\n		float speed_sqd_nb, speed_of_sound_nb, pressure_nb;\n#pragma unroll\n		for(int j = 0; j < NNB; j++)\n		{\n                        float3 normal; float normal_len;\n		        float factor;\n\n			int nb = elements_surrounding_elements[i + j*nelr];\n			normal.x = normals[i + (j + 0*NNB)*nelr];\n			normal.y = normals[i + (j + 1*NNB)*nelr];\n			normal.z = normals[i + (j + 2*NNB)*nelr];\n			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);\n\n			if(nb >= 0) 	// a legitimate neighbor\n			{\n				density_nb =        variables[nb + VAR_DENSITY*nelr];\n				momentum_nb.x =     variables[nb + (VAR_MOMENTUM+0)*nelr];\n				momentum_nb.y =     variables[nb + (VAR_MOMENTUM+1)*nelr];\n				momentum_nb.z =     variables[nb + (VAR_MOMENTUM+2)*nelr];\n				density_energy_nb = variables[nb + VAR_DENSITY_ENERGY*nelr];\n													compute_velocity(density_nb, momentum_nb, velocity_nb);\n				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);\n				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);\n				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);\n													compute_flux_contribution(density_nb, momentum_nb, density_energy_nb, pressure_nb, velocity_nb, flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z, flux_contribution_nb_density_energy);\n\n				// artificial viscosity\n				factor = -normal_len*smoothing_coefficient*float(0.5f)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);\n				flux_i_density += factor*(density_i-density_nb);\n				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);\n				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);\n				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);\n				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);\n\n				// accumulate cell-centered fluxes\n				factor = float(0.5f)*normal.x;\n				flux_i_density += factor*(momentum_nb.x+momentum_i.x);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.x+flux_contribution_i_density_energy.x);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.x+flux_contribution_i_momentum_x.x);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.x+flux_contribution_i_momentum_y.x);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.x+flux_contribution_i_momentum_z.x);\n\n				factor = float(0.5f)*normal.y;\n				flux_i_density += factor*(momentum_nb.y+momentum_i.y);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.y+flux_contribution_i_density_energy.y);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.y+flux_contribution_i_momentum_x.y);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.y+flux_contribution_i_momentum_y.y);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.y+flux_contribution_i_momentum_z.y);\n\n				factor = float(0.5f)*normal.z;\n				flux_i_density += factor*(momentum_nb.z+momentum_i.z);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.z+flux_contribution_i_density_energy.z);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.z+flux_contribution_i_momentum_x.z);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.z+flux_contribution_i_momentum_y.z);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.z+flux_contribution_i_momentum_z.z);\n			}\n			else if(nb == -1)	// a wing boundary\n			{\n				flux_i_momentum.x += normal.x*pressure_i;\n				flux_i_momentum.y += normal.y*pressure_i;\n				flux_i_momentum.z += normal.z*pressure_i;\n			}\n			else if(nb == -2) // a far field boundary\n			{\n				factor = float(0.5f)*normal.x;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.x+flux_contribution_i_density_energy.x);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.x + flux_contribution_i_momentum_x.x);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.x + flux_contribution_i_momentum_y.x);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.x + flux_contribution_i_momentum_z.x);\n\n				factor = float(0.5f)*normal.y;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.y+flux_contribution_i_density_energy.y);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.y + flux_contribution_i_momentum_x.y);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.y + flux_contribution_i_momentum_y.y);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.y + flux_contribution_i_momentum_z.y);\n\n				factor = float(0.5f)*normal.z;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.z+flux_contribution_i_density_energy.z);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.z + flux_contribution_i_momentum_x.z);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.z + flux_contribution_i_momentum_y.z);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.z + flux_contribution_i_momentum_z.z);\n\n			}\n                }\n		fluxes[i + VAR_DENSITY*nelr] = flux_i_density;\n		fluxes[i + (VAR_MOMENTUM+0)*nelr] = flux_i_momentum.x;\n		fluxes[i + (VAR_MOMENTUM+1)*nelr] = flux_i_momentum.y;\n		fluxes[i + (VAR_MOMENTUM+2)*nelr] = flux_i_momentum.z;\n		fluxes[i + VAR_DENSITY_ENERGY*nelr] = flux_i_density_energy;\n                \n	}\n        }\n}\n\nvoid time_step(int j, int nelr, float* old_variables, float* variables, float* step_factors, float* fluxes)\n{\n    #pragma omp parallel for  default(shared) schedule(auto)\n    for(int blk = 0; blk < nelr/block_length; ++blk)\n    {\n        int b_start = blk*block_length;\n        int b_end = (blk+1)*block_length > nelr ? nelr : (blk+1)*block_length;\n        #pragma omp simd\n        for(int i = b_start; i < b_end; ++i)\n        {\n            float factor = step_factors[i]/float(RK+1-j);\n\n            variables[i + VAR_DENSITY*nelr] = old_variables[i + VAR_DENSITY*nelr] + factor*fluxes[i + VAR_DENSITY*nelr];\n            variables[i + (VAR_MOMENTUM+0)*nelr] = old_variables[i + (VAR_MOMENTUM+0)*nelr] + factor*fluxes[i + (VAR_MOMENTUM+0)*nelr];\n            variables[i + (VAR_MOMENTUM+1)*nelr] = old_variables[i + (VAR_MOMENTUM+1)*nelr] + factor*fluxes[i + (VAR_MOMENTUM+1)*nelr];\n            variables[i + (VAR_MOMENTUM+2)*nelr] = old_variables[i + (VAR_MOMENTUM+2)*nelr] + factor*fluxes[i + (VAR_MOMENTUM+2)*nelr];\n            variables[i + VAR_DENSITY_ENERGY*nelr] = old_variables[i + VAR_DENSITY_ENERGY*nelr] + factor*fluxes[i + VAR_DENSITY_ENERGY*nelr];\n\n        }\n    }\n}\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n/*\n * Main function\n */\nint main(int argc, char** argv)\n{\n	if (argc < 2)\n	{\n		std::cout << "specify data file name" << std::endl;\n		return 0;\n	}\n	const char* data_file_name = argv[1];\n\n        float ff_variable[NVAR];\n        float3 ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy;\n\n	// set far field conditions\n	{\n		const float angle_of_attack = float(3.1415926535897931 / 180.0f) * float(deg_angle_of_attack);\n\n		ff_variable[VAR_DENSITY] = float(1.4);\n\n		float ff_pressure = float(1.0f);\n		float ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);\n		float ff_speed = float(ff_mach)*ff_speed_of_sound;\n\n		float3 ff_velocity;\n		ff_velocity.x = ff_speed*float(cos((float)angle_of_attack));\n		ff_velocity.y = ff_speed*float(sin((float)angle_of_attack));\n		ff_velocity.z = 0.0f;\n\n		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;\n		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;\n		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;\n\n		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(float(0.5f)*(ff_speed*ff_speed)) + (ff_pressure / float(GAMMA-1.0f));\n\n		float3 ff_momentum;\n		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);\n		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);\n		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);\n		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy);\n	}\n	int nel;\n	int nelr;\n\n\n	// read in domain geometry\n	float* areas;\n	int* elements_surrounding_elements;\n	float* normals;\n	{\n		std::ifstream file(data_file_name);\n\n		file >> nel;\n		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));\n\n		areas = new float[nelr];\n		elements_surrounding_elements = new int[nelr*NNB];\n		normals = new float[NDIM*NNB*nelr];\n\n		// read in data\n		for(int i = 0; i < nel; i++)\n		{\n			file >> areas[i];\n			for(int j = 0; j < NNB; j++)\n			{\n				file >> elements_surrounding_elements[i + j*nelr];\n				if(elements_surrounding_elements[i+j*nelr] < 0) elements_surrounding_elements[i+j*nelr] = -1;\n				elements_surrounding_elements[i + j*nelr]--; //it's coming in with Fortran numbering\n\n				for(int k = 0; k < NDIM; k++)\n				{\n					file >>  normals[i + (j + k*NNB)*nelr];\n					normals[i + (j + k*NNB)*nelr] = -normals[i + (j + k*NNB)*nelr];\n				}\n			}\n		}\n\n		// fill in remaining data\n		int last = nel-1;\n		for(int i = nel; i < nelr; i++)\n		{\n			areas[i] = areas[last];\n			for(int j = 0; j < NNB; j++)\n			{\n				// duplicate the last element\n				elements_surrounding_elements[i + j*nelr] = elements_surrounding_elements[last + j*nelr];\n				for(int k = 0; k < NDIM; k++) normals[i + (j + k*NNB)*nelr] = normals[last + (j + k*NNB)*nelr];\n			}\n		}\n	}\n\n	// Create arrays and set initial conditions\n	float* variables = alloc<float>(nelr*NVAR);\n	initialize_variables(nelr, variables, ff_variable);\n\n	float* old_variables = alloc<float>(nelr*NVAR);\n	float* fluxes = alloc<float>(nelr*NVAR);\n	float* step_factors = alloc<float>(nelr);\n\n	// these need to be computed the first time in order to compute time step\n	std::cout << "Starting..." << std::endl;\n#ifdef _OPENMP\n	double start = omp_get_wtime();\n    #ifdef OMP_OFFLOAD\n        #pragma omp target map(alloc: old_variables[0:(nelr*NVAR)]) map(to: nelr, areas[0:nelr], step_factors[0:nelr], elements_surrounding_elements[0:(nelr*NNB)], normals[0:(NDIM*NNB*nelr)], fluxes[0:(nelr*NVAR)], ff_variable[0:NVAR], ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy) map(variables[0:(nelr*NVAR)])\n    #endif\n#endif\n	// Begin iterations\n	for(int i = 0; i < iterations; i++)\n	{\n                copy<float>(old_variables, variables, nelr*NVAR);\n\n		// for the first iteration we compute the time step\n		compute_step_factor(nelr, variables, areas, step_factors);\n\n		for(int j = 0; j < RK; j++)\n		{\n			compute_flux(nelr, elements_surrounding_elements, normals, variables, fluxes, ff_variable, ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy);\n			time_step(j, nelr, old_variables, variables, step_factors, fluxes);\n		}\n	}\n\n#ifdef _OPENMP\n	double end = omp_get_wtime();\n	std::cout  << "Compute time: " << (end-start) << std::endl;\n#endif\n\n\n	std::cout << "Saving solution..." << std::endl;\n	dump(variables, nel, nelr);\n	std::cout << "Saved solution..." << std::endl;\n\n\n	std::cout << "Cleaning up..." << std::endl;\n	dealloc<float>(areas);\n	dealloc<int>(elements_surrounding_elements);\n	dealloc<float>(normals);\n\n	dealloc<float>(variables);\n	dealloc<float>(old_variables);\n	dealloc<float>(fluxes);\n	dealloc<float>(step_factors);\n\n	std::cout << "Done..." << std::endl;\n\n	return 0;\n}\n