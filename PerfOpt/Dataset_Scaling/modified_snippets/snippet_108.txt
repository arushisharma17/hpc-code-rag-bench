\n\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  Band matrix factorisation routines\n  */\n\n/* bdfactor.c  18/11/93 */\nstatic	char	rcsid[] = "$Id: ";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "matrix2.h"\n\n\n/* generate band matrix \n   for a matrix  with n columns,\n   lb subdiagonals and ub superdiagonals;\n\n   Way of saving a band of a matrix:\n   first we save subdiagonals (from 0 to lb-1);\n   then main diagonal (in the lb row)\n   and then superdiagonals (from lb+1 to lb+ub)\n   in such a way that the elements which were previously\n   in one column are now also in one column\n*/\n#ifndef ANSI_C\nBAND *bd_get(lb,ub,n)\nint lb, ub, n;\n#else\nBAND *bd_get(int lb, int ub, int n)\n#endif\n{\n   BAND *A;\n\n   if (lb < 0 || ub < 0 || n <= 0)\n     error(E_NEG,"bd_get");\n\n   if ((A = NEW(BAND)) == (BAND *)NULL)\n     error(E_MEM,"bd_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_BAND,0,sizeof(BAND));\n      mem_numvar(TYPE_BAND,1);\n   }\n\n   lb = A->lb = min(n-1,lb);\n   ub = A->ub = min(n-1,ub);\n   A->mat = m_get(lb+ub+1,n);\n   return A;\n}\n\n/* bd_free -- frees BAND matrix -- returns (-1) on error and 0 otherwise */\n#ifndef ANSI_C\nint bd_free(A)\nBAND *A;\n#else\nint bd_free(BAND *A)\n#endif\n{\n   if ( A == (BAND *)NULL || A->lb < 0 || A->ub < 0 )\n     /* don't trust it */\n     return (-1);\n\n   if (A->mat) m_free(A->mat);\n\n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_BAND,sizeof(BAND),0);\n      mem_numvar(TYPE_BAND,-1);\n   }\n\n   free((char *)A);\n   return 0;\n}\n\n\n/* resize band matrix */\n#ifndef ANSI_C\nBAND *bd_resize(A,new_lb,new_ub,new_n)\nBAND *A;\nint new_lb,new_ub,new_n;\n#else\nBAND *bd_resize(BAND *A, int new_lb, int new_ub, int new_n)\n#endif\n{\n   int lb,ub,i,j,l,shift,umin;\n   Real **Av;\n\n   if (new_lb < 0 || new_ub < 0 || new_n <= 0)\n     error(E_NEG,"bd_resize");\n   if ( ! A )\n     return bd_get(new_lb,new_ub,new_n);\n    if ( A->lb+A->ub+1 > A->mat->m )\n	error(E_INTERN,"bd_resize");\n\n   if ( A->lb == new_lb && A->ub == new_ub && A->mat->n == new_n )\n	return A;\n\n   lb = A->lb;\n   ub = A->ub;\n   Av = A->mat->me;\n   umin = min(ub,new_ub);\n\n    /* ensure that unused triangles at edges are zero'd */\n\n   for ( i = 0; i < lb; i++ )\n      for ( j = A->mat->n - lb + i; j < A->mat->n; j++ )\n	Av[i][j] = 0.0;  \n    for ( i = lb+1,l=1; l <= umin; i++,l++ )\n      for ( j = 0; j < l; j++ )\n	Av[i][j] = 0.0; \n\n   new_lb = A->lb = min(new_lb,new_n-1);\n   new_ub = A->ub = min(new_ub,new_n-1);\n   A->mat = m_resize(A->mat,new_lb+new_ub+1,new_n);\n   Av = A->mat->me;\n\n   /* if new_lb != lb then move the rows to get the main diag \n      in the new_lb row */\n\n   if (new_lb > lb) {\n      shift = new_lb-lb;\n\n      for (i=lb+umin, l=i+shift; i >= 0; i--,l--)\n	MEM_COPY(Av[i],Av[l],new_n*sizeof(Real));\n      for (l=shift-1; l >= 0; l--)\n	__zero__(Av[l],new_n);\n   }\n   else if (new_lb < lb) { \n      shift = lb - new_lb;\n\n      for (i=shift, l=0; i <= lb+umin; i++,l++)\n	MEM_COPY(Av[i],Av[l],new_n*sizeof(Real));\n      for (i=lb+umin+1; i <= new_lb+new_ub; i++)\n	__zero__(Av[i],new_n);\n   }\n\n   return A;\n}\n\n\n/* bd_copy -- copies band matrix A to B, returning B\n	-- if B is NULL, create\n	-- B is set to the correct size */\n#ifndef ANSI_C\nBAND *bd_copy(A,B)\nBAND *A,*B;\n#else\nBAND *bd_copy(const BAND *A, BAND *B)\n#endif\n{\n   int lb,ub,i,j,n;\n   \n   if ( !A )\n     error(E_NULL,"bd_copy");\n\n   if (A == B) return B;\n   \n   n = A->mat->n;\n   if ( !B )\n     B = bd_get(A->lb,A->ub,n);\n   else if (B->lb != A->lb || B->ub != A->ub || B->mat->n != n )\n     B = bd_resize(B,A->lb,A->ub,n);\n   \n   if (A->mat == B->mat) return B;\n   ub = B->ub = A->ub;\n   lb = B->lb = A->lb;\n\n   for ( i=0, j=n-lb; i <= lb; i++, j++ )\n     MEM_COPY(A->mat->me[i],B->mat->me[i],j*sizeof(Real));   \n\n   for ( i=lb+1, j=1; i <= lb+ub; i++, j++ )\n     MEM_COPY(A->mat->me[i]+j,B->mat->me[i]+j,(n - j)*sizeof(Real));     \n\n   return B;\n}\n\n\n/* copy band matrix bA to a square matrix A returning A */\n#ifndef ANSI_C\nMAT *band2mat(bA,A)\nBAND *bA;\nMAT *A;\n#else\nMAT *band2mat(const BAND *bA, MAT *A)\n#endif\n{\n   int i,j,l,n,n1;\n   int lb, ub;\n   Real **bmat;\n\n   if ( !bA )\n     error(E_NULL,"band2mat");\n   if ( bA->mat == A )\n     error(E_INSITU,"band2mat");\n\n   ub = bA->ub;\n   lb = bA->lb;\n   n = bA->mat->n;\n   n1 = n-1;\n   bmat = bA->mat->me;\n\n   A = m_resize(A,n,n);\n   m_zero(A);\n\n   for (j=0; j < n; j++)\n     for (i=min(n1,j+lb),l=lb+j-i; i >= max(0,j-ub); i--,l++)\n       A->me[i][j] = bmat[l][j];\n\n   return A;\n}\n\n/* copy a square matrix to a band matrix with \n   lb subdiagonals and ub superdiagonals */\n#ifndef ANSI_C\nBAND *mat2band(A,lb,ub,bA)\nBAND *bA;\nMAT *A;\nint lb, ub;\n#else\nBAND *mat2band(const MAT *A, int lb, int ub,BAND *bA)\n#endif\n{\n   int i, j, l, n1;\n   Real **bmat;\n   \n   if (! A )\n     error(E_NULL,"mat2band");\n   if (ub < 0 || lb < 0)\n     error(E_SIZES,"mat2band");\n   if ( bA != (BAND *)NULL && bA->mat == A )\n     error(E_INSITU,"mat2band");\n\n   n1 = A->n-1;\n   lb = min(n1,lb);\n   ub = min(n1,ub);\n   bA = bd_resize(bA,lb,ub,n1+1);\n   bmat = bA->mat->me;\n\n   for (j=0; j <= n1; j++)\n     for (i=min(n1,j+lb),l=lb+j-i; i >= max(0,j-ub); i--,l++)\n       bmat[l][j] = A->me[i][j];\n\n   return bA;\n}\n\n\n\n/* transposition of matrix in;\n   out - matrix after transposition;\n   can be done in situ\n*/\n#ifndef ANSI_C\nBAND *bd_transp(in,out)\nBAND *in, *out;\n#else\nBAND *bd_transp(const BAND *in, BAND *out)\n#endif\n{\n   int i, j, jj, l, k, lb, ub, lub, n, n1;\n   int in_situ;\n   Real  **in_v, **out_v;\n   \n   if ( in == (BAND *)NULL || in->mat == (MAT *)NULL )\n     error(E_NULL,"bd_transp");\n\n   lb = in->lb;\n   ub = in->ub;\n   lub = lb+ub;\n   n = in->mat->n;\n   n1 = n-1;\n\n   in_situ = ( in == out );\n   if ( ! in_situ )\n       out = bd_resize(out,ub,lb,n);\n   else\n   {   /* only need to swap lb and ub fields */\n       out->lb = ub;\n       out->ub = lb;\n   }\n\n   in_v = in->mat->me;\n   \n   if (! in_situ) {\n      int sh_in,sh_out; \n\n      out_v = out->mat->me;\n      for (i=0, l=lub, k=lb-i; i <= lub; i++,l--,k--) {\n	 sh_in = max(-k,0);\n	 sh_out = max(k,0);\n	 MEM_COPY(&(in_v[i][sh_in]),&(out_v[l][sh_out]),\n		  (n-sh_in-sh_out)*sizeof(Real));\n	 /**********************************\n	 for (j=n1-sh_out, jj=n1-sh_in; j >= sh_in; j--,jj--) {\n	    out_v[l][jj] = in_v[i][j];\n	 }\n	 **********************************/\n      }\n   }\n   else if (ub == lb) {\n      Real tmp;\n\n      for (i=0, l=lub, k=lb-i; i < lb; i++,l--,k--) {\n	 for (j=n1-k, jj=n1; j >= 0; j--,jj--) {\n	    tmp = in_v[l][jj];\n	    in_v[l][jj] = in_v[i][j];\n	    in_v[i][j] = tmp;\n	 }\n      }\n   }\n   else if (ub > lb) {  /* hence i-ub <= 0 & l-lb >= 0 */\n      int p,pp,lbi;\n      \n      for (i=0, l=lub; i < (lub+1)/2; i++,l--) {\n	 lbi = lb-i;\n	 for (j=l-lb, jj=0, p=max(-lbi,0), pp = max(l-ub,0); j <= n1; \n	      j++,jj++,p++,pp++) {\n	    in_v[l][pp] = in_v[i][p];\n	    in_v[i][jj] = in_v[l][j];\n	 }\n	 for (  ; p <= n1-max(lbi,0); p++,pp++)\n	   in_v[l][pp] = in_v[i][p];\n      }\n      \n      if (lub%2 == 0) { /* shift only */\n	 i = lub/2;\n	 for (j=max(i-lb,0), jj=0; jj <= n1-ub+i; j++,jj++) \n	   in_v[i][jj] = in_v[i][j];\n      }\n   }\n   else {      /* ub < lb, hence ub-l <= 0 & lb-i >= 0 */\n      int p,pp,ubi;\n\n      for (i=0, l=lub; i < (lub+1)/2; i++,l--) {\n	 ubi = i-ub;\n	 for (j=n1-max(lb-l,0), jj=n1-max(-ubi,0), p=n1-lb+i, pp=n1;\n	      p >= 0; j--, jj--, pp--, p--) {\n	    in_v[i][jj] = in_v[l][j];\n	    in_v[l][pp] = in_v[i][p];\n	 }\n	 for (  ; jj >= max(ubi,0); j--, jj--)\n	   in_v[i][jj] = in_v[l][j];\n      }\n\n      if (lub%2 == 0) {  /* shift only */\n	 i = lub/2;\n	 for (j=n1-lb+i, jj=n1-max(ub-i,0); j >= 0; j--, jj--) \n	    in_v[i][jj] = in_v[i][j];\n      }\n   }\n\n   return out;\n}\n\n/* bdv_mltadd -- band matrix-vector multiply and add\n   -- returns out <- x + s.bA.y\n   -- if y is NULL then create y (as zero vector)\n   -- error if either A or x is NULL */\n#ifndef ANSI_C\nVEC	*bdv_mltadd(x,y,bA,s,out)\n     BAND	*bA;\n     VEC	*x, *y;\n     double	s;\n     VEC *out;\n#else\nVEC	*bdv_mltadd(const VEC *x, const VEC *y, const BAND *bA,\n		    double s, VEC *out)\n#endif\n{\n  int	i, j;\n\n  if ( ! bA || ! x || ! y )\n    error(E_NULL,"bdv_mltadd");\n  if ( bA->mat->n != x->dim || y->dim != x->dim )\n    error(E_SIZES,"bdv_mltadd");\n  if ( ! out || out->dim != x->dim )\n    out = v_resize(out,x->dim);\n  out = v_copy(x,out);\n\n  for ( j = 0; j < x->dim; j++ )\n    for ( i = max(j-bA->ub,0); i <= j+bA->lb && i < x->dim; i++ )\n      out->ve[i] += s*bd_get_val(bA,i,j)*y->ve[j];\n\n  return out;\n}\n\n/* vbd_mltadd -- band matrix-vector multiply and add\n   -- returns out^T <- x^T + s.y^T.bA\n   -- if out is NULL then create out (as zero vector)\n   -- error if either bA or x is NULL */\n#ifndef ANSI_C\nVEC	*vbd_mltadd(x,y,bA,s,out)\n     BAND	*bA;\n     VEC	*x, *y;\n     double	s;\n     VEC *out;\n#else\nVEC	*vbd_mltadd(const VEC *x, const VEC *y, const BAND *bA,\n		    double s, VEC *out)\n#endif\n{\n  int	i, j;\n\n  if ( ! bA || ! x || ! y )\n    error(E_NULL,"vbd_mltadd");\n  if ( bA->mat->n != x->dim || y->dim != x->dim )\n    error(E_SIZES,"vbd_mltadd");\n  if ( ! out || out->dim != x->dim )\n    out = v_resize(out,x->dim);\n  out = v_copy(x,out);\n\n  for ( j = 0; j < x->dim; j++ )\n    for ( i = max(j-bA->ub,0); i <= j+bA->lb && i < x->dim; i++ )\n      out->ve[j] += s*bd_get_val(bA,i,j)*y->ve[i];\n\n  return out;\n}\n\n/* bd_zero -- zeros band matrix A which is returned */\n#ifndef ANSI_C\nBAND	*bd_zero(A)\nBAND	*A;\n#else\nBAND	*bd_zero(BAND *A)\n#endif\n{\n  if ( ! A )\n    error(E_NULL,"bd_zero");\n\n  m_zero(A->mat);\n  return A;\n}\n\n/* bds_mltadd -- returns OUT <- A+alpha*B\n	-- OUT is created (as zero) if NULL\n	-- if OUT is not the correct size, it is re-sized before the operation\n	-- if A or B are null, and error is generated */\n#ifndef ANSI_C\nBAND	*bds_mltadd(A,B,alpha,OUT)\nBAND	*A, *B, *OUT;\nReal	alpha;\n#else\nBAND	*bds_mltadd(const BAND *A, const BAND *B, double alpha, BAND *OUT)\n#endif\n{\n  int	i;\n\n  if ( ! A || ! B )\n    error(E_NULL,"bds_mltadd");\n  if ( A->mat->n != B->mat->n )\n    error(E_SIZES,"bds_mltadd");\n  if ( A == OUT || B == OUT )\n    error(E_INSITU,"bds_mltadd");\n\n  OUT = bd_copy(A,OUT);\n  OUT = bd_resize(OUT,max(A->lb,B->lb),max(A->ub,B->ub),A->mat->n);\n  for ( i = 0; i <= B->lb + B->ub; i++ )\n    __mltadd__(OUT->mat->me[i+OUT->lb-B->lb],B->mat->me[i],alpha,B->mat->n);\n  \n  return OUT;\n}\n\n/* sbd_mlt -- returns OUT <- s.A */\n#ifndef ANSI_C\nBAND	*sbd_mlt(Real s, BAND *A, BAND *OUT)\n#else\nBAND	*sbd_mlt(Real s, const BAND *A, BAND *OUT)\n#endif\n{\n  if ( ! A )\n    error(E_NULL,"sbd_mlt");\n\n  OUT = bd_resize(OUT,A->lb,A->ub,A->mat->n);\n  sm_mlt(s,A->mat,OUT->mat);\n\n  return OUT;\n}\n\n/* bdLUfactor -- gaussian elimination with partial pivoting\n   -- on entry, the matrix A in band storage with elements \n      in rows 0 to lb+ub; \n      The jth column of A is stored in the jth column of \n      band A (bA) as follows:\n      bA->mat->me[lb+j-i][j] = A->me[i][j] for \n      max(0,j-lb) <= i <= min(A->n-1,j+ub);\n   -- on exit: U is stored as an upper triangular matrix\n      with lb+ub superdiagonals in rows lb to 2*lb+ub, \n      and the matrix L is stored in rows 0 to lb-1.\n      Matrix U is permuted, whereas L is not permuted !!!\n      Therefore we save some memory.\n   */\n#ifndef ANSI_C\nBAND	*bdLUfactor(bA,pivot)\nBAND	*bA;\nPERM	*pivot;\n#else\nBAND	*bdLUfactor(BAND *bA, PERM *pivot)\n#endif\n{\n   int	i, j, k, l, n, n1, lb, ub, lub, k_end, k_lub;\n   int	i_max, shift;\n   Real	**bA_v;\n   Real max1, temp;\n   \n   if ( bA==(BAND *)NULL || pivot==(PERM *)NULL )\n     error(E_NULL,"bdLUfactor");\n\n   lb = bA->lb;\n   ub = bA->ub;\n   lub = lb+ub;\n   n = bA->mat->n;\n   n1 = n-1;\n   lub = lb+ub;\n\n   if ( pivot->size != n )\n     error(E_SIZES,"bdLUfactor");\n\n   \n   /* initialise pivot with identity permutation */\n   for ( i=0; i < n; i++ )\n     pivot->pe[i] = i;\n\n   /* extend band matrix */\n   /* extended part is filled with zeros */\n   bA = bd_resize(bA,lb,min(n1,lub),n);\n   bA_v = bA->mat->me;\n\n\n   /* main loop */\n\n   for ( k=0; k < n1; k++ )\n   {\n      k_end = max(0,lb+k-n1);\n      k_lub = min(k+lub,n1);\n\n      /* find the best pivot row */\n      \n      max1 = 0.0;	\n      i_max = -1;\n      for ( i=lb; i >= k_end; i-- ) {\n	 temp = fabs(bA_v[i][k]);\n	 if ( temp > max1 )\n	 { max1 = temp;	i_max = i; }\n      }\n      \n      /* if no pivot then ignore column k... */\n      if ( i_max == -1 )\n	continue;\n      \n      /* do we pivot ? */\n      if ( i_max != lb )	/* yes we do... */\n      {\n	 /* save transposition using non-shifted indices */\n	 shift = lb-i_max;\n	 px_transp(pivot,k+shift,k);\n	 for ( i=lb, j=k; j <= k_lub; i++,j++ )\n	 {\n	    temp = bA_v[i][j];\n	    bA_v[i][j] = bA_v[i-shift][j];\n	    bA_v[i-shift][j] = temp;\n	 }\n      }\n      \n      /* row operations */\n      for ( i=lb-1; i >= k_end; i-- ) {\n	 temp = bA_v[i][k] /= bA_v[lb][k];\n	 shift = lb-i;\n	 for ( j=k+1,l=i+1; j <= k_lub; l++,j++ )\n	   bA_v[l][j] -= temp*bA_v[l+shift][j];\n      }\n   }\n   \n   return bA;\n}\n\n\n/* bdLUsolve -- given an LU factorisation in bA, solve bA*x=b */\n/* pivot is changed upon return  */\n#ifndef ANSI_C\nVEC	*bdLUsolve(bA,pivot,b,x)\nBAND	*bA;\nPERM	*pivot;\nVEC	*b,*x;\n#else\nVEC	*bdLUsolve(const BAND *bA, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n   int i,j,l,n,n1,pi,lb,ub,jmin, maxj;\n   Real c;\n   Real **bA_v;\n\n   if ( bA==(BAND *)NULL || b==(VEC *)NULL || pivot==(PERM *)NULL )\n     error(E_NULL,"bdLUsolve");\n   if ( bA->mat->n != b->dim || bA->mat->n != pivot->size)\n     error(E_SIZES,"bdLUsolve");\n \n   lb = bA->lb;\n   ub = bA->ub;\n   n = b->dim;\n   n1 = n-1;\n   bA_v = bA->mat->me;\n\n   x = v_resize(x,b->dim);\n   px_vec(pivot,b,x);\n\n   /* solve Lx = b; implicit diagonal = 1 \n      L is not permuted, therefore it must be permuted now\n    */\n   \n   px_inv(pivot,pivot);\n   for (j=0; j < n; j++) {\n      jmin = j+1;\n      c = x->ve[j];\n      maxj = max(0,j+lb-n1);\n      for (i=jmin,l=lb-1; l >= maxj; i++,l--) {\n	 if ( (pi = pivot->pe[i]) < jmin) \n	   pi = pivot->pe[i] = pivot->pe[pi];\n	 x->ve[pi] -= bA_v[l][j]*c;\n      }\n   }\n\n   /* solve Ux = b; explicit diagonal */\n\n   x->ve[n1] /= bA_v[lb][n1];\n   for (i=n-2; i >= 0; i--) {\n      c = x->ve[i];\n      for (j=min(n1,i+ub), l=lb+j-i; j > i; j--,l--)\n	c -= bA_v[l][j]*x->ve[j];\n      x->ve[i] = c/bA_v[lb][i];\n   }\n   \n   return (x);\n}\n\n/* LDLfactor -- L.D.L' factorisation of A in-situ;\n   A is a band matrix\n   it works using only lower bandwidth & main diagonal\n   so it is possible to set A->ub = 0\n */\n#ifndef ANSI_C\nBAND *bdLDLfactor(A)\nBAND *A;\n#else\nBAND *bdLDLfactor(BAND *A)\n#endif\n{\n   int i,j,k,n,n1,lb,ki,jk,ji,lbkm,lbkp;\n   Real **Av;\n   Real c, cc;\n\n   if ( ! A )\n     error(E_NULL,"bdLDLfactor");\n\n   if (A->lb == 0) return A;\n\n   lb = A->lb;\n   n = A->mat->n;\n   n1 = n-1;\n   Av = A->mat->me;\n   \n   for (k=0; k < n; k++) {    \n      lbkm = lb-k;\n      lbkp = lb+k;\n\n      /* matrix D */\n      c = Av[lb][k];\n      for (j=max(0,-lbkm), jk=lbkm+j; j < k; j++, jk++) {\n	 cc = Av[jk][j];\n	 c -= Av[lb][j]*cc*cc;\n      }\n      if (c == 0.0)\n	error(E_SING,"bdLDLfactor");\n      Av[lb][k] = c;\n\n      /* matrix L */\n      \n      for (i=min(n1,lbkp), ki=lbkp-i; i > k; i--,ki++) {\n	 c = Av[ki][k];\n	 for (j=max(0,i-lb), ji=lb+j-i, jk=lbkm+j; j < k;\n	      j++, ji++, jk++)\n	   c -= Av[lb][j]*Av[ji][j]*Av[jk][j];\n	 Av[ki][k] = c/Av[lb][k];\n      }\n   }\n   \n   return A;\n}\n\n/* solve A*x = b, where A is factorized by \n   Choleski LDL^T factorization */\n#ifndef ANSI_C\nVEC    *bdLDLsolve(A,b,x)\nBAND   *A;\nVEC    *b, *x;\n#else\nVEC    *bdLDLsolve(const BAND *A, const VEC *b, VEC *x)\n#endif\n{\n   int i,j,l,n,n1,lb,ilb;\n   Real **Av, *Avlb;\n   Real c;\n\n   if ( ! A || ! b )\n     error(E_NULL,"bdLDLsolve");\n   if ( A->mat->n != b->dim )\n     error(E_SIZES,"bdLDLsolve");\n\n   n = A->mat->n;\n   n1 = n-1;\n   x = v_resize(x,n);\n   lb = A->lb;\n   Av = A->mat->me;  \n   Avlb = Av[lb];\n   \n   /* solve L*y = b */\n   x->ve[0] = b->ve[0];\n   for (i=1; i < n; i++) {\n      ilb = i-lb;\n      c = b->ve[i];\n      for (j=max(0,ilb), l=j-ilb; j < i; j++,l++)\n	c -= Av[l][j]*x->ve[j];\n      x->ve[i] = c;\n   }\n\n   /* solve D*z = y */\n   for (i=0; i < n; i++) \n     x->ve[i] /= Avlb[i];\n\n   /* solve L^T*x = z */\n   for (i=n-2; i >= 0; i--) {\n      ilb = i+lb;\n      c = x->ve[i];\n      for (j=min(n1,ilb), l=ilb-j; j > i; j--,l++)\n	c -= Av[l][i]*x->ve[j];\n      x->ve[i] = c;\n   }\n\n   return x;\n}\n\n\n/* ******************************************************\n  This function is a contribution from Ruediger Franke.\n   His e-mail addres is: Ruediger.Franke@rz.tu-ilmenau.de\n   \n   ******************************************************\n*/\n\n/* bd_mv_mlt --\n *   computes out = A * x\n *   may not work in situ (x != out)\n */\n\nVEC *bd_mv_mlt(A, x, out)\nBAND *A;\nVEC *x, *out;\n{\n  int i, j, j_end, k;\n  int start_idx, end_idx;\n  int n, m, lb, ub;\n  Real **A_me;\n  Real *x_ve;\n  Real sum;\n\n  if (!A || !x)\n    error(E_NULL,"bd_mv_mlt");\n  if (x->dim != A->mat->n)\n    error(E_SIZES,"bd_mv_mlt");\n  if (!out || out->dim != A->mat->n)\n    out = v_resize(out, A->mat->n);\n  if (out == x)\n    error(E_INSITU,"bd_mv_mlt");\n\n  n = A->mat->n;\n  m = A->mat->m;\n  lb = A->lb;\n  ub = A->ub;\n  A_me = A->mat->me;\n  start_idx = lb;\n  end_idx = m + n-1 - ub;\n  for (i=0; i<n; i++, start_idx--, end_idx--) {\n    j = max(0, start_idx);\n    k = max(0, -start_idx);\n    j_end = min(m, end_idx);\n    x_ve = x->ve + k;\n    sum = 0.0;	     \n    for (; j < j_end; j++, k++)\n      sum += A_me[j][k] * *x_ve++;\n    out->ve[i] = sum;\n  }\n\n  return out;\n}\n\n\n\n