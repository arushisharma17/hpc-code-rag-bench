\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Memory port routines: MEM_COPY and MEM_ZERO\n*/\n\n/* For BSD 4.[23] environments: using bcopy() and bzero() */\n\n#include "machine.h"\n\n#ifndef MEM_COPY\nvoid	MEM_COPY(from,to,len)\nchar	*from, *to;\nint	len;\n{\n    int		i;\n\n    if ( from < to )\n    {\n	for ( i = 0; i < len; i++ )\n	    *to++ = *from++;\n    }\n    else\n    {\n	from += len;	to += len;\n	for ( i = 0; i < len; i++ )\n	    *(--to) = *(--from);\n    }\n}\n#endif\n\n#ifndef MEM_ZERO\nvoid	MEM_ZERO(ptr,len)\nchar	*ptr;\nint	len;\n{\n    int		i;\n\n    for ( i = 0; i < len; i++ )\n	*(ptr++) = '\0';\n}\n#endif\n\n/*\n	This file contains versions of something approximating the well-known\n	BLAS routines in C, suitable for Meschach (hence the `m').\n	These are "vanilla" implementations, at least with some consideration\n	of the effects of caching and paging, and maybe some loop unrolling\n	for register-rich machines\n*/\n\n/*\n	Organisation of matrices: it is assumed that matrices are represented\n	by Real **'s. To keep flexibility, there is also an "initial\n	column" parameter j0, so that the actual elements used are\n		A[0][j0],   A[0][j0+1],   ..., A[0][j0+n-1]\n		A[1][j0],   A[1][j0+1],   ..., A[1][j0+n-1]\n		   ..         ..          ...      ..\n		A[m-1][j0], A[m-1][j0+1], ..., A[m-1][j0+n-1]\n*/\n\nstatic char	rcsid[] = "$Id: extras.c,v 1.4 1995/06/08 15:13:15 des Exp $";\n\n#include	<math.h>\n\n#define	REGISTER_RICH	1\n\n/* mblar-1 routines */\n\n/* Mscale -- sets x <- alpha.x */\nvoid	Mscale(len,alpha,x)\nint	len;\ndouble	alpha;\nReal	*x;\n{\n    register int	i;\n\n    for ( i = 0; i < len; i++ )\n	x[i] *= alpha;\n}\n\n/* Mswap -- swaps x and y */\nvoid	Mswap(len,x,y)\nint	len;\nReal	*x, *y;\n{\n    register int	i;\n    register Real	tmp;\n\n    for ( i = 0; i < len; i++ )\n    {\n	tmp = x[i];\n	x[i] = y[i];\n	y[i] = tmp;\n    }\n}\n\n/* Mcopy -- copies x to y */\nvoid	Mcopy(len,x,y)\nint	len;\nReal	*x, *y;\n{\n    register int	i;\n\n    for ( i = 0; i < len; i++ )\n	y[i] = x[i];\n}\n\n/* Maxpy -- y <- y + alpha.x */\nvoid	Maxpy(len,alpha,x,y)\nint	len;\ndouble	alpha;\nReal	*x, *y;\n{\n    register int	i, len4;\n\n    /****************************************\n    for ( i = 0; i < len; i++ )\n	y[i] += alpha*x[i];\n    ****************************************/\n\n#ifdef REGISTER_RICH\n    len4 = len / 4;\n    len  = len % 4;\n    for ( i = 0; i < len4; i++ )\n    {\n	y[4*i]   += alpha*x[4*i];\n	y[4*i+1] += alpha*x[4*i+1];\n	y[4*i+2] += alpha*x[4*i+2];\n	y[4*i+3] += alpha*x[4*i+3];\n    }\n    x += 4*len4;	y += 4*len4;\n#endif\n    for ( i = 0; i < len; i++ )\n	y[i] += alpha*x[i];\n}\n\n/* Mdot -- returns x'.y */\ndouble	Mdot(len,x,y)\nint	len;\nReal	*x, *y;\n{\n    register int	i, len4;\n    register Real	sum;\n\n#ifndef REGISTER_RICH\n    sum = 0.0;\n#endif\n\n#ifdef REGISTER_RICH\n    register Real	sum0, sum1, sum2, sum3;\n    \n    sum0 = sum1 = sum2 = sum3 = 0.0;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    \n    for ( i = 0; i < len4; i++ )\n    {\n	sum0 += x[4*i  ]*y[4*i  ];\n	sum1 += x[4*i+1]*y[4*i+1];\n	sum2 += x[4*i+2]*y[4*i+2];\n	sum3 += x[4*i+3]*y[4*i+3];\n    }\n    sum = sum0 + sum1 + sum2 + sum3;\n    x += 4*len4;	y += 4*len4;\n#endif\n\n    for ( i = 0; i < len; i++ )\n	sum += x[i]*y[i];\n\n    return sum;\n}\n\n#ifndef ABS\n#define	ABS(x)	((x) >= 0 ? (x) : -(x))\n#endif\n\n/* Mnorminf -- returns ||x||_inf */\ndouble	Mnorminf(len,x)\nint	len;\nReal	*x;\n{\n    register int	i;\n    register Real	tmp, max_val;\n\n    max_val = 0.0;\n    for ( i = 0; i < len; i++ )\n    {\n	tmp = ABS(x[i]);\n	if ( max_val < tmp )\n	    max_val = tmp;\n    }\n\n    return max_val;\n}\n\n/* Mnorm1 -- returns ||x||_1 */\ndouble	Mnorm1(len,x)\nint	len;\nReal	*x;\n{\n    register int	i;\n    register Real	sum;\n\n    sum = 0.0;\n    for ( i = 0; i < len; i++ )\n	sum += ABS(x[i]);\n\n    return sum;\n}\n\n/* Mnorm2 -- returns ||x||_2 */\ndouble	Mnorm2(len,x)\nint	len;\nReal	*x;\n{\n    register int	i;\n    register Real	norm, invnorm, sum, tmp;\n\n    norm = Mnorminf(len,x);\n    if ( norm == 0.0 )\n	return 0.0;\n    invnorm = 1.0/norm;\n    sum = 0.0;\n    for ( i = 0; i < len; i++ )\n    {\n	tmp = x[i]*invnorm;\n	sum += tmp*tmp;\n    }\n\n    return sum/invnorm;\n}\n\n/* mblar-2 routines */\n\n/* Mmv -- y <- alpha.A.x + beta.y */\nvoid	Mmv(m,n,alpha,A,j0,x,beta,y)\nint	m, n, j0;\ndouble	alpha, beta;\nReal	**A, *x, *y;\n{\n    register int	i, j, m4, n4;\n    register Real	sum0, sum1, sum2, sum3, tmp0, tmp1, tmp2, tmp3;\n    register Real	*dp0, *dp1, *dp2, *dp3;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	y[i] += alpha*Mdot(n,&(A[i][j0]),x);\n    ****************************************/\n\n    m4 = n4 = 0;\n\n#ifdef REGISTER_RICH\n    m4 = m / 4;\n    m  = m % 4;\n    n4 = n / 4;\n    n  = n % 4;\n\n    for ( i = 0; i < m4; i++ )\n    {\n	sum0 = sum1 = sum2 = sum3 = 0.0;\n	dp0 = &(A[4*i  ][j0]);\n	dp1 = &(A[4*i+1][j0]);\n	dp2 = &(A[4*i+2][j0]);\n	dp3 = &(A[4*i+3][j0]);\n\n	for ( j = 0; j < n4; j++ )\n	{\n	    tmp0 = x[4*j  ];\n	    tmp1 = x[4*j+1];\n	    tmp2 = x[4*j+2];\n	    tmp3 = x[4*j+3];\n	    sum0 = sum0 + dp0[j]*tmp0 + dp0[j+1]*tmp1 +\n		dp0[j+2]*tmp2 + dp0[j+3]*tmp3;\n	    sum1 = sum1 + dp1[j]*tmp0 + dp1[j+1]*tmp1 +\n		dp1[j+2]*tmp2 + dp1[j+3]*tmp3;\n	    sum2 = sum2 + dp2[j]*tmp0 + dp2[j+1]*tmp1 +\n		dp2[j+2]*tmp2 + dp2[j+3]*tmp3;\n	    sum3 = sum3 + dp3[j]*tmp0 + dp3[j+1]*tmp2 +\n		dp3[j+2]*tmp2 + dp3[j+3]*tmp3;\n	}\n	for ( j = 0; j < n; j++ )\n	{\n	    sum0 += dp0[4*n4+j]*x[4*n4+j];\n	    sum1 += dp1[4*n4+j]*x[4*n4+j];\n	    sum2 += dp2[4*n4+j]*x[4*n4+j];\n	    sum3 += dp3[4*n4+j]*x[4*n4+j];\n	}\n	y[4*i  ] = beta*y[4*i  ] + alpha*sum0;\n	y[4*i+1] = beta*y[4*i+1] + alpha*sum1;\n	y[4*i+2] = beta*y[4*i+2] + alpha*sum2;\n	y[4*i+3] = beta*y[4*i+3] + alpha*sum3;\n    }\n#endif\n\n    for ( i = 0; i < m; i++ )\n	y[4*m4+i] = beta*y[i] + alpha*Mdot(4*n4+n,&(A[4*m4+i][j0]),x);\n}\n\n/* Mvm -- y <- alpha.A^T.x + beta.y */\nvoid	Mvm(m,n,alpha,A,j0,x,beta,y)\nint	m, n, j0;\ndouble	alpha, beta;\nReal	**A, *x, *y;\n{\n    register int	i, j, m4, n2;\n    register Real	*Aref;\n    register Real 	tmp;\n\n#ifdef REGISTER_RICH\n    register Real	*Aref0, *Aref1;\n    register Real	tmp0, tmp1;\n    register Real	yval0, yval1, yval2, yval3;\n#endif\n\n    if ( beta != 1.0 )\n	Mscale(m,beta,y);\n    /****************************************\n    for ( j = 0; j < n; j++ )\n	Maxpy(m,alpha*x[j],&(A[j][j0]),y);\n    ****************************************/\n    m4 = n2 = 0;\n\n    m4 = m / 4;\n    m  = m % 4;\n#ifdef REGISTER_RICH\n    n2 = n / 2;\n    n  = n % 2;\n\n    for ( j = 0; j < n2; j++ )\n    {\n	tmp0 = alpha*x[2*j];\n	tmp1 = alpha*x[2*j+1];\n	Aref0 = &(A[2*j  ][j0]);\n	Aref1 = &(A[2*j+1][j0]);\n	for ( i = 0; i < m4; i++ )\n	{\n	    yval0 = y[4*i  ] + tmp0*Aref0[4*i  ];\n	    yval1 = y[4*i+1] + tmp0*Aref0[4*i+1];\n	    yval2 = y[4*i+2] + tmp0*Aref0[4*i+2];\n	    yval3 = y[4*i+3] + tmp0*Aref0[4*i+3];\n	    y[4*i  ] = yval0 + tmp1*Aref1[4*i  ];\n	    y[4*i+1] = yval1 + tmp1*Aref1[4*i+1];\n	    y[4*i+2] = yval2 + tmp1*Aref1[4*i+2];\n	    y[4*i+3] = yval3 + tmp1*Aref1[4*i+3];\n	}\n	y += 4*m4;	Aref0 += 4*m4;	Aref1 += 4*m4;\n	for ( i = 0; i < m; i++ )\n	    y[i] += tmp0*Aref0[i] + tmp1*Aref1[i];\n    }\n#endif\n\n    for ( j = 0; j < n; j++ )\n    {\n	tmp = alpha*x[2*n2+j];\n	Aref = &(A[2*n2+j][j0]);\n	for ( i = 0; i < m4; i++ )\n	{\n	    y[4*i  ] += tmp*Aref[4*i  ];\n	    y[4*i+1] += tmp*Aref[4*i+1];\n	    y[4*i+2] += tmp*Aref[4*i+2];\n	    y[4*i+3] += tmp*Aref[4*i+3];\n	}\n	y += 4*m4;	Aref += 4*m4;\n	for ( i = 0; i < m; i++ )\n	    y[i] += tmp*Aref[i];\n    }\n}\n\n/* Mupdate -- A <- A + alpha.x.y^T */\nvoid	Mupdate(m,n,alpha,x,y,A,j0)\nint	m, n, j0;\ndouble	alpha;\nReal	**A, *x, *y;\n{\n    register int	i, j, n4;\n    register Real	*Aref;\n    register Real 	tmp;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	Maxpy(n,alpha*x[i],y,&(A[i][j0]));\n    ****************************************/\n\n    n4 = n / 4;\n    n  = n % 4;\n    for ( i = 0; i < m; i++ )\n    {\n	tmp = alpha*x[i];\n	Aref = &(A[i][j0]);\n	for ( j = 0; j < n4; j++ )\n	{\n	    Aref[4*j  ] += tmp*y[4*j  ];\n	    Aref[4*j+1] += tmp*y[4*j+1];\n	    Aref[4*j+2] += tmp*y[4*j+2];\n	    Aref[4*j+3] += tmp*y[4*j+3];\n	}\n	Aref += 4*n4;	y += 4*n4;\n	for ( j = 0; j < n; j++ )\n	    Aref[j] += tmp*y[j];\n    }\n}\n\n/* mblar-3 routines */\n\n/* Mmm -- C <- C + alpha.A.B */\nvoid	Mmm(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n    /* register Real	tmp, sum; */\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	for ( k = 0; k < p; k++ )\n	    Maxpy(n,alpha*A[i][Aj0+k],&(B[k][Bj0]),&(C[i][Cj0]));\n    ****************************************/\n    for ( i = 0; i < m; i++ )\n	Mvm(p,n,alpha,B,Bj0,&(A[i][Aj0]),1.0,&(C[i][Cj0]));\n}\n\n/* Mmtrm -- C <- C + alpha.A^T.B */\nvoid	Mmtrm(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	for ( k = 0; k < p; k++ )\n	    Maxpy(n,alpha*A[k][Aj0+i],&(B[k][Bj0]),&(C[i][Cj0]));\n    ****************************************/\n    for ( k = 0; k < p; k++ )\n	Mupdate(m,n,alpha,&(A[k][Aj0]),&(B[k][Bj0]),C,Cj0);\n}\n\n/* Mmmtr -- C <- C + alpha.A.B^T */\nvoid	Mmmtr(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	for ( j = 0; j < n; j++ )\n	    C[i][Cj0+j] += alpha*Mdot(p,&(A[i][Aj0]),&(B[j][Bj0]));\n    ****************************************/\n    for ( i = 0; i < m; i++ )\n	Mmv(n,p,alpha,B,Bj0,&(A[i][Aj0]),1.0,&(C[i][Cj0]));\n}\n\n/* Mmtrmtr -- C <- C + alpha.A^T.B^T */\nvoid	Mmtrmtr(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n\n    for ( i = 0; i < m; i++ )\n	for ( j = 0; j < n; j++ )\n	    for ( k = 0; k < p; k++ )\n		C[i][Cj0+j] += A[i][Aj0+k]*B[k][Bj0+j];\n}\n\n