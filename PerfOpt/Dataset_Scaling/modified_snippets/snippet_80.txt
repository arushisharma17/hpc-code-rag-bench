\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  This file contains the routines needed to perform QR factorisation\n  of matrices, as well as Householder transformations.\n  The internal "factored form" of a matrix A is not quite standard.\n  The diagonal of A is replaced by the diagonal of R -- not by the 1st non-zero\n  entries of the Householder vectors. The 1st non-zero entries are held in\n  the diag parameter of QRfactor(). The reason for this non-standard\n  representation is that it enables direct use of the Usolve() function\n  rather than requiring that  a seperate function be written just for this case.\n  See, e.g., QRsolve() below for more details.\n  \n*/\n\n\nstatic	char	rcsid[] = "$Id: qrfactor.c,v 1.5 1994/01/13 05:35:07 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "matrix2.h"\n\n\n\n\n\n#define		sign(x)	((x) > 0.0 ? 1 : ((x) < 0.0 ? -1 : 0 ))\n\nextern	VEC	*Usolve();	/* See matrix2.h */\n\n/* Note: The usual representation of a Householder transformation is taken\n   to be:\n   P = I - beta.u.uT\n   where beta = 2/(uT.u) and u is called the Householder vector\n   */\n\n/* QRfactor -- forms the QR factorisation of A -- factorisation stored in\n   compact form as described above ( not quite standard format ) */\n#ifndef ANSI_C\nMAT	*QRfactor(A,diag)\nMAT	*A;\nVEC	*diag;\n#else\nMAT	*QRfactor(MAT *A, VEC *diag)\n#endif\n{\n    unsigned int	k,limit;\n    Real	beta;\n    STATIC	VEC	*hh=VNULL, *w=VNULL;\n    \n    if ( ! A || ! diag )\n	error(E_NULL,"QRfactor");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit )\n	error(E_SIZES,"QRfactor");\n    \n    hh = v_resize(hh,A->m);\n    w  = v_resize(w, A->n);\n    MEM_STAT_REG(hh,TYPE_VEC);\n    MEM_STAT_REG(w, TYPE_VEC);\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* get H/holder vector for the k-th column */\n	get_col(A,k,hh);\n	/* hhvec(hh,k,&beta->ve[k],hh,&A->me[k][k]); */\n	hhvec(hh,k,&beta,hh,&A->me[k][k]);\n	diag->ve[k] = hh->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	/* hhtrcols(A,k,k+1,hh,beta->ve[k]); */\n	_hhtrcols(A,k,k+1,hh,beta,w);\n    }\n\n#ifdef	THREADSAFE\n    V_FREE(hh);	V_FREE(w);\n#endif\n\n    return (A);\n}\n\n/* QRCPfactor -- forms the QR factorisation of A with column pivoting\n   -- factorisation stored in compact form as described above\n   ( not quite standard format )				*/\n#ifndef ANSI_C\nMAT	*QRCPfactor(A,diag,px)\nMAT	*A;\nVEC	*diag;\nPERM	*px;\n#else\nMAT	*QRCPfactor(MAT *A, VEC *diag, PERM *px)\n#endif\n{\n    unsigned int	i, i_max, j, k, limit;\n    STATIC	VEC	*gamma=VNULL, *tmp1=VNULL, *tmp2=VNULL, *w=VNULL;\n    Real	beta, maxgamma, sum, tmp;\n    \n    if ( ! A || ! diag || ! px )\n	error(E_NULL,"QRCPfactor");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit || px->size != A->n )\n	error(E_SIZES,"QRCPfactor");\n    \n    tmp1 = v_resize(tmp1,A->m);\n    tmp2 = v_resize(tmp2,A->m);\n    gamma = v_resize(gamma,A->n);\n    w    = v_resize(w,   A->n);\n    MEM_STAT_REG(tmp1,TYPE_VEC);\n    MEM_STAT_REG(tmp2,TYPE_VEC);\n    MEM_STAT_REG(gamma,TYPE_VEC);\n    MEM_STAT_REG(w,   TYPE_VEC);\n    \n    /* initialise gamma and px */\n    for ( j=0; j<A->n; j++ )\n    {\n	px->pe[j] = j;\n	sum = 0.0;\n	for ( i=0; i<A->m; i++ )\n	    sum += square(A->me[i][j]);\n	gamma->ve[j] = sum;\n    }\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* find "best" column to use */\n	i_max = k;	maxgamma = gamma->ve[k];\n	for ( i=k+1; i<A->n; i++ )\n	    /* Loop invariant:maxgamma=gamma[i_max]\n	       >=gamma[l];l=k,...,i-1 */\n	    if ( gamma->ve[i] > maxgamma )\n	    {	maxgamma = gamma->ve[i]; i_max = i;	}\n	\n	/* swap columns if necessary */\n	if ( i_max != k )\n	{\n	    /* swap gamma values */\n	    tmp = gamma->ve[k];\n	    gamma->ve[k] = gamma->ve[i_max];\n	    gamma->ve[i_max] = tmp;\n	    \n	    /* update column permutation */\n	    px_transp(px,k,i_max);\n	    \n	    /* swap columns of A */\n	    for ( i=0; i<A->m; i++ )\n	    {\n		tmp = A->me[i][k];\n		A->me[i][k] = A->me[i][i_max];\n		A->me[i][i_max] = tmp;\n	    }\n	}\n	\n	/* get H/holder vector for the k-th column */\n	get_col(A,k,tmp1);\n	/* hhvec(tmp1,k,&beta->ve[k],tmp1,&A->me[k][k]); */\n	hhvec(tmp1,k,&beta,tmp1,&A->me[k][k]);\n	diag->ve[k] = tmp1->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	/* hhtrcols(A,k,k+1,tmp1,beta->ve[k]); */\n	_hhtrcols(A,k,k+1,tmp1,beta,w);\n	\n	/* update gamma values */\n	for ( j=k+1; j<A->n; j++ )\n	    gamma->ve[j] -= square(A->me[k][j]);\n    }\n\n#ifdef	THREADSAFE\n    V_FREE(gamma);	V_FREE(tmp1);	V_FREE(tmp2);	V_FREE(w);\n#endif\n\n    return (A);\n}\n\n/* Qsolve -- solves Qx = b, Q is an orthogonal matrix stored in compact\n   form a la QRfactor() -- may be in-situ */\n#ifndef ANSI_C\nVEC	*_Qsolve(QR,diag,b,x,tmp)\nMAT	*QR;\nVEC	*diag, *b, *x, *tmp;\n#else\nVEC	*_Qsolve(const MAT *QR, const VEC *diag, const VEC *b, \n		 VEC *x, VEC *tmp)\n#endif\n{\n    unsigned int	dynamic;\n    int		k, limit;\n    Real	beta, r_ii, tmp_val;\n    \n    limit = min(QR->m,QR->n);\n    dynamic = FALSE;\n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,"_Qsolve");\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,"_Qsolve");\n    x = v_resize(x,QR->m);\n    if ( tmp == VNULL )\n	dynamic = TRUE;\n    tmp = v_resize(tmp,QR->m);\n    \n    /* apply H/holder transforms in normal order */\n    x = v_copy(b,x);\n    for ( k = 0 ; k < limit ; k++ )\n    {\n	get_col(QR,k,tmp);\n	r_ii = fabs(tmp->ve[k]);\n	tmp->ve[k] = diag->ve[k];\n	tmp_val = (r_ii*fabs(diag->ve[k]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	/* hhtrvec(tmp,beta->ve[k],k,x,x); */\n	hhtrvec(tmp,beta,k,x,x);\n    }\n    \n    if ( dynamic )\n	V_FREE(tmp);\n    \n    return (x);\n}\n\n/* makeQ -- constructs orthogonal matrix from Householder vectors stored in\n   compact QR form */\n#ifndef ANSI_C\nMAT	*makeQ(QR,diag,Qout)\nMAT	*QR,*Qout;\nVEC	*diag;\n#else\nMAT	*makeQ(const MAT *QR,const VEC *diag, MAT *Qout)\n#endif\n{\n    STATIC	VEC	*tmp1=VNULL,*tmp2=VNULL;\n    unsigned int	i, limit;\n    Real	beta, r_ii, tmp_val;\n    int	j;\n    \n    limit = min(QR->m,QR->n);\n    if ( ! QR || ! diag )\n	error(E_NULL,"makeQ");\n    if ( diag->dim < limit )\n	error(E_SIZES,"makeQ");\n    if ( Qout==(MAT *)NULL || Qout->m < QR->m || Qout->n < QR->m )\n	Qout = m_get(QR->m,QR->m);\n    \n    tmp1 = v_resize(tmp1,QR->m);	/* contains basis vec & columns of Q */\n    tmp2 = v_resize(tmp2,QR->m);	/* contains H/holder vectors */\n    MEM_STAT_REG(tmp1,TYPE_VEC);\n    MEM_STAT_REG(tmp2,TYPE_VEC);\n    \n    for ( i=0; i<QR->m ; i++ )\n    {	/* get i-th column of Q */\n	/* set up tmp1 as i-th basis vector */\n	for ( j=0; j<QR->m ; j++ )\n	    tmp1->ve[j] = 0.0;\n	tmp1->ve[i] = 1.0;\n	\n	/* apply H/h transforms in reverse order */\n	for ( j=limit-1; j>=0; j-- )\n	{\n	    get_col(QR,j,tmp2);\n	    r_ii = fabs(tmp2->ve[j]);\n	    tmp2->ve[j] = diag->ve[j];\n	    tmp_val = (r_ii*fabs(diag->ve[j]));\n	    beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	    /* hhtrvec(tmp2,beta->ve[j],j,tmp1,tmp1); */\n	    hhtrvec(tmp2,beta,j,tmp1,tmp1);\n	}\n	\n	/* insert into Q */\n	set_col(Qout,i,tmp1);\n    }\n\n#ifdef	THREADSAFE\n    V_FREE(tmp1);	V_FREE(tmp2);\n#endif\n\n    return (Qout);\n}\n\n/* makeR -- constructs upper triangular matrix from QR (compact form)\n   -- may be in-situ (all it does is zero the lower 1/2) */\n#ifndef ANSI_C\nMAT	*makeR(QR,Rout)\nMAT	*QR,*Rout;\n#else\nMAT	*makeR(const MAT *QR, MAT *Rout)\n#endif\n{\n    unsigned int	i,j;\n    \n    if ( QR==MNULL )\n	error(E_NULL,"makeR");\n    Rout = m_copy(QR,Rout);\n    \n    for ( i=1; i<QR->m; i++ )\n	for ( j=0; j<QR->n && j<i; j++ )\n	    Rout->me[i][j] = 0.0;\n    \n    return (Rout);\n}\n\n/* QRsolve -- solves the system Q.R.x=b where Q & R are stored in compact form\n   -- returns x, which is created if necessary */\n#ifndef ANSI_C\nVEC	*QRsolve(QR,diag,b,x)\nMAT	*QR;\nVEC	*diag /* , *beta */ , *b, *x;\n#else\nVEC	*QRsolve(const MAT *QR, const VEC *diag, const VEC *b, VEC *x)\n#endif\n{\n    int	limit;\n    STATIC	VEC	*tmp = VNULL;\n    \n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,"QRsolve");\n    limit = min(QR->m,QR->n);\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,"QRsolve");\n    tmp = v_resize(tmp,limit);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n\n    x = v_resize(x,QR->n);\n    _Qsolve(QR,diag,b,x,tmp);\n    x = Usolve(QR,x,x,0.0);\n    v_resize(x,QR->n);\n\n#ifdef	THREADSAFE\n    V_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* QRCPsolve -- solves A.x = b where A is factored by QRCPfactor()\n   -- assumes that A is in the compact factored form */\n#ifndef ANSI_C\nVEC	*QRCPsolve(QR,diag,pivot,b,x)\nMAT	*QR;\nVEC	*diag;\nPERM	*pivot;\nVEC	*b, *x;\n#else\nVEC	*QRCPsolve(const MAT *QR, const VEC *diag, PERM *pivot,\n		   const VEC *b, VEC *x)\n#endif\n{\n    STATIC	VEC	*tmp=VNULL;\n    \n    if ( ! QR || ! diag || ! pivot || ! b )\n	error(E_NULL,"QRCPsolve");\n    if ( (QR->m > diag->dim &&QR->n > diag->dim) || QR->n != pivot->size )\n	error(E_SIZES,"QRCPsolve");\n    \n    tmp = QRsolve(QR,diag,b,tmp);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n    x = pxinv_vec(pivot,tmp,x);\n\n#ifdef	THREADSAFE\n    V_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* Umlt -- compute out = upper_triang(U).x\n	-- may be in situ */\n#ifndef ANSI_C\nstatic	VEC	*Umlt(U,x,out)\nMAT	*U;\nVEC	*x, *out;\n#else\nstatic	VEC	*Umlt(const MAT *U, const VEC *x, VEC *out)\n#endif\n{\n    int		i, limit;\n\n    if ( U == MNULL || x == VNULL )\n	error(E_NULL,"Umlt");\n    limit = min(U->m,U->n);\n    if ( limit != x->dim )\n	error(E_SIZES,"Umlt");\n    if ( out == VNULL || out->dim < limit )\n	out = v_resize(out,limit);\n\n    for ( i = 0; i < limit; i++ )\n	out->ve[i] = __ip__(&(x->ve[i]),&(U->me[i][i]),limit - i);\n    return out;\n}\n\n/* UTmlt -- returns out = upper_triang(U)^T.x */\n#ifndef ANSI_C\nstatic	VEC	*UTmlt(U,x,out)\nMAT	*U;\nVEC	*x, *out;\n#else\nstatic	VEC	*UTmlt(const MAT *U, const VEC *x, VEC *out)\n#endif\n{\n    Real	sum;\n    int		i, j, limit;\n\n    if ( U == MNULL || x == VNULL )\n	error(E_NULL,"UTmlt");\n    limit = min(U->m,U->n);\n    if ( out == VNULL || out->dim < limit )\n	out = v_resize(out,limit);\n\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	sum = 0.0;\n	for ( j = 0; j <= i; j++ )\n	    sum += U->me[j][i]*x->ve[j];\n	out->ve[i] = sum;\n    }\n    return out;\n}\n\n/* QRTsolve -- solve A^T.sc = c where the QR factors of A are stored in\n	compact form\n	-- returns sc\n	-- original due to Mike Osborne modified Wed 09th Dec 1992 */\n#ifndef ANSI_C\nVEC *QRTsolve(A,diag,c,sc)\nMAT *A;\nVEC *diag, *c, *sc;\n#else\nVEC *QRTsolve(const MAT *A, const VEC *diag, const VEC *c, VEC *sc)\n#endif\n{\n    int		i, j, k, n, p;\n    Real	beta, r_ii, s, tmp_val;\n\n    if ( ! A || ! diag || ! c )\n	error(E_NULL,"QRTsolve");\n    if ( diag->dim < min(A->m,A->n) )\n	error(E_SIZES,"QRTsolve");\n    sc = v_resize(sc,A->m);\n    n = sc->dim;\n    p = c->dim;\n    if ( n == p )\n	k = p-2;\n    else\n	k = p-1;\n    v_zero(sc);\n    sc->ve[0] = c->ve[0]/A->me[0][0];\n    if ( n ==  1)\n	return sc;\n    if ( p > 1)\n    {\n	for ( i = 1; i < p; i++ )\n	{\n	    s = 0.0;\n	    for ( j = 0; j < i; j++ )\n		s += A->me[j][i]*sc->ve[j];\n	    if ( A->me[i][i] == 0.0 )\n		error(E_SING,"QRTsolve");\n	    sc->ve[i]=(c->ve[i]-s)/A->me[i][i];\n	}\n    }\n    for (i = k; i >= 0; i--)\n    {\n	s = diag->ve[i]*sc->ve[i];\n	for ( j = i+1; j < n; j++ )\n	    s += A->me[j][i]*sc->ve[j];\n	r_ii = fabs(A->me[i][i]);\n	tmp_val = (r_ii*fabs(diag->ve[i]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	tmp_val = beta*s;\n	sc->ve[i] -= tmp_val*diag->ve[i];\n	for ( j = i+1; j < n; j++ )\n	    sc->ve[j] -= tmp_val*A->me[j][i];\n    }\n\n    return sc;\n}\n\n/* QRcondest -- returns an estimate of the 2-norm condition number of the\n		matrix factorised by QRfactor() or QRCPfactor()\n	-- note that as Q does not affect the 2-norm condition number,\n		it is not necessary to pass the diag, beta (or pivot) vectors\n	-- generates a lower bound on the true condition number\n	-- if the matrix is exactly singular, HUGE_VAL is returned\n	-- note that QRcondest() is likely to be more reliable for\n		matrices factored using QRCPfactor() */\n#ifndef ANSI_C\ndouble	QRcondest(QR)\nMAT	*QR;\n#else\ndouble	QRcondest(const MAT *QR)\n#endif\n{\n    STATIC	VEC	*y=VNULL;\n    Real	norm1, norm2, sum, tmp1, tmp2;\n    int		i, j, limit;\n\n    if ( QR == MNULL )\n	error(E_NULL,"QRcondest");\n\n    limit = min(QR->m,QR->n);\n    for ( i = 0; i < limit; i++ )\n	if ( QR->me[i][i] == 0.0 )\n	    return HUGE_VAL;\n\n    y = v_resize(y,limit);\n    MEM_STAT_REG(y,TYPE_VEC);\n    /* use the trick for getting a unit vector y with ||R.y||_inf small\n       from the LU condition estimator */\n    for ( i = 0; i < limit; i++ )\n    {\n	sum = 0.0;\n	for ( j = 0; j < i; j++ )\n	    sum -= QR->me[j][i]*y->ve[j];\n	sum -= (sum < 0.0) ? 1.0 : -1.0;\n	y->ve[i] = sum / QR->me[i][i];\n    }\n    UTmlt(QR,y,y);\n\n    /* now apply inverse power method to R^T.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = v_norm2(y);\n	sv_mlt(1/tmp1,y,y);\n	UTsolve(QR,y,y,0.0);\n	tmp2 = v_norm2(y);\n	sv_mlt(1/v_norm2(y),y,y);\n	Usolve(QR,y,y,0.0);\n    }\n    /* now compute approximation for ||R^{-1}||_2 */\n    norm1 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* now use complementary approach to compute approximation to ||R||_2 */\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	sum = 0.0;\n	for ( j = i+1; j < limit; j++ )\n	    sum += QR->me[i][j]*y->ve[j];\n	y->ve[i] = (sum >= 0.0) ? 1.0 : -1.0;\n	y->ve[i] = (QR->me[i][i] >= 0.0) ? y->ve[i] : - y->ve[i];\n    }\n\n    /* now apply power method to R^T.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = v_norm2(y);\n	sv_mlt(1/tmp1,y,y);\n	Umlt(QR,y,y);\n	tmp2 = v_norm2(y);\n	sv_mlt(1/tmp2,y,y);\n	UTmlt(QR,y,y);\n    }\n    norm2 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* printf("QRcondest: norm1 = %g, norm2 = %g\n",norm1,norm2); */\n\n#ifdef THREADSAFE\n    V_FREE(y);\n#endif\n\n    return norm1*norm2;\n}\n