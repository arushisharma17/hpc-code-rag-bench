\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/* tutorial.c 10/12/1993 */\n\n/* routines from Chapter 1 of Meschach */\n\nstatic char rcsid[] = "$Id: tutorial.c,v 1.3 1994/01/16 22:53:09 des Exp $";\n\n#include <math.h>\n#include "matrix.h"\n\n/* rk4 -- 4th order Runge--Kutta method */\ndouble rk4(f,t,x,h)\ndouble t, h;\nVEC    *(*f)(), *x;\n{\n   static VEC *v1=VNULL, *v2=VNULL, *v3=VNULL, *v4=VNULL;\n   static VEC *temp=VNULL;\n   \n   /* do not work with NULL initial vector */\n   if ( x == VNULL )\n     error(E_NULL,"rk4");\n\n   /* ensure that v1, ..., v4, temp are of the correct size */\n   v1   = v_resize(v1,x->dim);\n   v2   = v_resize(v2,x->dim);\n   v3   = v_resize(v3,x->dim);\n   v4   = v_resize(v4,x->dim);\n   temp = v_resize(temp,x->dim);\n\n   /* register workspace variables */\n   MEM_STAT_REG(v1,TYPE_VEC);\n   MEM_STAT_REG(v2,TYPE_VEC);\n   MEM_STAT_REG(v3,TYPE_VEC);\n   MEM_STAT_REG(v4,TYPE_VEC);\n   MEM_STAT_REG(temp,TYPE_VEC);\n   /* end of memory allocation */\n\n   (*f)(t,x,v1); /* most compilers allow: "f(t,x,v1);" */\n   v_mltadd(x,v1,0.5*h,temp);    /* temp = x+.5*h*v1 */\n   (*f)(t+0.5*h,temp,v2);\n   v_mltadd(x,v2,0.5*h,temp);    /* temp = x+.5*h*v2 */\n   (*f)(t+0.5*h,temp,v3);\n   v_mltadd(x,v3,h,temp);        /* temp = x+h*v3 */\n   (*f)(t+h,temp,v4);\n   \n   /* now add: v1+2*v2+2*v3+v4 */\n   v_copy(v1,temp);              /* temp = v1 */\n   v_mltadd(temp,v2,2.0,temp);   /* temp = v1+2*v2 */\n   v_mltadd(temp,v3,2.0,temp);   /* temp = v1+2*v2+2*v3 */\n   v_add(temp,v4,temp);          /* temp = v1+2*v2+2*v3+v4 */\n   \n   /* adjust x */\n   v_mltadd(x,temp,h/6.0,x);     /* x = x+(h/6)*temp */\n   \n   return t+h;                   /* return the new time */\n}\n\n\n\n/* rk4 -- 4th order Runge-Kutta method */\n/* another variant */\ndouble rk4_var(f,t,x,h)\ndouble t, h;\nVEC    *(*f)(), *x;\n{\n   static VEC *v1, *v2, *v3, *v4, *temp;\n   \n   /* do not work with NULL initial vector */\n   if ( x == VNULL )        error(E_NULL,"rk4");\n   \n   /* ensure that v1, ..., v4, temp are of the correct size */\n   v_resize_vars(x->dim, &v1, &v2, &v3, &v4, &temp, NULL);\n\n   /* register workspace variables */\n   mem_stat_reg_vars(0, TYPE_VEC, __FILE__, __LINE__,\n		     &v1, &v2, &v3, &v4, &temp, NULL);\n   /* end of memory allocation */\n\n   (*f)(t,x,v1);             v_mltadd(x,v1,0.5*h,temp);\n   (*f)(t+0.5*h,temp,v2);    v_mltadd(x,v2,0.5*h,temp);\n   (*f)(t+0.5*h,temp,v3);    v_mltadd(x,v3,h,temp);\n   (*f)(t+h,temp,v4);\n   \n   /* now add: temp = v1+2*v2+2*v3+v4 */\n   v_linlist(temp, v1, 1.0, v2, 2.0, v3, 2.0, v4, 1.0, VNULL);\n   /* adjust x */\n   v_mltadd(x,temp,h/6.0,x);     /* x = x+(h/6)*temp */\n   \n   return t+h;                   /* return the new time */\n}\n\n\n/* f -- right-hand side of ODE solver */\nVEC	*f(t,x,out)\nVEC	*x, *out;\ndouble	t;\n{\n   if ( x == VNULL || out == VNULL )\n     error(E_NULL,"f");\n   if ( x->dim != 2 || out->dim != 2 )\n     error(E_SIZES,"f");\n   \n   out->ve[0] = x->ve[1];\n   out->ve[1] = - x->ve[0];\n   \n   return out;\n}\n\n\nvoid tutor_rk4()\n{\n   VEC        *x;\n   VEC        *f();\n   double     h, t, t_fin;\n   double     rk4();\n   \n   input("Input initial time: ","%lf",&t);\n   input("Input final time: ",  "%lf",&t_fin);\n   x = v_get(2);    /* this is the size needed by f() */\n   prompter("Input initial state:\n");	x = v_input(VNULL);\n   input("Input step size: ",   "%lf",&h);\n   \n   printf("# At time %g, the state is\n",t);\n   v_output(x);\n   while (t < t_fin)\n   {\n      /* you can use t = rk4_var(f,t,x,min(h,t_fin-t)); */\n      t = rk4(f,t,x,min(h,t_fin-t));   /* new t is returned */\n      printf("# At time %g, the state is\n",t);\n      v_output(x);\n   }\n}\n\n\n\n\n#include "matrix2.h"\n\nvoid tutor_ls()\n{\n   MAT *A, *QR;\n   VEC *b, *x, *diag;\n   \n   /* read in A matrix */\n   printf("Input A matrix:\n");\n   \n   A = m_input(MNULL);     /* A has whatever size is input */\n   \n   if ( A->m < A->n )\n   {\n      printf("Need m >= n to obtain least squares fit\n");\n      exit(0);\n   }\n   printf("# A =\n");       m_output(A);\n   diag = v_get(A->m);\n   /* QR is to be the QR factorisation of A */\n   QR = m_copy(A,MNULL);\n   QRfactor(QR,diag);   \n   /* read in b vector */\n   printf("Input b vector:\n");\n   b = v_get(A->m);\n   b = v_input(b);\n   printf("# b =\n");       v_output(b);\n   \n   /* solve for x */\n   x = QRsolve(QR,diag,b,VNULL);\n   printf("Vector of best fit parameters is\n");\n   v_output(x);\n   /* ... and work out norm of errors... */\n   printf("||A*x-b|| = %g\n",\n	  v_norm2(v_sub(mv_mlt(A,x,VNULL),b,VNULL)));\n}\n\n\n#include "iter.h"\n\n\n#define N 50\n#define VEC2MAT(v,m)  vm_move((v),0,(m),0,0,N,N);\n\n#define PI 3.141592653589793116\n#define index(i,j) (N*((i)-1)+(j)-1)\n\n/* right hand side function (for generating b) */\ndouble f1(x,y)\ndouble x,y;\n{\n  /* return 2.0*PI*PI*sin(PI*x)*sin(PI*y); */\n   return exp(x*y);\n}\n\n/* discrete laplacian */\nSPMAT *laplacian(A)\nSPMAT *A;\n{\n   Real h;\n   int i,j;\n   \n   if (!A)\n     A = sp_get(N*N,N*N,5);\n\n   for ( i = 1; i <= N; i++ )\n     for ( j = 1; j <= N; j++ )\n     {\n        if ( i < N )\n	  sp_set_val(A,index(i,j),index(i+1,j),-1.0);\n        if ( i > 1 )\n	  sp_set_val(A,index(i,j),index(i-1,j),-1.0);\n        if ( j < N )\n	  sp_set_val(A,index(i,j),index(i,j+1),-1.0);\n        if ( j > 1 )\n	  sp_set_val(A,index(i,j),index(i,j-1),-1.0);\n        sp_set_val(A,index(i,j),index(i,j),4.0);\n     }\n   return A;\n}\n\n/* generating right hand side */\nVEC *rhs_lap(b)\nVEC *b;\n{\n   Real h,h2,x,y;\n   int i,j;\n   \n   if (!b)\n     b = v_get(N*N);\n\n   h = 1.0/(N+1);      /* for a unit square */\n   h2 = h*h;\n   x = 0.0;\n   for ( i = 1; i <= N; i++ ) {\n      x += h;\n      y = 0.0;\n     for ( j = 1; j <= N; j++ ) {\n	y += h;\n	b->ve[index(i,j)] = h2*f1(x,y);\n     }\n   }\n   return b;\n}\n   \nvoid tut_lap()\n{\n   SPMAT *A, *LLT;\n   VEC *b, *out, *x;\n   MAT *B;\n   int num_steps;\n   FILE *fp;\n\n   A = sp_get(N*N,N*N,5);\n   b = v_get(N*N);\n\n   laplacian(A);\n   LLT = sp_copy(A);\n   spICHfactor(LLT);\n\n   out = v_get(A->m);\n   x = v_get(A->m);\n\n   rhs_lap(b);   /* new rhs */\n   iter_spcg(A,LLT,b,1e-6,out,1000,&num_steps);\n   printf("Number of iterations = %d\n",num_steps);\n\n   /* save b as a MATLAB matrix */\n\n   fp = fopen("laplace.mat","w");  /* b will be saved in laplace.mat */\n   if (fp == NULL) {\n      printf("Cannot open %s\n","laplace.mat");\n      exit(1);\n   }\n   \n   /* b must be transformed to a matrix */\n   \n   B = m_get(N,N);\n   VEC2MAT(out,B);\n   m_save(fp,B,"sol");  /* sol is an internal name in MATLAB */\n\n}\n\n\nvoid main()\n{\n   int i;\n\n   input("Choose the problem (1=Runge-Kutta, 2=least squares,3=laplace): ",\n	 "%d",&i);\n   switch (i) {\n    case 1: tutor_rk4(); break;\n    case 2: tutor_ls(); break;\n    case 3: tut_lap(); break;\n    default: \n      printf(" Wrong value of i (only 1, 2 or 3)\n\n");\n      break;\n   }\n\n}\n\n