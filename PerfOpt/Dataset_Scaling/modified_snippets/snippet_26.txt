//=====================================================================\n//	MAIN FUNCTION\n//=====================================================================\n\nvoid master(fp timeinst,\n					fp* initvalu,\n					fp* parameter,\n					fp* finavalu,\n					int mode){\n\n	//=====================================================================\n	//	VARIABLES\n	//=====================================================================\n\n	// counters\n	int i;\n\n	// intermediate output on host\n	fp JCaDyad;\n	fp JCaSL;\n	fp JCaCyt;\n\n	// offset pointers\n	int initvalu_offset_batch;															//\n	int initvalu_offset_ecc;																// 46 points\n	int parameter_offset_ecc;\n	int initvalu_offset_Dyad;															// 15 points\n	int parameter_offset_Dyad;\n	int initvalu_offset_SL;																// 15 points\n	int parameter_offset_SL;\n	int initvalu_offset_Cyt;																// 15 poitns\n	int parameter_offset_Cyt;\n\n	// module parameters\n	fp CaDyad;																					// from ECC model, *** Converting from [mM] to [uM] ***\n	fp CaSL;																						// from ECC model, *** Converting from [mM] to [uM] ***\n	fp CaCyt;																					// from ECC model, *** Converting from [mM] to [uM] ***\n\n		// thread counters\n		int th_id, nthreads;\n		int th_count[4];\n		int temp;\n\n	//=====================================================================\n	//	KERNELS FOR 1 WORKLOAD - PARALLEL\n	//=====================================================================\n\n	nthreads = omp_get_max_threads();\n\n	if(mode == 0){\n\n		// partition workload between threads\n		temp = 0;\n		for(i=0; i<4; i++){													// do for all 4 pieces of work\n			if(temp>=nthreads){											// limit according to number of threads\n				temp = 0;\n			}\n			th_count[i] = temp;												// assign thread to piece of work\n			temp = temp +1;\n		}\n\n		// run pieces of work in parallel\n		#pragma omp parallel private(th_id)\n		{\n\n			if (th_id == th_count[1]) {\n\n				// ecc function\n				initvalu_offset_ecc = 0;												// 46 points\n				parameter_offset_ecc = 0;\n				ecc(						timeinst,\n											initvalu,\n											initvalu_offset_ecc,\n											parameter,\n											parameter_offset_ecc,\n											finavalu);\n\n			}\n\n			if (th_id == th_count[2]) {\n\n				// cam function for Dyad\n				initvalu_offset_Dyad = 46;											// 15 points\n				parameter_offset_Dyad = 1;\n				CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n				JCaDyad = cam(timeinst,\n											initvalu,\n											initvalu_offset_Dyad,\n											parameter,\n											parameter_offset_Dyad,\n											finavalu,\n											CaDyad);\n\n			}\n\n			if (th_id == th_count[3]) {\n\n				// cam function for SL\n				initvalu_offset_SL = 61;											// 15 points\n				parameter_offset_SL = 6;\n				CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n				JCaSL = cam(		timeinst,\n											initvalu,\n											initvalu_offset_SL,\n											parameter,\n											parameter_offset_SL,\n											finavalu,\n											CaSL);\n\n			}\n\n			if (th_id == th_count[4]) {\n\n				// cam function for Cyt\n				initvalu_offset_Cyt = 76;												// 15 poitns\n				parameter_offset_Cyt = 11;\n				CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n				JCaCyt = cam(	timeinst,\n											initvalu,\n											initvalu_offset_Cyt,\n											parameter,\n											parameter_offset_Cyt,\n											finavalu,\n											CaCyt);\n\n			}\n\n		}\n\n	}\n\n	//=====================================================================\n	//	KERNELS FOR MANY WORKLOAD - SERIAL\n	//=====================================================================\n\n	else{\n\n		// ecc function\n		initvalu_offset_ecc = 0;												// 46 points\n		parameter_offset_ecc = 0;\n		ecc(						timeinst,\n									initvalu,\n									initvalu_offset_ecc,\n									parameter,\n									parameter_offset_ecc,\n									finavalu);\n\n		// cam function for Dyad\n		initvalu_offset_Dyad = 46;											// 15 points\n		parameter_offset_Dyad = 1;\n		CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n		JCaDyad = cam(timeinst,\n									initvalu,\n									initvalu_offset_Dyad,\n									parameter,\n									parameter_offset_Dyad,\n									finavalu,\n									CaDyad);\n\n		// cam function for SL\n		initvalu_offset_SL = 61;											// 15 points\n		parameter_offset_SL = 6;\n		CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n		JCaSL = cam(		timeinst,\n									initvalu,\n									initvalu_offset_SL,\n									parameter,\n									parameter_offset_SL,\n									finavalu,\n									CaSL);\n\n		// cam function for Cyt\n		initvalu_offset_Cyt = 76;												// 15 poitns\n		parameter_offset_Cyt = 11;\n		CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n		JCaCyt = cam(	timeinst,\n									initvalu,\n									initvalu_offset_Cyt,\n									parameter,\n									parameter_offset_Cyt,\n									finavalu,\n									CaCyt);\n\n	}\n\n	//=====================================================================\n	//	FINAL KERNEL\n	//=====================================================================\n\n	// final adjustments\n	fin(						initvalu,\n								initvalu_offset_ecc,\n								initvalu_offset_Dyad,\n								initvalu_offset_SL,\n								initvalu_offset_Cyt,\n								parameter,\n								finavalu,\n								JCaDyad,\n								JCaSL,\n								JCaCyt);\n\n	//=====================================================================\n	//	COMPENSATION FOR NANs and INFs\n	//=====================================================================\n\n	// make sure function does not return NANs and INFs\n	for(i=0; i<EQUATIONS; i++){\n		if (isnan(finavalu[i]) == 1){ \n			finavalu[i] = 0.0001;												// for NAN set rate of change to 0.0001\n		}\n		else if (isinf(finavalu[i]) == 1){ \n			finavalu[i] = 0.0001;												// for INF set rate of change to 0.0001\n		}\n	}\n\n}\n