\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*  mem_stat.c    6/09/93  */\n\n/* Deallocation of static arrays */\n\n\n#include <stdio.h>\n#include  "matrix.h"\n#include  "meminfo.h"\n#ifdef COMPLEX   \n#include  "zmatrix.h"\n#endif\n#ifdef SPARSE\n#include  "sparse.h"\n#include  "iter.h"\n#endif\n\nstatic char rcsid[] = "$Id: memstat.c,v 1.1 1994/01/13 05:32:44 des Exp $";\n\n/* global variable */\n\nextern MEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS];\n\n\n/* local type */\n\ntypedef struct {\n  void	**var;	/* for &A, where A is a pointer */\n  int	type;	/* type of A */\n  int	mark;	/* what mark is chosen */\n  char	*fname;	/* source file name where last registered */\n  int	line;	/* line # of file where last registered */\n} MEM_STAT_STRUCT;\n\n\n/* local variables */\n\n/* how many marks are used */\nstatic int mem_stat_mark_many = 0;\n\n/* current mark */\nstatic int mem_stat_mark_curr = 0;\n\n\nstatic MEM_STAT_STRUCT mem_stat_var[MEM_HASHSIZE];\n\n/* array of indices (+1) to mem_stat_var */\nstatic unsigned int mem_hash_idx[MEM_HASHSIZE];\n\n/* points to the first unused element in mem_hash_idx */\nstatic unsigned int mem_hash_idx_end = 0;\n\n\n\n/* hashing function */\n#ifndef ANSI_C\nstatic unsigned int mem_hash(ptr)\nvoid **ptr;\n#else\nstatic unsigned int mem_hash(void **ptr)\n#endif\n{\n   unsigned long lp = (unsigned long)ptr;\n\n   return (lp % MEM_HASHSIZE);\n}\n\n\n/* look for a place in mem_stat_var */\n#ifndef ANSI_C\nstatic int mem_lookup(var)\nvoid **var;\n#else\nstatic int mem_lookup(void **var)\n#endif\n{\n   int k, j;\n\n   k = mem_hash(var);\n\n   if (mem_stat_var[k].var == var) {\n      return -1;\n   }\n   else if (mem_stat_var[k].var == NULL) {\n      return k;\n   }\n   else {  /* look for an empty place */\n      j = k;\n      while (mem_stat_var[j].var != var && j < MEM_HASHSIZE\n	     && mem_stat_var[j].var != NULL) \n	j++;\n\n      if (mem_stat_var[j].var == NULL) return j;\n      else if (mem_stat_var[j].var == var) return -1; \n      else { /* if (j == MEM_HASHSIZE) */\n	 j = 0;\n	 while (mem_stat_var[j].var != var && j < k\n		&& mem_stat_var[j].var != NULL) \n	   j++;\n	 if (mem_stat_var[j].var == NULL) return j;\n	 else if (mem_stat_var[j].var == var) return -1; \n	 else { /* if (j == k) */\n	    fprintf(stderr,\n              "\n WARNING !!! static memory: mem_stat_var is too small\n");\n	    fprintf(stderr,\n	      " Increase MEM_HASHSIZE in file: %s (currently = %d)\n\n",\n		    MEM_HASHSIZE_FILE, MEM_HASHSIZE);\n	    if ( !isatty(fileno(stdout)) ) {\n	       fprintf(stdout,\n                "\n WARNING !!! static memory: mem_stat_var is too small\n");\n	       fprintf(stdout,\n	        " Increase MEM_HASHSIZE in file: %s (currently = %d)\n\n",\n		    MEM_HASHSIZE_FILE, MEM_HASHSIZE);\n	    }\n	    error(E_MEM,"mem_lookup");\n	 }\n      }\n   }\n\n   return -1;\n}\n\n\n/* register static variables;\n   Input arguments:\n     var - variable to be registered,\n     type - type of this variable; \n     list - list of types\n     fname - source file name where last registered\n     line - line number of source file\n\n   returned value < 0  --> error,\n   returned value == 0 --> not registered,\n   returned value >= 0 --> registered with this mark;\n*/\n#ifndef ANSI_C\nint mem_stat_reg_list(var,type,list,fname,line)\nvoid	**var;\nint	type,list;\nchar	*fname;\nint	line;\n#else\nint mem_stat_reg_list(void **var, int type, int list,\n		      char *fname, int line)\n#endif\n{\n   int n;\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return -1;\n\n   if (mem_stat_mark_curr == 0) return 0;  /* not registered */\n   if (var == NULL) return -1;             /* error */\n\n   if ( type < 0 || type >= mem_connect[list].ntypes || \n       mem_connect[list].free_funcs[type] == NULL )\n   {\n      warning(WARN_WRONG_TYPE,"mem_stat_reg_list");\n      return -1;\n   }\n   \n   if ((n = mem_lookup(var)) >= 0) {\n      mem_stat_var[n].var = var;\n      mem_stat_var[n].mark = mem_stat_mark_curr;\n      mem_stat_var[n].type = type;\n      mem_stat_var[n].fname = fname;\n      mem_stat_var[n].line = line;\n      /* save n+1, not n */\n      mem_hash_idx[mem_hash_idx_end++] = n+1;\n   }\n\n   return mem_stat_mark_curr;\n}\n\n\n/* set a mark;\n   Input argument:\n   mark - positive number denoting a mark;\n   returned: \n             mark if mark > 0,\n             0 if mark == 0,\n	     -1 if mark is negative.\n*/\n#ifndef ANSI_C\nint mem_stat_mark(mark)\nint mark;\n#else\nint mem_stat_mark(int mark)\n#endif\n{\n   if (mark < 0) {\n      mem_stat_mark_curr = 0;\n      return -1;   /* error */\n   }\n   else if (mark == 0) {\n      mem_stat_mark_curr = 0; \n      return 0; \n   }\n\n   mem_stat_mark_curr = mark;\n   mem_stat_mark_many++;\n\n   return mark;\n}\n\n\n\n/* deallocate static variables;\n   Input argument:\n   mark - a positive number denoting the mark;\n\n   Returned:\n     -1 if mark < 0 (error);\n     0  if mark == 0;\n*/\n#ifndef ANSI_C\nint mem_stat_free_list(mark,list)\nint mark,list;\n#else\nint mem_stat_free_list(int mark, int list)\n#endif\n{\n   unsigned int i,j;\n   int	 (*free_fn)();\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS \n       || mem_connect[list].free_funcs == NULL )\n     return -1;\n\n   if (mark < 0) {\n      mem_stat_mark_curr = 0;\n      return -1;\n   }\n   else if (mark == 0) {\n      mem_stat_mark_curr = 0;\n      return 0;\n   }\n   \n   if (mem_stat_mark_many <= 0) {\n      warning(WARN_NO_MARK,"mem_stat_free");\n      return -1;\n   }\n\n#ifdef DEBUG\n   printf("mem_stat_free: Freeing variables registered for mark %d\n", mark);\n#endif /* DEBUG */\n   /* deallocate the marked variables */\n   for (i=0; i < mem_hash_idx_end; i++) {\n      j = mem_hash_idx[i];\n      if (j == 0) continue;\n      else {\n	 j--;\n	 if (mem_stat_var[j].mark == mark) {\n	     free_fn = mem_connect[list].free_funcs[mem_stat_var[j].type];\n#ifdef DEBUG\n	     printf("# Freeing variable(s) registered in file \"%s\", line %d\n",\n		    mem_stat_var[j].fname, mem_stat_var[j].line);\n#endif /* DEBUG */\n	     if ( free_fn != NULL )\n		 (*free_fn)(*mem_stat_var[j].var);\n	     else\n		 warning(WARN_WRONG_TYPE,"mem_stat_free");\n	    \n	    *(mem_stat_var[j].var) = NULL;\n	    mem_stat_var[j].var = NULL;\n	    mem_stat_var[j].mark = 0;\n	    mem_stat_var[j].fname = NULL;\n	    mem_stat_var[j].line = 0;\n	    mem_hash_idx[i] = 0;\n	 }\n      }\n   }\n\n   while (mem_hash_idx_end > 0 && mem_hash_idx[mem_hash_idx_end-1] == 0)\n     mem_hash_idx_end--;\n\n   mem_stat_mark_curr = 0;\n   mem_stat_mark_many--;\n   return 0;\n}\n\n\n/* only for diagnostic purposes */\n#ifndef ANSI_C\nvoid mem_stat_dump(fp,list)\nFILE *fp;\nint list;\n#else\nvoid mem_stat_dump(FILE *fp, int list)\n#endif\n{\n   unsigned int i,j,k=1;\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS \n       || mem_connect[list].free_funcs == NULL )\n     return;\n\n   fprintf(fp," Array mem_stat_var (list no. %d):\n",list);\n   for (i=0; i < mem_hash_idx_end; i++) {\n      j = mem_hash_idx[i];\n      if (j == 0) continue;\n      else {\n	 j--;\n	 fprintf(fp," %d.  var = 0x%p, type = %s, mark = %d\n",\n		 k,mem_stat_var[j].var,\n		 mem_stat_var[j].type < mem_connect[list].ntypes &&\n		 mem_connect[list].free_funcs[mem_stat_var[j].type] != NULL ?\n		 mem_connect[list].type_names[(int)mem_stat_var[j].type] : \n		 "???",\n		 mem_stat_var[j].mark);\n	 k++;\n      }\n   }\n   \n   fprintf(fp,"\n");\n}\n\n\n/* query function about the current mark */\n#ifdef ANSI_C\nint mem_stat_show_mark(void)\n#else\nint mem_stat_show_mark()\n#endif\n{\n   return mem_stat_mark_curr;\n}\n\n\n/* Varying number of arguments */\n\n\n#ifdef ANSI_C\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   mem_stat_vars(list,type,&v1,&v2,&v3,...,VNULL);\n   where \n     int list,type;\n     void **v1, **v2, **v3,...;\n     The last argument should be VNULL ! \n     type is the type of variables v1,v2,v3,...\n     (of course they must be of the same type)\n*/\n\nint mem_stat_reg_vars(int list,int type,char *fname,int line, ...)\n{\n   va_list ap;\n   int i=0;\n   void **par;\n   \n   /* va_start(ap, type); */\n   va_start(ap,line);	/* Changed for Linux 7th Oct, 2003 */\n   while (par = va_arg(ap,void **)) {   /* NULL ends the list*/\n      mem_stat_reg_list(par,type,list,fname,line);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n#elif VARARGS\n/* old varargs is used */\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   mem_stat_vars(list,type,&v1,&v2,&v3,...,VNULL);\n   where \n     int list,type;\n     void **v1, **v2, **v3,...;\n     The last argument should be VNULL ! \n     type is the type of variables v1,v2,v3,...\n     (of course they must be of the same type)\n*/\n\nint mem_stat_reg_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int type,list,i=0;\n   void **par;\n   \n   va_start(ap);\n   list = va_arg(ap,int);\n   type = va_arg(ap,int);\n   while (par = va_arg(ap,void **)) {   /* NULL ends the list*/\n      mem_stat_reg_list(par,type,list);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#endif\n