\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*	\n	File containing routines for computing the Schur decomposition\n	of a real non-symmetric matrix\n	See also: hessen.c\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n\nstatic char rcsid[] = "$Id: schur.c,v 1.7 1994/03/17 05:36:53 des Exp $";\n\n\n\n#ifndef ANSI_C\nstatic	void	hhldr3(x,y,z,nu1,beta,newval)\ndouble	x, y, z;\nReal	*nu1, *beta, *newval;\n#else\nstatic	void	hhldr3(double x, double y, double z,\n		       Real *nu1, Real *beta, Real *newval)\n#endif\n{\n	Real	alpha;\n\n	if ( x >= 0.0 )\n		alpha = sqrt(x*x+y*y+z*z);\n	else\n		alpha = -sqrt(x*x+y*y+z*z);\n	*nu1 = x + alpha;\n	*beta = 1.0/(alpha*(*nu1));\n	*newval = alpha;\n}\n\n#ifndef ANSI_C\nstatic	void	hhldr3cols(A,k,j0,beta,nu1,nu2,nu3)\nMAT	*A;\nint	k, j0;\ndouble	beta, nu1, nu2, nu3;\n#else\nstatic	void	hhldr3cols(MAT *A, int k, int j0, double beta,\n			   double nu1, double nu2, double nu3)\n#endif\n{\n	Real	**A_me, ip, prod;\n	int	j, n;\n\n	if ( k < 0 || k+3 > A->m || j0 < 0 )\n		error(E_BOUNDS,"hhldr3cols");\n	A_me = A->me;		n = A->n;\n\n	/* printf("hhldr3cols:(l.%d) j0 = %d, k = %d, A at 0x%lx, m = %d, n = %d\n",\n	       __LINE__, j0, k, (long)A, A->m, A->n); */\n	/* printf("hhldr3cols: A (dumped) =\n");	m_dump(stdout,A); */\n\n	for ( j = j0; j < n; j++ )\n	{\n	    /*****	    \n	    ip = nu1*A_me[k][j] + nu2*A_me[k+1][j] + nu3*A_me[k+2][j];\n	    prod = ip*beta;\n	    A_me[k][j]   -= prod*nu1;\n	    A_me[k+1][j] -= prod*nu2;\n	    A_me[k+2][j] -= prod*nu3;\n	    *****/\n	    /* printf("hhldr3cols: j = %d\n", j); */\n\n	    ip = nu1*m_entry(A,k,j)+nu2*m_entry(A,k+1,j)+nu3*m_entry(A,k+2,j);\n	    prod = ip*beta;\n	    /*****\n	    m_set_val(A,k  ,j,m_entry(A,k  ,j) - prod*nu1);\n	    m_set_val(A,k+1,j,m_entry(A,k+1,j) - prod*nu2);\n	    m_set_val(A,k+2,j,m_entry(A,k+2,j) - prod*nu3);\n	    *****/\n	    m_add_val(A,k  ,j,-prod*nu1);\n	    m_add_val(A,k+1,j,-prod*nu2);\n	    m_add_val(A,k+2,j,-prod*nu3);\n\n	}\n	/* printf("hhldr3cols:(l.%d) j0 = %d, k = %d, m = %d, n = %d\n",\n	       __LINE__, j0, k, A->m, A->n); */\n	/* putc('\n',stdout); */\n}\n\n#ifndef ANSI_C\nstatic	void	hhldr3rows(A,k,i0,beta,nu1,nu2,nu3)\nMAT	*A;\nint	k, i0;\ndouble	beta, nu1, nu2, nu3;\n#else\nstatic	void	hhldr3rows(MAT *A, int k, int i0, double beta,\n			   double nu1, double nu2, double nu3)\n#endif\n{\n	Real	**A_me, ip, prod;\n	int	i, m;\n\n	/* printf("hhldr3rows:(l.%d) A at 0x%lx\n", __LINE__, (long)A); */\n	/* printf("hhldr3rows: k = %d\n", k); */\n	if ( k < 0 || k+3 > A->n )\n		error(E_BOUNDS,"hhldr3rows");\n	A_me = A->me;		m = A->m;\n	i0 = min(i0,m-1);\n\n	for ( i = 0; i <= i0; i++ )\n	{\n	    /****\n	    ip = nu1*A_me[i][k] + nu2*A_me[i][k+1] + nu3*A_me[i][k+2];\n	    prod = ip*beta;\n	    A_me[i][k]   -= prod*nu1;\n	    A_me[i][k+1] -= prod*nu2;\n	    A_me[i][k+2] -= prod*nu3;\n	    ****/\n\n	    ip = nu1*m_entry(A,i,k)+nu2*m_entry(A,i,k+1)+nu3*m_entry(A,i,k+2);\n	    prod = ip*beta;\n	    m_add_val(A,i,k  , - prod*nu1);\n	    m_add_val(A,i,k+1, - prod*nu2);\n	    m_add_val(A,i,k+2, - prod*nu3);\n\n	}\n}\n\n/* schur -- computes the Schur decomposition of the matrix A in situ\n	-- optionally, gives Q matrix such that Q^T.A.Q is upper triangular\n	-- returns upper triangular Schur matrix */\n#ifndef ANSI_C\nMAT	*schur(A,Q)\nMAT	*A, *Q;\n#else\nMAT	*schur(MAT *A, MAT *Q)\n#endif\n{\n    int		i, j, iter, k, k_min, k_max, k_tmp, n, split;\n    Real	beta2, c, discrim, dummy, nu1, s, t, tmp, x, y, z;\n    Real	**A_me;\n    Real	sqrt_macheps;\n    STATIC	VEC	*diag=VNULL, *beta=VNULL;\n    \n    if ( ! A )\n	error(E_NULL,"schur");\n    if ( A->m != A->n || ( Q && Q->m != Q->n ) )\n	error(E_SQUARE,"schur");\n    if ( Q != MNULL && Q->m != A->m )\n	error(E_SIZES,"schur");\n    n = A->n;\n    diag = v_resize(diag,A->n);\n    beta = v_resize(beta,A->n);\n    MEM_STAT_REG(diag,TYPE_VEC);\n    MEM_STAT_REG(beta,TYPE_VEC);\n    /* compute Hessenberg form */\n    Hfactor(A,diag,beta);\n    \n    /* save Q if necessary */\n    if ( Q )\n	Q = makeHQ(A,diag,beta,Q);\n    makeH(A,A);\n\n    sqrt_macheps = sqrt(MACHEPS);\n\n    k_min = 0;	A_me = A->me;\n\n    while ( k_min < n )\n    {\n	Real	a00, a01, a10, a11;\n	double	scale, t, numer, denom;\n\n	/* find k_max to suit:\n	   submatrix k_min..k_max should be irreducible */\n	k_max = n-1;\n	for ( k = k_min; k < k_max; k++ )\n	    /* if ( A_me[k+1][k] == 0.0 ) */\n	    if ( m_entry(A,k+1,k) == 0.0 )\n	    {	k_max = k;	break;	}\n\n	if ( k_max <= k_min )\n	{\n	    k_min = k_max + 1;\n	    continue;		/* outer loop */\n	}\n\n	/* check to see if we have a 2 x 2 block\n	   with complex eigenvalues */\n	if ( k_max == k_min + 1 )\n	{\n	    /* tmp = A_me[k_min][k_min] - A_me[k_max][k_max]; */\n	    a00 = m_entry(A,k_min,k_min);\n	    a01 = m_entry(A,k_min,k_max);\n	    a10 = m_entry(A,k_max,k_min);\n	    a11 = m_entry(A,k_max,k_max);\n	    tmp = a00 - a11;\n	    /* discrim = tmp*tmp +\n		4*A_me[k_min][k_max]*A_me[k_max][k_min]; */\n	    discrim = tmp*tmp + 4*a01*a10;\n	    if ( discrim < 0.0 )\n	    {	/* yes -- e-vals are complex\n		   -- put 2 x 2 block in form [a b; c a];\n		   then eigenvalues have real part a & imag part sqrt(|bc|) */\n		numer = - tmp;\n		denom = ( a01+a10 >= 0.0 ) ?\n		    (a01+a10) + sqrt((a01+a10)*(a01+a10)+tmp*tmp) :\n		    (a01+a10) - sqrt((a01+a10)*(a01+a10)+tmp*tmp);\n		if ( denom != 0.0 )\n		{   /* t = s/c = numer/denom */\n		    t = numer/denom;\n		    scale = c = 1.0/sqrt(1+t*t);\n		    s = c*t;\n		}\n		else\n		{\n		    c = 1.0;\n		    s = 0.0;\n		}\n		rot_cols(A,k_min,k_max,c,s,A);\n		rot_rows(A,k_min,k_max,c,s,A);\n		if ( Q != MNULL )\n		    rot_cols(Q,k_min,k_max,c,s,Q);\n		k_min = k_max + 1;\n		continue;\n	    }\n	    else /* discrim >= 0; i.e. block has two real eigenvalues */\n	    {	/* no -- e-vals are not complex;\n		   split 2 x 2 block and continue */\n		/* s/c = numer/denom */\n		numer = ( tmp >= 0.0 ) ?\n		    - tmp - sqrt(discrim) : - tmp + sqrt(discrim);\n		denom = 2*a01;\n		if ( fabs(numer) < fabs(denom) )\n		{   /* t = s/c = numer/denom */\n		    t = numer/denom;\n		    scale = c = 1.0/sqrt(1+t*t);\n		    s = c*t;\n		}\n		else if ( numer != 0.0 )\n		{   /* t = c/s = denom/numer */\n		    t = denom/numer;\n		    scale = 1.0/sqrt(1+t*t);\n		    c = fabs(t)*scale;\n		    s = ( t >= 0.0 ) ? scale : -scale;\n		}\n		else /* numer == denom == 0 */\n		{\n		    c = 0.0;\n		    s = 1.0;\n		}\n		rot_cols(A,k_min,k_max,c,s,A);\n		rot_rows(A,k_min,k_max,c,s,A);\n		/* A->me[k_max][k_min] = 0.0; */\n		if ( Q != MNULL )\n		    rot_cols(Q,k_min,k_max,c,s,Q);\n		k_min = k_max + 1;	/* go to next block */\n		continue;\n	    }\n	}\n\n	/* now have r x r block with r >= 2:\n	   apply Francis QR step until block splits */\n	split = FALSE;		iter = 0;\n	while ( ! split )\n	{\n	    iter++;\n	    \n	    /* set up Wilkinson/Francis complex shift */\n	    k_tmp = k_max - 1;\n\n	    a00 = m_entry(A,k_tmp,k_tmp);\n	    a01 = m_entry(A,k_tmp,k_max);\n	    a10 = m_entry(A,k_max,k_tmp);\n	    a11 = m_entry(A,k_max,k_max);\n\n	    /* treat degenerate cases differently\n	       -- if there are still no splits after five iterations\n	          and the bottom 2 x 2 looks degenerate, force it to\n		  split */\n#ifdef DEBUG\n	    printf("# schur: bottom 2 x 2 = [%lg, %lg; %lg, %lg]\n",\n		   a00, a01, a10, a11);\n#endif\n	    if ( iter >= 5 &&\n		 fabs(a00-a11) < sqrt_macheps*(fabs(a00)+fabs(a11)) &&\n		 (fabs(a01) < sqrt_macheps*(fabs(a00)+fabs(a11)) ||\n		  fabs(a10) < sqrt_macheps*(fabs(a00)+fabs(a11))) )\n	    {\n	      if ( fabs(a01) < sqrt_macheps*(fabs(a00)+fabs(a11)) )\n		m_set_val(A,k_tmp,k_max,0.0);\n	      if ( fabs(a10) < sqrt_macheps*(fabs(a00)+fabs(a11)) )\n		{\n		  m_set_val(A,k_max,k_tmp,0.0);\n		  split = TRUE;\n		  continue;\n		}\n	    }\n\n	    s = a00 + a11;\n	    t = a00*a11 - a01*a10;\n\n	    /* break loop if a 2 x 2 complex block */\n	    if ( k_max == k_min + 1 && s*s < 4.0*t )\n	    {\n		split = TRUE;\n		continue;\n	    }\n\n	    /* perturb shift if convergence is slow */\n	    if ( (iter % 10) == 0 )\n	    {	s += iter*0.02;		t += iter*0.02;\n	    }\n\n	    /* set up Householder transformations */\n	    k_tmp = k_min + 1;\n	    /********************\n	    x = A_me[k_min][k_min]*A_me[k_min][k_min] +\n		A_me[k_min][k_tmp]*A_me[k_tmp][k_min] -\n		    s*A_me[k_min][k_min] + t;\n	    y = A_me[k_tmp][k_min]*\n		(A_me[k_min][k_min]+A_me[k_tmp][k_tmp]-s);\n	    if ( k_min + 2 <= k_max )\n		z = A_me[k_tmp][k_min]*A_me[k_min+2][k_tmp];\n	    else\n		z = 0.0;\n	    ********************/\n\n	    a00 = m_entry(A,k_min,k_min);\n	    a01 = m_entry(A,k_min,k_tmp);\n	    a10 = m_entry(A,k_tmp,k_min);\n	    a11 = m_entry(A,k_tmp,k_tmp);\n\n	    /********************\n	    a00 = A->me[k_min][k_min];\n	    a01 = A->me[k_min][k_tmp];\n	    a10 = A->me[k_tmp][k_min];\n	    a11 = A->me[k_tmp][k_tmp];\n	    ********************/\n	    x = a00*a00 + a01*a10 - s*a00 + t;\n	    y = a10*(a00+a11-s);\n	    if ( k_min + 2 <= k_max )\n		z = a10* /* m_entry(A,k_min+2,k_tmp) */ A->me[k_min+2][k_tmp];\n	    else\n		z = 0.0;\n\n	    for ( k = k_min; k <= k_max-1; k++ )\n	    {\n		if ( k < k_max - 1 )\n		{\n		    hhldr3(x,y,z,&nu1,&beta2,&dummy);\n		    tracecatch(hhldr3cols(A,k,max(k-1,0),  beta2,nu1,y,z),"schur");\n		    tracecatch(hhldr3rows(A,k,min(n-1,k+3),beta2,nu1,y,z),"schur");\n		    if ( Q != MNULL )\n			hhldr3rows(Q,k,n-1,beta2,nu1,y,z);\n		}\n		else\n		{\n		    givens(x,y,&c,&s);\n		    rot_cols(A,k,k+1,c,s,A);\n		    rot_rows(A,k,k+1,c,s,A);\n		    if ( Q )\n			rot_cols(Q,k,k+1,c,s,Q);\n		}\n		/* if ( k >= 2 )\n		    m_set_val(A,k,k-2,0.0); */\n		/* x = A_me[k+1][k]; */\n		x = m_entry(A,k+1,k);\n		if ( k <= k_max - 2 )\n		    /* y = A_me[k+2][k];*/\n		    y = m_entry(A,k+2,k);\n		else\n		    y = 0.0;\n		if ( k <= k_max - 3 )\n		    /* z = A_me[k+3][k]; */\n		    z = m_entry(A,k+3,k);\n		else\n		    z = 0.0;\n	    }\n	    /* if ( k_min > 0 )\n		m_set_val(A,k_min,k_min-1,0.0);\n	    if ( k_max < n - 1 )\n		m_set_val(A,k_max+1,k_max,0.0); */\n	    for ( k = k_min; k <= k_max-2; k++ )\n	    {\n		/* zero appropriate sub-diagonals */\n		m_set_val(A,k+2,k,0.0);\n		if ( k < k_max-2 )\n		    m_set_val(A,k+3,k,0.0);\n	    }\n\n	    /* test to see if matrix should split */\n	    for ( k = k_min; k < k_max; k++ )\n		if ( fabs(A_me[k+1][k]) < MACHEPS*\n		    (fabs(A_me[k][k])+fabs(A_me[k+1][k+1])) )\n		{	A_me[k+1][k] = 0.0;	split = TRUE;	}\n	}\n    }\n    \n    /* polish up A by zeroing strictly lower triangular elements\n       and small sub-diagonal elements */\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < i-1; j++ )\n	    A_me[i][j] = 0.0;\n    for ( i = 0; i < A->m - 1; i++ )\n	if ( fabs(A_me[i+1][i]) < MACHEPS*\n	    (fabs(A_me[i][i])+fabs(A_me[i+1][i+1])) )\n	    A_me[i+1][i] = 0.0;\n\n#ifdef	THREADSAFE\n    V_FREE(diag);	V_FREE(beta);\n#endif\n\n    return A;\n}\n\n/* schur_vals -- compute real & imaginary parts of eigenvalues\n	-- assumes T contains a block upper triangular matrix\n		as produced by schur()\n	-- real parts stored in real_pt, imaginary parts in imag_pt */\n#ifndef ANSI_C\nvoid	schur_evals(T,real_pt,imag_pt)\nMAT	*T;\nVEC	*real_pt, *imag_pt;\n#else\nvoid	schur_evals(MAT *T, VEC *real_pt, VEC *imag_pt)\n#endif\n{\n	int	i, n;\n	Real	discrim, **T_me;\n	Real	diff, sum, tmp;\n\n	if ( ! T || ! real_pt || ! imag_pt )\n		error(E_NULL,"schur_evals");\n	if ( T->m != T->n )\n		error(E_SQUARE,"schur_evals");\n	n = T->n;	T_me = T->me;\n	real_pt = v_resize(real_pt,(unsigned int)n);\n	imag_pt = v_resize(imag_pt,(unsigned int)n);\n\n	i = 0;\n	while ( i < n )\n	{\n		if ( i < n-1 && T_me[i+1][i] != 0.0 )\n		{   /* should be a complex eigenvalue */\n		    sum  = 0.5*(T_me[i][i]+T_me[i+1][i+1]);\n		    diff = 0.5*(T_me[i][i]-T_me[i+1][i+1]);\n		    discrim = diff*diff + T_me[i][i+1]*T_me[i+1][i];\n		    if ( discrim < 0.0 )\n		    {	/* yes -- complex e-vals */\n			real_pt->ve[i] = real_pt->ve[i+1] = sum;\n			imag_pt->ve[i] = sqrt(-discrim);\n			imag_pt->ve[i+1] = - imag_pt->ve[i];\n		    }\n		    else\n		    {	/* no -- actually both real */\n			tmp = sqrt(discrim);\n			real_pt->ve[i]   = sum + tmp;\n			real_pt->ve[i+1] = sum - tmp;\n			imag_pt->ve[i]   = imag_pt->ve[i+1] = 0.0;\n		    }\n		    i += 2;\n		}\n		else\n		{   /* real eigenvalue */\n		    real_pt->ve[i] = T_me[i][i];\n		    imag_pt->ve[i] = 0.0;\n		    i++;\n		}\n	}\n}\n\n/* schur_vecs -- returns eigenvectors computed from the real Schur\n		decomposition of a matrix\n	-- T is the block upper triangular Schur matrix\n	-- Q is the orthognal matrix where A = Q.T.Q^T\n	-- if Q is null, the eigenvectors of T are returned\n	-- X_re is the real part of the matrix of eigenvectors,\n		and X_im is the imaginary part of the matrix.\n	-- X_re is returned */\n#ifndef ANSI_C\nMAT	*schur_vecs(T,Q,X_re,X_im)\nMAT	*T, *Q, *X_re, *X_im;\n#else\nMAT	*schur_vecs(MAT *T, MAT *Q, MAT *X_re, MAT *X_im)\n#endif\n{\n	int	i, j, limit;\n	Real	t11_re, t11_im, t12, t21, t22_re, t22_im;\n	Real	l_re, l_im, det_re, det_im, invdet_re, invdet_im,\n		val1_re, val1_im, val2_re, val2_im,\n		tmp_val1_re, tmp_val1_im, tmp_val2_re, tmp_val2_im, **T_me;\n	Real	sum, diff, discrim, magdet, norm, scale;\n	STATIC VEC	*tmp1_re=VNULL, *tmp1_im=VNULL,\n			*tmp2_re=VNULL, *tmp2_im=VNULL;\n\n	if ( ! T || ! X_re )\n	    error(E_NULL,"schur_vecs");\n	if ( T->m != T->n || X_re->m != X_re->n ||\n		( Q != MNULL && Q->m != Q->n ) ||\n		( X_im != MNULL && X_im->m != X_im->n ) )\n	    error(E_SQUARE,"schur_vecs");\n	if ( T->m != X_re->m ||\n		( Q != MNULL && T->m != Q->m ) ||\n		( X_im != MNULL && T->m != X_im->m ) )\n	    error(E_SIZES,"schur_vecs");\n\n	tmp1_re = v_resize(tmp1_re,T->m);\n	tmp1_im = v_resize(tmp1_im,T->m);\n	tmp2_re = v_resize(tmp2_re,T->m);\n	tmp2_im = v_resize(tmp2_im,T->m);\n	MEM_STAT_REG(tmp1_re,TYPE_VEC);\n	MEM_STAT_REG(tmp1_im,TYPE_VEC);\n	MEM_STAT_REG(tmp2_re,TYPE_VEC);\n	MEM_STAT_REG(tmp2_im,TYPE_VEC);\n\n	T_me = T->me;\n	i = 0;\n	while ( i < T->m )\n	{\n	    if ( i+1 < T->m && T->me[i+1][i] != 0.0 )\n	    {	/* complex eigenvalue */\n		sum  = 0.5*(T_me[i][i]+T_me[i+1][i+1]);\n		diff = 0.5*(T_me[i][i]-T_me[i+1][i+1]);\n		discrim = diff*diff + T_me[i][i+1]*T_me[i+1][i];\n		l_re = l_im = 0.0;\n		if ( discrim < 0.0 )\n		{	/* yes -- complex e-vals */\n		    l_re = sum;\n		    l_im = sqrt(-discrim);\n		}\n		else /* not correct Real Schur form */\n		    error(E_RANGE,"schur_vecs");\n	    }\n	    else\n	    {\n		l_re = T_me[i][i];\n		l_im = 0.0;\n	    }\n\n	    v_zero(tmp1_im);\n	    v_rand(tmp1_re);\n	    sv_mlt(MACHEPS,tmp1_re,tmp1_re);\n\n	    /* solve (T-l.I)x = tmp1 */\n	    limit = ( l_im != 0.0 ) ? i+1 : i;\n	    /* printf("limit = %d\n",limit); */\n	    for ( j = limit+1; j < T->m; j++ )\n		tmp1_re->ve[j] = 0.0;\n	    j = limit;\n	    while ( j >= 0 )\n	    {\n		if ( j > 0 && T->me[j][j-1] != 0.0 )\n		{   /* 2 x 2 diagonal block */\n		    /* printf("checkpoint A\n"); */\n		    val1_re = tmp1_re->ve[j-1] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf("checkpoint B\n"); */\n		    val1_im = tmp1_im->ve[j-1] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf("checkpoint C\n"); */\n		    val2_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint D\n"); */\n		    val2_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint E\n"); */\n		    \n		    t11_re = T_me[j-1][j-1] - l_re;\n		    t11_im = - l_im;\n		    t22_re = T_me[j][j] - l_re;\n		    t22_im = - l_im;\n		    t12 = T_me[j-1][j];\n		    t21 = T_me[j][j-1];\n\n		    scale =  fabs(T_me[j-1][j-1]) + fabs(T_me[j][j]) +\n			fabs(t12) + fabs(t21) + fabs(l_re) + fabs(l_im);\n\n		    det_re = t11_re*t22_re - t11_im*t22_im - t12*t21;\n		    det_im = t11_re*t22_im + t11_im*t22_re;\n		    magdet = det_re*det_re+det_im*det_im;\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        det_re = MACHEPS*scale;\n			magdet = det_re*det_re+det_im*det_im;\n		    }\n		    invdet_re =   det_re/magdet;\n		    invdet_im = - det_im/magdet;\n		    tmp_val1_re = t22_re*val1_re-t22_im*val1_im-t12*val2_re;\n		    tmp_val1_im = t22_im*val1_re+t22_re*val1_im-t12*val2_im;\n		    tmp_val2_re = t11_re*val2_re-t11_im*val2_im-t21*val1_re;\n		    tmp_val2_im = t11_im*val2_re+t11_re*val2_im-t21*val1_im;\n		    tmp1_re->ve[j-1] = invdet_re*tmp_val1_re -\n		    		invdet_im*tmp_val1_im;\n		    tmp1_im->ve[j-1] = invdet_im*tmp_val1_re +\n		    		invdet_re*tmp_val1_im;\n		    tmp1_re->ve[j]   = invdet_re*tmp_val2_re -\n		    		invdet_im*tmp_val2_im;\n		    tmp1_im->ve[j]   = invdet_im*tmp_val2_re +\n		    		invdet_re*tmp_val2_im;\n		    j -= 2;\n	        }\n	        else\n		{\n		    t11_re = T_me[j][j] - l_re;\n		    t11_im = - l_im;\n		    magdet = t11_re*t11_re + t11_im*t11_im;\n		    scale = fabs(T_me[j][j]) + fabs(l_re);\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        t11_re = MACHEPS*scale;\n			magdet = t11_re*t11_re + t11_im*t11_im;\n		    }\n		    invdet_re =   t11_re/magdet;\n		    invdet_im = - t11_im/magdet;\n		    /* printf("checkpoint F\n"); */\n		    val1_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint G\n"); */\n		    val1_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint H\n"); */\n		    tmp1_re->ve[j] = invdet_re*val1_re - invdet_im*val1_im;\n		    tmp1_im->ve[j] = invdet_im*val1_re + invdet_re*val1_im;\n		    j -= 1;\n		}\n	    }\n\n	    norm = v_norm_inf(tmp1_re) + v_norm_inf(tmp1_im);\n	    sv_mlt(1/norm,tmp1_re,tmp1_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp1_im,tmp1_im);\n	    mv_mlt(Q,tmp1_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		mv_mlt(Q,tmp1_im,tmp2_im);\n	    if ( l_im != 0.0 )\n		norm = sqrt(in_prod(tmp2_re,tmp2_re)+in_prod(tmp2_im,tmp2_im));\n	    else\n		norm = v_norm2(tmp2_re);\n	    sv_mlt(1/norm,tmp2_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp2_im,tmp2_im);\n\n	    if ( l_im != 0.0 )\n	    {\n		if ( ! X_im )\n		error(E_NULL,"schur_vecs");\n		set_col(X_re,i,tmp2_re);\n		set_col(X_im,i,tmp2_im);\n		sv_mlt(-1.0,tmp2_im,tmp2_im);\n		set_col(X_re,i+1,tmp2_re);\n		set_col(X_im,i+1,tmp2_im);\n		i += 2;\n	    }\n	    else\n	    {\n		set_col(X_re,i,tmp2_re);\n		if ( X_im != MNULL )\n		    set_col(X_im,i,tmp1_im);	/* zero vector */\n		i += 1;\n	    }\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(tmp1_re);	V_FREE(tmp1_im);\n	V_FREE(tmp2_re);	V_FREE(tmp2_im);\n#endif\n\n	return X_re;\n}\n\n