#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n\n#include "common.h"\n\nvoid stopwatch_start(stopwatch *sw){\n    if (sw == NULL)\n        return;\n\n    bzero(&sw->begin, sizeof(struct timeval));\n    bzero(&sw->end  , sizeof(struct timeval));\n\n    gettimeofday(&sw->begin, NULL);\n}\n\nvoid stopwatch_stop(stopwatch *sw){\n    if (sw == NULL)\n        return;\n\n    gettimeofday(&sw->end, NULL);\n}\n\ndouble \nget_interval_by_sec(stopwatch *sw){\n    if (sw == NULL)\n        return 0;\n    return ((double)(sw->end.tv_sec-sw->begin.tv_sec)+(double)(sw->end.tv_usec-sw->begin.tv_usec)/1000000);\n}\n\nint \nget_interval_by_usec(stopwatch *sw){\n    if (sw == NULL)\n        return 0;\n    return ((sw->end.tv_sec-sw->begin.tv_sec)*1000000+(sw->end.tv_usec-sw->begin.tv_usec));\n}\n\nfunc_ret_t \ncreate_matrix_from_file(float **mp, const char* filename, int *size_p){\n  int i, j, size;\n  float *m;\n  FILE *fp = NULL;\n\n  fp = fopen(filename, "rb");\n  if ( fp == NULL) {\n      return RET_FAILURE;\n  }\n\n  fscanf(fp, "%d\n", &size);\n\n  m = (float*) malloc(sizeof(float)*size*size);\n  if ( m == NULL) {\n      fclose(fp);\n      return RET_FAILURE;\n  }\n\n  for (i=0; i < size; i++) {\n      for (j=0; j < size; j++) {\n          fscanf(fp, "%f ", m+i*size+j);\n      }\n  }\n\n  fclose(fp);\n\n  *size_p = size;\n  *mp = m;\n\n  return RET_SUCCESS;\n}\n\n\nfunc_ret_t\ncreate_matrix_from_random(float **mp, int size){\n  float *l, *u, *m;\n  int i,j,k;\n\n  srand(time(NULL));\n\n  l = (float*)malloc(size*size*sizeof(float));\n  if ( l == NULL)\n    return RET_FAILURE;\n\n  u = (float*)malloc(size*size*sizeof(float));\n  if ( u == NULL) {\n      free(l);\n      return RET_FAILURE;\n  }\n\n  for (i = 0; i < size; i++) {\n      for (j=0; j < size; j++) {\n          if (i>j) {\n              l[i*size+j] = GET_RAND_FP;\n          } else if (i == j) {\n              l[i*size+j] = 1;\n          } else {\n              l[i*size+j] = 0;\n          }\n      }\n  }\n\n  for (j=0; j < size; j++) {\n      for (i=0; i < size; i++) {\n          if (i>j) {\n              u[j*size+i] = 0;\n          }else {\n              u[j*size+i] = GET_RAND_FP; \n          }\n      }\n  }\n\n  for (i=0; i < size; i++) {\n      for (j=0; j < size; j++) {\n          for (k=0; k <= MIN(i,j); k++)\n            m[i*size+j] = l[i*size+k] * u[j*size+k];\n      }\n  }\n\n  free(l);\n  free(u);\n\n  *mp = m;\n\n  return RET_SUCCESS;\n}\n\nvoid\nmatrix_multiply(float *inputa, float *inputb, float *output, int size){\n  int i, j, k;\n\n  for (i=0; i < size; i++)\n    for (k=0; k < size; k++)\n      for (j=0; j < size; j++)\n        output[i*size+j] = inputa[i*size+k] * inputb[k*size+j];\n\n}\n\nfunc_ret_t\nlud_verify(float *m, float *lu, int matrix_dim){\n  int i,j,k;\n  float *tmp = (float*)malloc(matrix_dim*matrix_dim*sizeof(float));\n\n  for (i=0; i < matrix_dim; i ++)\n    for (j=0; j< matrix_dim; j++) {\n        float sum = 0;\n        float l,u;\n        for (k=0; k <= MIN(i,j); k++){\n            if ( i==k)\n              l=1;\n            else\n              l=lu[i*matrix_dim+k];\n            u=lu[k*matrix_dim+j];\n            sum+=l*u;\n        }\n        tmp[i*matrix_dim+j] = sum;\n    }\n  /* printf(">>>>>LU<<<<<<<\n"); */\n  /* for (i=0; i<matrix_dim; i++){ */\n  /*   for (j=0; j<matrix_dim;j++){ */\n  /*       printf("%f ", lu[i*matrix_dim+j]); */\n  /*   } */\n  /*   printf("\n"); */\n  /* } */\n  /* printf(">>>>>result<<<<<<<\n"); */\n  /* for (i=0; i<matrix_dim; i++){ */\n  /*   for (j=0; j<matrix_dim;j++){ */\n  /*       printf("%f ", tmp[i*matrix_dim+j]); */\n  /*   } */\n  /*   printf("\n"); */\n  /* } */\n  /* printf(">>>>>input<<<<<<<\n"); */\n  /* for (i=0; i<matrix_dim; i++){ */\n  /*   for (j=0; j<matrix_dim;j++){ */\n  /*       printf("%f ", m[i*matrix_dim+j]); */\n  /*   } */\n  /*   printf("\n"); */\n  /* } */\n\n  for (i=0; i<matrix_dim; i++){\n      for (j=0; j<matrix_dim; j++){\n          if ( fabs(m[i*matrix_dim+j]-tmp[i*matrix_dim+j]) > 0.0001)\n            printf("dismatch at (%d, %d): (o)%f (n)%f\n", i, j, m[i*matrix_dim+j], tmp[i*matrix_dim+j]);\n      }\n  }\n  free(tmp);\n}\n\nvoid\nmatrix_duplicate(float *src, float **dst, int matrix_dim) {\n    int s = matrix_dim*matrix_dim*sizeof(float);\n   float *p = (float *) malloc (s);\n   memcpy(p, src, s);\n   *dst = p;\n}\n\nvoid\nprint_matrix(float *m, int matrix_dim) {\n    int i, j;\n    for (i=0; i<matrix_dim;i++) {\n      for (j=0; j<matrix_dim;j++)\n        printf("%f ", m[i*matrix_dim+j]);\n      printf("\n");\n    }\n}\n\n\n// Generate well-conditioned matrix internally  by Ke Wang 2013/08/07 22:20:06\n\nfunc_ret_t\ncreate_matrix(float **mp, int size){\n  float *m;\n  int i,j;\n  float lamda = -0.001;\n  float coe[2*size-1];\n  float coe_i =0.0;\n\n  for (i=0; i < size; i++)\n    {\n      coe_i = 10*exp(lamda*i); \n      j=size-1+i;     \n      coe[j]=coe_i;\n      j=size-1-i;     \n      coe[j]=coe_i;\n    }\n\n  m = (float*) malloc(sizeof(float)*size*size);\n  if ( m == NULL) {\n      return RET_FAILURE;\n  }\n\n  for (i=0; i < size; i++) {\n      for (j=0; j < size; j++) {\n	m[i*size+j]=coe[size-1-i+j];\n      }\n  }\n\n  *mp = m;\n\n  return RET_SUCCESS;\n}\n