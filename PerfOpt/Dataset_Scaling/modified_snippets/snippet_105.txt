\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\nstatic	char	rcsid[] = "$Id: zcopy.c,v 1.1 1994/01/13 04:28:42 des Exp $";\n#include	<stdio.h>\n#include	"zmatrix.h"\n\n\n\n/* _zm_copy -- copies matrix into new area */\n#ifndef ANSI_C\nZMAT	*_zm_copy(in,out,i0,j0)\nZMAT	*in,*out;\nunsigned int	i0,j0;\n#else\nZMAT	*_zm_copy(const ZMAT *in, ZMAT *out, int i0, int j0)\n#endif\n{\n	unsigned int	i /* ,j */;\n\n	if ( in==ZMNULL )\n		error(E_NULL,"_zm_copy");\n	if ( in==out )\n		return (out);\n	if ( out==ZMNULL || out->m < in->m || out->n < in->n )\n		out = zm_resize(out,in->m,in->n);\n\n	for ( i=i0; i < in->m; i++ )\n		MEM_COPY(&(in->me[i][j0]),&(out->me[i][j0]),\n				(in->n - j0)*sizeof(complex));\n		/* for ( j=j0; j < in->n; j++ )\n			out->me[i][j] = in->me[i][j]; */\n\n	return (out);\n}\n\n/* _zv_copy -- copies vector into new area */\n#ifndef ANSI_C\nZVEC	*_zv_copy(in,out,i0)\nZVEC	*in,*out;\nunsigned int	i0;\n#else\nZVEC	*_zv_copy(const ZVEC *in, ZVEC *out, int i0)\n#endif\n{\n	/* unsigned int	i,j; */\n\n	if ( in==ZVNULL )\n		error(E_NULL,"_zv_copy");\n	if ( in==out )\n		return (out);\n	if ( out==ZVNULL || out->dim < in->dim )\n		out = zv_resize(out,in->dim);\n\n	MEM_COPY(&(in->ve[i0]),&(out->ve[i0]),(in->dim - i0)*sizeof(complex));\n	/* for ( i=i0; i < in->dim; i++ )\n		out->ve[i] = in->ve[i]; */\n\n	return (out);\n}\n\n\n/*\n	The z._move() routines are for moving blocks of memory around\n	within Meschach data structures and for re-arranging matrices,\n	vectors etc.\n*/\n\n/* zm_move -- copies selected pieces of a matrix\n	-- moves the m0 x n0 submatrix with top-left cor-ordinates (i0,j0)\n	   to the corresponding submatrix of out with top-left co-ordinates\n	   (i1,j1)\n	-- out is resized (& created) if necessary */\n#ifndef ANSI_C\nZMAT	*zm_move(in,i0,j0,m0,n0,out,i1,j1)\nZMAT	*in, *out;\nint	i0, j0, m0, n0, i1, j1;\n#else\nZMAT	*zm_move(const ZMAT *in, int i0, int j0, int m0, int n0,\n		 ZMAT *out, int i1, int j1)\n#endif\n{\n    int		i;\n\n    if ( ! in )\n	error(E_NULL,"zm_move");\n    if ( i0 < 0 || j0 < 0 || i1 < 0 || j1 < 0 || m0 < 0 || n0 < 0 ||\n	 i0+m0 > in->m || j0+n0 > in->n )\n	error(E_BOUNDS,"zm_move");\n\n    if ( ! out )\n	out = zm_resize(out,i1+m0,j1+n0);\n    else if ( i1+m0 > out->m || j1+n0 > out->n )\n	out = zm_resize(out,max(out->m,i1+m0),max(out->n,j1+n0));\n\n    for ( i = 0; i < m0; i++ )\n	MEM_COPY(&(in->me[i0+i][j0]),&(out->me[i1+i][j1]),\n		 n0*sizeof(complex));\n\n    return out;\n}\n\n/* zv_move -- copies selected pieces of a vector\n	-- moves the length dim0 subvector with initial index i0\n	   to the corresponding subvector of out with initial index i1\n	-- out is resized if necessary */\n#ifndef ANSI_C\nZVEC	*zv_move(in,i0,dim0,out,i1)\nZVEC	*in, *out;\nint	i0, dim0, i1;\n#else\nZVEC	*zv_move(const ZVEC *in, int i0, int dim0,\n		 ZVEC *out, int i1)\n#endif\n{\n    if ( ! in )\n	error(E_NULL,"zv_move");\n    if ( i0 < 0 || dim0 < 0 || i1 < 0 ||\n	 i0+dim0 > in->dim )\n	error(E_BOUNDS,"zv_move");\n\n    if ( (! out) || i1+dim0 > out->dim )\n	out = zv_resize(out,i1+dim0);\n\n    MEM_COPY(&(in->ve[i0]),&(out->ve[i1]),dim0*sizeof(complex));\n\n    return out;\n}\n\n\n/* zmv_move -- copies selected piece of matrix to a vector\n	-- moves the m0 x n0 submatrix with top-left co-ordinate (i0,j0) to\n	   the subvector with initial index i1 (and length m0*n0)\n	-- rows are copied contiguously\n	-- out is resized if necessary */\n#ifndef ANSI_C\nZVEC	*zmv_move(in,i0,j0,m0,n0,out,i1)\nZMAT	*in;\nZVEC	*out;\nint	i0, j0, m0, n0, i1;\n#else\nZVEC	*zmv_move(const ZMAT *in, int i0, int j0, int m0, int n0,\n		  ZVEC *out, int i1)\n#endif\n{\n    int		dim1, i;\n\n    if ( ! in )\n	error(E_NULL,"zmv_move");\n    if ( i0 < 0 || j0 < 0 || m0 < 0 || n0 < 0 || i1 < 0 ||\n	 i0+m0 > in->m || j0+n0 > in->n )\n	error(E_BOUNDS,"zmv_move");\n\n    dim1 = m0*n0;\n    if ( (! out) || i1+dim1 > out->dim )\n	out = zv_resize(out,i1+dim1);\n\n    for ( i = 0; i < m0; i++ )\n	MEM_COPY(&(in->me[i0+i][j0]),&(out->ve[i1+i*n0]),n0*sizeof(complex));\n\n    return out;\n}\n\n/* zvm_move -- copies selected piece of vector to a matrix\n	-- moves the subvector with initial index i0 and length m1*n1 to\n	   the m1 x n1 submatrix with top-left co-ordinate (i1,j1)\n        -- copying is done by rows\n	-- out is resized if necessary */\n#ifndef ANSI_C\nZMAT	*zvm_move(in,i0,out,i1,j1,m1,n1)\nZVEC	*in;\nZMAT	*out;\nint	i0, i1, j1, m1, n1;\n#else\nZMAT	*zvm_move(const ZVEC *in, int i0,\n		  ZMAT *out, int i1, int j1, int m1, int n1)\n#endif\n{\n    int		dim0, i;\n\n    if ( ! in )\n	error(E_NULL,"zvm_move");\n    if ( i0 < 0 || i1 < 0 || j1 < 0 || m1 < 0 || n1 < 0 ||\n	 i0+m1*n1 > in->dim )\n	error(E_BOUNDS,"zvm_move");\n\n    if ( ! out )\n	out = zm_resize(out,i1+m1,j1+n1);\n    else\n	out = zm_resize(out,max(i1+m1,out->m),max(j1+n1,out->n));\n\n    dim0 = m1*n1;\n    for ( i = 0; i < m1; i++ )\n	MEM_COPY(&(in->ve[i0+i*n1]),&(out->me[i1+i][j1]),n1*sizeof(complex));\n\n    return out;\n}\n