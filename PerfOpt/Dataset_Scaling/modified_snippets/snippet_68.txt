\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Fast Fourier Transform routine\n	Loosely based on the Fortran routine in Rabiner & Gold's\n	"Digital Signal Processing"\n*/\n\nstatic char rcsid[] = "$Id: fft.c,v 1.4 1996/08/20 14:21:05 stewart Exp $";\n\n#include        <stdio.h>\n#include        <math.h>\n#include        "matrix.h"\n#include        "matrix2.h"\n\n\n/* fft -- d.i.t. fast Fourier transform \n        -- radix-2 FFT only\n        -- vector extended to a power of 2 */\n#ifndef ANSI_C\nvoid    fft(x_re,x_im)\nVEC     *x_re, *x_im;\n#else\nvoid    fft(VEC *x_re, VEC *x_im)\n#endif\n{\n    int         i, ip, j, k, li, n, length;\n    Real      *xr, *xi;\n    Real	theta, pi = 3.1415926535897932384;\n    Real      w_re, w_im, u_re, u_im, t_re, t_im;\n    Real      tmp, tmpr, tmpi;\n\n    if ( ! x_re || ! x_im )\n        error(E_NULL,"fft");\n    if ( x_re->dim != x_im->dim )\n        error(E_SIZES,"fft");\n\n    n = 1;\n    while ( x_re->dim > n )\n        n *= 2;\n    x_re = v_resize(x_re,n);\n    x_im = v_resize(x_im,n);\n    /*  printf("# fft: x_re =\n");  v_output(x_re); */\n    /*  printf("# fft: x_im =\n");  v_output(x_im); */\n    xr   = x_re->ve;\n    xi   = x_im->ve;\n\n    /* Decimation in time (DIT) algorithm */\n    j = 0;\n    for ( i = 0; i < n-1; i++ )\n    {\n        if ( i < j )\n        {\n            tmp = xr[i];\n            xr[i] = xr[j];\n            xr[j] = tmp;\n            tmp = xi[i];\n            xi[i] = xi[j];\n            xi[j] = tmp;\n        }\n        k = n / 2;\n        while ( k <= j )\n        {\n            j -= k;\n            k /= 2;\n        }\n        j += k;\n    }\n\n    /* Actual FFT */\n    for ( li = 1; li < n; li *= 2 )\n    {\n        length = 2*li;\n        theta  = pi/li;\n        u_re   = 1.0;\n        u_im   = 0.0;\n        if ( li == 1 )\n        {\n            w_re = -1.0;\n            w_im =  0.0;\n        }\n        else if ( li == 2 )\n        {\n            w_re =  0.0;\n            w_im =  1.0;\n        }\n        else\n        {\n            w_re = cos(theta);\n            w_im = sin(theta);\n        }\n        for ( j = 0; j < li; j++ )\n        {\n            for ( i =  j; i < n; i += length )\n            {\n                ip = i + li;\n                /* step 1 */\n                t_re = xr[ip]*u_re - xi[ip]*u_im;\n                t_im = xr[ip]*u_im + xi[ip]*u_re;\n                /* step 2 */\n                xr[ip] = xr[i]  - t_re;\n                xi[ip] = xi[i]  - t_im;\n                /* step 3 */\n                xr[i] += t_re;\n                xi[i] += t_im;\n            }\n            tmpr = u_re*w_re - u_im*w_im;\n            tmpi = u_im*w_re + u_re*w_im;\n            u_re = tmpr;\n            u_im = tmpi;\n        }\n    }\n}\n\n/* ifft -- inverse FFT using the same interface as fft() */\n#ifndef ANSI_C\nvoid	ifft(x_re,x_im)\nVEC	*x_re, *x_im;\n#else\nvoid	ifft(VEC *x_re, VEC *x_im)\n#endif\n{\n    /* we just use complex conjugates */\n\n    sv_mlt(-1.0,x_im,x_im);\n    fft(x_re,x_im);\n    sv_mlt(-1.0/((double)(x_re->dim)),x_im,x_im);\n    sv_mlt( 1.0/((double)(x_re->dim)),x_re,x_re);\n}\n