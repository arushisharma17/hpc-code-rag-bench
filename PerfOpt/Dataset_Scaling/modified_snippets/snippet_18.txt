/***********************************************\n	streamcluster_omp.cpp\n	: parallelized code of streamcluster using OpenMP\n	\n	- original code from PARSEC Benchmark Suite\n	- parallelization with OpenMP API has been applied by\n	\n	Sang-Ha (a.k.a Shawn) Lee - sl4ge@virginia.edu\n	University of Virginia\n	Department of Electrical and Computer Engineering\n	Department of Computer Science\n	\n***********************************************/\n\n#include <stdio.h>\n#include <iostream>\n#include <fstream>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <string.h>\n#include <assert.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <limits.h>\n#include <omp.h>\n\n#ifdef ENABLE_PARSEC_HOOKS\n#include <hooks.h>\n#endif\n\nusing namespace std;\n\n#define MAXNAMESIZE 1024 // max filename length\n#define SEED 1\n/* increase this to reduce probability of random error */\n/* increasing it also ups running time of "speedy" part of the code */\n/* SP = 1 seems to be fine */\n#define SP 1 // number of repetitions of speedy must be >=1\n\n/* higher ITER --> more likely to get correct # of centers */\n/* higher ITER also scales the running time almost linearly */\n#define ITER 3 // iterate ITER* k log k times; ITER >= 1\n\n//#define PRINTINFO //comment this out to disable output\n#define PROFILE // comment this out to disable instrumentation code\n//#define ENABLE_THREADS  // comment this out to disable threads\n//#define INSERT_WASTE //uncomment this to insert waste computation into dist function\n\n#define CACHE_LINE 512 // cache line in byte\n\n/* this structure represents a point */\n/* these will be passed around to avoid copying coordinates */\ntypedef struct {\n  float weight;\n  float *coord;\n  long assign;  /* number of point where this one is assigned */\n  float cost;  /* cost of that assignment, weight*distance */\n} Point;\n\n/* this is the array of points */\ntypedef struct {\n  long num; /* number of points; may not be N if this is a sample */\n  int dim;  /* dimensionality */\n  Point *p; /* the array itself */\n} Points;\n\nstatic bool *switch_membership; //whether to switch membership in pgain\nstatic bool* is_center; //whether a point is a center\nstatic int* center_table; //index table of centers\nfloat* block;\n\nstatic int nproc; //# of threads\nstatic int c, d;\nstatic int ompthreads;\n\n// instrumentation code\n#ifdef PROFILE\ndouble time_local_search;\ndouble time_speedy;\ndouble time_select_feasible;\ndouble time_gain;\ndouble time_shuffle;\ndouble time_gain_dist;\ndouble time_gain_init;\n#endif \n\ndouble gettime() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return (double)t.tv_sec+t.tv_usec*1e-6;\n}\n\nint isIdentical(float *i, float *j, int D)\n// tells whether two points of D dimensions are identical\n{\n  int a = 0;\n  int equal = 1;\n\n  while (equal && a < D) {\n    if (i[a] != j[a]) equal = 0;\n    else a++;\n  }\n  if (equal) return 1;\n  else return 0;\n\n}\n\n/* comparator for floating point numbers */\nstatic int floatcomp(const void *i, const void *j)\n{\n  float a, b;\n  a = *(float *)(i);\n  b = *(float *)(j);\n  if (a > b) return (1);\n  if (a < b) return (-1);\n  return(0);\n}\n\n/* shuffle points into random order */\nvoid shuffle(Points *points)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n  long i, j;\n  Point temp;\n  for (i=0;i<points->num-1;i++) {\n    j=(lrand48()%(points->num - i)) + i;\n    temp = points->p[i];\n    points->p[i] = points->p[j];\n    points->p[j] = temp;\n  }\n#ifdef PROFILE\n  double t2 = gettime();\n  time_shuffle += t2-t1;\n#endif\n}\n\n/* shuffle an array of integers */\nvoid intshuffle(int *intarray, int length)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n  long i, j;\n  int temp;\n  for (i=0;i<length;i++) {\n    j=(lrand48()%(length - i))+i;\n    temp = intarray[i];\n    intarray[i]=intarray[j];\n    intarray[j]=temp;\n  }\n#ifdef PROFILE\n  double t2 = gettime();\n  time_shuffle += t2-t1;\n#endif\n}\n\n#ifdef INSERT_WASTE\ndouble waste(double s )\n{\n  for( int i =0 ; i< 4; i++ ) {\n    s += pow(s,0.78);\n  }\n  return s;\n}\n#endif\n\n/* compute Euclidean distance squared between two points */\nfloat dist(Point p1, Point p2, int dim)\n{\n  int i;\n  float result=0.0;\n  for (i=0;i<dim;i++)\n    result += (p1.coord[i] - p2.coord[i])*(p1.coord[i] - p2.coord[i]);\n#ifdef INSERT_WASTE\n  double s = waste(result);\n  result += s;\n  result -= s;\n#endif\n  return(result);\n}\n\n/* run speedy on the points, return total cost of solution */\nfloat pspeedy(Points *points, float z, long *kcenter, int pid, pthread_barrier_t* barrier)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n  static double totalcost;\n\n  static bool open = false;\n  static double* costs; //cost for each thread. \n  static int i;\n\n#ifdef ENABLE_THREADS\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n#endif\n\n#ifdef PRINTINFO\n  if( pid == 0 ){\n    fprintf(stderr, "Speedy: facility cost %lf\n", z);\n  }\n#endif\n\n  /* create center at first point, send it to itself */\n  for( int k = k1; k < k2; k++ )    {\n    float distance = dist(points->p[k],points->p[0],points->dim);\n    points->p[k].cost = distance * points->p[k].weight;\n    points->p[k].assign=0;\n  }\n\n  if( pid==0 )   {\n    *kcenter = 1;\n    costs = (double*)malloc(sizeof(double)*nproc);\n  }\n    \n  if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.\n    while(1) {\n#ifdef ENABLE_THREADS\n      pthread_mutex_lock(&mutex);\n      while(!open) pthread_cond_wait(&cond,&mutex);\n      pthread_mutex_unlock(&mutex);\n#endif\n      if( i >= points->num ) break;\n      for( int k = k1; k < k2; k++ )\n	{\n	  float distance = dist(points->p[i],points->p[k],points->dim);\n	  if( distance*points->p[k].weight < points->p[k].cost )\n	    {\n	      points->p[k].cost = distance * points->p[k].weight;\n	      points->p[k].assign=i;\n	    }\n	}\n#ifdef ENABLE_THREADS\n      pthread_barrier_wait(barrier);\n      pthread_barrier_wait(barrier);\n#endif\n    } \n  }\n  else  { // I am the master thread. I decide whether to open a center and notify others if so. \n    for(i = 1; i < points->num; i++ )  {\n      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);\n      if( to_open )  {\n	(*kcenter)++;\n#ifdef ENABLE_THREADS\n	pthread_mutex_lock(&mutex);\n#endif\n	open = true;\n#ifdef ENABLE_THREADS\n	pthread_mutex_unlock(&mutex);\n	pthread_cond_broadcast(&cond);\n#endif\n	for( int k = k1; k < k2; k++ )  {\n	  float distance = dist(points->p[i],points->p[k],points->dim);\n	  if( distance*points->p[k].weight < points->p[k].cost )  {\n	    points->p[k].cost = distance * points->p[k].weight;\n	    points->p[k].assign=i;\n	  }\n	}\n#ifdef ENABLE_THREADS\n	pthread_barrier_wait(barrier);\n#endif\n	open = false;\n#ifdef ENABLE_THREADS\n	pthread_barrier_wait(barrier);\n#endif\n      }\n    }\n#ifdef ENABLE_THREADS\n    pthread_mutex_lock(&mutex);\n#endif\n    open = true;\n#ifdef ENABLE_THREADS\n    pthread_mutex_unlock(&mutex);\n    pthread_cond_broadcast(&cond);\n#endif\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  open = false;\n  double mytotal = 0;\n  for( int k = k1; k < k2; k++ )  {\n    mytotal += points->p[k].cost;\n  }\n  costs[pid] = mytotal;\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  // aggregate costs from each thread\n  if( pid == 0 )\n    {\n      totalcost=z*(*kcenter);\n      for( int i = 0; i < nproc; i++ )\n	{\n	  totalcost += costs[i];\n	} \n      free(costs);\n    }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    {\n      fprintf(stderr, "Speedy opened %d facilities for total cost %lf\n",\n	      *kcenter, totalcost);\n      fprintf(stderr, "Distance Cost %lf\n", totalcost - z*(*kcenter));\n    }\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  if( pid== 0 ) {\n    time_speedy += t2 -t1;\n  }\n#endif\n  return(totalcost);\n}\n\n\n/* For a given point x, find the cost of the following operation:\n * -- open a facility at x if there isn't already one there,\n * -- for points y such that the assignment distance of y exceeds dist(y, x),\n *    make y a member of x,\n * -- for facilities y such that reassigning y and all its members to x \n *    would save cost, realize this closing and reassignment.\n * \n * If the cost of this operation is negative (i.e., if this entire operation\n * saves cost), perform this operation and return the amount of cost saved;\n * otherwise, do nothing.\n */\n\n/* numcenters will be updated to reflect the new number of centers */\n/* z is the facility cost, x is the number of this point in the array \n   points */\n\ndouble pgain(long x, Points *points, double z, long int *numcenters, int pid, pthread_barrier_t* barrier)\n{\n  //  printf("pgain pthread %d begin\n",pid);\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n#ifdef PROFILE\n  double t0 = gettime();\n#endif	\n\n	\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n  int i;\n  int number_of_centers_to_close = 0;\n\n  static double *work_mem;\n  static double gl_cost_of_opening_x;\n  static int gl_number_of_centers_to_close;\n	\n  //each thread takes a block of working_mem.\n  int stride = *numcenters+2;\n  //make stride a multiple of CACHE_LINE\n  int cl = CACHE_LINE/sizeof(double);\n  if( stride % cl != 0 ) { \n    stride = cl * ( stride / cl + 1);\n  }\n  int K = stride -2 ; // K==*numcenters\n  \n  //my own cost of opening x\n  double cost_of_opening_x = 0;\n\n  if( pid==0 )    { \n    work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));\n    gl_cost_of_opening_x = 0;\n    gl_number_of_centers_to_close = 0;\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  /*For each center, we have a *lower* field that indicates \n    how much we will save by closing the center. \n    Each thread has its own copy of the *lower* fields as an array.\n    We first build a table to index the positions of the *lower* fields. \n  */\n	\n  int count = 0;\n  for( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      center_table[i] = count++;\n    }		\n  }	\n  work_mem[pid*stride] = count;\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  if( pid == 0 ) {\n    int accum = 0;\n    for( int p = 0; p < nproc; p++ ) {\n      int tmp = (int)work_mem[p*stride];\n      work_mem[p*stride] = accum;\n      accum += tmp;\n    }\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  for( int i = k1; i < k2; i++ ) {		\n    if( is_center[i] ) {\n      center_table[i] += (int)work_mem[pid*stride];\n    }		\n  }	\n	\n  //now we finish building the table. clear the working memory.\n  memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));\n  memset(work_mem+pid*stride, 0, stride*sizeof(double));\n  if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));\n	\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n#ifdef PROFILE\n  double t1 = gettime();\n  if( pid == 0 ) time_gain_init += t1-t0;\n#endif\n  //my *lower* fields\n  double* lower = &work_mem[pid*stride];\n  //global *lower* fields\n  double* gl_lower = &work_mem[nproc*stride];\n	\n	// OpenMP parallelization\n//	#pragma omp parallel for \n	#pragma omp parallel for reduction(+: cost_of_opening_x)\n  for ( i = k1; i < k2; i++ ) {\n    float x_cost = dist(points->p[i], points->p[x], points->dim) \n      * points->p[i].weight;\n    float current_cost = points->p[i].cost;\n		\n    if ( x_cost < current_cost ) {\n\n      // point i would save cost just by switching to x\n      // (note that i cannot be a median, \n      // or else dist(p[i], p[x]) would be 0)			\n      switch_membership[i] = 1;\n      cost_of_opening_x += x_cost - current_cost;			\n    } else {\n\n      // cost of assigning i to x is at least current assignment cost of i\n\n      // consider the savings that i's **current** median would realize\n      // if we reassigned that median and all its members to x;\n      // note we've already accounted for the fact that the median\n      // would save z by closing; now we have to subtract from the savings\n      // the extra cost of reassigning that median and its members \n      int assign = points->p[i].assign;\n      lower[center_table[assign]] += current_cost - x_cost;			\n    }\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif	\n#ifdef PROFILE\n  double t2 = gettime();\n  if( pid==0){\n    time_gain_dist += t2 - t1;\n  }\n#endif	\n  // at this time, we can calculate the cost of opening a center\n  // at x; if it is negative, we'll go through with opening it\n	\n	\n  for ( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      double low = z;\n      //aggregate from all threads\n      for( int p = 0; p < nproc; p++ ) {\n				low += work_mem[center_table[i]+p*stride];\n      }\n      gl_lower[center_table[i]] = low;\n			//printf("%d : %f %f\n", i, low, work_mem[center_table[i]+stride]);\n      if ( low > 0 ) {\n	// i is a median, and\n	// if we were to open x (which we still may not) we'd close i\n\n	// note, we'll ignore the following quantity unless we do open x\n	++number_of_centers_to_close;  \n	cost_of_opening_x -= low;\n      }\n    }\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n		\n  //use the rest of working memory to store the following\n  work_mem[pid*stride + K] = number_of_centers_to_close;\n  work_mem[pid*stride + K+1] = cost_of_opening_x;\n	\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  //  printf("thread %d cost complete\n",pid); \n\n  if( pid==0 ) {\n    gl_cost_of_opening_x = z;\n    //aggregate\n    for( int p = 0; p < nproc; p++ ) {\n      gl_number_of_centers_to_close += (int)work_mem[p*stride + K];\n      gl_cost_of_opening_x += work_mem[p*stride+K+1];\n    }\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  // Now, check whether opening x would save cost; if so, do it, and\n  // otherwise do nothing\n\n  if ( gl_cost_of_opening_x < 0 ) {\n    //  we'd save money by opening x; we'll do it\n		#pragma omp parallel for\n    for ( int i = k1; i < k2; i++ ) {\n      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;\n      if ( switch_membership[i] || close_center ) {\n				// Either i's median (which may be i itself) is closing,\n				// or i is closer to x than to its current median\n				points->p[i].cost = points->p[i].weight *\n					dist(points->p[i], points->p[x], points->dim);\n				points->p[i].assign = x;\n      }\n    }\n		\n    for( int i = k1; i < k2; i++ ) {\n      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {\n				is_center[i] = false;\n      }\n    }\n    if( x >= k1 && x < k2 ) {\n      is_center[x] = true;\n    }\n    //    pthread_barrier_wait(barrier);\n\n    if( pid==0 ) {\n      *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;\n    }\n  }\n  else {\n    if( pid==0 )\n      gl_cost_of_opening_x = 0;  // the value we'll return\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  if( pid == 0 ) {\n    free(work_mem);\n    //    free(is_center);\n    //    free(switch_membership);\n    //    free(proc_cost_of_opening_x);\n    //    free(proc_number_of_centers_to_close);\n  }\n\n#ifdef PROFILE\n  double t3 = gettime();\n  if( pid==0 )\n  time_gain += t3-t0;\n#endif\n	//printf("cost=%f\n", -gl_cost_of_opening_x);\n  return -gl_cost_of_opening_x;\n}\n\n\n/* facility location on the points using local search */\n/* z is the facility cost, returns the total cost and # of centers */\n/* assumes we are seeded with a reasonable solution */\n/* cost should represent this solution's cost */\n/* halt if there is < e improvement after iter calls to gain */\n/* feasible is an array of numfeasible points which may be centers */\n\nfloat pFL(Points *points, int *feasible, int numfeasible,\n	  float z, long *k, double cost, long iter, float e, \n	  int pid, pthread_barrier_t* barrier)\n{\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  long i;\n  long x;\n  double change;\n  long numberOfPoints;\n\n  change = cost;\n  /* continue until we run iter iterations without improvement */\n  /* stop instead if improvement is less than e */\n  while (change/cost > 1.0*e) {\n    change = 0.0;\n    numberOfPoints = points->num;\n    /* randomize order in which centers are considered */\n\n    if( pid == 0 ) {\n      intshuffle(feasible, numfeasible);\n    }\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n    for (i=0;i<iter;i++) {\n      x = i%numfeasible;\n			//printf("iteration %d started********\n", i);\n      change += pgain(feasible[x], points, z, k, pid, barrier);\n			c++;\n			//printf("iteration %d finished @@@@@@\n", i);\n    }\n\n    cost -= change;\n#ifdef PRINTINFO\n    if( pid == 0 ) {\n      fprintf(stderr, "%d centers, cost %lf, total distance %lf\n",\n	      *k, cost, cost - z*(*k));\n    }\n#endif\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n  }\n  return(cost);\n}\n\nint selectfeasible_fast(Points *points, int **feasible, int kmin, int pid, pthread_barrier_t* barrier)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n  int numfeasible = points->num;\n  if (numfeasible > (ITER*kmin*log((double)kmin)))\n    numfeasible = (int)(ITER*kmin*log((double)kmin));\n  *feasible = (int *)malloc(numfeasible*sizeof(int));\n  \n  float* accumweight;\n  float totalweight;\n\n  /* \n     Calcuate my block. \n     For now this routine does not seem to be the bottleneck, so it is not parallelized. \n     When necessary, this can be parallelized by setting k1 and k2 to \n     proper values and calling this routine from all threads ( it is called only\n     by thread 0 for now ). \n     Note that when parallelized, the randomization might not be the same and it might\n     not be difficult to measure the parallel speed-up for the whole program. \n   */\n  //  long bsize = numfeasible;\n  long k1 = 0;\n  long k2 = numfeasible;\n\n  float w;\n  int l,r,k;\n\n  /* not many points, all will be feasible */\n  if (numfeasible == points->num) {\n    for (int i=k1;i<k2;i++)\n      (*feasible)[i] = i;\n    return numfeasible;\n  }\n\n  accumweight= (float*)malloc(sizeof(float)*points->num);\n  accumweight[0] = points->p[0].weight;\n  totalweight=0;\n  for( int i = 1; i < points->num; i++ ) {\n    accumweight[i] = accumweight[i-1] + points->p[i].weight;\n  }\n  totalweight=accumweight[points->num-1];\n\n  for(int i=k1; i<k2; i++ ) {\n    w = (lrand48()/(float)INT_MAX)*totalweight;\n    //binary search\n    l=0;\n    r=points->num-1;\n    if( accumweight[0] > w )  { \n      (*feasible)[i]=0; \n      continue;\n    }\n    while( l+1 < r ) {\n      k = (l+r)/2;\n      if( accumweight[k] > w ) {\n	r = k;\n      } \n      else {\n	l=k;\n      }\n    }\n    (*feasible)[i]=r;\n  }\n\n  free(accumweight); \n\n#ifdef PROFILE\n  double t2 = gettime();\n  time_select_feasible += t2-t1;\n#endif\n  return numfeasible;\n}\n\n/* compute approximate kmedian on the points */\nfloat pkmedian(Points *points, long kmin, long kmax, long* kfinal,\n	       int pid, pthread_barrier_t* barrier )\n{\n  int i;\n  double cost;\n  double lastcost;\n  double hiz, loz, z;\n\n  static long k;\n  static int *feasible;\n  static int numfeasible;\n  static double* hizs;\n\n  if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));\n  hiz = loz = 0.0;\n  long numberOfPoints = points->num;\n  long ptDimension = points->dim;\n\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    {\n      printf("Starting Kmedian procedure\n");\n      printf("%i points in %i dimensions\n", numberOfPoints, ptDimension);\n    }\n#endif\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  double myhiz = 0;\n  for (long kk=k1;kk < k2; kk++ ) {\n    myhiz += dist(points->p[kk], points->p[0],\n		      ptDimension)*points->p[kk].weight;\n  }\n  hizs[pid] = myhiz;\n\n#ifdef ENABLE_THREADS  \n  pthread_barrier_wait(barrier);\n#endif\n\n  for( int i = 0; i < nproc; i++ )   {\n    hiz += hizs[i];\n  }\n\n  loz=0.0; z = (hiz+loz)/2.0;\n  /* NEW: Check whether more centers than points! */\n  if (points->num <= kmax) {\n    /* just return all points as facilities */\n    for (long kk=k1;kk<k2;kk++) {\n      points->p[kk].assign = kk;\n      points->p[kk].cost = 0;\n    }\n    cost = 0;\n    if( pid== 0 ) {\n      free(hizs); \n      *kfinal = k;\n    }\n    return cost;\n  }\n\n  if( pid == 0 ) shuffle(points);\n  cost = pspeedy(points, z, &k, pid, barrier);\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    printf("thread %d: Finished first call to speedy, cost=%lf, k=%i\n",pid,cost,k);\n#endif\n  i=0;\n  /* give speedy SP chances to get at least kmin/2 facilities */\n  while ((k < kmin)&&(i<SP)) {\n    cost = pspeedy(points, z, &k, pid, barrier);\n    i++;\n  }\n\n#ifdef PRINTINFO\n  if( pid==0)\n    printf("thread %d: second call to speedy, cost=%lf, k=%d\n",pid,cost,k);\n#endif \n  /* if still not enough facilities, assume z is too high */\n  while (k < kmin) {\n#ifdef PRINTINFO\n    if( pid == 0 ) {\n      printf("%lf %lf\n", loz, hiz);\n      printf("Speedy indicates we should try lower z\n");\n    }\n#endif\n    if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}\n    if( pid == 0 ) shuffle(points);\n    cost = pspeedy(points, z, &k, pid, barrier);\n    i++;\n  }\n\n  /* now we begin the binary search for real */\n  /* must designate some points as feasible centers */\n  /* this creates more consistancy between FL runs */\n  /* helps to guarantee correct # of centers at the end */\n  \n  if( pid == 0 )\n    {\n      numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);\n      for( int i = 0; i< points->num; i++ ) {\n	is_center[points->p[i].assign]= true;\n      }\n    }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  while(1) {\n		d++;\n#ifdef PRINTINFO\n    if( pid==0 )\n      {\n	printf("loz = %lf, hiz = %lf\n", loz, hiz);\n	printf("Running Local Search...\n");\n      }\n#endif\n    /* first get a rough estimate on the FL solution */\n    //    pthread_barrier_wait(barrier);\n\n    lastcost = cost;\n    cost = pFL(points, feasible, numfeasible,\n	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);\n\n    /* if number of centers seems good, try a more accurate FL */\n    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||\n	((k <= kmax+2)&&(k >= kmin-2))) {\n\n#ifdef PRINTINFO\n      if( pid== 0)\n	{\n	  printf("Trying a more accurate local search...\n");\n	}\n#endif\n      /* may need to run a little longer here before halting without\n	 improvement */\n      cost = pFL(points, feasible, numfeasible,\n		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);\n    }\n\n    if (k > kmax) {\n      /* facilities too cheap */\n      /* increase facility cost and up the cost accordingly */\n      loz = z; z = (hiz+loz)/2.0;\n      cost += (z-loz)*k;\n    }\n    if (k < kmin) {\n      /* facilities too expensive */\n      /* decrease facility cost and reduce the cost accordingly */\n      hiz = z; z = (hiz+loz)/2.0;\n      cost += (z-hiz)*k;\n    }\n\n    /* if k is good, return the result */\n    /* if we're stuck, just give up and return what we have */\n    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )\n      { \n	break;\n      }\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n  }\n\n  //clean up...\n  if( pid==0 ) {\n    free(feasible); \n    free(hizs);\n    *kfinal = k;\n  }\n\n  return cost;\n}\n\n/* compute the means for the k clusters */\nint contcenters(Points *points)\n{\n  long i, ii;\n  float relweight;\n\n  for (i=0;i<points->num;i++) {\n    /* compute relative weight of this point to the cluster */\n    if (points->p[i].assign != i) {\n      relweight=points->p[points->p[i].assign].weight + points->p[i].weight;\n      relweight = points->p[i].weight/relweight;\n      for (ii=0;ii<points->dim;ii++) {\n	points->p[points->p[i].assign].coord[ii]*=1.0-relweight;\n	points->p[points->p[i].assign].coord[ii]+=\n	  points->p[i].coord[ii]*relweight;\n      }\n      points->p[points->p[i].assign].weight += points->p[i].weight;\n    }\n  }\n  \n  return 0;\n}\n\n/* copy centers from points to centers */\nvoid copycenters(Points *points, Points* centers, long* centerIDs, long offset)\n{\n  long i;\n  long k;\n\n  bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));\n\n  /* mark the centers */\n  for ( i = 0; i < points->num; i++ ) {\n    is_a_median[points->p[i].assign] = 1;\n  }\n\n  k=centers->num;\n\n  /* count how many  */\n  for ( i = 0; i < points->num; i++ ) {\n    if ( is_a_median[i] ) {\n      memcpy( centers->p[k].coord, points->p[i].coord, points->dim * sizeof(float));\n      centers->p[k].weight = points->p[i].weight;\n      centerIDs[k] = i + offset;\n      k++;\n    }\n  }\n\n  centers->num = k;\n\n  free(is_a_median);\n}\n\nstruct pkmedian_arg_t\n{\n  Points* points;\n  long kmin;\n  long kmax;\n  long* kfinal;\n  int pid;\n  pthread_barrier_t* barrier;\n};\n\nvoid* localSearchSub(void* arg_) {\n\n  pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;\n  pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);\n\n  return NULL;\n}\n\nvoid localSearch( Points* points, long kmin, long kmax, long* kfinal ) {\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n    pthread_barrier_t barrier;\n#ifdef ENABLE_THREADS\n    pthread_barrier_init(&barrier,NULL,nproc);\n#endif\n    pthread_t* threads = new pthread_t[nproc];\n    pkmedian_arg_t* arg = new pkmedian_arg_t[nproc];\n\n\n    for( int i = 0; i < nproc; i++ ) {\n      arg[i].points = points;\n      arg[i].kmin = kmin;\n      arg[i].kmax = kmax;\n      arg[i].pid = i;\n      arg[i].kfinal = kfinal;\n\n      arg[i].barrier = &barrier;\n#ifdef ENABLE_THREADS\n      pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);\n#else\n      localSearchSub(&arg[0]);\n#endif\n    }\n\n    for ( int i = 0; i < nproc; i++) {\n#ifdef ENABLE_THREADS\n      pthread_join(threads[i],NULL);\n#endif\n    }\n\n    delete[] threads;\n    delete[] arg;\n#ifdef ENABLE_THREADS\n    pthread_barrier_destroy(&barrier);\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  time_local_search += t2-t1;\n#endif\n \n}\n\nclass PStream {\npublic:\n  virtual size_t read( float* dest, int dim, int num ) = 0;\n  virtual int ferror() = 0;\n  virtual int feof() = 0;\n  virtual ~PStream() {\n  }\n};\n\n//synthetic stream\nclass SimStream : public PStream {\npublic:\n  SimStream(long n_ ) {\n    n = n_;\n  }\n  size_t read( float* dest, int dim, int num ) {\n    size_t count = 0;\n    for( int i = 0; i < num && n > 0; i++ ) {\n      for( int k = 0; k < dim; k++ ) {\n	dest[i*dim + k] = lrand48()/(float)INT_MAX;\n      }\n      n--;\n      count++;\n    }\n    return count;\n  }\n  int ferror() {\n    return 0;\n  }\n  int feof() {\n    return n <= 0;\n  }\n  ~SimStream() { \n  }\nprivate:\n  long n;\n};\n\nclass FileStream : public PStream {\npublic:\n  FileStream(char* filename) {\n    fp = fopen( filename, "rb");\n    if( fp == NULL ) {\n      fprintf(stderr,"error opening file %s\n.",filename);\n      exit(1);\n    }\n  }\n  size_t read( float* dest, int dim, int num ) {\n    return std::fread(dest, sizeof(float)*dim, num, fp); \n  }\n  int ferror() {\n    return std::ferror(fp);\n  }\n  int feof() {\n    return std::feof(fp);\n  }\n  ~FileStream() {\n    printf("closing file stream\n");\n    fclose(fp);\n  }\nprivate:\n  FILE* fp;\n};\n\nvoid outcenterIDs( Points* centers, long* centerIDs, char* outfile ) {\n  FILE* fp = fopen(outfile, "w");\n  if( fp==NULL ) {\n    fprintf(stderr, "error opening %s\n",outfile);\n    exit(1);\n  }\n  int* is_a_median = (int*)calloc( sizeof(int), centers->num );\n  for( int i =0 ; i< centers->num; i++ ) {\n    is_a_median[centers->p[i].assign] = 1;\n  }\n\n  for( int i = 0; i < centers->num; i++ ) {\n    if( is_a_median[i] ) {\n      fprintf(fp, "%u\n", centerIDs[i]);\n      fprintf(fp, "%lf\n", centers->p[i].weight);\n      for( int k = 0; k < centers->dim; k++ ) {\n	fprintf(fp, "%lf ", centers->p[i].coord[k]);\n      }\n      fprintf(fp,"\n\n");\n    }\n  }\n  fclose(fp);\n}\n\nvoid streamCluster( PStream* stream, \n		    long kmin, long kmax, int dim,\n		    long chunksize, long centersize, char* outfile )\n{\n  block = (float*)malloc( chunksize*dim*sizeof(float) );\n  float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );\n  long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));\n\n  if( block == NULL ) { \n    fprintf(stderr,"not enough memory for a chunk!\n");\n    exit(1);\n  }\n\n  Points points;\n  points.dim = dim;\n  points.num = chunksize;\n  points.p = (Point *)malloc(chunksize*sizeof(Point));\n  for( int i = 0; i < chunksize; i++ ) {		\n    points.p[i].coord = &block[i*dim];\n  }\n\n	\n	\n  Points centers;\n  centers.dim = dim;\n  centers.p = (Point *)malloc(centersize*sizeof(Point));\n  centers.num = 0;\n\n  for( int i = 0; i< centersize; i++ ) {\n    centers.p[i].coord = &centerBlock[i*dim];\n    centers.p[i].weight = 1.0;\n  }\n\n  long IDoffset = 0;\n  long kfinal;\n  while(1) {\n\n    size_t numRead  = stream->read(block, dim, chunksize ); \n    fprintf(stderr,"read %d points\n",numRead);\n\n    if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {\n      fprintf(stderr, "error reading data!\n");\n      exit(1);\n    }\n\n    points.num = numRead;\n    for( int i = 0; i < points.num; i++ ) {\n      points.p[i].weight = 1.0;\n    }\n\n    switch_membership = (bool*)malloc(points.num*sizeof(bool));\n    is_center = (bool*)calloc(points.num,sizeof(bool));\n    center_table = (int*)malloc(points.num*sizeof(int));\n\n    localSearch(&points,kmin, kmax,&kfinal);\n\n    fprintf(stderr,"finish local search\n");\n    contcenters(&points);\n    if( kfinal + centers.num > centersize ) {\n      //here we don't handle the situation where # of centers gets too large. \n      fprintf(stderr,"oops! no more space for centers\n");\n      exit(1);\n    }\n\n#ifdef PRINTINFO\n    printf("finish cont center\n");\n#endif\n\n    copycenters(&points, &centers, centerIDs, IDoffset);\n    IDoffset += numRead;\n\n#ifdef PRINTINFO\n    printf("finish copy centers\n"); \n#endif\n\n    free(is_center);\n    free(switch_membership);\n    free(center_table);\n\n    if( stream->feof() ) {\n      break;\n    }\n  }\n\n  //finally cluster all temp centers\n  switch_membership = (bool*)malloc(centers.num*sizeof(bool));\n  is_center = (bool*)calloc(centers.num,sizeof(bool));\n  center_table = (int*)malloc(centers.num*sizeof(int));\n\n  localSearch( &centers, kmin, kmax ,&kfinal );\n  contcenters(&centers);\n  outcenterIDs( &centers, centerIDs, outfile);\n}\n\nint main(int argc, char **argv)\n{\n  char *outfilename = new char[MAXNAMESIZE];\n  char *infilename = new char[MAXNAMESIZE];\n  long kmin, kmax, n, chunksize, clustersize;\n  int dim;\n	int numthreads;\n	c = 0;\n	d = 0;\n#ifdef PARSEC_VERSION\n#define __PARSEC_STRING(x) #x\n#define __PARSEC_XSTRING(x) __PARSEC_STRING(x)\n        printf("PARSEC Benchmark Suite Version "__PARSEC_XSTRING(PARSEC_VERSION)"\n");\n	fflush(NULL);\n#else\n        printf("PARSEC Benchmark Suite\n");\n	fflush(NULL);\n#endif //PARSEC_VERSION\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_bench_begin(__parsec_streamcluster);\n#endif\n\n  if (argc<10) {\n    fprintf(stderr,"usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n",\n	    argv[0]);\n    fprintf(stderr,"  k1:          Min. number of centers allowed\n");\n    fprintf(stderr,"  k2:          Max. number of centers allowed\n");\n    fprintf(stderr,"  d:           Dimension of each data point\n");\n    fprintf(stderr,"  n:           Number of data points\n");\n    fprintf(stderr,"  chunksize:   Number of data points to handle per step\n");\n    fprintf(stderr,"  clustersize: Maximum number of intermediate centers\n");\n    fprintf(stderr,"  infile:      Input file (if n<=0)\n");\n    fprintf(stderr,"  outfile:     Output file\n");\n    fprintf(stderr,"  nproc:       Number of threads to use\n");\n    fprintf(stderr,"\n");\n    fprintf(stderr, "if n > 0, points will be randomly generated instead of reading from infile.\n");\n    exit(1);\n  }\n  kmin = atoi(argv[1]);\n  kmax = atoi(argv[2]);\n  dim = atoi(argv[3]);\n  n = atoi(argv[4]);\n  chunksize = atoi(argv[5]);\n  clustersize = atoi(argv[6]);\n  strcpy(infilename, argv[7]);\n  strcpy(outfilename, argv[8]);\n  nproc = atoi(argv[9]);\n	\n	ompthreads = nproc;\n	nproc = 1;\n	omp_set_num_threads(ompthreads);\n	\n  srand48(SEED);\n  PStream* stream;\n  if( n > 0 ) {\n    stream = new SimStream(n);\n  }\n  else {\n    stream = new FileStream(infilename);\n  }\n\n  double t1 = gettime();\n\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_roi_begin();\n#endif\n  streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_roi_end();\n#endif\n\n  double t2 = gettime();\n\n  printf("time = %lf\n",t2-t1);\n\n  delete stream;\n\n  printf("time pgain = %lf\n", time_gain);\n  printf("time pgain_dist = %lf\n", time_gain_dist);\n  printf("time pgain_init = %lf\n", time_gain_init);\n  printf("time pselect = %lf\n", time_select_feasible);\n  printf("time pspeedy = %lf\n", time_speedy);\n  printf("time pshuffle = %lf\n", time_shuffle);\n  printf("time localSearch = %lf\n", time_local_search);\n	printf("loops=%d\n", d);\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_bench_end();\n#endif\n  \n  return 0;\n}\n