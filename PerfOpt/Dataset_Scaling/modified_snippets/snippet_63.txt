\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  This file contains the routines needed to perform QR factorisation\n  of matrices, as well as Householder transformations.\n  The internal "factored form" of a matrix A is not quite standard.\n  The diagonal of A is replaced by the diagonal of R -- not by the 1st non-zero\n  entries of the Householder vectors. The 1st non-zero entries are held in\n  the diag parameter of QRfactor(). The reason for this non-standard\n  representation is that it enables direct use of the Usolve() function\n  rather than requiring that  a seperate function be written just for this case.\n  See, e.g., QRsolve() below for more details.\n\n  Complex version\n  \n*/\n\nstatic	char	rcsid[] = "$Id: zqrfctr.c,v 1.1 1994/01/13 04:21:22 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"zmatrix.h"\n#include	"zmatrix2.h" \n\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n\n#define		sign(x)	((x) > 0.0 ? 1 : ((x) < 0.0 ? -1 : 0 ))\n\n/* Note: The usual representation of a Householder transformation is taken\n   to be:\n   P = I - beta.u.u*\n   where beta = 2/(u*.u) and u is called the Householder vector\n   (u* is the conjugate transposed vector of u\n*/\n\n/* zQRfactor -- forms the QR factorisation of A\n	-- factorisation stored in compact form as described above\n	(not quite standard format) */\nZMAT	*zQRfactor(A,diag)\nZMAT	*A;\nZVEC	*diag;\n{\n    unsigned int	k,limit;\n    Real	beta;\n    STATIC	ZVEC	*tmp1=ZVNULL, *w=ZVNULL;\n    \n    if ( ! A || ! diag )\n	error(E_NULL,"zQRfactor");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit )\n	error(E_SIZES,"zQRfactor");\n    \n    tmp1 = zv_resize(tmp1,A->m);\n    w    = zv_resize(w,   A->n);\n    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n    MEM_STAT_REG(w,   TYPE_ZVEC);\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* get H/holder vector for the k-th column */\n	zget_col(A,k,tmp1);\n	zhhvec(tmp1,k,&beta,tmp1,&A->me[k][k]);\n	diag->ve[k] = tmp1->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	tracecatch(_zhhtrcols(A,k,k+1,tmp1,beta,w),"zQRfactor");\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp1);	ZV_FREE(w);\n#endif\n\n    return (A);\n}\n\n/* zQRCPfactor -- forms the QR factorisation of A with column pivoting\n   -- factorisation stored in compact form as described above\n   ( not quite standard format )				*/\nZMAT	*zQRCPfactor(A,diag,px)\nZMAT	*A;\nZVEC	*diag;\nPERM	*px;\n{\n    unsigned int	i, i_max, j, k, limit;\n    STATIC	ZVEC	*tmp1=ZVNULL, *tmp2=ZVNULL, *w=ZVNULL;\n    STATIC	VEC	*gamma=VNULL;\n    Real 	beta;\n    Real	maxgamma, sum, tmp;\n    complex	ztmp;\n    \n    if ( ! A || ! diag || ! px )\n	error(E_NULL,"QRCPfactor");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit || px->size != A->n )\n	error(E_SIZES,"QRCPfactor");\n    \n    tmp1 = zv_resize(tmp1,A->m);\n    tmp2 = zv_resize(tmp2,A->m);\n    gamma = v_resize(gamma,A->n);\n    w    = zv_resize(w,A->n);\n    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n    MEM_STAT_REG(tmp2,TYPE_ZVEC);\n    MEM_STAT_REG(gamma,TYPE_VEC);\n    MEM_STAT_REG(w,   TYPE_ZVEC);\n    \n    /* initialise gamma and px */\n    for ( j=0; j<A->n; j++ )\n    {\n	px->pe[j] = j;\n	sum = 0.0;\n	for ( i=0; i<A->m; i++ )\n	    sum += square(A->me[i][j].re) + square(A->me[i][j].im);\n	gamma->ve[j] = sum;\n    }\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* find "best" column to use */\n	i_max = k;	maxgamma = gamma->ve[k];\n	for ( i=k+1; i<A->n; i++ )\n	    /* Loop invariant:maxgamma=gamma[i_max]\n	       >=gamma[l];l=k,...,i-1 */\n	    if ( gamma->ve[i] > maxgamma )\n	    {	maxgamma = gamma->ve[i]; i_max = i;	}\n	\n	/* swap columns if necessary */\n	if ( i_max != k )\n	{\n	    /* swap gamma values */\n	    tmp = gamma->ve[k];\n	    gamma->ve[k] = gamma->ve[i_max];\n	    gamma->ve[i_max] = tmp;\n	    \n	    /* update column permutation */\n	    px_transp(px,k,i_max);\n	    \n	    /* swap columns of A */\n	    for ( i=0; i<A->m; i++ )\n	    {\n		ztmp = A->me[i][k];\n		A->me[i][k] = A->me[i][i_max];\n		A->me[i][i_max] = ztmp;\n	    }\n	}\n	\n	/* get H/holder vector for the k-th column */\n	zget_col(A,k,tmp1);\n	/* hhvec(tmp1,k,&beta->ve[k],tmp1,&A->me[k][k]); */\n	zhhvec(tmp1,k,&beta,tmp1,&A->me[k][k]);\n	diag->ve[k] = tmp1->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	_zhhtrcols(A,k,k+1,tmp1,beta,w);\n	\n	/* update gamma values */\n	for ( j=k+1; j<A->n; j++ )\n	    gamma->ve[j] -= square(A->me[k][j].re)+square(A->me[k][j].im);\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp1);	ZV_FREE(tmp2);	V_FREE(gamma);	ZV_FREE(w);\n#endif\n    return (A);\n}\n\n/* zQsolve -- solves Qx = b, Q is an orthogonal matrix stored in compact\n	form a la QRfactor()\n	-- may be in-situ */\nZVEC	*_zQsolve(QR,diag,b,x,tmp)\nZMAT	*QR;\nZVEC	*diag, *b, *x, *tmp;\n{\n    unsigned int	dynamic;\n    int		k, limit;\n    Real	beta, r_ii, tmp_val;\n    \n    limit = min(QR->m,QR->n);\n    dynamic = FALSE;\n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,"_zQsolve");\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,"_zQsolve");\n    x = zv_resize(x,QR->m);\n    if ( tmp == ZVNULL )\n	dynamic = TRUE;\n    tmp = zv_resize(tmp,QR->m);\n    \n    /* apply H/holder transforms in normal order */\n    x = zv_copy(b,x);\n    for ( k = 0 ; k < limit ; k++ )\n    {\n	zget_col(QR,k,tmp);\n	r_ii = zabs(tmp->ve[k]);\n	tmp->ve[k] = diag->ve[k];\n	tmp_val = (r_ii*zabs(diag->ve[k]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	/* hhtrvec(tmp,beta->ve[k],k,x,x); */\n	zhhtrvec(tmp,beta,k,x,x);\n    }\n    \n    if ( dynamic )\n	ZV_FREE(tmp);\n    \n    return (x);\n}\n\n/* zmakeQ -- constructs orthogonal matrix from Householder vectors stored in\n   compact QR form */\nZMAT	*zmakeQ(QR,diag,Qout)\nZMAT	*QR,*Qout;\nZVEC	*diag;\n{\n    STATIC	ZVEC	*tmp1=ZVNULL,*tmp2=ZVNULL;\n    unsigned int	i, limit;\n    Real	beta, r_ii, tmp_val;\n    int	j;\n\n    limit = min(QR->m,QR->n);\n    if ( ! QR || ! diag )\n	error(E_NULL,"zmakeQ");\n    if ( diag->dim < limit )\n	error(E_SIZES,"zmakeQ");\n    Qout = zm_resize(Qout,QR->m,QR->m);\n\n    tmp1 = zv_resize(tmp1,QR->m);	/* contains basis vec & columns of Q */\n    tmp2 = zv_resize(tmp2,QR->m);	/* contains H/holder vectors */\n    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n    MEM_STAT_REG(tmp2,TYPE_ZVEC);\n\n    for ( i=0; i<QR->m ; i++ )\n    {	/* get i-th column of Q */\n	/* set up tmp1 as i-th basis vector */\n	for ( j=0; j<QR->m ; j++ )\n	    tmp1->ve[j].re = tmp1->ve[j].im = 0.0;\n	tmp1->ve[i].re = 1.0;\n	\n	/* apply H/h transforms in reverse order */\n	for ( j=limit-1; j>=0; j-- )\n	{\n	    zget_col(QR,j,tmp2);\n	    r_ii = zabs(tmp2->ve[j]);\n	    tmp2->ve[j] = diag->ve[j];\n	    tmp_val = (r_ii*zabs(diag->ve[j]));\n	    beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	    /* hhtrvec(tmp2,beta->ve[j],j,tmp1,tmp1); */\n	    zhhtrvec(tmp2,beta,j,tmp1,tmp1);\n	}\n	\n	/* insert into Q */\n	zset_col(Qout,i,tmp1);\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp1);	ZV_FREE(tmp2);\n#endif\n\n    return (Qout);\n}\n\n/* zmakeR -- constructs upper triangular matrix from QR (compact form)\n	-- may be in-situ (all it does is zero the lower 1/2) */\nZMAT	*zmakeR(QR,Rout)\nZMAT	*QR,*Rout;\n{\n    unsigned int	i,j;\n    \n    if ( QR==ZMNULL )\n	error(E_NULL,"zmakeR");\n    Rout = zm_copy(QR,Rout);\n    \n    for ( i=1; i<QR->m; i++ )\n	for ( j=0; j<QR->n && j<i; j++ )\n	    Rout->me[i][j].re = Rout->me[i][j].im = 0.0;\n    \n    return (Rout);\n}\n\n/* zQRsolve -- solves the system Q.R.x=b where Q & R are stored in compact form\n   -- returns x, which is created if necessary */\nZVEC	*zQRsolve(QR,diag,b,x)\nZMAT	*QR;\nZVEC	*diag, *b, *x;\n{\n    int	limit;\n    STATIC	ZVEC	*tmp = ZVNULL;\n    \n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,"zQRsolve");\n    limit = min(QR->m,QR->n);\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,"zQRsolve");\n    tmp = zv_resize(tmp,limit);\n    MEM_STAT_REG(tmp,TYPE_ZVEC);\n\n    x = zv_resize(x,QR->n);\n    _zQsolve(QR,diag,b,x,tmp);\n    x = zUsolve(QR,x,x,0.0);\n    x = zv_resize(x,QR->n);\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* zQRAsolve -- solves the system (Q.R)*.x = b\n	-- Q & R are stored in compact form\n	-- returns x, which is created if necessary */\nZVEC	*zQRAsolve(QR,diag,b,x)\nZMAT	*QR;\nZVEC	*diag, *b, *x;\n{\n    int		j, limit;\n    Real	beta, r_ii, tmp_val;\n    STATIC	ZVEC	*tmp = ZVNULL;\n    \n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,"zQRAsolve");\n    limit = min(QR->m,QR->n);\n    if ( diag->dim < limit || b->dim != QR->n )\n	error(E_SIZES,"zQRAsolve");\n\n    x = zv_resize(x,QR->m);\n    x = zUAsolve(QR,b,x,0.0);\n    x = zv_resize(x,QR->m);\n\n    tmp = zv_resize(tmp,x->dim);\n    MEM_STAT_REG(tmp,TYPE_ZVEC);\n    /*  printf("zQRAsolve: tmp->dim = %d, x->dim = %d\n", tmp->dim, x->dim); */\n    \n    /* apply H/h transforms in reverse order */\n    for ( j=limit-1; j>=0; j-- )\n    {\n	zget_col(QR,j,tmp);\n	tmp = zv_resize(tmp,QR->m);\n	r_ii = zabs(tmp->ve[j]);\n	tmp->ve[j] = diag->ve[j];\n	tmp_val = (r_ii*zabs(diag->ve[j]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	zhhtrvec(tmp,beta,j,x,x);\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* zQRCPsolve -- solves A.x = b where A is factored by QRCPfactor()\n   -- assumes that A is in the compact factored form */\nZVEC	*zQRCPsolve(QR,diag,pivot,b,x)\nZMAT	*QR;\nZVEC	*diag;\nPERM	*pivot;\nZVEC	*b, *x;\n{\n    if ( ! QR || ! diag || ! pivot || ! b )\n	error(E_NULL,"zQRCPsolve");\n    if ( (QR->m > diag->dim && QR->n > diag->dim) || QR->n != pivot->size )\n	error(E_SIZES,"zQRCPsolve");\n    \n    x = zQRsolve(QR,diag,b,x);\n    x = pxinv_zvec(pivot,x,x);\n\n    return x;\n}\n\n/* zUmlt -- compute out = upper_triang(U).x\n	-- may be in situ */\nZVEC	*zUmlt(U,x,out)\nZMAT	*U;\nZVEC	*x, *out;\n{\n    int		i, limit;\n\n    if ( U == ZMNULL || x == ZVNULL )\n	error(E_NULL,"zUmlt");\n    limit = min(U->m,U->n);\n    if ( limit != x->dim )\n	error(E_SIZES,"zUmlt");\n    if ( out == ZVNULL || out->dim < limit )\n	out = zv_resize(out,limit);\n\n    for ( i = 0; i < limit; i++ )\n	out->ve[i] = __zip__(&(x->ve[i]),&(U->me[i][i]),limit - i,Z_NOCONJ);\n    return out;\n}\n\n/* zUAmlt -- returns out = upper_triang(U)^T.x */\nZVEC	*zUAmlt(U,x,out)\nZMAT	*U;\nZVEC	*x, *out;\n{\n    /* complex	sum; */\n    complex	tmp;\n    int		i, limit;\n\n    if ( U == ZMNULL || x == ZVNULL )\n	error(E_NULL,"zUAmlt");\n    limit = min(U->m,U->n);\n    if ( out == ZVNULL || out->dim < limit )\n	out = zv_resize(out,limit);\n\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	tmp = x->ve[i];\n	out->ve[i].re = out->ve[i].im = 0.0;\n	__zmltadd__(&(out->ve[i]),&(U->me[i][i]),tmp,limit-i-1,Z_CONJ);\n    }\n\n    return out;\n}\n\n\n/* zQRcondest -- returns an estimate of the 2-norm condition number of the\n		matrix factorised by QRfactor() or QRCPfactor()\n	-- note that as Q does not affect the 2-norm condition number,\n		it is not necessary to pass the diag, beta (or pivot) vectors\n	-- generates a lower bound on the true condition number\n	-- if the matrix is exactly singular, HUGE_VAL is returned\n	-- note that QRcondest() is likely to be more reliable for\n		matrices factored using QRCPfactor() */\ndouble	zQRcondest(QR)\nZMAT	*QR;\n{\n    STATIC	ZVEC	*y=ZVNULL;\n    Real	norm, norm1, norm2, tmp1, tmp2;\n    complex	sum, tmp;\n    int		i, j, limit;\n\n    if ( QR == ZMNULL )\n	error(E_NULL,"zQRcondest");\n\n    limit = min(QR->m,QR->n);\n    for ( i = 0; i < limit; i++ )\n	/* if ( QR->me[i][i] == 0.0 ) */\n	if ( is_zero(QR->me[i][i]) )\n	    return HUGE_VAL;\n\n    y = zv_resize(y,limit);\n    MEM_STAT_REG(y,TYPE_ZVEC);\n    /* use the trick for getting a unit vector y with ||R.y||_inf small\n       from the LU condition estimator */\n    for ( i = 0; i < limit; i++ )\n    {\n	sum.re = sum.im = 0.0;\n	for ( j = 0; j < i; j++ )\n	    /* sum -= QR->me[j][i]*y->ve[j]; */\n	    sum = zsub(sum,zmlt(QR->me[j][i],y->ve[j]));\n	/* sum -= (sum < 0.0) ? 1.0 : -1.0; */\n	norm1 = zabs(sum);\n	if ( norm1 == 0.0 )\n	    sum.re = 1.0;\n	else\n	{\n	    sum.re += sum.re / norm1;\n	    sum.im += sum.im / norm1;\n	}\n	/* y->ve[i] = sum / QR->me[i][i]; */\n	y->ve[i] = zdiv(sum,QR->me[i][i]);\n    }\n    zUAmlt(QR,y,y);\n\n    /* now apply inverse power method to R*.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp1,0.0),y,y);\n	zUAsolve(QR,y,y,0.0);\n	tmp2 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp2,0.0),y,y);\n	zUsolve(QR,y,y,0.0);\n    }\n    /* now compute approximation for ||R^{-1}||_2 */\n    norm1 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* now use complementary approach to compute approximation to ||R||_2 */\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	sum.re = sum.im = 0.0;\n	for ( j = i+1; j < limit; j++ )\n	    sum = zadd(sum,zmlt(QR->me[i][j],y->ve[j]));\n	if ( is_zero(QR->me[i][i]) )\n	    return HUGE_VAL;\n	tmp = zdiv(sum,QR->me[i][i]);\n	if ( is_zero(tmp) )\n	{\n	    y->ve[i].re = 1.0;\n	    y->ve[i].im = 0.0;\n	}\n	else\n	{\n	    norm = zabs(tmp);\n	    y->ve[i].re = sum.re / norm;\n	    y->ve[i].im = sum.im / norm;\n	}\n	/* y->ve[i] = (sum >= 0.0) ? 1.0 : -1.0; */\n	/* y->ve[i] = (QR->me[i][i] >= 0.0) ? y->ve[i] : - y->ve[i]; */\n    }\n\n    /* now apply power method to R*.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp1,0.0),y,y);\n	zUmlt(QR,y,y);\n	tmp2 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp2,0.0),y,y);\n	zUAmlt(QR,y,y);\n    }\n    norm2 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* printf("QRcondest: norm1 = %g, norm2 = %g\n",norm1,norm2); */\n\n#ifdef	THREADSAFE\n    ZV_FREE(y);\n#endif\n\n    return norm1*norm2;\n}\n\n