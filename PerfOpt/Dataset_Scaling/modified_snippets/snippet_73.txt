\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* solve.c 1.2 11/25/87 */\nstatic	char	rcsid[] = "$Id: solve.c,v 1.3 1994/01/13 05:29:57 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "matrix2.h"\n\n\n\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* Usolve -- back substitution with optional over-riding diagonal\n		-- can be in-situ but doesn't need to be */\n#ifndef ANSI_C\nVEC	*Usolve(matrix,b,out,diag)\nMAT	*matrix;\nVEC	*b, *out;\ndouble	diag;\n#else\nVEC	*Usolve(const MAT *matrix, const VEC *b, VEC *out, double diag)\n#endif\n{\n	unsigned int	dim /* , j */;\n	int	i, i_lim;\n	Real	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum, tiny;\n\n	if ( matrix==MNULL || b==VNULL )\n		error(E_NULL,"Usolve");\n	dim = min(matrix->m,matrix->n);\n	if ( b->dim < dim )\n		error(E_SIZES,"Usolve");\n	if ( out==VNULL || out->dim < dim )\n		out = v_resize(out,matrix->n);\n	mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n\n	tiny = 10.0/HUGE_VAL;\n\n	for ( i=dim-1; i>=0; i-- )\n		if ( b_ent[i] != 0.0 )\n		    break;\n		else\n		    out_ent[i] = 0.0;\n	i_lim = i;\n\n	for (    ; i>=0; i-- )\n	{\n		sum = b_ent[i];\n		mat_row = &(mat_ent[i][i+1]);\n		out_col = &(out_ent[i+1]);\n		sum -= __ip__(mat_row,out_col,i_lim-i);\n		/******************************************************\n		for ( j=i+1; j<=i_lim; j++ )\n			sum -= mat_ent[i][j]*out_ent[j];\n			sum -= (*mat_row++)*(*out_col++);\n		******************************************************/\n		if ( diag==0.0 )\n		{\n			if ( fabs(mat_ent[i][i]) <= tiny*fabs(sum) )\n				error(E_SING,"Usolve");\n			else\n				out_ent[i] = sum/mat_ent[i][i];\n		}\n		else\n			out_ent[i] = sum/diag;\n	}\n\n	return (out);\n}\n\n/* Lsolve -- forward elimination with (optional) default diagonal value */\n#ifndef ANSI_C\nVEC	*Lsolve(matrix,b,out,diag)\nMAT	*matrix;\nVEC	*b,*out;\ndouble	diag;\n#else\nVEC	*Lsolve(const MAT *matrix, const VEC *b, VEC *out, double diag)\n#endif\n{\n	unsigned int	dim, i, i_lim /* , j */;\n	Real	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum, tiny;\n\n	if ( matrix==(MAT *)NULL || b==(VEC *)NULL )\n		error(E_NULL,"Lsolve");\n	dim = min(matrix->m,matrix->n);\n	if ( b->dim < dim )\n		error(E_SIZES,"Lsolve");\n	if ( out==(VEC *)NULL || out->dim < dim )\n		out = v_resize(out,matrix->n);\n	mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n\n	for ( i=0; i<dim; i++ )\n		if ( b_ent[i] != 0.0 )\n		    break;\n		else\n		    out_ent[i] = 0.0;\n	i_lim = i;\n\n	tiny = 10.0/HUGE_VAL;\n\n	for (    ; i<dim; i++ )\n	{\n		sum = b_ent[i];\n		mat_row = &(mat_ent[i][i_lim]);\n		out_col = &(out_ent[i_lim]);\n		sum -= __ip__(mat_row,out_col,(int)(i-i_lim));\n		/*****************************************************\n		for ( j=i_lim; j<i; j++ )\n			sum -= mat_ent[i][j]*out_ent[j];\n			sum -= (*mat_row++)*(*out_col++);\n		******************************************************/\n		if ( diag==0.0 )\n		{\n			if ( fabs(mat_ent[i][i]) <= tiny*fabs(sum) )\n				error(E_SING,"Lsolve");\n			else\n				out_ent[i] = sum/mat_ent[i][i];\n		}\n		else\n			out_ent[i] = sum/diag;\n	}\n\n	return (out);\n}\n\n\n/* UTsolve -- forward elimination with (optional) default diagonal value\n		using UPPER triangular part of matrix */\n#ifndef ANSI_C\nVEC	*UTsolve(U,b,out,diag)\nMAT	*U;\nVEC	*b,*out;\ndouble	diag;\n#else\nVEC	*UTsolve(const MAT *U, const VEC *b, VEC *out, double diag)\n#endif\n{\n    unsigned int	dim, i, i_lim;\n    Real	**U_me, *b_ve, *out_ve, tmp, invdiag, tiny;\n    \n    if ( ! U || ! b )\n	error(E_NULL,"UTsolve");\n    dim = min(U->m,U->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"UTsolve");\n    out = v_resize(out,U->n);\n    U_me = U->me;	b_ve = b->ve;	out_ve = out->ve;\n\n    tiny = 10.0/HUGE_VAL;\n\n    for ( i=0; i<dim; i++ )\n	if ( b_ve[i] != 0.0 )\n	    break;\n	else\n	    out_ve[i] = 0.0;\n    i_lim = i;\n    if ( b != out )\n    {\n	__zero__(out_ve,out->dim);\n	MEM_COPY(&(b_ve[i_lim]),&(out_ve[i_lim]),(dim-i_lim)*sizeof(Real));\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (    ; i<dim; i++ )\n	{\n	    tmp = U_me[i][i];\n	    if ( fabs(tmp) <= tiny*fabs(out_ve[i]) )\n		error(E_SING,"UTsolve");\n	    out_ve[i] /= tmp;\n	    __mltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),-out_ve[i],dim-i-1);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (    ; i<dim; i++ )\n	{\n	    out_ve[i] *= invdiag;\n	    __mltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),-out_ve[i],dim-i-1);\n	}\n    }\n    return (out);\n}\n\n/* Dsolve -- solves Dx=b where D is the diagonal of A -- may be in-situ */\n#ifndef ANSI_C\nVEC	*Dsolve(A,b,x)\nMAT	*A;\nVEC	*b,*x;\n#else\nVEC	*Dsolve(const MAT *A, const VEC *b, VEC *x)\n#endif\n{\n    unsigned int	dim, i;\n    Real	tiny;\n    \n    if ( ! A || ! b )\n	error(E_NULL,"Dsolve");\n    dim = min(A->m,A->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"Dsolve");\n    x = v_resize(x,A->n);\n\n    tiny = 10.0/HUGE_VAL;\n\n    dim = b->dim;\n    for ( i=0; i<dim; i++ )\n	if ( fabs(A->me[i][i]) <= tiny*fabs(b->ve[i]) )\n	    error(E_SING,"Dsolve");\n	else\n	    x->ve[i] = b->ve[i]/A->me[i][i];\n    \n    return (x);\n}\n\n/* LTsolve -- back substitution with optional over-riding diagonal\n		using the LOWER triangular part of matrix\n		-- can be in-situ but doesn't need to be */\n#ifndef ANSI_C\nVEC	*LTsolve(L,b,out,diag)\nMAT	*L;\nVEC	*b, *out;\ndouble	diag;\n#else\nVEC	*LTsolve(const MAT *L, const VEC *b, VEC *out, double diag)\n#endif\n{\n    unsigned int	dim;\n    int		i, i_lim;\n    Real	**L_me, *b_ve, *out_ve, tmp, invdiag, tiny;\n    \n    if ( ! L || ! b )\n	error(E_NULL,"LTsolve");\n    dim = min(L->m,L->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"LTsolve");\n    out = v_resize(out,L->n);\n    L_me = L->me;	b_ve = b->ve;	out_ve = out->ve;\n\n    tiny = 10.0/HUGE_VAL;\n    \n    for ( i=dim-1; i>=0; i-- )\n	if ( b_ve[i] != 0.0 )\n	    break;\n    i_lim = i;\n\n    if ( b != out )\n    {\n	__zero__(out_ve,out->dim);\n	MEM_COPY(b_ve,out_ve,(i_lim+1)*sizeof(Real));\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (        ; i>=0; i-- )\n	{\n	    tmp = L_me[i][i];\n	    if ( fabs(tmp) <= tiny*fabs(out_ve[i]) )\n		error(E_SING,"LTsolve");\n	    out_ve[i] /= tmp;\n	    __mltadd__(out_ve,L_me[i],-out_ve[i],i);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (        ; i>=0; i-- )\n	{\n	    out_ve[i] *= invdiag;\n	    __mltadd__(out_ve,L_me[i],-out_ve[i],i);\n	}\n    }\n    \n    return (out);\n}\n