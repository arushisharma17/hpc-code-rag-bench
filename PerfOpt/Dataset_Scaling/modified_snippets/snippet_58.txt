\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	A collection of functions for computing norms: scaled and unscaled\n*/\nstatic	char	rcsid[] = "$Id: norm.c,v 1.6 1994/01/13 05:34:35 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n\n\n/* _v_norm1 -- computes (scaled) 1-norms of vectors */\n#ifndef ANSI_C\ndouble	_v_norm1(x,scale)\nVEC	*x, *scale;\n#else\ndouble	_v_norm1(const VEC *x, const VEC *scale)\n#endif\n{\n	int	i, dim;\n	Real	s, sum;\n\n	if ( x == (VEC *)NULL )\n		error(E_NULL,"_v_norm1");\n	dim = x->dim;\n\n	sum = 0.0;\n	if ( scale == (VEC *)NULL )\n		for ( i = 0; i < dim; i++ )\n			sum += fabs(x->ve[i]);\n	else if ( scale->dim < dim )\n		error(E_SIZES,"_v_norm1");\n	else\n		for ( i = 0; i < dim; i++ )\n		{	s = scale->ve[i];\n			sum += ( s== 0.0 ) ? fabs(x->ve[i]) : fabs(x->ve[i]/s);\n		}\n\n	return sum;\n}\n\n/* square -- returns x^2 */\n#ifndef ANSI_C\ndouble	square(x)\ndouble	x;\n#else\ndouble	square(double x)\n#endif\n{	return x*x;	}\n\n/* cube -- returns x^3 */\n#ifndef ANSI_C\ndouble cube(x)\ndouble x;\n#else\ndouble cube(double x)\n#endif\n{  return x*x*x;   }\n\n/* _v_norm2 -- computes (scaled) 2-norm (Euclidean norm) of vectors */\n#ifndef ANSI_C\ndouble	_v_norm2(x,scale)\nVEC	*x, *scale;\n#else\ndouble	_v_norm2(const VEC *x, const VEC *scale)\n#endif\n{\n	int	i, dim;\n	Real	s, sum;\n\n	if ( x == (VEC *)NULL )\n		error(E_NULL,"_v_norm2");\n	dim = x->dim;\n\n	sum = 0.0;\n	if ( scale == (VEC *)NULL )\n		for ( i = 0; i < dim; i++ )\n			sum += square(x->ve[i]);\n	else if ( scale->dim < dim )\n		error(E_SIZES,"_v_norm2");\n	else\n		for ( i = 0; i < dim; i++ )\n		{	s = scale->ve[i];\n			sum += ( s== 0.0 ) ? square(x->ve[i]) :\n							square(x->ve[i]/s);\n		}\n\n	return sqrt(sum);\n}\n\n#define	max(a,b)	((a) > (b) ? (a) : (b))\n\n/* _v_norm_inf -- computes (scaled) infinity-norm (supremum norm) of vectors */\n#ifndef ANSI_C\ndouble	_v_norm_inf(x,scale)\nVEC	*x, *scale;\n#else\ndouble	_v_norm_inf(const VEC *x, const VEC *scale)\n#endif\n{\n	int	i, dim;\n	Real	s, maxval, tmp;\n\n	if ( x == (VEC *)NULL )\n		error(E_NULL,"_v_norm_inf");\n	dim = x->dim;\n\n	maxval = 0.0;\n	if ( scale == (VEC *)NULL )\n		for ( i = 0; i < dim; i++ )\n		{	tmp = fabs(x->ve[i]);\n			maxval = max(maxval,tmp);\n		}\n	else if ( scale->dim < dim )\n		error(E_SIZES,"_v_norm_inf");\n	else\n		for ( i = 0; i < dim; i++ )\n		{	s = scale->ve[i];\n			tmp = ( s== 0.0 ) ? fabs(x->ve[i]) : fabs(x->ve[i]/s);\n			maxval = max(maxval,tmp);\n		}\n\n	return maxval;\n}\n\n/* m_norm1 -- compute matrix 1-norm -- unscaled */\n#ifndef ANSI_C\ndouble	m_norm1(A)\nMAT	*A;\n#else\ndouble	m_norm1(const MAT *A)\n#endif\n{\n	int	i, j, m, n;\n	Real	maxval, sum;\n\n	if ( A == (MAT *)NULL )\n		error(E_NULL,"m_norm1");\n\n	m = A->m;	n = A->n;\n	maxval = 0.0;\n\n	for ( j = 0; j < n; j++ )\n	{\n		sum = 0.0;\n		for ( i = 0; i < m; i ++ )\n			sum += fabs(A->me[i][j]);\n		maxval = max(maxval,sum);\n	}\n\n	return maxval;\n}\n\n/* m_norm_inf -- compute matrix infinity-norm -- unscaled */\n#ifndef ANSI_C\ndouble	m_norm_inf(A)\nMAT	*A;\n#else\ndouble	m_norm_inf(const MAT *A)\n#endif\n{\n	int	i, j, m, n;\n	Real	maxval, sum;\n\n	if ( A == (MAT *)NULL )\n		error(E_NULL,"m_norm_inf");\n\n	m = A->m;	n = A->n;\n	maxval = 0.0;\n\n	for ( i = 0; i < m; i++ )\n	{\n		sum = 0.0;\n		for ( j = 0; j < n; j ++ )\n			sum += fabs(A->me[i][j]);\n		maxval = max(maxval,sum);\n	}\n\n	return maxval;\n}\n\n/* m_norm_frob -- compute matrix frobenius-norm -- unscaled */\n#ifndef ANSI_C\ndouble	m_norm_frob(A)\nMAT	*A;\n#else\ndouble	m_norm_frob(const MAT *A)\n#endif\n{\n	int	i, j, m, n;\n	Real	sum;\n\n	if ( A == (MAT *)NULL )\n		error(E_NULL,"m_norm_frob");\n\n	m = A->m;	n = A->n;\n	sum = 0.0;\n\n	for ( i = 0; i < m; i++ )\n		for ( j = 0; j < n; j ++ )\n			sum += square(A->me[i][j]);\n\n	return sqrt(sum);\n}\n\n