//====================================================================================================100\n//		UPDATE\n//====================================================================================================100\n\n// Lukasz G. Szafaryn 24 JAN 09\n\n//====================================================================================================100\n//		DESCRIPTION\n//====================================================================================================100\n\n// Myocyte application models cardiac myocyte (heart muscle cell) and simulates its behavior according to the work by Saucerman and Bers [8]. The model integrates \n// cardiac myocyte electrical activity with the calcineurin pathway, which is a key aspect of the development of heart failure. The model spans large number of temporal \n// scales to reflect how changes in heart rate as observed during exercise or stress contribute to calcineurin pathway activation, which ultimately leads to the expression \n// of numerous genes that remodel the hearts structure. It can be used to identify potential therapeutic targets that may be useful for the treatment of heart failure. \n// Biochemical reactions, ion transport and electrical activity in the cell are modeled with 91 ordinary differential equations (ODEs) that are determined by more than 200 \n// experimentally validated parameters. The model is simulated by solving this group of ODEs for a specified time interval. The process of ODE solving is based on the \n// causal relationship between values of ODEs at different time steps, thus it is mostly sequential. At every dynamically determined time step, the solver evaluates the \n// model consisting of a set of 91 ODEs and 480 supporting equations to determine behavior of the system at that particular time instance. If evaluation results are not \n// within the expected tolerance at a given time step (usually as a result of incorrect determination of the time step), another calculation attempt is made at a modified \n// (usually reduced) time step. Since the ODEs are stiff (exhibit fast rate of change within short time intervals), they need to be simulated at small time scales with an \n// adaptive step size solver. \n\n//	1) The original version of the current solver code was obtained from: Mathematics Source Library (http://mymathlib.webtrellis.net/index.html). The solver has been \n//      somewhat modified to tailor it to our needs. However, it can be reverted back to original form or modified to suit other simulations.\n// 2) This solver and particular solving algorithm used with it (embedded_fehlberg_7_8) were adapted to work with a set of equations, not just one like in original version.\n//	3) In order for solver to provide deterministic number of steps (needed for particular amount of memore previousely allocated for results), every next step is \n//      incremented by 1 time unit (h_init).\n//	4) Function assumes that simulation starts at some point of time (whatever time the initial values are provided for) and runs for the number of miliseconds (xmax) \n//      specified by the uses as a parameter on command line.\n// 5) The appropriate amount of memory is previousely allocated for that range (y).\n//	6) This setup in 3) - 5) allows solver to adjust the step ony from current time instance to current time instance + 0.9. The next time instance is current time instance + 1;\n//	7) The original solver cannot handle cases when equations return NAN and INF values due to discontinuities and /0. That is why equations provided by user need to \n//      make sure that no NAN and INF are returned.\n// 8) Application reads initial data and parameters from text files: y.txt and params.txt respectively that need to be located in the same folder as source files. \n//     For simplicity and testing purposes only, when multiple number of simulation instances is specified, application still reads initial data from the same input files. That \n//     can be modified in this source code.\n\n//====================================================================================================100\n//		IMPLEMENTATION-SPECIFIC DESCRIPTION (OPEN MP)\n//====================================================================================================100\n\n// This is the OpenMP version of Myocyte code.\n\n// The original single-threaded code was written in MATLAB and used MATLAB ode45 ODE solver. In the process of accelerating this code, we arrived with the \n// intermediate versions that used single-threaded Sundials CVODE solver which evaluated model parallelized with OpenMP at each time step. In order to convert entire \n// solver to OpenMP code (to remove some of the operational overheads such as thread launches in OpenMP) we used a simpler solver, from Mathematics Source \n// Library, and tailored it to our needs. The parallelism in the cardiac myocyte model is on a very fine-grained level, close to that of ILP, therefore it is very hard to exploit \n// as DLP or TLB in OpenMP code. We were able to divide the model into 4 individual groups that run in parallel. However, even that is not enough work to compensate \n// for some of the OpenMP thread launch overheads, which resulted in performance worse than that of single-threaded C code. Speedup in this code could \n// be achieved only if a customizable accelerator such as FPGA was used for evaluation of the model itself. We also approached the application from another angle and \n// allowed it to run several concurrent simulations, thus turning it into an embarrassingly parallel problem. This version of the code is also useful for scientists who want to \n// run the same simulation with different sets of input parameters. OpenMP version of this code provides constant speedup of about 3.64x regardless of the number of \n// concurrent simulations.\n\n// Speedup numbers reported in the description of this application were obtained on the machine with: Intel Quad Core CPU, 4GB of RAM, Nvidia GTX280 GPU.  \n\n// 1) When running with parallelization inside each simulation instance (value of 3rd command line parameter equal to 0), performance is bad because:\n// a) thread launch overhead\n// b) small amount of work for each forked thread\n// 2) When running with parallelization across simulation instances, code gets continues speedup with the increasing number of simulation insances which saturates\n//     around 4 instances on Quad Core CPU (roughly corresponding to the number of multiprocessorsXprocessors in GTX280), with the speedup of around 3.5x compared\n//     to serial C version of code, as expected.\n\n// The following are the command parameters to the application:\n// 1) Simulation time interval which is the number of miliseconds to simulate. Needs to be integer > 0\n// 2) Number of instances of simulation to run. Needs to be integer > 0.\n// 3) Method of parallelization. Need to be 0 for parallelization inside each simulation instance, or 1 for parallelization across instances.\n// 4) Number of threads to use. Needs to be integer > 0.\n// Example:\n// a.out 100 100 1 4\n\n//====================================================================================================100\n//	DEFINE / INCLUDE\n//====================================================================================================100\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#include <omp.h>\n\n#include "define.c"\n#include "ecc.c"\n#include "cam.c"\n#include "fin.c"\n#include "master.c"\n#include "embedded_fehlberg_7_8.c"\n#include "solver.c"\n\n#include "file.c"\n#include "timer.c"\n\n//====================================================================================================100\n//	MAIN FUNCTION\n//====================================================================================================100\n\nint main(int argc, char *argv []){\n\n	//================================================================================80\n	//		VARIABLES\n	//================================================================================80\n\n	//============================================================60\n	//		TIME\n	//============================================================60\n\n	long long time0;\n	long long time1;\n	long long time2;\n	long long time3;\n	long long time4;\n	long long time5;\n\n	time0 = get_time();\n\n	//============================================================60\n	//		COUNTERS\n	//============================================================60\n\n	long long memory;\n	int i,j;\n	int status;\n	int mode;\n\n	//============================================================60\n	//		SOLVER PARAMETERS\n	//============================================================60\n\n	long workload;\n	long xmin;\n	long xmax;\n	fp h;\n	fp tolerance;\n\n	//============================================================60\n	//		DATA\n	//============================================================60\n\n	fp*** y;\n	fp** x;\n	fp** params;\n\n	//============================================================60\n	//		OPENMP\n	//============================================================60\n\n	int threads;\n\n	//================================================================================80\n	// 	GET INPUT PARAMETERS\n	//================================================================================80\n\n	//============================================================60\n	//		CHECK NUMBER OF ARGUMENTS\n	//============================================================60\n\n	if(argc!=5){\n		printf("ERROR: %d is the incorrect number of arguments, the number of arguments must be 4\n", argc-1);\n		return 0;\n	}\n\n	//============================================================60\n	//		GET AND CHECK PARTICULAR ARGUMENTS\n	//============================================================60\n\n	else{\n\n		//========================================40\n		//		SPAN\n		//========================================40\n\n		xmax = atoi(argv[1]);\n		if(xmax<0){\n			printf("ERROR: %d is the incorrect end of simulation interval, use numbers > 0\n", xmax);\n			return 0;\n		}\n\n		//========================================40\n		//		WORKLOAD\n		//========================================40\n\n		workload = atoi(argv[2]);\n		if(workload<0){\n			printf("ERROR: %d is the incorrect number of instances of simulation, use numbers > 0\n", workload);\n			return 0;\n		}\n\n		//========================================40\n		//		MODE\n		//========================================40\n\n		mode = 0;\n		mode = atoi(argv[3]);\n		if(mode != 0 && mode != 1){\n			printf("ERROR: %d is the incorrect mode, it should be omitted or equal to 0 or 1\n", mode);\n			return 0;\n		}\n\n		//========================================40\n		//		THREADS\n		//========================================40\n\n		threads = atoi(argv[4]);\n		if(threads<0){\n			printf("ERROR: %d is the incorrect number of threads, use numbers > 0\n", threads);\n			return 0;\n		}\n		omp_set_num_threads(threads);\n\n	}\n\n	time1 = get_time();\n\n	//================================================================================80\n	// 	ALLOCATE MEMORY\n	//================================================================================80\n\n	//============================================================60\n	//		MEMORY CHECK\n	//============================================================60\n\n	memory = workload*(xmax+1)*EQUATIONS*4;\n	if(memory>1000000000){\n		printf("ERROR: trying to allocate more than 1.0GB of memory, decrease workload and span parameters or change memory parameter\n");\n		return 0;\n	}\n\n	//============================================================60\n	// 	ALLOCATE ARRAYS\n	//============================================================60\n\n	y = (fp ***) malloc(workload* sizeof(fp **));\n	for(i=0; i<workload; i++){\n		y[i] = (fp**)malloc((1+xmax)*sizeof(fp*));\n		for(j=0; j<(1+xmax); j++){\n			y[i][j]= (fp *) malloc(EQUATIONS* sizeof(fp));\n		}\n	}\n\n	x = (fp **) malloc(workload * sizeof(fp *));\n	for (i= 0; i<workload; i++){\n		x[i]= (fp *)malloc((1+xmax) *sizeof(fp));\n	}\n\n	params = (fp **) malloc(workload * sizeof(fp *));\n	for (i= 0; i<workload; i++){\n		params[i]= (fp *)malloc(PARAMETERS * sizeof(fp));\n	}\n\n	time2 = get_time();\n\n	//================================================================================80\n	// 	INITIAL VALUES\n	//================================================================================80\n\n	// y\n	for(i=0; i<workload; i++){\n		read(	"../../data/myocyte/y.txt",\n					y[i][0],\n					91,\n					1,\n					0);\n	}\n\n	// params\n	for(i=0; i<workload; i++){\n		read(	"../../data/myocyte/params.txt",\n					params[i],\n					16,\n					1,\n					0);\n	}\n\n	time3 = get_time();\n\n	//================================================================================80\n	//	EXECUTION\n	//================================================================================80\n\n	if(mode == 0){\n\n		for(i=0; i<workload; i++){\n\n			status = solver(	y[i],\n										x[i],\n										xmax,\n										params[i],\n										mode);\n\n			// if(status !=0){\n				// printf("STATUS: %d\n", status);\n			// }\n\n		}\n\n	}\n	else{\n\n		#pragma omp parallel for private(i, status) shared(y, x, xmax, params, mode)\n		for(i=0; i<workload; i++){\n\n			status = solver(	y[i],\n										x[i],\n										xmax,\n										params[i],\n										mode);\n\n			// if(status !=0){\n				// printf("STATUS: %d\n", status);\n			// }\n\n		}\n\n	}\n\n	// // print results\n	// int k;\n	// for(i=0; i<workload; i++){\n		// printf("WORKLOAD %d:\n", i);\n		// for(j=0; j<(xmax+1); j++){\n			// printf("\tTIME %d:\n", j);\n			// for(k=0; k<EQUATIONS; k++){\n				// printf("\t\ty[%d][%d][%d]=%13.10f\n", i, j, k, y[i][j][k]);\n			// }\n		// }\n	// }\n\n	time4 = get_time();\n\n	//================================================================================80\n	//	DEALLOCATION\n	//================================================================================80\n\n	// y values\n	for (i= 0; i< workload; i++){\n		for (j= 0; j< (1+xmax); j++){\n			free(y[i][j]);\n		}\n		free(y[i]);\n	}\n	free(y);\n\n	// x values\n	for (i= 0; i< workload; i++){\n		free(x[i]);\n	}\n	free(x);\n\n	// parameters\n	for (i= 0; i< workload; i++){\n		free(params[i]);\n	}\n	free(params);\n\n	time5= get_time();\n\n	//================================================================================80\n	//		DISPLAY TIMING\n	//================================================================================80\n\n	printf("Time spent in different stages of the application:\n");\n	printf("%.12f s, %.12f % : SETUP VARIABLES, READ COMMAND LINE ARGUMENTS\n", 	(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time5-time0) * 100);\n	printf("%.12f s, %.12f % : ALLOCATE MEMORY\n", 														(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time5-time0) * 100);\n	printf("%.12f s, %.12f % : READ DATA FROM FILES\n", 												(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time5-time0) * 100);\n	printf("%.12f s, %.12f % : RUN COMPUTATION\n", 														(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time5-time0) * 100);\n	printf("%.12f s, %.12f % : FREE MEMORY\n", 																(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time5-time0) * 100);\n	printf("Total time:\n");\n	printf("%.12f s\n", 																											(float) (time5-time0) / 1000000);\n\n//====================================================================================================100\n//	END OF FILE\n//====================================================================================================100\n\n}\n