\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* 1.2 submat.c 11/25/87 */\n\n#include	<stdio.h>\n#include	"matrix.h"\n\nstatic	char	rcsid[] = "$Id: submat.c,v 1.2 1994/01/13 05:28:12 des Exp $";\n\n\n/* get_col -- gets a specified column of a matrix and retruns it as a vector */\n#ifndef ANSI_C\nVEC	*get_col(mat,col,vec)\nunsigned int	col;\nMAT	*mat;\nVEC	*vec;\n#else\nVEC	*get_col(const MAT *mat, unsigned int col, VEC *vec)\n#endif\n{\n   unsigned int	i;\n   \n   if ( mat==(MAT *)NULL )\n     error(E_NULL,"get_col");\n   if ( col >= mat->n )\n     error(E_RANGE,"get_col");\n   if ( vec==(VEC *)NULL || vec->dim<mat->m )\n     vec = v_resize(vec,mat->m);\n   \n   for ( i=0; i<mat->m; i++ )\n     vec->ve[i] = mat->me[i][col];\n   \n   return (vec);\n}\n\n/* get_row -- gets a specified row of a matrix and retruns it as a vector */\n#ifndef ANSI_C\nVEC	*get_row(mat,row,vec)\nunsigned int	row;\nMAT	*mat;\nVEC	*vec;\n#else\nVEC	*get_row(const MAT *mat, unsigned int row, VEC *vec)\n#endif\n{\n   unsigned int	i;\n   \n   if ( mat==(MAT *)NULL )\n     error(E_NULL,"get_row");\n   if ( row >= mat->m )\n     error(E_RANGE,"get_row");\n   if ( vec==(VEC *)NULL || vec->dim<mat->n )\n     vec = v_resize(vec,mat->n);\n   \n   for ( i=0; i<mat->n; i++ )\n     vec->ve[i] = mat->me[row][i];\n   \n   return (vec);\n}\n\n/* _set_col -- sets column of matrix to values given in vec (in situ)\n	-- that is, mat(i0:lim,col) <- vec(i0:lim) */\n#ifndef ANSI_C\nMAT	*_set_col(mat,col,vec,i0)\nMAT	*mat;\nVEC	*vec;\nunsigned int	col,i0;\n#else\nMAT	*_set_col(MAT *mat, unsigned int col, const VEC *vec, unsigned int i0)\n#endif\n{\n   unsigned int	i,lim;\n   \n   if ( mat==(MAT *)NULL || vec==(VEC *)NULL )\n     error(E_NULL,"_set_col");\n   if ( col >= mat->n )\n     error(E_RANGE,"_set_col");\n   lim = min(mat->m,vec->dim);\n   for ( i=i0; i<lim; i++ )\n     mat->me[i][col] = vec->ve[i];\n   \n   return (mat);\n}\n\n/* _set_row -- sets row of matrix to values given in vec (in situ) */\n#ifndef ANSI_C\nMAT	*_set_row(mat,row,vec,j0)\nMAT	*mat;\nVEC	*vec;\nunsigned int	row,j0;\n#else\nMAT	*_set_row(MAT *mat, unsigned int row, const VEC *vec, unsigned int j0)\n#endif\n{\n   unsigned int	j,lim;\n   \n   if ( mat==(MAT *)NULL || vec==(VEC *)NULL )\n     error(E_NULL,"_set_row");\n   if ( row >= mat->m )\n     error(E_RANGE,"_set_row");\n   lim = min(mat->n,vec->dim);\n   for ( j=j0; j<lim; j++ )\n     mat->me[row][j] = vec->ve[j];\n   \n   return (mat);\n}\n\n/* sub_mat -- returns sub-matrix of old which is formed by the rectangle\n   from (row1,col1) to (row2,col2)\n   -- Note: storage is shared so that altering the "new"\n   matrix will alter the "old" matrix */\n#ifndef ANSI_C\nMAT	*sub_mat(old,row1,col1,row2,col2,new)\nMAT	*old,*new;\nunsigned int	row1,col1,row2,col2;\n#else\nMAT	*sub_mat(const MAT *old, \n		 unsigned int row1, unsigned int col1,\n		 unsigned int row2, unsigned int col2,\n		 MAT *new)\n#endif\n{\n   unsigned int	i;\n   \n   if ( old==(MAT *)NULL )\n     error(E_NULL,"sub_mat");\n   if ( row1 > row2 || col1 > col2 || row2 >= old->m || col2 >= old->n )\n     error(E_RANGE,"sub_mat");\n   if ( new==(MAT *)NULL || new->m < row2-row1+1 )\n   {\n      new = NEW(MAT);\n      new->me = NEW_A(row2-row1+1,Real *);\n      if ( new==(MAT *)NULL || new->me==(Real **)NULL )\n	error(E_MEM,"sub_mat");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,0,sizeof(MAT)+\n		      (row2-row1+1)*sizeof(Real *));\n      }\n      \n   }\n   new->m = row2-row1+1;\n   \n   new->n = col2-col1+1;\n   \n   new->base = (Real *)NULL;\n   \n   for ( i=0; i < new->m; i++ )\n     new->me[i] = (old->me[i+row1]) + col1;\n   \n   return (new);\n}\n\n\n/* sub_vec -- returns sub-vector which is formed by the elements i1 to i2\n   -- as for sub_mat, storage is shared */\n#ifndef ANSI_C\nVEC	*sub_vec(old,i1,i2,new)\nVEC	*old, *new;\nint	i1, i2;\n#else\nVEC	*sub_vec(const VEC *old, int i1, int i2, VEC *new)\n#endif\n{\n   if ( old == (VEC *)NULL )\n     error(E_NULL,"sub_vec");\n   if ( i1 > i2 || old->dim < i2 )\n     error(E_RANGE,"sub_vec");\n   \n   if ( new == (VEC *)NULL )\n     new = NEW(VEC);\n   if ( new == (VEC *)NULL )\n     error(E_MEM,"sub_vec");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_VEC,0,sizeof(VEC));\n   }\n   \n   \n   new->dim = i2 - i1 + 1;\n   new->ve = &(old->ve[i1]);\n   \n   return new;\n}\n