\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n		File containing routines for determining Hessenberg\n	factorisations.\n\n	Complex version\n*/\n\nstatic	char	rcsid[] = "$Id: zhessen.c,v 1.2 1995/03/27 15:47:50 des Exp $";\n\n#include	<stdio.h>\n#include	"zmatrix.h"\n#include        "zmatrix2.h"\n\n\n/* zHfactor -- compute Hessenberg factorisation in compact form.\n	-- factorisation performed in situ\n	-- for details of the compact form see zQRfactor.c and zmatrix2.doc */\nZMAT	*zHfactor(A, diag)\nZMAT	*A;\nZVEC	*diag;\n{\n	STATIC	ZVEC	*tmp1 = ZVNULL, *w = ZVNULL;\n	Real	beta;\n	int	k, limit;\n\n	if ( ! A || ! diag )\n		error(E_NULL,"zHfactor");\n	if ( diag->dim < A->m - 1 )\n		error(E_SIZES,"zHfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"zHfactor");\n	limit = A->m - 1;\n\n	tmp1 = zv_resize(tmp1,A->m);\n	w    = zv_resize(w,   A->n);\n	MEM_STAT_REG(tmp1,TYPE_ZVEC);\n	MEM_STAT_REG(w,   TYPE_ZVEC);\n\n	for ( k = 0; k < limit; k++ )\n	{\n	    zget_col(A,k,tmp1);\n	    zhhvec(tmp1,k+1,&beta,tmp1,&A->me[k+1][k]);\n	    diag->ve[k] = tmp1->ve[k+1];\n	    /* printf("zHfactor: k = %d, beta = %g, tmp1 =\n",k,beta);\n	    zv_output(tmp1); */\n	    \n	    _zhhtrcols(A,k+1,k+1,tmp1,beta,w);\n	    zhhtrrows(A,0  ,k+1,tmp1,beta);\n	    /* printf("# at stage k = %d, A =\n",k);	zm_output(A); */\n	}\n\n#ifdef	THREADSAFE\n	ZV_FREE(tmp1);	ZV_FREE(w);\n#endif\n\n	return (A);\n}\n\n/* zHQunpack -- unpack the compact representation of H and Q of a\n	Hessenberg factorisation\n	-- if either H or Q is NULL, then it is not unpacked\n	-- it can be in situ with HQ == H\n	-- returns HQ\n*/\nZMAT	*zHQunpack(HQ,diag,Q,H)\nZMAT	*HQ, *Q, *H;\nZVEC	*diag;\n{\n	int	i, j, limit;\n	Real	beta, r_ii, tmp_val;\n	STATIC	ZVEC	*tmp1 = ZVNULL, *tmp2 = ZVNULL;\n\n	if ( HQ==ZMNULL || diag==ZVNULL )\n		error(E_NULL,"zHQunpack");\n	if ( HQ == Q || H == Q )\n	    error(E_INSITU,"zHQunpack");\n	limit = HQ->m - 1;\n	if ( diag->dim < limit )\n		error(E_SIZES,"zHQunpack");\n	if ( HQ->m != HQ->n )\n		error(E_SQUARE,"zHQunpack");\n\n\n	if ( Q != ZMNULL )\n	{\n	    Q = zm_resize(Q,HQ->m,HQ->m);\n	    tmp1 = zv_resize(tmp1,H->m);\n	    tmp2 = zv_resize(tmp2,H->m);\n	    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n	    MEM_STAT_REG(tmp2,TYPE_ZVEC);\n	    \n	    for ( i = 0; i < H->m; i++ )\n	    {\n		/* tmp1 = i'th basis vector */\n		for ( j = 0; j < H->m; j++ )\n		    tmp1->ve[j].re = tmp1->ve[j].im = 0.0;\n		tmp1->ve[i].re = 1.0;\n		\n		/* apply H/h transforms in reverse order */\n		for ( j = limit-1; j >= 0; j-- )\n		{\n		    zget_col(HQ,j,tmp2);\n		    r_ii = zabs(tmp2->ve[j+1]);\n		    tmp2->ve[j+1] = diag->ve[j];\n		    tmp_val = (r_ii*zabs(diag->ve[j]));\n		    beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n		    /* printf("zHQunpack: j = %d, beta = %g, tmp2 =\n",\n			   j,beta);\n		    zv_output(tmp2); */\n		    zhhtrvec(tmp2,beta,j+1,tmp1,tmp1);\n		}\n		\n		/* insert into Q */\n		zset_col(Q,i,tmp1);\n	    }\n	}\n\n	if ( H != ZMNULL )\n	{\n	    H = zm_copy(HQ,zm_resize(H,HQ->m,HQ->n));\n	    \n	    limit = H->m;\n	    for ( i = 1; i < limit; i++ )\n		for ( j = 0; j < i-1; j++ )\n		    H->me[i][j].re = H->me[i][j].im = 0.0;\n	}\n\n#ifdef	THREADSAFE\n	ZV_FREE(tmp1);	ZV_FREE(tmp2);\n#endif\n\n	return HQ;\n}\n\n\n\n