// #ifdef __cplusplus\n// extern "C" {\n// #endif\n\n//===============================================================================================================================================================================================================\n//	DEFINE / INCLUDE\n//===============================================================================================================================================================================================================\n#include "avimod.h"\n\n//===============================================================================================================================================================================================================\n//	FUNCTIONS\n//===============================================================================================================================================================================================================\n\n// Flips the specified image and crops it to the specified dimensions\n// If scaled == true, all values are scaled to the range [0.0, 1.0\nfp* chop_flip_image(	char *image, \n								int height, \n								int width, \n								int cropped,\n								int scaled,\n								int converted) {\n\n	// fixed dimensions for cropping or not cropping, square vertices starting from initial point in top left corner going down and right\n	int top;\n	int bottom;\n	int left;\n	int right;\n	if(cropped==1){\n		top = 0;\n		bottom = 0;\n		left = 0;\n		right = 0;\n	}\n	else{\n		top = 0;\n		bottom = height - 1;\n		left = 0;\n		right = width - 1;\n	}\n\n	// dimensions of new cropped image\n	int height_new = bottom - top + 1;\n	int width_new = right - left + 1;\n\n	// counters\n	int i, j;\n\n	// allocate memory for cropped/flipped frame\n	fp* result = (fp *) malloc(height_new * width_new * sizeof(fp));\n\n	// crop/flip and scale frame\n	fp temp;\n	if (scaled) {\n		fp scale = 1.0 / 255.0;\n		for(i = 0; i <height_new; i++){				// rows\n			for(j = 0; j <width_new; j++){			// colums\n				temp = (fp) image[((height - 1 - (i + top)) * width) + (j + left)] * scale;\n				if(temp<0){\n					result[i*width_new+j] = temp + 256;\n				}\n				else{\n					result[i*width_new+j] = temp;\n				}\n			}\n		}\n	} else {\n		for(i = 0; i <height_new; i++){				// rows\n			for(j = 0; j <width_new; j++){			// colums\n				temp = (fp) image[((height - 1 - (i + top)) * width) + (j + left)] ;\n				if(temp<0){\n					result[i*width_new+j] = temp + 256;\n				}\n				else{\n					result[i*width_new+j] = temp;\n				}\n			}\n		}\n	}\n\n// convert storage method (from row-major to column-major)\n	fp* result_converted = (fp *) malloc(height_new * width_new * sizeof(fp));\n	if(converted==1){\n		for(i = 0; i <width_new; i++){				// rows\n			for(j = 0; j <height_new; j++){			// colums\n				result_converted[i*height_new+j] = result[j*width_new+i];\n			}\n		}\n	}\n	else{\n		result_converted = result;\n	}\n	free(result);\n\n	// return\n	return result_converted;\n}\n\n// Returns the specified frame from the specified video file\n// If cropped == true, the frame is cropped to pre-determined dimensions\n//  (hardcoded to the boundaries of the blood vessel in the test video)\n// If scaled == true, all values are scaled to the range [0.0, 1.0]\nfp* get_frame(	avi_t* cell_file, \n						int frame_num, \n						int cropped, \n						int scaled,\n						int converted) {\n\n	// variable\n	int dummy;\n	int width = AVI_video_width(cell_file);\n	int height = AVI_video_height(cell_file);\n	int status;\n\n	// There are 600 frames in this file (i.e. frame_num = 600 causes an error)\n	AVI_set_video_position(cell_file, frame_num);\n\n	//Read in the frame from the AVI\n	char* image_buf = (char*) malloc(width * height * sizeof(char));\n	status = AVI_read_frame(cell_file, image_buf, &dummy);\n	if(status == -1) {\n		AVI_print_error((char*) "Error with AVI_read_frame");\n		exit(-1);\n	}\n\n	// The image is read in upside-down, so we need to flip it\n	fp* image_chopped;\n	image_chopped = chop_flip_image(	image_buf, \n														height, \n														width, \n														cropped,\n														scaled,\n														converted);\n\n	// free image buffer\n	free(image_buf);\n\n	// return\n	return image_chopped;\n\n} \n\n// #ifdef __cplusplus\n// }\n// #endif\n