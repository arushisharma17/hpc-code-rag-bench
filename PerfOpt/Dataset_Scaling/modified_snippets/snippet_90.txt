\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Givens operations file. Contains routines for calculating and\n	applying givens rotations for/to vectors and also to matrices by\n	row and by column.\n\n	Complex version.\n*/\n\nstatic	char	rcsid[] = "$Id: ";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"zmatrix.h"\n#include        "zmatrix2.h"\n\n/*\n	(Complex) Givens rotation matrix:\n		[ c   -s ]\n		[ s*   c ]\n	Note that c is real and s is complex\n*/\n\n/* zgivens -- returns c,s parameters for Givens rotation to\n		eliminate y in the **column** vector [ x y ] */\nvoid	zgivens(x,y,c,s)\ncomplex	x,y,*s;\nReal	*c;\n{\n	Real	inv_norm, norm;\n	complex	tmp;\n\n	/* this is a safe way of computing sqrt(|x|^2+|y|^2) */\n	tmp.re = zabs(x);	tmp.im = zabs(y);\n	norm = zabs(tmp);\n\n	if ( norm == 0.0 )\n	{	*c = 1.0;	s->re = s->im = 0.0;	} /* identity */\n	else\n	{\n	    inv_norm = 1.0 / tmp.re;	/* inv_norm = 1/|x| */\n	    x.re *= inv_norm;\n	    x.im *= inv_norm;		/* normalise x */\n	    inv_norm = 1.0/norm;		/* inv_norm = 1/||[x,y]||2 */\n	    *c = tmp.re * inv_norm;\n	    /* now compute - conj(normalised x).y/||[x,y]||2 */\n	    s->re = - inv_norm*(x.re*y.re + x.im*y.im);\n	    s->im =   inv_norm*(x.re*y.im - x.im*y.re);\n	}\n}\n\n/* rot_zvec -- apply Givens rotation to x's i & k components */\nZVEC	*rot_zvec(x,i,k,c,s,out)\nZVEC	*x,*out;\nint	i,k;\ndouble	c;\ncomplex	s;\n{\n\n	complex	temp1, temp2;\n\n	if ( x==ZVNULL )\n		error(E_NULL,"rot_zvec");\n	if ( i < 0 || i >= x->dim || k < 0 || k >= x->dim )\n		error(E_RANGE,"rot_zvec");\n	if ( x != out )\n	    out = zv_copy(x,out);\n\n	/* temp1 = c*out->ve[i] - s*out->ve[k]; */\n	temp1.re = c*out->ve[i].re\n	    - s.re*out->ve[k].re + s.im*out->ve[k].im;\n	temp1.im = c*out->ve[i].im\n	    - s.re*out->ve[k].im - s.im*out->ve[k].re;\n\n	/* temp2 = c*out->ve[k] + zconj(s)*out->ve[i]; */\n	temp2.re = c*out->ve[k].re\n		+ s.re*out->ve[i].re + s.im*out->ve[i].im;\n	temp2.im = c*out->ve[k].im\n		+ s.re*out->ve[i].im - s.im*out->ve[i].re;\n\n	out->ve[i] = temp1;\n	out->ve[k] = temp2;\n\n	return (out);\n}\n\n/* zrot_rows -- premultiply mat by givens rotation described by c,s */\nZMAT	*zrot_rows(mat,i,k,c,s,out)\nZMAT	*mat,*out;\nint	i,k;\ndouble	c;\ncomplex	s;\n{\n	unsigned int	j;\n	complex	temp1, temp2;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,"zrot_rows");\n	if ( i < 0 || i >= mat->m || k < 0 || k >= mat->m )\n		error(E_RANGE,"zrot_rows");\n\n	if ( mat != out )\n		out = zm_copy(mat,zm_resize(out,mat->m,mat->n));\n\n	/* temp1 = c*out->me[i][j] - s*out->me[k][j]; */\n	for ( j=0; j<mat->n; j++ )\n	{\n	    /* temp1 = c*out->me[i][j] - s*out->me[k][j]; */\n	    temp1.re = c*out->me[i][j].re\n		- s.re*out->me[k][j].re + s.im*out->me[k][j].im;\n	    temp1.im = c*out->me[i][j].im\n		- s.re*out->me[k][j].im - s.im*out->me[k][j].re;\n	    \n	    /* temp2 = c*out->me[k][j] + conj(s)*out->me[i][j]; */\n	    temp2.re = c*out->me[k][j].re\n		+ s.re*out->me[i][j].re + s.im*out->me[i][j].im;\n	    temp2.im = c*out->me[k][j].im\n		+ s.re*out->me[i][j].im - s.im*out->me[i][j].re;\n	    \n	    out->me[i][j] = temp1;\n	    out->me[k][j] = temp2;\n	}\n\n	return (out);\n}\n\n/* zrot_cols -- postmultiply mat by adjoint Givens rotation described by c,s */\nZMAT	*zrot_cols(mat,i,k,c,s,out)\nZMAT	*mat,*out;\nint	i,k;\ndouble	c;\ncomplex	s;\n{\n	unsigned int	j;\n	complex	x, y;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,"zrot_cols");\n	if ( i < 0 || i >= mat->n || k < 0 || k >= mat->n )\n		error(E_RANGE,"zrot_cols");\n\n	if ( mat != out )\n		out = zm_copy(mat,zm_resize(out,mat->m,mat->n));\n\n	for ( j=0; j<mat->m; j++ )\n	{\n	    x = out->me[j][i];	y = out->me[j][k];\n	    /* out->me[j][i] = c*x - conj(s)*y; */\n	    out->me[j][i].re = c*x.re - s.re*y.re - s.im*y.im;\n	    out->me[j][i].im = c*x.im - s.re*y.im + s.im*y.re;\n	    \n	    /* out->me[j][k] = c*y + s*x; */\n	    out->me[j][k].re = c*y.re + s.re*x.re - s.im*x.im;\n	    out->me[j][k].im = c*y.im + s.re*x.im + s.im*x.re;\n	}\n\n	return (out);\n}\n\n