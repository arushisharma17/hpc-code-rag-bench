\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains routines for import/exporting data to/from\n		MATLAB. The main routines are:\n			MAT *m_save(FILE *fp,MAT *A,char *name)\n			VEC *v_save(FILE *fp,VEC *x,char *name)\n			MAT *m_load(FILE *fp,char **name)\n*/\n\n#include        <stdio.h>\n#include        "matrix.h"\n#include	"matlab.h"\n\nstatic char rcsid[] = "$Id: matlab.c,v 1.8 1995/02/14 20:12:36 des Exp $";\n\n/* m_save -- save matrix in ".mat" file for MATLAB\n	-- returns matrix to be saved */\n#ifndef ANSI_C\nMAT     *m_save(fp,A,name)\nFILE    *fp;\nMAT     *A;\nchar    *name;\n#else\nMAT     *m_save(FILE *fp, MAT *A, const char *name)\n#endif\n{\n	int     i, j;\n	matlab  mat;\n\n	if ( ! A )\n		error(E_NULL,"m_save");\n\n	mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n	mat.m = A->m;\n	mat.n = A->n;\n	mat.imag = FALSE;\n	mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n\n	/* write header */\n	fwrite(&mat,sizeof(matlab),1,fp);\n	/* write name */\n	if ( name == (char *)NULL )\n		fwrite("",sizeof(char),1,fp);\n	else\n		fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n	/* write actual data */\n#if ORDER == ROW_ORDER\n	for ( i = 0; i < A->m; i++ )\n		fwrite(A->me[i],sizeof(Real),(int)(A->n),fp);\n#else /* column major order: ORDER == COL_ORDER */\n	for ( j = 0; j < A->n; j++ )\n	  for ( i = 0; i < A->m; i++ )\n	    fwrite(&(A->me[i][j]),sizeof(Real),1,fp);\n#endif\n\n	return A;\n}\n\n\n/* v_save -- save vector in ".mat" file for MATLAB\n	-- saves it as a row vector\n	-- returns vector to be saved */\n#ifndef ANSI_C\nVEC     *v_save(fp,x,name)\nFILE    *fp;\nVEC     *x;\nchar    *name;\n#else\nVEC     *v_save(FILE *fp, VEC *x, const char *name)\n#endif\n{\n	matlab  mat;\n\n	if ( ! x )\n		error(E_NULL,"v_save");\n\n	mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n	mat.m = x->dim;\n	mat.n = 1;\n	mat.imag = FALSE;\n	mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n\n	/* write header */\n	fwrite(&mat,sizeof(matlab),1,fp);\n	/* write name */\n	if ( name == (char *)NULL )\n		fwrite("",sizeof(char),1,fp);\n	else\n		fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n	/* write actual data */\n	fwrite(x->ve,sizeof(Real),(int)(x->dim),fp);\n\n	return x;\n}\n\n/* d_save -- save double in ".mat" file for MATLAB\n	-- saves it as a row vector\n	-- returns vector to be saved */\n#ifndef ANSI_C\ndouble	d_save(fp,x,name)\nFILE    *fp;\ndouble	x;\nchar    *name;\n#else\ndouble	d_save(FILE *fp, double x, const char *name)\n#endif\n{\n	matlab  mat;\n	Real x1 = x;\n\n	mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n	mat.m = 1;\n	mat.n = 1;\n	mat.imag = FALSE;\n	mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n\n	/* write header */\n	fwrite(&mat,sizeof(matlab),1,fp);\n	/* write name */\n	if ( name == (char *)NULL )\n		fwrite("",sizeof(char),1,fp);\n	else\n		fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n	/* write actual data */\n	fwrite(&x1,sizeof(Real),1,fp);\n\n	return x;\n}\n\n/* m_load -- loads in a ".mat" file variable as produced by MATLAB\n	-- matrix returned; imaginary parts ignored */\n#ifndef ANSI_C\nMAT     *m_load(fp,name)\nFILE    *fp;\nchar    **name;\n#else\nMAT     *m_load(FILE *fp, char **name)\n#endif\n{\n	MAT     *A;\n	int     i;\n	int     m_flag, o_flag, p_flag, t_flag;\n	float   f_temp;\n	Real    d_temp;\n	matlab  mat;\n\n	if ( fread(&mat,sizeof(matlab),1,fp) != 1 )\n	    error(E_FORMAT,"m_load");\n	if ( mat.type >= 10000 )	/* don't load a sparse matrix! */\n	    error(E_FORMAT,"m_load");\n	m_flag = (mat.type/1000) % 10;\n	o_flag = (mat.type/100) % 10;\n	p_flag = (mat.type/10) % 10;\n	t_flag = (mat.type) % 10;\n	if ( m_flag != MACH_ID )\n		error(E_FORMAT,"m_load");\n	if ( t_flag != 0 )\n		error(E_FORMAT,"m_load");\n	if ( p_flag != DOUBLE_PREC && p_flag != SINGLE_PREC )\n		error(E_FORMAT,"m_load");\n	*name = (char *)malloc((unsigned)(mat.namlen)+1);\n	if ( fread(*name,sizeof(char),(unsigned)(mat.namlen),fp) == 0 )\n		error(E_FORMAT,"m_load");\n	A = m_get((unsigned)(mat.m),(unsigned)(mat.n));\n	for ( i = 0; i < A->m*A->n; i++ )\n	{\n		if ( p_flag == DOUBLE_PREC )\n		    fread(&d_temp,sizeof(double),1,fp);\n		else\n		{\n		    fread(&f_temp,sizeof(float),1,fp);\n		    d_temp = f_temp;\n		}\n		if ( o_flag == ROW_ORDER )\n		    A->me[i / A->n][i % A->n] = d_temp;\n		else if ( o_flag == COL_ORDER )\n		    A->me[i % A->m][i / A->m] = d_temp;\n		else\n		    error(E_FORMAT,"m_load");\n	}\n\n	if ( mat.imag )         /* skip imaginary part */\n	for ( i = 0; i < A->m*A->n; i++ )\n	{\n		if ( p_flag == DOUBLE_PREC )\n		    fread(&d_temp,sizeof(double),1,fp);\n		else\n		    fread(&f_temp,sizeof(float),1,fp);\n	}\n\n	return A;\n}\n\n