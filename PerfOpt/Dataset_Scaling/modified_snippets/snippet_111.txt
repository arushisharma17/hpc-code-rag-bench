\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n#include	<stdio.h>\n#include	"matrix.h"\n#include	"zmatrix.h"\nstatic	char	rcsid[] = "$Id: zvecop.c,v 1.3 1997/10/07 16:13:54 stewart Exp stewart $";\n\n\n\n/* _zin_prod -- inner product of two vectors from i0 downwards\n	-- flag != 0 means compute sum_i a[i]*.b[i];\n	-- flag == 0 means compute sum_i a[i].b[i] */\n#ifndef ANSI_C\ncomplex	_zin_prod(a,b,i0,flag)\nZVEC	*a,*b;\nunsigned int	i0, flag;\n#else\ncomplex	_zin_prod(const ZVEC *a, const ZVEC *b, \n		  unsigned int i0, unsigned int flag)\n#endif\n{\n	unsigned int	limit;\n\n	if ( a==ZVNULL || b==ZVNULL )\n		error(E_NULL,"_zin_prod");\n	limit = min(a->dim,b->dim);\n	if ( i0 > limit )\n		error(E_BOUNDS,"_zin_prod");\n\n	return __zip__(&(a->ve[i0]),&(b->ve[i0]),(int)(limit-i0),flag);\n}\n\n/* zv_mlt -- scalar-vector multiply -- may be in-situ */\n#ifndef ANSI_C\nZVEC	*zv_mlt(scalar,vector,out)\ncomplex	scalar;\nZVEC	*vector,*out;\n#else\nZVEC	*zv_mlt(complex scalar, const ZVEC *vector, ZVEC *out)\n#endif\n{\n	/* unsigned int	dim, i; */\n	/* complex	*out_ve, *vec_ve; */\n\n	if ( vector==ZVNULL )\n		error(E_NULL,"zv_mlt");\n	if ( out==ZVNULL || out->dim != vector->dim )\n		out = zv_resize(out,vector->dim);\n	if ( scalar.re == 0.0 && scalar.im == 0.0 )\n		return zv_zero(out);\n	if ( scalar.re == 1.0 && scalar.im == 0.0 )\n		return zv_copy(vector,out);\n\n	__zmlt__(vector->ve,scalar,out->ve,(int)(vector->dim));\n\n	return (out);\n}\n\n/* zv_add -- vector addition -- may be in-situ */\n#ifndef ANSI_C\nZVEC	*zv_add(vec1,vec2,out)\nZVEC	*vec1,*vec2,*out;\n#else\nZVEC	*zv_add(const ZVEC *vec1, const ZVEC *vec2, ZVEC *out)\n#endif\n{\n	unsigned int	dim;\n\n	if ( vec1==ZVNULL || vec2==ZVNULL )\n		error(E_NULL,"zv_add");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,"zv_add");\n	if ( out==ZVNULL || out->dim != vec1->dim )\n		out = zv_resize(out,vec1->dim);\n	dim = vec1->dim;\n	__zadd__(vec1->ve,vec2->ve,out->ve,(int)dim);\n\n	return (out);\n}\n\n/* zv_mltadd -- scalar/vector multiplication and addition\n		-- out = v1 + scale.v2		*/\n#ifndef ANSI_C\nZVEC	*zv_mltadd(v1,v2,scale,out)\nZVEC	*v1,*v2,*out;\ncomplex	scale;\n#else\nZVEC	*zv_mltadd(const ZVEC *v1, const ZVEC *v2, complex scale, ZVEC *out)\n#endif\n{\n	/* register unsigned int	dim, i; */\n	/* complex	*out_ve, *v1_ve, *v2_ve; */\n\n	if ( v1==ZVNULL || v2==ZVNULL )\n		error(E_NULL,"zv_mltadd");\n	if ( v1->dim != v2->dim )\n		error(E_SIZES,"zv_mltadd");\n	if ( scale.re == 0.0 && scale.im == 0.0 )\n		return zv_copy(v1,out);\n	if ( scale.re == 1.0 && scale.im == 0.0 )\n		return zv_add(v1,v2,out);\n\n	if ( v2 != out )\n	{\n	    tracecatch(out = zv_copy(v1,out),"zv_mltadd");\n\n	    /* dim = v1->dim; */\n	    __zmltadd__(out->ve,v2->ve,scale,(int)(v1->dim),0);\n	}\n	else\n	{\n	    tracecatch(out = zv_mlt(scale,v2,out),"zv_mltadd");\n	    out = zv_add(v1,out,out);\n	}\n\n	return (out);\n}\n\n/* zv_sub -- vector subtraction -- may be in-situ */\n#ifndef ANSI_C\nZVEC	*zv_sub(vec1,vec2,out)\nZVEC	*vec1,*vec2,*out;\n#else\nZVEC	*zv_sub(const ZVEC *vec1, const ZVEC *vec2, ZVEC *out)\n#endif\n{\n	/* unsigned int	i, dim; */\n	/* complex	*out_ve, *vec1_ve, *vec2_ve; */\n\n	if ( vec1==ZVNULL || vec2==ZVNULL )\n		error(E_NULL,"zv_sub");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,"zv_sub");\n	if ( out==ZVNULL || out->dim != vec1->dim )\n		out = zv_resize(out,vec1->dim);\n\n	__zsub__(vec1->ve,vec2->ve,out->ve,(int)(vec1->dim));\n\n	return (out);\n}\n\n/* zv_map -- maps function f over components of x: out[i] = f(x[i])\n	-- _zv_map sets out[i] = f(x[i],params) */\n#ifndef ANSI_C\nZVEC	*zv_map(f,x,out)\n#ifdef PROTOYPES_IN_STRUCT\ncomplex	(*f)(complex);\n#else\ncomplex (*f)();\n#endif\nZVEC	*x, *out;\n#else\nZVEC	*zv_map(complex (*f)(complex), const ZVEC *x, ZVEC *out)\n#endif\n{\n	complex	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,"zv_map");\n	if ( ! out || out->dim != x->dim )\n		out = zv_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		out_ve[i] = (*f)(x_ve[i]);\n\n	return out;\n}\n\n#ifndef ANSI_C\nZVEC	*_zv_map(f,params,x,out)\n#ifdef PROTOTYPES_IN_STRUCT\ncomplex	(*f)(void *,complex);\n#else\ncomplex	(*f)();\n#endif\nZVEC	*x, *out;\nvoid	*params;\n#else\nZVEC	*_zv_map(complex (*f)(void *,complex), void *params,\n		 const ZVEC *x, ZVEC *out)\n#endif\n{\n	complex	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,"_zv_map");\n	if ( ! out || out->dim != x->dim )\n		out = zv_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		out_ve[i] = (*f)(params,x_ve[i]);\n\n	return out;\n}\n\n/* zv_lincomb -- returns sum_i a[i].v[i], a[i] real, v[i] vectors */\n#ifndef ANSI_C\nZVEC	*zv_lincomb(n,v,a,out)\nint	n;	/* number of a's and v's */\ncomplex	a[];\nZVEC	*v[], *out;\n#else\nZVEC	*zv_lincomb(int n, const ZVEC *v[], const complex a[], ZVEC *out)\n#endif\n{\n	int	i;\n\n	if ( ! a || ! v )\n		error(E_NULL,"zv_lincomb");\n	if ( n <= 0 )\n		return ZVNULL;\n\n	for ( i = 1; i < n; i++ )\n		if ( out == v[i] )\n		    error(E_INSITU,"zv_lincomb");\n\n	out = zv_mlt(a[0],v[0],out);\n	for ( i = 1; i < n; i++ )\n	{\n		if ( ! v[i] )\n			error(E_NULL,"zv_lincomb");\n		if ( v[i]->dim != out->dim )\n			error(E_SIZES,"zv_lincomb");\n		out = zv_mltadd(out,v[i],a[i],out);\n	}\n\n	return out;\n}\n\n\n#ifdef ANSI_C\n\n\n/* zv_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      zv_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (ZVEC *) and ai are numbers (complex)\n*/\n\nZVEC	*zv_linlist(ZVEC *out,ZVEC *v1,complex a1,...)\n{\n   va_list ap;\n   ZVEC *par;\n   complex a_par;\n\n   if ( ! v1 )\n     return ZVNULL;\n   \n   va_start(ap, a1);\n   out = zv_mlt(a1,v1,out);\n   \n   while (par = va_arg(ap,ZVEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,complex);\n      if (a_par.re == 0.0 && a_par.im == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,"zv_linlist");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,"zv_linlist");\n\n      if (a_par.re == 1.0 && a_par.im == 0.0)\n	out = zv_add(out,par,out);\n      else if (a_par.re == -1.0 && a_par.im == 0.0)\n	out = zv_sub(out,par,out);\n      else\n	out = zv_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n\n\n#elif VARARGS\n\n/* zv_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      zv_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (ZVEC *) and ai are numbers (complex)\n*/\nZVEC  *zv_linlist(va_alist) va_dcl\n{\n   va_list ap;\n   ZVEC *par, *out;\n   complex a_par;\n\n   va_start(ap);\n   out = va_arg(ap,ZVEC *);\n   par = va_arg(ap,ZVEC *);\n   if ( ! par ) {\n      va_end(ap);\n      return ZVNULL;\n   }\n   \n   a_par = va_arg(ap,complex);\n   out = zv_mlt(a_par,par,out);\n   \n   while (par = va_arg(ap,ZVEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,complex);\n      if (a_par.re == 0.0 && a_par.im == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,"zv_linlist");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,"zv_linlist");\n\n      if (a_par.re == 1.0 && a_par.im == 0.0)\n	out = zv_add(out,par,out);\n      else if (a_par.re == -1.0 && a_par.im == 0.0)\n	out = zv_sub(out,par,out);\n      else\n	out = zv_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n\n\n#endif\n\n\n\n/* zv_star -- computes componentwise (Hadamard) product of x1 and x2\n	-- result out is returned */\n#ifndef ANSI_C\nZVEC	*zv_star(x1, x2, out)\nZVEC	*x1, *x2, *out;\n#else\nZVEC	*zv_star(const ZVEC *x1, const ZVEC *x2, ZVEC *out)\n#endif\n{\n    int		i;\n    Real	t_re, t_im;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,"zv_star");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,"zv_star");\n    out = zv_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	/* out->ve[i] = x1->ve[i] * x2->ve[i]; */\n	t_re = x1->ve[i].re*x2->ve[i].re - x1->ve[i].im*x2->ve[i].im;\n	t_im = x1->ve[i].re*x2->ve[i].im + x1->ve[i].im*x2->ve[i].re;\n	out->ve[i].re = t_re;\n	out->ve[i].im = t_im;\n    }\n\n    return out;\n}\n\n/* zv_slash -- computes componentwise ratio of x2 and x1\n	-- out[i] = x2[i] / x1[i]\n	-- if x1[i] == 0 for some i, then raise E_SING error\n	-- result out is returned */\n#ifndef ANSI_C\nZVEC	*zv_slash(x1, x2, out)\nZVEC	*x1, *x2, *out;\n#else\nZVEC	*zv_slash(const ZVEC *x1, const ZVEC *x2, ZVEC *out)\n#endif\n{\n    int		i;\n    Real	r2, t_re, t_im;\n    complex	tmp;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,"zv_slash");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,"zv_slash");\n    out = zv_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	r2 = x1->ve[i].re*x1->ve[i].re + x1->ve[i].im*x1->ve[i].im;\n	if ( r2 == 0.0 )\n	    error(E_SING,"zv_slash");\n	tmp.re =   x1->ve[i].re / r2;\n	tmp.im = - x1->ve[i].im / r2;\n	t_re = tmp.re*x2->ve[i].re - tmp.im*x2->ve[i].im;\n	t_im = tmp.re*x2->ve[i].im + tmp.im*x2->ve[i].re;\n	out->ve[i].re = t_re;\n	out->ve[i].im = t_im;\n    }\n\n    return out;\n}\n\n/* zv_sum -- returns sum of entries of a vector */\n#ifndef ANSI_C\ncomplex	zv_sum(x)\nZVEC	*x;\n#else\ncomplex	zv_sum(const ZVEC *x)\n#endif\n{\n    int		i;\n    complex	sum;\n\n    if ( ! x )\n	error(E_NULL,"zv_sum");\n\n    sum.re = sum.im = 0.0;\n    for ( i = 0; i < x->dim; i++ )\n    {\n	sum.re += x->ve[i].re;\n	sum.im += x->ve[i].im;\n    }\n\n    return sum;\n}\n\n/* px_zvec -- permute vector */\n#ifndef ANSI_C\nZVEC	*px_zvec(px,vector,out)\nPERM	*px;\nZVEC	*vector,*out;\n#else\nZVEC	*px_zvec(PERM *px, ZVEC *vector, ZVEC *out)\n#endif\n{\n    unsigned int	old_i, i, size, start;\n    complex	tmp;\n    \n    if ( px==PNULL || vector==ZVNULL )\n	error(E_NULL,"px_zvec");\n    if ( px->size > vector->dim )\n	error(E_SIZES,"px_zvec");\n    if ( out==ZVNULL || out->dim < vector->dim )\n	out = zv_resize(out,vector->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return zv_copy(vector,out);\n    \n    if ( out != vector )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,"px_vec");\n	    else\n		out->ve[i] = vector->ve[px->pe[i]];\n    }\n    else\n    {	/* in situ algorithm */\n	start = 0;\n	while ( start < size )\n	{\n	    old_i = start;\n	    i = px->pe[old_i];\n	    if ( i >= size )\n	    {\n		start++;\n		continue;\n	    }\n	    tmp = vector->ve[start];\n	    while ( TRUE )\n	    {\n		vector->ve[old_i] = vector->ve[i];\n		px->pe[old_i] = i+size;\n		old_i = i;\n		i = px->pe[old_i];\n		if ( i >= size )\n		    break;\n		if ( i == start )\n		{\n		    vector->ve[old_i] = tmp;\n		    px->pe[old_i] = i+size;\n		    break;\n		}\n	    }\n	    start++;\n	}\n	\n	for ( i = 0; i < size; i++ )\n	    if ( px->pe[i] < size )\n		error(E_BOUNDS,"px_vec");\n	    else\n		px->pe[i] = px->pe[i]-size;\n    }\n    \n    return out;\n}\n\n/* pxinv_zvec -- apply the inverse of px to x, returning the result in out\n		-- may NOT be in situ */\n#ifndef ANSI_C\nZVEC	*pxinv_zvec(px,x,out)\nPERM	*px;\nZVEC	*x, *out;\n#else\nZVEC	*pxinv_zvec(PERM *px, ZVEC *x, ZVEC *out)\n#endif\n{\n    unsigned int	i, size;\n    \n    if ( ! px || ! x )\n	error(E_NULL,"pxinv_zvec");\n    if ( px->size > x->dim )\n	error(E_SIZES,"pxinv_zvec");\n    if ( ! out || out->dim < x->dim )\n	out = zv_resize(out,x->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return zv_copy(x,out);\n    if ( out != x )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,"pxinv_vec");\n	    else\n		out->ve[px->pe[i]] = x->ve[i];\n    }\n    else\n    {	/* in situ algorithm --- cheat's way out */\n	px_inv(px,px);\n	px_zvec(px,x,out);\n	px_inv(px,px);\n    }\n    \n    \n    return out;\n}\n\n/* zv_rand -- randomise a complex vector; uniform in [0,1)+[0,1)*i */\n#ifndef ANSI_C\nZVEC	*zv_rand(x)\nZVEC	*x;\n#else\nZVEC	*zv_rand(ZVEC *x)\n#endif\n{\n    if ( ! x )\n	error(E_NULL,"zv_rand");\n\n    mrandlist((Real *)(x->ve),2*x->dim);\n\n    return x;\n}\n