\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  File with basic error-handling operations\n*/\n\nstatic	char	rcsid[] = "$Id: err.c,v 1.6 1995/01/30 14:49:14 des Exp $";\n\n#include	<stdio.h>\n#include	<setjmp.h>\n#include	<ctype.h>\n#include        "err.h"\n\n\n#ifdef SYSV\n/* AT&T System V */\n#include	<sys/signal.h>\n#else\n/* something else -- assume BSD or ANSI C */\n#include	<signal.h>\n#endif\n\n\n\n#define		FALSE	0\n#define		TRUE	1\n\n#define	EF_EXIT		0\n#define	EF_ABORT	1\n#define	EF_JUMP		2\n#define	EF_SILENT	3\n\n/* The only error caught in this file! */\n#define	E_SIGNAL	16\n\nstatic	char	*err_mesg[] =\n{	  "unknown error",			    /* 0 */\n	  "sizes of objects don't match",	    /* 1 */\n	  "index out of bounds",		    /* 2 */\n	  "can't allocate memory",		    /* 3 */\n	  "singular matrix",			    /* 4 */\n	  "matrix not positive definite",	    /* 5 */\n	  "incorrect format input",		    /* 6 */\n	  "bad input file/device",		    /* 7 */\n	  "NULL objects passed",		    /* 8 */\n	  "matrix not square",			    /* 9 */\n	  "object out of range",		    /* 10 */\n	  "can't do operation in situ for non-square matrix",   /* 11 */\n	  "can't do operation in situ",		    /* 12 */\n	  "excessive number of iterations",	    /* 13 */\n	  "convergence criterion failed",	    /* 14 */\n	  "bad starting value",			    /* 15 */\n	  "floating exception",			    /* 16 */\n	  "internal inconsistency (data structure)",/* 17 */\n	  "unexpected end-of-file",		    /* 18 */\n	  "shared vectors (cannot release them)",   /* 19 */  \n	  "negative argument",			    /* 20 */\n	  "cannot overwrite object",                /* 21 */\n	  "breakdown in iterative method"           /* 22 */\n	 };\n\n#define	MAXERR	(sizeof(err_mesg)/sizeof(char *))\n\nstatic char *warn_mesg[] = {\n   "unknown warning",				  /* 0 */\n   "wrong type number (use macro TYPE_*)",	  /* 1 */\n   "no corresponding mem_stat_mark",		  /* 2 */\n   "computed norm of a residual is less than 0",  /* 3 */\n   "resizing a shared vector"			  /* 4 */\n};\n\n#define MAXWARN  (sizeof(warn_mesg)/sizeof(char *))\n\n\n\n#define	MAX_ERRS	100\n\njmp_buf	restart;\n\n\n/* array of pointers to lists of errors */\n\ntypedef struct {\n   char **listp;    /* pointer to a list of errors */\n   unsigned len;    /* length of the list */\n   unsigned warn;   /* =FALSE - errors, =TRUE - warnings */\n}  Err_list;\n\nstatic Err_list     err_list[ERR_LIST_MAX_LEN] = {\n {err_mesg,MAXERR,FALSE},	/* basic errors list */\n {warn_mesg,MAXWARN,TRUE}	/* basic warnings list */\n};\n\n\nstatic int err_list_end = 2;   /* number of elements in err_list */\n\n/* attach a new list of errors pointed by err_ptr\n   or change a previous one;\n   list_len is the number of elements in the list;\n   list_num is the list number;\n   warn == FALSE - errors (stop the program),\n   warn == TRUE - warnings (continue the program);\n   Note: lists numbered 0 and 1 are attached automatically,\n   you do not need to do it\n   */\n#ifndef ANSI_C\nint err_list_attach(list_num, list_len,err_ptr,warn)\nint list_num, list_len, warn;\nchar **err_ptr;\n#else\nint err_list_attach(int list_num, int list_len, char **err_ptr, int warn)\n#endif\n{\n   if (list_num < 0 || list_len <= 0 ||\n       err_ptr == (char **)NULL) \n     return -1;\n   \n   if (list_num >= ERR_LIST_MAX_LEN) {\n	fprintf(stderr,"\n file \"%s\": %s %s\n",\n		"err.c","increase the value of ERR_LIST_MAX_LEN",\n		"in matrix.h and zmatdef.h");\n	if ( ! isatty(fileno(stdout)) )\n	  fprintf(stderr,"\n file \"%s\": %s %s\n",\n		  "err.c","increase the value of ERR_LIST_MAX_LEN",\n		  "in matrix.h and zmatdef.h");\n	printf("Exiting program\n");\n	exit(0);\n     }\n\n   if (err_list[list_num].listp != (char **)NULL &&\n       err_list[list_num].listp != err_ptr)\n     free((char *)err_list[list_num].listp);\n   err_list[list_num].listp = err_ptr;\n   err_list[list_num].len = list_len;\n   err_list[list_num].warn = warn;\n   err_list_end = list_num+1;\n   \n   return list_num;\n}\n\n\n/* release the error list numbered list_num */\n#ifndef ANSI_C\nint err_list_free(list_num)\nint list_num;\n#else\nint err_list_free(int list_num)\n#endif\n{\n   if (list_num < 0 || list_num >= err_list_end) return -1;\n   if (err_list[list_num].listp != (char **)NULL) {\n      err_list[list_num].listp = (char **)NULL;\n      err_list[list_num].len = 0;\n      err_list[list_num].warn = 0;\n   }\n   return 0;\n}\n\n\n/* check if list_num is attached;\n   return FALSE if not;\n   return TRUE if yes\n   */\n#ifndef ANSI_C\nint err_is_list_attached(list_num)\nint list_num;\n#else\nint err_is_list_attached(int list_num)\n#endif\n{\n   if (list_num < 0 || list_num >= err_list_end)\n     return FALSE;\n   \n   if (err_list[list_num].listp != (char **)NULL)\n     return TRUE;\n   \n   return FALSE;\n}\n\n/* other local variables */\n\nstatic	int	err_flag = EF_EXIT, num_errs = 0, cnt_errs = 1;\n\n/* set_err_flag -- sets err_flag -- returns old err_flag */\n#ifndef ANSI_C\nint	set_err_flag(flag)\nint	flag;\n#else\nint	set_err_flag(int flag)\n#endif\n{\n   int	tmp;\n   \n   tmp = err_flag;\n   err_flag = flag;\n   return tmp;\n}\n\n/* count_errs -- sets cnt_errs (TRUE/FALSE) & returns old value */\n#ifndef ANSI_C\nint	count_errs(flag)\nint	flag;\n#else\nint	count_errs(int flag)\n#endif\n{\n   int	tmp;\n   \n   tmp = cnt_errs;\n   cnt_errs = flag;\n   return tmp;\n}\n\n/* ev_err -- reports error (err_num) in file "file" at line "line_num" and\n   returns to user error handler;\n   list_num is an error list number (0 is the basic list \n   pointed by err_mesg, 1 is the basic list of warnings)\n */\n#ifndef ANSI_C\nint	ev_err(file,err_num,line_num,fn_name,list_num)\nchar	*file, *fn_name;\nint	err_num, line_num,list_num;\n#else\nint	ev_err(const char *file, int err_num, int line_num,\n	       const char *fn_name, int list_num)\n#endif\n{\n   int	num;\n   \n   if ( err_num < 0 ) err_num = 0;\n   \n   if (list_num < 0 || list_num >= err_list_end ||\n       err_list[list_num].listp == (char **)NULL) {\n      fprintf(stderr,\n	      "\n Not (properly) attached list of errors: list_num = %d\n",\n	      list_num);\n      fprintf(stderr," Call \"err_list_attach\" in your program\n");\n      if ( ! isatty(fileno(stdout)) ) {\n	 fprintf(stderr,\n		 "\n Not (properly) attached list of errors: list_num = %d\n",\n		 list_num);\n	 fprintf(stderr," Call \"err_list_attach\" in your program\n");\n      }\n      printf("\nExiting program\n");\n      exit(0);\n   }\n   \n   num = err_num;\n   if ( num >= err_list[list_num].len ) num = 0;\n   \n   if ( cnt_errs && ++num_errs >= MAX_ERRS )	/* too many errors */\n   {\n      fprintf(stderr,"\n\"%s\", line %d: %s in function %s()\n",\n	      file,line_num,err_list[list_num].listp[num],\n	      isascii(*fn_name) ? fn_name : "???");\n      if ( ! isatty(fileno(stdout)) )\n	fprintf(stdout,"\n\"%s\", line %d: %s in function %s()\n",\n		file,line_num,err_list[list_num].listp[num],\n		isascii(*fn_name) ? fn_name : "???");\n      printf("Sorry, too many errors: %d\n",num_errs);\n      printf("Exiting program\n");\n      exit(0);\n   }\n   if ( err_list[list_num].warn )\n       switch ( err_flag )\n       {\n	   case EF_SILENT: break;\n	   default:\n	   fprintf(stderr,"\n\"%s\", line %d: %s in function %s()\n\n",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : "???");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,"\n\"%s\", line %d: %s in function %s()\n\n",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : "???");\n	   break;\n       }\n   else\n       switch ( err_flag )\n       {\n	   case EF_SILENT:\n	   longjmp(restart,(err_num==0)? -1 : err_num);\n	   break;\n	   case EF_ABORT:\n	   fprintf(stderr,"\n\"%s\", line %d: %s in function %s()\n",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : "???");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,"\n\"%s\", line %d: %s in function %s()\n",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : "???");\n	   abort();\n	   break;\n	   case EF_JUMP:\n	   fprintf(stderr,"\n\"%s\", line %d: %s in function %s()\n",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : "???");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,"\n\"%s\", line %d: %s in function %s()\n",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : "???");\n	   longjmp(restart,(err_num==0)? -1 : err_num);\n	   break;\n	   default:\n	   fprintf(stderr,"\n\"%s\", line %d: %s in function %s()\n\n",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : "???");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,"\n\"%s\", line %d: %s in function %s()\n\n",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : "???");\n	   \n	   break;\n       }\n   \n   /* ensure exit if fall through */\n   if ( ! err_list[list_num].warn )  exit(0);\n\n   return 0;\n}\n\n/* float_error -- catches floating arithmetic signals */\n#ifndef ANSI_C\nstatic void	float_error(num)\nint	num;\n#else\nstatic void	float_error(int num)\n#endif\n{\n   signal(SIGFPE,float_error);\n   /* fprintf(stderr,"SIGFPE: signal #%d\n",num); */\n   /* fprintf(stderr,"errno = %d\n",errno); */\n   ev_err("???.c",E_SIGNAL,0,"???",0);\n}\n\n/* catch_signal -- sets up float_error() to catch SIGFPE's */\nvoid	catch_FPE()\n{\n   signal(SIGFPE,float_error);\n}\n\n\n