/**\n * @file ex_particle_OPENMP_seq.c\n * @author Michael Trotter & Matt Goodrum\n * @brief Particle filter implementation in C/OpenMP \n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI 3.1415926535897932\n/**\n@var M value for Linear Congruential Generator (LCG); use GCC's value\n*/\nlong M = INT_MAX;\n/**\n@var A value for LCG\n*/\nint A = 1103515245;\n/**\n@var C value for LCG\n*/\nint C = 12345;\n/*****************************\n*GET_TIME\n*returns a long int representing the time\n*****************************/\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n// Returns the number of seconds elapsed between the two specified times\nfloat elapsed_time(long long start_time, long long end_time) {\n        return (float) (end_time - start_time) / (1000 * 1000);\n}\n/** \n* Takes in a double and returns an integer that approximates to that double\n* @return if the mantissa < .5 => return value < input value; else return value > input value\n*/\ndouble roundDouble(double value){\n	int newValue = (int)(value);\n	if(value - newValue < .5)\n	return newValue;\n	else\n	return newValue++;\n}\n/**\n* Set values of the 3D array to a newValue if that value is equal to the testValue\n* @param testValue The value to be replaced\n* @param newValue The value to replace testValue with\n* @param array3D The image vector\n* @param dimX The x dimension of the frame\n* @param dimY The y dimension of the frame\n* @param dimZ The number of frames\n*/\nvoid setIf(int testValue, int newValue, int * array3D, int * dimX, int * dimY, int * dimZ){\n	int x, y, z;\n	for(x = 0; x < *dimX; x++){\n		for(y = 0; y < *dimY; y++){\n			for(z = 0; z < *dimZ; z++){\n				if(array3D[x * *dimY * *dimZ+y * *dimZ + z] == testValue)\n				array3D[x * *dimY * *dimZ + y * *dimZ + z] = newValue;\n			}\n		}\n	}\n}\n/**\n* Generates a uniformly distributed random number using the provided seed and GCC's settings for the Linear Congruential Generator (LCG)\n* @see http://en.wikipedia.org/wiki/Linear_congruential_generator\n* @note This function is thread-safe\n* @param seed The seed array\n* @param index The specific index of the seed to be advanced\n* @return a uniformly distributed number [0, 1)\n*/\ndouble randu(int * seed, int index)\n{\n	int num = A*seed[index] + C;\n	seed[index] = num % M;\n	return fabs(seed[index]/((double) M));\n}\n/**\n* Generates a normally distributed random number using the Box-Muller transformation\n* @note This function is thread-safe\n* @param seed The seed array\n* @param index The specific index of the seed to be advanced\n* @return a double representing random number generated using the Box-Muller algorithm\n* @see http://en.wikipedia.org/wiki/Normal_distribution, section computing value for normal random distribution\n*/\ndouble randn(int * seed, int index){\n	/*Box-Muller algorithm*/\n	double u = randu(seed, index);\n	double v = randu(seed, index);\n	double cosine = cos(2*PI*v);\n	double rt = -2*log(u);\n	return sqrt(rt)*cosine;\n}\n/**\n* Sets values of 3D matrix using randomly generated numbers from a normal distribution\n* @param array3D The video to be modified\n* @param dimX The x dimension of the frame\n* @param dimY The y dimension of the frame\n* @param dimZ The number of frames\n* @param seed The seed array\n*/\nvoid addNoise(int * array3D, int * dimX, int * dimY, int * dimZ, int * seed){\n	int x, y, z;\n	for(x = 0; x < *dimX; x++){\n		for(y = 0; y < *dimY; y++){\n			for(z = 0; z < *dimZ; z++){\n				array3D[x * *dimY * *dimZ + y * *dimZ + z] = array3D[x * *dimY * *dimZ + y * *dimZ + z] + (int)(5*randn(seed, 0));\n			}\n		}\n	}\n}\n/**\n* Fills a radius x radius matrix representing the disk\n* @param disk The pointer to the disk to be made\n* @param radius  The radius of the disk to be made\n*/\nvoid strelDisk(int * disk, int radius)\n{\n	int diameter = radius*2 - 1;\n	int x, y;\n	for(x = 0; x < diameter; x++){\n		for(y = 0; y < diameter; y++){\n			double distance = sqrt(pow((double)(x-radius+1),2) + pow((double)(y-radius+1),2));\n			if(distance < radius)\n			disk[x*diameter + y] = 1;\n		}\n	}\n}\n/**\n* Dilates the provided video\n* @param matrix The video to be dilated\n* @param posX The x location of the pixel to be dilated\n* @param posY The y location of the pixel to be dilated\n* @param poxZ The z location of the pixel to be dilated\n* @param dimX The x dimension of the frame\n* @param dimY The y dimension of the frame\n* @param dimZ The number of frames\n* @param error The error radius\n*/\nvoid dilate_matrix(int * matrix, int posX, int posY, int posZ, int dimX, int dimY, int dimZ, int error)\n{\n	int startX = posX - error;\n	while(startX < 0)\n	startX++;\n	int startY = posY - error;\n	while(startY < 0)\n	startY++;\n	int endX = posX + error;\n	while(endX > dimX)\n	endX--;\n	int endY = posY + error;\n	while(endY > dimY)\n	endY--;\n	int x,y;\n	for(x = startX; x < endX; x++){\n		for(y = startY; y < endY; y++){\n			double distance = sqrt( pow((double)(x-posX),2) + pow((double)(y-posY),2) );\n			if(distance < error)\n			matrix[x*dimY*dimZ + y*dimZ + posZ] = 1;\n		}\n	}\n}\n\n/**\n* Dilates the target matrix using the radius as a guide\n* @param matrix The reference matrix\n* @param dimX The x dimension of the video\n* @param dimY The y dimension of the video\n* @param dimZ The z dimension of the video\n* @param error The error radius to be dilated\n* @param newMatrix The target matrix\n*/\nvoid imdilate_disk(int * matrix, int dimX, int dimY, int dimZ, int error, int * newMatrix)\n{\n	int x, y, z;\n	for(z = 0; z < dimZ; z++){\n		for(x = 0; x < dimX; x++){\n			for(y = 0; y < dimY; y++){\n				if(matrix[x*dimY*dimZ + y*dimZ + z] == 1){\n					dilate_matrix(newMatrix, x, y, z, dimX, dimY, dimZ, error);\n				}\n			}\n		}\n	}\n}\n/**\n* Fills a 2D array describing the offsets of the disk object\n* @param se The disk object\n* @param numOnes The number of ones in the disk\n* @param neighbors The array that will contain the offsets\n* @param radius The radius used for dilation\n*/\nvoid getneighbors(int * se, int numOnes, double * neighbors, int radius){\n	int x, y;\n	int neighY = 0;\n	int center = radius - 1;\n	int diameter = radius*2 -1;\n	for(x = 0; x < diameter; x++){\n		for(y = 0; y < diameter; y++){\n			if(se[x*diameter + y]){\n				neighbors[neighY*2] = (int)(y - center);\n				neighbors[neighY*2 + 1] = (int)(x - center);\n				neighY++;\n			}\n		}\n	}\n}\n/**\n* The synthetic video sequence we will work with here is composed of a\n* single moving object, circular in shape (fixed radius)\n* The motion here is a linear motion\n* the foreground intensity and the backgrounf intensity is known\n* the image is corrupted with zero mean Gaussian noise\n* @param I The video itself\n* @param IszX The x dimension of the video\n* @param IszY The y dimension of the video\n* @param Nfr The number of frames of the video\n* @param seed The seed array used for number generation\n*/\nvoid videoSequence(int * I, int IszX, int IszY, int Nfr, int * seed){\n	int k;\n	int max_size = IszX*IszY*Nfr;\n	/*get object centers*/\n	int x0 = (int)roundDouble(IszY/2.0);\n	int y0 = (int)roundDouble(IszX/2.0);\n	I[x0 *IszY *Nfr + y0 * Nfr  + 0] = 1;\n	\n	/*move point*/\n	int xk, yk, pos;\n	for(k = 1; k < Nfr; k++){\n		xk = abs(x0 + (k-1));\n		yk = abs(y0 - 2*(k-1));\n		pos = yk * IszY * Nfr + xk *Nfr + k;\n		if(pos >= max_size)\n		pos = 0;\n		I[pos] = 1;\n	}\n	\n	/*dilate matrix*/\n	int * newMatrix = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);\n	imdilate_disk(I, IszX, IszY, Nfr, 5, newMatrix);\n	int x, y;\n	for(x = 0; x < IszX; x++){\n		for(y = 0; y < IszY; y++){\n			for(k = 0; k < Nfr; k++){\n				I[x*IszY*Nfr + y*Nfr + k] = newMatrix[x*IszY*Nfr + y*Nfr + k];\n			}\n		}\n	}\n	free(newMatrix);\n	\n	/*define background, add noise*/\n	setIf(0, 100, I, &IszX, &IszY, &Nfr);\n	setIf(1, 228, I, &IszX, &IszY, &Nfr);\n	/*add noise*/\n	addNoise(I, &IszX, &IszY, &Nfr, seed);\n}\n/**\n* Determines the likelihood sum based on the formula: SUM( (IK[IND] - 100)^2 - (IK[IND] - 228)^2)/ 100\n* @param I The 3D matrix\n* @param ind The current ind array\n* @param numOnes The length of ind array\n* @return A double representing the sum\n*/\ndouble calcLikelihoodSum(int * I, int * ind, int numOnes){\n	double likelihoodSum = 0.0;\n	int y;\n	for(y = 0; y < numOnes; y++)\n	likelihoodSum += (pow((I[ind[y]] - 100),2) - pow((I[ind[y]]-228),2))/50.0;\n	return likelihoodSum;\n}\n/**\n* Finds the first element in the CDF that is greater than or equal to the provided value and returns that index\n* @note This function uses sequential search\n* @param CDF The CDF\n* @param lengthCDF The length of CDF\n* @param value The value to be found\n* @return The index of value in the CDF; if value is never found, returns the last index\n*/\nint findIndex(double * CDF, int lengthCDF, double value){\n	int index = -1;\n	int x;\n	for(x = 0; x < lengthCDF; x++){\n		if(CDF[x] >= value){\n			index = x;\n			break;\n		}\n	}\n	if(index == -1){\n		return lengthCDF-1;\n	}\n	return index;\n}\n/**\n* Finds the first element in the CDF that is greater than or equal to the provided value and returns that index\n* @note This function uses binary search before switching to sequential search\n* @param CDF The CDF\n* @param beginIndex The index to start searching from\n* @param endIndex The index to stop searching\n* @param value The value to find\n* @return The index of value in the CDF; if value is never found, returns the last index\n* @warning Use at your own risk; not fully tested\n*/\nint findIndexBin(double * CDF, int beginIndex, int endIndex, double value){\n	if(endIndex < beginIndex)\n	return -1;\n	int middleIndex = beginIndex + ((endIndex - beginIndex)/2);\n	/*check the value*/\n	if(CDF[middleIndex] >= value)\n	{\n		/*check that it's good*/\n		if(middleIndex == 0)\n		return middleIndex;\n		else if(CDF[middleIndex-1] < value)\n		return middleIndex;\n		else if(CDF[middleIndex-1] == value)\n		{\n			while(middleIndex > 0 && CDF[middleIndex-1] == value)\n			middleIndex--;\n			return middleIndex;\n		}\n	}\n	if(CDF[middleIndex] > value)\n	return findIndexBin(CDF, beginIndex, middleIndex+1, value);\n	return findIndexBin(CDF, middleIndex-1, endIndex, value);\n}\n/**\n* The implementation of the particle filter using OpenMP for many frames\n* @see http://openmp.org/wp/\n* @note This function is designed to work with a video of several frames. In addition, it references a provided MATLAB function which takes the video, the objxy matrix and the x and y arrays as arguments and returns the likelihoods\n* @param I The video to be run\n* @param IszX The x dimension of the video\n* @param IszY The y dimension of the video\n* @param Nfr The number of frames\n* @param seed The seed array used for random number generation\n* @param Nparticles The number of particles to be used\n*/\nvoid particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){\n	\n	int max_size = IszX*IszY*Nfr;\n	long long start = get_time();\n	//original particle centroid\n	double xe = roundDouble(IszY/2.0);\n	double ye = roundDouble(IszX/2.0);\n	\n	//expected object locations, compared to center\n	int radius = 5;\n	int diameter = radius*2 - 1;\n	int * disk = (int *)malloc(diameter*diameter*sizeof(int));\n	strelDisk(disk, radius);\n	int countOnes = 0;\n	int x, y;\n	for(x = 0; x < diameter; x++){\n		for(y = 0; y < diameter; y++){\n			if(disk[x*diameter + y] == 1)\n				countOnes++;\n		}\n	}\n	double * objxy = (double *)malloc(countOnes*2*sizeof(double));\n	getneighbors(disk, countOnes, objxy, radius);\n	\n	long long get_neighbors = get_time();\n	printf("TIME TO GET NEIGHBORS TOOK: %f\n", elapsed_time(start, get_neighbors));\n	//initial weights are all equal (1/Nparticles)\n	double * weights = (double *)malloc(sizeof(double)*Nparticles);\n	#pragma omp parallel for shared(weights, Nparticles) private(x)\n	for(x = 0; x < Nparticles; x++){\n		weights[x] = 1/((double)(Nparticles));\n	}\n	long long get_weights = get_time();\n	printf("TIME TO GET WEIGHTSTOOK: %f\n", elapsed_time(get_neighbors, get_weights));\n	//initial likelihood to 0.0\n	double * likelihood = (double *)malloc(sizeof(double)*Nparticles);\n	double * arrayX = (double *)malloc(sizeof(double)*Nparticles);\n	double * arrayY = (double *)malloc(sizeof(double)*Nparticles);\n	double * xj = (double *)malloc(sizeof(double)*Nparticles);\n	double * yj = (double *)malloc(sizeof(double)*Nparticles);\n	double * CDF = (double *)malloc(sizeof(double)*Nparticles);\n	double * u = (double *)malloc(sizeof(double)*Nparticles);\n	int * ind = (int*)malloc(sizeof(int)*countOnes*Nparticles);\n	#pragma omp parallel for shared(arrayX, arrayY, xe, ye) private(x)\n	for(x = 0; x < Nparticles; x++){\n		arrayX[x] = xe;\n		arrayY[x] = ye;\n	}\n	int k;\n	\n	printf("TIME TO SET ARRAYS TOOK: %f\n", elapsed_time(get_weights, get_time()));\n	int indX, indY;\n	for(k = 1; k < Nfr; k++){\n		long long set_arrays = get_time();\n		//apply motion model\n		//draws sample from motion model (random walk). The only prior information\n		//is that the object moves 2x as fast as in the y direction\n		#pragma omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x)\n		for(x = 0; x < Nparticles; x++){\n			arrayX[x] += 1 + 5*randn(seed, x);\n			arrayY[x] += -2 + 2*randn(seed, x);\n		}\n		long long error = get_time();\n		printf("TIME TO SET ERROR TOOK: %f\n", elapsed_time(set_arrays, error));\n		//particle filter likelihood\n		#pragma omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)\n		for(x = 0; x < Nparticles; x++){\n			//compute the likelihood: remember our assumption is that you know\n			// foreground and the background image intensity distribution.\n			// Notice that we consider here a likelihood ratio, instead of\n			// p(z|x). It is possible in this case. why? a hometask for you.		\n			//calc ind\n			for(y = 0; y < countOnes; y++){\n				indX = roundDouble(arrayX[x]) + objxy[y*2 + 1];\n				indY = roundDouble(arrayY[x]) + objxy[y*2];\n				ind[x*countOnes + y] = fabs(indX*IszY*Nfr + indY*Nfr + k);\n				if(ind[x*countOnes + y] >= max_size)\n					ind[x*countOnes + y] = 0;\n			}\n			likelihood[x] = 0;\n			for(y = 0; y < countOnes; y++)\n				likelihood[x] += (pow((I[ind[x*countOnes + y]] - 100),2) - pow((I[ind[x*countOnes + y]]-228),2))/50.0;\n			likelihood[x] = likelihood[x]/((double) countOnes);\n		}\n		long long likelihood_time = get_time();\n		printf("TIME TO GET LIKELIHOODS TOOK: %f\n", elapsed_time(error, likelihood_time));\n		// update & normalize weights\n		// using equation (63) of Arulampalam Tutorial\n		#pragma omp parallel for shared(Nparticles, weights, likelihood) private(x)\n		for(x = 0; x < Nparticles; x++){\n			weights[x] = weights[x] * exp(likelihood[x]);\n		}\n		long long exponential = get_time();\n		printf("TIME TO GET EXP TOOK: %f\n", elapsed_time(likelihood_time, exponential));\n		double sumWeights = 0;\n		#pragma omp parallel for private(x) reduction(+:sumWeights)\n		for(x = 0; x < Nparticles; x++){\n			sumWeights += weights[x];\n		}\n		long long sum_time = get_time();\n		printf("TIME TO SUM WEIGHTS TOOK: %f\n", elapsed_time(exponential, sum_time));\n		#pragma omp parallel for shared(sumWeights, weights) private(x)\n		for(x = 0; x < Nparticles; x++){\n			weights[x] = weights[x]/sumWeights;\n		}\n		long long normalize = get_time();\n		printf("TIME TO NORMALIZE WEIGHTS TOOK: %f\n", elapsed_time(sum_time, normalize));\n		xe = 0;\n		ye = 0;\n		// estimate the object location by expected values\n		#pragma omp parallel for private(x) reduction(+:xe, ye)\n		for(x = 0; x < Nparticles; x++){\n			xe += arrayX[x] * weights[x];\n			ye += arrayY[x] * weights[x];\n		}\n		long long move_time = get_time();\n		printf("TIME TO MOVE OBJECT TOOK: %f\n", elapsed_time(normalize, move_time));\n		printf("XE: %lf\n", xe);\n		printf("YE: %lf\n", ye);\n		double distance = sqrt( pow((double)(xe-(int)roundDouble(IszY/2.0)),2) + pow((double)(ye-(int)roundDouble(IszX/2.0)),2) );\n		printf("%lf\n", distance);\n		//display(hold off for now)\n		\n		//pause(hold off for now)\n		\n		//resampling\n		\n		\n		CDF[0] = weights[0];\n		for(x = 1; x < Nparticles; x++){\n			CDF[x] = weights[x] + CDF[x-1];\n		}\n		long long cum_sum = get_time();\n		printf("TIME TO CALC CUM SUM TOOK: %f\n", elapsed_time(move_time, cum_sum));\n		double u1 = (1/((double)(Nparticles)))*randu(seed, 0);\n		#pragma omp parallel for shared(u, u1, Nparticles) private(x)\n		for(x = 0; x < Nparticles; x++){\n			u[x] = u1 + x/((double)(Nparticles));\n		}\n		long long u_time = get_time();\n		printf("TIME TO CALC U TOOK: %f\n", elapsed_time(cum_sum, u_time));\n		int j, i;\n		\n		#pragma omp parallel for shared(CDF, Nparticles, xj, yj, u, arrayX, arrayY) private(i, j)\n		for(j = 0; j < Nparticles; j++){\n			i = findIndex(CDF, Nparticles, u[j]);\n			if(i == -1)\n				i = Nparticles-1;\n			xj[j] = arrayX[i];\n			yj[j] = arrayY[i];\n			\n		}\n		long long xyj_time = get_time();\n		printf("TIME TO CALC NEW ARRAY X AND Y TOOK: %f\n", elapsed_time(u_time, xyj_time));\n		\n		//#pragma omp parallel for shared(weights, Nparticles) private(x)\n		for(x = 0; x < Nparticles; x++){\n			//reassign arrayX and arrayY\n			arrayX[x] = xj[x];\n			arrayY[x] = yj[x];\n			weights[x] = 1/((double)(Nparticles));\n		}\n		long long reset = get_time();\n		printf("TIME TO RESET WEIGHTS TOOK: %f\n", elapsed_time(xyj_time, reset));\n	}\n	free(disk);\n	free(objxy);\n	free(weights);\n	free(likelihood);\n	free(xj);\n	free(yj);\n	free(arrayX);\n	free(arrayY);\n	free(CDF);\n	free(u);\n	free(ind);\n}\nint main(int argc, char * argv[]){\n	\n	char* usage = "openmp.out -x <dimX> -y <dimY> -z <Nfr> -np <Nparticles>";\n	//check number of arguments\n	if(argc != 9)\n	{\n		printf("%s\n", usage);\n		return 0;\n	}\n	//check args deliminators\n	if( strcmp( argv[1], "-x" ) ||  strcmp( argv[3], "-y" ) || strcmp( argv[5], "-z" ) || strcmp( argv[7], "-np" ) ) {\n		printf( "%s\n",usage );\n		return 0;\n	}\n	\n	int IszX, IszY, Nfr, Nparticles;\n	\n	//converting a string to a integer\n	if( sscanf( argv[2], "%d", &IszX ) == EOF ) {\n	   printf("ERROR: dimX input is incorrect");\n	   return 0;\n	}\n	\n	if( IszX <= 0 ) {\n		printf("dimX must be > 0\n");\n		return 0;\n	}\n	\n	//converting a string to a integer\n	if( sscanf( argv[4], "%d", &IszY ) == EOF ) {\n	   printf("ERROR: dimY input is incorrect");\n	   return 0;\n	}\n	\n	if( IszY <= 0 ) {\n		printf("dimY must be > 0\n");\n		return 0;\n	}\n	\n	//converting a string to a integer\n	if( sscanf( argv[6], "%d", &Nfr ) == EOF ) {\n	   printf("ERROR: Number of frames input is incorrect");\n	   return 0;\n	}\n	\n	if( Nfr <= 0 ) {\n		printf("number of frames must be > 0\n");\n		return 0;\n	}\n	\n	//converting a string to a integer\n	if( sscanf( argv[8], "%d", &Nparticles ) == EOF ) {\n	   printf("ERROR: Number of particles input is incorrect");\n	   return 0;\n	}\n	\n	if( Nparticles <= 0 ) {\n		printf("Number of particles must be > 0\n");\n		return 0;\n	}\n	//establish seed\n	int * seed = (int *)malloc(sizeof(int)*Nparticles);\n	int i;\n	for(i = 0; i < Nparticles; i++)\n		seed[i] = time(0)*i;\n	//malloc matrix\n	int * I = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);\n	long long start = get_time();\n	//call video sequence\n	videoSequence(I, IszX, IszY, Nfr, seed);\n	long long endVideoSequence = get_time();\n	printf("VIDEO SEQUENCE TOOK %f\n", elapsed_time(start, endVideoSequence));\n	//call particle filter\n	particleFilter(I, IszX, IszY, Nfr, seed, Nparticles);\n	long long endParticleFilter = get_time();\n	printf("PARTICLE FILTER TOOK %f\n", elapsed_time(endVideoSequence, endParticleFilter));\n	printf("ENTIRE PROGRAM TOOK %f\n", elapsed_time(start, endParticleFilter));\n	\n	free(seed);\n	free(I);\n	return 0;\n}\n