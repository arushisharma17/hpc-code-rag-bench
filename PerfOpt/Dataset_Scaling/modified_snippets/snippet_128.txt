\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains tests for the sparse matrix part of Meschach\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix2.h"\n#include	"sparse2.h"\n#include        "iter.h"\n\n#define	errmesg(mesg)	printf("Error: %s error: line %d\n",mesg,__LINE__)\n#define notice(mesg)	printf("# Testing %s...\n",mesg);\n\n/* for iterative methods */\n\n#if REAL == DOUBLE\n#define	EPS	1e-7\n#elif REAL == FLOAT\n#define EPS   1e-3\n#endif\n\nint	chk_col_accessSPT(A)\nSPMAT	*A;\n{\n    int		i, j, nxt_idx, nxt_row, scan_cnt, total_cnt;\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( ! A )\n	error(E_NULL,"chk_col_accessSPT");\n    if ( ! A->flag_col )\n	return FALSE;\n\n    /* scan down each column, counting the number of entries met */\n    scan_cnt = 0;\n    for ( j = 0; j < A->n; j++ )\n    {\n	i = -1;\n	nxt_idx = A->start_idx[j];\n	nxt_row = A->start_row[j];\n	while ( nxt_row >= 0 && nxt_idx >= 0 && nxt_row > i )\n	{\n	    i = nxt_row;\n	    r = &(A->row[i]);\n	    e = &(r->elt[nxt_idx]);\n	    nxt_idx = e->nxt_idx;\n	    nxt_row = e->nxt_row;\n	    scan_cnt++;\n	}\n    }\n\n    total_cnt = 0;\n    for ( i = 0; i < A->m; i++ )\n	total_cnt += A->row[i].len;\n    if ( total_cnt != scan_cnt )\n	return FALSE;\n    else\n	return TRUE;\n}\n\n\nvoid	main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n    VEC		*x, *y, *z, *u, *v;\n    Real	s1, s2;\n    PERM	*pivot;\n    SPMAT	*A, *B, *C;\n    SPMAT       *B1, *C1;\n    SPROW	*r;\n    int		i, j, k, deg, seed, m, m_old, n, n_old;\n\n\n    mem_info_on(TRUE);\n\n    setbuf(stdout, (char *)NULL);\n    /* get seed if in argument list */\n    if ( argc == 1 )\n	seed = 1111;\n    else if ( argc == 2 && sscanf(argv[1],"%d",&seed) == 1 )\n	;\n    else\n    {\n	printf("usage: %s [seed]\n", argv[0]);\n	exit(0);\n    }\n    srand(seed);\n\n    /* set up two random sparse matrices */\n    m = 120;\n    n = 100;\n    deg = 8;\n    notice("allocating sparse matrices");\n    A = sp_get(m,n,deg);\n    B = sp_get(m,n,deg);\n    notice("setting and getting matrix entries");\n    for ( k = 0; k < m*deg; k++ )\n    {\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(A,i,j,rand()/((Real)MAX_RAND));\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(B,i,j,rand()/((Real)MAX_RAND));\n    }\n    for ( k = 0; k < 10; k++ )\n    {\n	s1 = rand()/((Real)MAX_RAND);\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(A,i,j,s1);\n	s2 = sp_get_val(A,i,j);\n	if ( fabs(s1 - s2) >= MACHEPS )\n	    break;\n    }\n    if ( k < 10 )\n	errmesg("sp_set_val()/sp_get_val()");\n\n    /* test copy routines */\n    notice("copy routines");\n    x = v_get(n);\n    y = v_get(m);\n    z = v_get(m);\n    /* first copy routine */\n    C = sp_copy(A);\n    for ( k = 0; k < 100; k++ )\n    {\n	v_rand(x);\n	sp_mv_mlt(A,x,y);\n	sp_mv_mlt(C,x,z);\n	if ( v_norm_inf(v_sub(y,z,z)) >= MACHEPS*deg*m )\n	    break;\n    }\n    if ( k < 100 )\n    {\n	errmesg("sp_copy()/sp_mv_mlt()");\n	printf("# Error in A.x (inf norm) = %g [cf MACHEPS = %g]\n",\n	       v_norm_inf(z), MACHEPS);\n    }\n    /* second copy routine\n       -- note that A & B have different sparsity patterns */\n\n    mem_stat_mark(1);\n    sp_copy2(A,B);\n    mem_stat_free(1);\n    for ( k = 0; k < 10; k++ )\n    {\n	v_rand(x);\n	sp_mv_mlt(A,x,y);\n	sp_mv_mlt(B,x,z);\n	if ( v_norm_inf(v_sub(y,z,z)) >= MACHEPS*deg*m )\n	    break;\n    }\n    if ( k < 10 )\n    {\n	errmesg("sp_copy2()/sp_mv_mlt()");\n	printf("# Error in A.x (inf norm) = %g [cf MACHEPS = %g]\n",\n	       v_norm_inf(z), MACHEPS);\n    }\n\n    /* now check compacting routine */\n    notice("compacting routine");\n    sp_compact(B,0.0);\n    for ( k = 0; k < 10; k++ )\n    {\n	v_rand(x);\n	sp_mv_mlt(A,x,y);\n	sp_mv_mlt(B,x,z);\n	if ( v_norm_inf(v_sub(y,z,z)) >= MACHEPS*deg*m )\n	    break;\n    }\n    if ( k < 10 )\n    {\n	errmesg("sp_compact()");\n	printf("# Error in A.x (inf norm) = %g [cf MACHEPS = %g]\n",\n	       v_norm_inf(z), MACHEPS);\n    }\n    for ( i = 0; i < B->m; i++ )\n    {\n	r = &(B->row[i]);\n	for ( j = 0; j < r->len; j++ )\n	    if ( r->elt[j].val == 0.0 )\n		break;\n    }\n    if ( i < B->m )\n    {\n	errmesg("sp_compact()");\n	printf("# Zero entry in compacted matrix\n");\n    }\n\n    /* check column access paths */\n    notice("resizing and access paths");\n    m_old = A->m-1;\n    n_old = A->n-1;\n    A = sp_resize(A,A->m+10,A->n+10);\n    for ( k = 0 ; k < 20; k++ )\n    {\n	i = m_old + ((rand() >> 8) % 10);\n	j = n_old + ((rand() >> 8) % 10);\n	s1 = rand()/((Real)MAX_RAND);\n	sp_set_val(A,i,j,s1);\n	if ( fabs(s1 - sp_get_val(A,i,j)) >= MACHEPS )\n	    break;\n    }\n    if ( k < 20 )\n	errmesg("sp_resize()");\n    sp_col_access(A);\n    if ( ! chk_col_accessSPT(A) )\n    {\n	errmesg("sp_col_access()");\n    }\n    sp_diag_access(A);\n    for ( i = 0; i < A->m; i++ )\n    {\n	r = &(A->row[i]);\n	if ( r->diag != sprow_idx(r,i) )\n	    break;\n    }\n    if ( i < A->m )\n    {\n	errmesg("sp_diag_access()");\n    }\n\n    /* test both sp_mv_mlt() and sp_vm_mlt() */\n    x = v_resize(x,B->n);\n    y = v_resize(y,B->m);\n    u = v_get(B->m);\n    v = v_get(B->n);\n    for ( k = 0; k < 10; k++ )\n    {\n	v_rand(x);\n	v_rand(y);\n	sp_mv_mlt(B,x,u);\n	sp_vm_mlt(B,y,v);\n	if ( fabs(in_prod(x,v) - in_prod(y,u)) >=\n	    MACHEPS*v_norm2(x)*v_norm2(u)*5 )\n	    break;\n    }\n    if ( k < 10 )\n    {\n	errmesg("sp_mv_mlt()/sp_vm_mlt()");\n	printf("# Error in inner products = %g [cf MACHEPS = %g]\n",\n	       fabs(in_prod(x,v) - in_prod(y,u)), MACHEPS);\n    }\n\n    SP_FREE(A);\n    SP_FREE(B);\n    SP_FREE(C);\n\n    /* now test Cholesky and LU factorise and solve */\n    notice("sparse Cholesky factorise/solve");\n    A = iter_gen_sym(120,8);\n    B = sp_copy(A);\n    spCHfactor(A);\n    x = v_resize(x,A->m);\n    y = v_resize(y,A->m);\n    v_rand(x);\n    sp_mv_mlt(B,x,y);\n    z = v_resize(z,A->m);\n    spCHsolve(A,y,z);\n    v = v_resize(v,A->m);\n    sp_mv_mlt(B,z,v);\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*10 )\n    {\n	errmesg("spCHfactor()/spCHsolve()");\n	printf("# Sparse Cholesky residual = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*10 )\n    {\n	errmesg("spCHfactor()/spCHsolve()");\n	printf("# Solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* now test symbolic and incomplete factorisation */\n    SP_FREE(A);\n    A = sp_copy(B);\n    \n    mem_stat_mark(2);\n    spCHsymb(A);\n    mem_stat_mark(2);\n\n    spICHfactor(A);\n    spCHsolve(A,y,z);\n    v = v_resize(v,A->m);\n    sp_mv_mlt(B,z,v);\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*5 )\n    {\n	errmesg("spCHsymb()/spICHfactor()");\n	printf("# Sparse Cholesky residual = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*10 )\n    {\n	errmesg("spCHsymb()/spICHfactor()");\n	printf("# Solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* now test sparse LU factorisation */\n    notice("sparse LU factorise/solve");\n    SP_FREE(A);\n    SP_FREE(B);\n    A = iter_gen_nonsym(100,100,8,1.0);\n\n    B = sp_copy(A);\n    x = v_resize(x,A->n);\n    z = v_resize(z,A->n);\n    y = v_resize(y,A->m);\n    v = v_resize(v,A->m);\n\n    v_rand(x);\n    sp_mv_mlt(B,x,y);\n    pivot = px_get(A->m);\n\n    mem_stat_mark(3);\n    spLUfactor(A,pivot,0.1);\n    spLUsolve(A,pivot,y,z);\n    mem_stat_free(3);\n    sp_mv_mlt(B,z,v);\n\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*A->m )\n    {\n	errmesg("spLUfactor()/spLUsolve()");\n	printf("# Sparse LU residual = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*100*A->m )\n    {\n	errmesg("spLUfactor()/spLUsolve()");\n	printf("# Sparse LU solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* now check spLUTsolve */\n    mem_stat_mark(4);\n    sp_vm_mlt(B,x,y);\n    spLUTsolve(A,pivot,y,z);\n    sp_vm_mlt(B,z,v);\n    mem_stat_free(4);\n\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*A->m )\n    {\n	errmesg("spLUTsolve()");\n	printf("# Sparse LU residual = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*100*A->m )\n    {\n	errmesg("spLUTsolve()");\n	printf("# Sparse LU solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* algebraic operations */\n    notice("addition,subtraction and multiplying by a number");\n    SP_FREE(A);\n    SP_FREE(B);\n\n    m = 120;\n    n = 120;\n    deg = 5;\n    A = sp_get(m,n,deg);\n    B = sp_get(m,n,deg);\n    C = sp_get(m,n,deg);\n    C1 = sp_get(m,n,deg);\n\n    for ( k = 0; k < m*deg; k++ )\n    {\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(A,i,j,rand()/((Real)MAX_RAND));\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(B,i,j,rand()/((Real)MAX_RAND));\n    }\n    \n    s1 = mrand(); \n    B1 = sp_copy(B);\n\n    mem_stat_mark(1);\n    sp_smlt(B,s1,C);\n    sp_add(A,C,C1);\n    sp_sub(C1,A,C);\n    sp_smlt(C,-1.0/s1,C);\n    sp_add(C,B1,C);\n\n    s2 = 0.0;\n    for (k=0; k < C->m; k++) {\n       r = &(C->row[k]);\n       for (j=0; j < r->len; j++) {\n	  if (s2 < fabs(r->elt[j].val)) \n	    s2 = fabs(r->elt[j].val);\n       }\n    }\n\n    if (s2 > MACHEPS*A->m) {\n       errmesg("add, sub, mlt sparse matrices (args not in situ)\n");\n       printf(" difference = %g [MACEPS = %g]\n",s2,MACHEPS);\n    }\n\n    sp_mltadd(A,B1,s1,C1);\n    sp_sub(C1,A,A);\n    sp_smlt(A,1.0/s1,C1);\n    sp_sub(C1,B1,C1);\n    mem_stat_free(1);\n\n    s2 = 0.0;\n    for (k=0; k < C1->m; k++) {\n       r = &(C1->row[k]);\n       for (j=0; j < r->len; j++) {\n	  if (s2 < fabs(r->elt[j].val)) \n	    s2 = fabs(r->elt[j].val);\n       }\n    }\n\n    if (s2 > MACHEPS*A->m) {\n       errmesg("add, sub, mlt sparse matrices (args not in situ)\n");\n       printf(" difference = %g [MACEPS = %g]\n",s2,MACHEPS);\n    }\n\n    V_FREE(x);\n    V_FREE(y);    \n    V_FREE(z);\n    V_FREE(u);\n    V_FREE(v);  \n    PX_FREE(pivot);\n    SP_FREE(A);\n    SP_FREE(B);\n    SP_FREE(C);\n    SP_FREE(B1);\n    SP_FREE(C1);\n\n    printf("# Done testing (%s)\n",argv[0]);\n    mem_info();\n}\n    \n\n\n\n\n