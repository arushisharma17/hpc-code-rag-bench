\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n	Complex case\n*/\n\nstatic	char	rcsid[] = "$Id: zsolve.c,v 1.1 1994/01/13 04:20:33 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "zmatrix2.h"\n\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0 )\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* zUsolve -- back substitution with optional over-riding diagonal\n		-- can be in-situ but doesn't need to be */\nZVEC	*zUsolve(matrix,b,out,diag)\nZMAT	*matrix;\nZVEC	*b, *out;\ndouble	diag;\n{\n    unsigned int	dim /* , j */;\n    int	i, i_lim;\n    complex	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum;\n    \n    if ( matrix==ZMNULL || b==ZVNULL )\n	error(E_NULL,"zUsolve");\n    dim = min(matrix->m,matrix->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"zUsolve");\n    if ( out==ZVNULL || out->dim < dim )\n	out = zv_resize(out,matrix->n);\n    mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n    \n    for ( i=dim-1; i>=0; i-- )\n	if ( ! is_zero(b_ent[i]) )\n	    break;\n	else\n	    out_ent[i].re = out_ent[i].im = 0.0;\n    i_lim = i;\n    \n    for ( i = i_lim; i>=0; i-- )\n    {\n	sum = b_ent[i];\n	mat_row = &(mat_ent[i][i+1]);\n	out_col = &(out_ent[i+1]);\n	sum = zsub(sum,__zip__(mat_row,out_col,i_lim-i,Z_NOCONJ));\n	/******************************************************\n	  for ( j=i+1; j<=i_lim; j++ )\n	  sum -= mat_ent[i][j]*out_ent[j];\n	  sum -= (*mat_row++)*(*out_col++);\n	******************************************************/\n	if ( diag == 0.0 )\n	{\n	    if ( is_zero(mat_ent[i][i]) )\n		error(E_SING,"zUsolve");\n	    else\n		/* out_ent[i] = sum/mat_ent[i][i]; */\n		out_ent[i] = zdiv(sum,mat_ent[i][i]);\n	}\n	else\n	{\n	    /* out_ent[i] = sum/diag; */\n	    out_ent[i].re = sum.re / diag;\n	    out_ent[i].im = sum.im / diag;\n	}\n    }\n    \n    return (out);\n}\n\n/* zLsolve -- forward elimination with (optional) default diagonal value */\nZVEC	*zLsolve(matrix,b,out,diag)\nZMAT	*matrix;\nZVEC	*b,*out;\ndouble	diag;\n{\n    unsigned int	dim, i, i_lim /* , j */;\n    complex	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum;\n    \n    if ( matrix==ZMNULL || b==ZVNULL )\n	error(E_NULL,"zLsolve");\n    dim = min(matrix->m,matrix->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"zLsolve");\n    if ( out==ZVNULL || out->dim < dim )\n	out = zv_resize(out,matrix->n);\n    mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n    \n    for ( i=0; i<dim; i++ )\n	if ( ! is_zero(b_ent[i]) )\n	    break;\n	else\n	    out_ent[i].re = out_ent[i].im = 0.0;\n    i_lim = i;\n    \n    for ( i = i_lim; i<dim; i++ )\n    {\n	sum = b_ent[i];\n	mat_row = &(mat_ent[i][i_lim]);\n	out_col = &(out_ent[i_lim]);\n	sum = zsub(sum,__zip__(mat_row,out_col,(int)(i-i_lim),Z_NOCONJ));\n	/*****************************************************\n	  for ( j=i_lim; j<i; j++ )\n	  sum -= mat_ent[i][j]*out_ent[j];\n	  sum -= (*mat_row++)*(*out_col++);\n	******************************************************/\n	if ( diag == 0.0 )\n	{\n	    if ( is_zero(mat_ent[i][i]) )\n		error(E_SING,"zLsolve");\n	    else\n		out_ent[i] = zdiv(sum,mat_ent[i][i]);\n	}\n	else\n	{\n	    out_ent[i].re = sum.re / diag;\n	    out_ent[i].im = sum.im / diag;\n	}\n    }\n    \n    return (out);\n}\n\n\n/* zUAsolve -- forward elimination with (optional) default diagonal value\n		using UPPER triangular part of matrix */\nZVEC	*zUAsolve(U,b,out,diag)\nZMAT	*U;\nZVEC	*b,*out;\ndouble	diag;\n{\n    unsigned int	dim, i, i_lim /* , j */;\n    complex	**U_me, *b_ve, *out_ve, tmp;\n    Real	invdiag;\n    \n    if ( ! U || ! b )\n	error(E_NULL,"zUAsolve");\n    dim = min(U->m,U->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"zUAsolve");\n    out = zv_resize(out,U->n);\n    U_me = U->me;	b_ve = b->ve;	out_ve = out->ve;\n    \n    for ( i=0; i<dim; i++ )\n	if ( ! is_zero(b_ve[i]) )\n	    break;\n	else\n	    out_ve[i].re = out_ve[i].im = 0.0;\n    i_lim = i;\n    if ( b != out )\n    {\n	__zzero__(out_ve,out->dim);\n	/* MEM_COPY(&(b_ve[i_lim]),&(out_ve[i_lim]),\n	   (dim-i_lim)*sizeof(complex)); */\n	MEMCOPY(&(b_ve[i_lim]),&(out_ve[i_lim]),dim-i_lim,complex);\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (    ; i<dim; i++ )\n	{\n	    tmp = zconj(U_me[i][i]);\n	    if ( is_zero(tmp) )\n		error(E_SING,"zUAsolve");\n	    /* out_ve[i] /= tmp; */\n	    out_ve[i] = zdiv(out_ve[i],tmp);\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),tmp,dim-i-1,Z_CONJ);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (    ; i<dim; i++ )\n	{\n	    out_ve[i].re *= invdiag;\n	    out_ve[i].im *= invdiag;\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),tmp,dim-i-1,Z_CONJ);\n	}\n    }\n    return (out);\n}\n\n/* zDsolve -- solves Dx=b where D is the diagonal of A -- may be in-situ */\nZVEC	*zDsolve(A,b,x)\nZMAT	*A;\nZVEC	*b,*x;\n{\n    unsigned int	dim, i;\n    \n    if ( ! A || ! b )\n	error(E_NULL,"zDsolve");\n    dim = min(A->m,A->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"zDsolve");\n    x = zv_resize(x,A->n);\n    \n    dim = b->dim;\n    for ( i=0; i<dim; i++ )\n	if ( is_zero(A->me[i][i]) )\n	    error(E_SING,"zDsolve");\n	else\n	    x->ve[i] = zdiv(b->ve[i],A->me[i][i]);\n    \n    return (x);\n}\n\n/* zLAsolve -- back substitution with optional over-riding diagonal\n		using the LOWER triangular part of matrix\n		-- can be in-situ but doesn't need to be */\nZVEC	*zLAsolve(L,b,out,diag)\nZMAT	*L;\nZVEC	*b, *out;\ndouble	diag;\n{\n    unsigned int	dim;\n    int		i, i_lim;\n    complex	**L_me, *b_ve, *out_ve, tmp;\n    Real	invdiag;\n    \n    if ( ! L || ! b )\n	error(E_NULL,"zLAsolve");\n    dim = min(L->m,L->n);\n    if ( b->dim < dim )\n	error(E_SIZES,"zLAsolve");\n    out = zv_resize(out,L->n);\n    L_me = L->me;	b_ve = b->ve;	out_ve = out->ve;\n    \n    for ( i=dim-1; i>=0; i-- )\n	if ( ! is_zero(b_ve[i]) )\n	    break;\n    i_lim = i;\n\n    if ( b != out )\n    {\n	__zzero__(out_ve,out->dim);\n	/* MEM_COPY(b_ve,out_ve,(i_lim+1)*sizeof(complex)); */\n	MEMCOPY(b_ve,out_ve,i_lim+1,complex);\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (        ; i>=0; i-- )\n	{\n	    tmp = zconj(L_me[i][i]);\n	    if ( is_zero(tmp) )\n		error(E_SING,"zLAsolve");\n	    out_ve[i] = zdiv(out_ve[i],tmp);\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(out_ve,L_me[i],tmp,i,Z_CONJ);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (        ; i>=0; i-- )\n	{\n	    out_ve[i].re *= invdiag;\n	    out_ve[i].im *= invdiag;\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(out_ve,L_me[i],tmp,i,Z_CONJ);\n	}\n    }\n    \n    return (out);\n}\n