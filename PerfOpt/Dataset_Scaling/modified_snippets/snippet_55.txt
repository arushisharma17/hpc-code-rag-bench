\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Sparse LU factorisation\n	See also: sparse.[ch] etc for details about sparse matrices\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "sparse2.h"\n\n\n\n/* Macro for speedup */\n/* #define	sprow_idx2(r,c,hint)	\\n   ( ( (hint) >= 0 && (r)->elt[hint].col == (c)) ? hint : sprow_idx((r),(c)) ) */\n\n\n/* spLUfactor -- sparse LU factorisation with pivoting\n	-- uses partial pivoting and Markowitz criterion\n			|a[p][k]| >= alpha * max_i |a[i][k]|\n	-- creates fill-in as needed\n	-- in situ factorisation */\n#ifndef ANSI_C\nSPMAT	*spLUfactor(A,px,alpha)\nSPMAT	*A;\nPERM	*px;\ndouble	alpha;\n#else\nSPMAT	*spLUfactor(SPMAT *A, PERM *px, double alpha)\n#endif\n{\n	int	i, best_i, k, idx, len, best_len, m, n;\n	SPROW	*r, *r_piv, tmp_row;\n	STATIC	SPROW	*merge = (SPROW *)NULL;\n	Real	max_val, tmp;\n	STATIC VEC	*col_vals=VNULL;\n\n	if ( ! A || ! px )\n		error(E_NULL,"spLUfctr");\n	if ( alpha <= 0.0 || alpha > 1.0 )\n		error(E_RANGE,"alpha in spLUfctr");\n	if ( px->size <= A->m )\n		px = px_resize(px,A->m);\n	px_ident(px);\n	col_vals = v_resize(col_vals,A->m);\n	MEM_STAT_REG(col_vals,TYPE_VEC);\n\n	m = A->m;	n = A->n;\n	if ( ! A->flag_col )\n		sp_col_access(A);\n	if ( ! A->flag_diag )\n		sp_diag_access(A);\n	A->flag_col = A->flag_diag = FALSE;\n	if ( ! merge ) {\n	   merge = sprow_get(20);\n	   MEM_STAT_REG(merge,TYPE_SPROW);\n	}\n\n	for ( k = 0; k < n; k++ )\n	{\n	    /* find pivot row/element for partial pivoting */\n\n	    /* get first row with a non-zero entry in the k-th column */\n	    max_val = 0.0;\n	    for ( i = k; i < m; i++ )\n	    {\n		r = &(A->row[i]);\n		idx = sprow_idx(r,k);\n		if ( idx < 0 )\n		    tmp = 0.0;\n		else\n		    tmp = r->elt[idx].val;\n		if ( fabs(tmp) > max_val )\n		    max_val = fabs(tmp);\n		col_vals->ve[i] = tmp;\n	    }\n\n	    if ( max_val == 0.0 )\n		continue;\n\n	    best_len = n+1;	/* only if no possibilities */\n	    best_i = -1;\n	    for ( i = k; i < m; i++ )\n	    {\n		tmp = fabs(col_vals->ve[i]);\n		if ( tmp == 0.0 )\n		    continue;\n		if ( tmp >= alpha*max_val )\n		{\n		    r = &(A->row[i]);\n		    idx = sprow_idx(r,k);\n		    len = (r->len) - idx;\n		    if ( len < best_len )\n		    {\n			best_len = len;\n			best_i = i;\n		    }\n		}\n	    }\n\n	    /* swap row #best_i with row #k */\n	    MEM_COPY(&(A->row[best_i]),&tmp_row,sizeof(SPROW));\n	    MEM_COPY(&(A->row[k]),&(A->row[best_i]),sizeof(SPROW));\n	    MEM_COPY(&tmp_row,&(A->row[k]),sizeof(SPROW));\n	    /* swap col_vals entries */\n	    tmp = col_vals->ve[best_i];\n	    col_vals->ve[best_i] = col_vals->ve[k];\n	    col_vals->ve[k] = tmp;\n	    px_transp(px,k,best_i);\n\n	    r_piv = &(A->row[k]);\n	    for ( i = k+1; i < n; i++ )\n	    {\n		/* compute and set multiplier */\n		tmp = col_vals->ve[i]/col_vals->ve[k];\n		if ( tmp != 0.0 )\n		    sp_set_val(A,i,k,tmp);\n		else\n		    continue;\n\n		/* perform row operations */\n		merge->len = 0;\n		r = &(A->row[i]);\n		sprow_mltadd(r,r_piv,-tmp,k+1,merge,TYPE_SPROW);\n		idx = sprow_idx(r,k+1);\n		if ( idx < 0 )\n		    idx = -(idx+2);\n		/* see if r needs expanding */\n		if ( r->maxlen < idx + merge->len )\n		    sprow_xpd(r,idx+merge->len,TYPE_SPMAT);\n		r->len = idx+merge->len;\n		MEM_COPY((char *)(merge->elt),(char *)&(r->elt[idx]),\n			merge->len*sizeof(row_elt));\n	    }\n	}\n#ifdef	THREADSAFE\n	sprow_free(merge);	V_FREE(col_vals);\n#endif\n\n	return A;\n}\n\n/* spLUsolve -- solve A.x = b using factored matrix A from spLUfactor()\n	-- returns x\n	-- may not be in-situ */\n#ifndef ANSI_C\nVEC	*spLUsolve(A,pivot,b,x)\nSPMAT	*A;\nPERM	*pivot;\nVEC	*b, *x;\n#else\nVEC	*spLUsolve(const SPMAT *A, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	int	i, idx, len, lim;\n	Real	sum, *x_ve;\n	SPROW	*r;\n	row_elt	*elt;\n\n	if ( ! A || ! b )\n	    error(E_NULL,"spLUsolve");\n	if ( (pivot != PNULL && A->m != pivot->size) || A->m != b->dim )\n	    error(E_SIZES,"spLUsolve");\n	if ( ! x || x->dim != A->n )\n	    x = v_resize(x,A->n);\n\n	if ( pivot != PNULL )\n	    x = px_vec(pivot,b,x);\n	else\n	    x = v_copy(b,x);\n\n	x_ve = x->ve;\n	lim = min(A->m,A->n);\n	for ( i = 0; i < lim; i++ )\n	{\n	    sum = x_ve[i];\n	    r = &(A->row[i]);\n	    len = r->len;\n	    elt = r->elt;\n	    for ( idx = 0; idx < len && elt->col < i; idx++, elt++ )\n		sum -= elt->val*x_ve[elt->col];\n	    x_ve[i] = sum;\n	}\n\n	for ( i = lim-1; i >= 0; i-- )\n	{\n	    sum = x_ve[i];\n	    r = &(A->row[i]);\n	    len = r->len;\n	    elt = &(r->elt[len-1]);\n	    for ( idx = len-1; idx >= 0 && elt->col > i; idx--, elt-- )\n		sum -= elt->val*x_ve[elt->col];\n	    if ( idx < 0 || elt->col != i || elt->val == 0.0 )\n		error(E_SING,"spLUsolve");\n	    x_ve[i] = sum/elt->val;\n	}\n\n	return x;\n}\n\n/* spLUTsolve -- solve A.x = b using factored matrix A from spLUfactor()\n	-- returns x\n	-- may not be in-situ */\n#ifndef ANSI_C\nVEC	*spLUTsolve(A,pivot,b,x)\nSPMAT	*A;\nPERM	*pivot;\nVEC	*b, *x;\n#else\nVEC	*spLUTsolve(SPMAT *A, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	int	i, idx, lim, rownum;\n	Real	sum, *tmp_ve;\n	/* SPROW	*r; */\n	row_elt	*elt;\n	STATIC VEC	*tmp=VNULL;\n\n	if ( ! A || ! b )\n	    error(E_NULL,"spLUTsolve");\n	if ( (pivot != PNULL && A->m != pivot->size) || A->m != b->dim )\n	    error(E_SIZES,"spLUTsolve");\n	tmp = v_copy(b,tmp);\n	MEM_STAT_REG(tmp,TYPE_VEC);\n\n	if ( ! A->flag_col )\n	    sp_col_access(A);\n	if ( ! A->flag_diag )\n	    sp_diag_access(A);\n\n	lim = min(A->m,A->n);\n	tmp_ve = tmp->ve;\n	/* solve U^T.tmp = b */\n	for ( i = 0; i < lim; i++ )\n	{\n	    sum = tmp_ve[i];\n	    rownum = A->start_row[i];\n	    idx    = A->start_idx[i];\n	    if ( rownum < 0 || idx < 0 )\n		error(E_SING,"spLUTsolve");\n	    while ( rownum < i && rownum >= 0 && idx >= 0 )\n	    {\n		elt = &(A->row[rownum].elt[idx]);\n		sum -= elt->val*tmp_ve[rownum];\n		rownum = elt->nxt_row;\n		idx    = elt->nxt_idx;\n	    }\n	    if ( rownum != i )\n		error(E_SING,"spLUTsolve");\n	    elt = &(A->row[rownum].elt[idx]);\n	    if ( elt->val == 0.0 )\n		error(E_SING,"spLUTsolve");\n	    tmp_ve[i] = sum/elt->val;\n	}\n\n	/* now solve L^T.tmp = (old) tmp */\n	for ( i = lim-1; i >= 0; i-- )\n	{\n	    sum = tmp_ve[i];\n	    rownum = i;\n	    idx    = A->row[rownum].diag;\n	    if ( idx < 0 )\n		error(E_NULL,"spLUTsolve");\n	    elt = &(A->row[rownum].elt[idx]);\n	    rownum = elt->nxt_row;\n	    idx    = elt->nxt_idx;\n	    while ( rownum < lim && rownum >= 0 && idx >= 0 )\n	    {\n		elt = &(A->row[rownum].elt[idx]);\n		sum -= elt->val*tmp_ve[rownum];\n		rownum = elt->nxt_row;\n		idx    = elt->nxt_idx;\n	    }\n	    tmp_ve[i] = sum;\n	}\n\n	if ( pivot != PNULL )\n	    x = pxinv_vec(pivot,tmp,x);\n	else\n	    x = v_copy(tmp,x);\n\n#ifdef	THREADSAFE\n	V_FREE(tmp);\n#endif\n\n	return x;\n}\n\n/* spILUfactor -- sparse modified incomplete LU factorisation with\n						no pivoting\n	-- all pivot entries are ensured to be >= alpha in magnitude\n	-- setting alpha = 0 gives incomplete LU factorisation\n	-- no fill-in is generated\n	-- in situ factorisation */\n#ifndef ANSI_C\nSPMAT	*spILUfactor(A,alpha)\nSPMAT	*A;\ndouble	alpha;\n#else\nSPMAT	*spILUfactor(SPMAT *A, double alpha)\n#endif\n{\n    int		i, k, idx, idx_piv, m, n, old_idx, old_idx_piv;\n    SPROW	*r, *r_piv;\n    Real	piv_val, tmp;\n    \n    /* printf("spILUfactor: entered\n"); */\n    if ( ! A )\n	error(E_NULL,"spILUfactor");\n    if ( alpha < 0.0 )\n	error(E_RANGE,"[alpha] in spILUfactor");\n    \n    m = A->m;	n = A->n;\n    sp_diag_access(A);\n    sp_col_access(A);\n    \n    for ( k = 0; k < n; k++ )\n    {\n	/* printf("spILUfactor(l.%d): checkpoint A: k = %d\n",__LINE__,k); */\n	/* printf("spILUfactor(l.%d): A =\n", __LINE__); */\n	/* sp_output(A); */\n	r_piv = &(A->row[k]);\n	idx_piv = r_piv->diag;\n	if ( idx_piv < 0 )\n	{\n	    sprow_set_val(r_piv,k,alpha);\n	    idx_piv = sprow_idx(r_piv,k);\n	}\n	/* printf("spILUfactor: checkpoint B\n"); */\n	if ( idx_piv < 0 )\n	    error(E_BOUNDS,"spILUfactor");\n	old_idx_piv = idx_piv;\n	piv_val = r_piv->elt[idx_piv].val;\n	/* printf("spILUfactor: checkpoint C\n"); */\n	if ( fabs(piv_val) < alpha )\n	    piv_val = ( piv_val < 0.0 ) ? -alpha : alpha;\n	if ( piv_val == 0.0 )	/* alpha == 0.0 too! */\n	    error(E_SING,"spILUfactor");\n\n	/* go to next row with a non-zero in this column */\n	i = r_piv->elt[idx_piv].nxt_row;\n	old_idx = idx = r_piv->elt[idx_piv].nxt_idx;\n	while ( i >= k )\n	{\n	    /* printf("spILUfactor: checkpoint D: i = %d\n",i); */\n	    /* perform row operations */\n	    r = &(A->row[i]);\n	    /* idx = sprow_idx(r,k); */\n	    /* printf("spLUfactor(l.%d) i = %d, idx = %d\n",\n		   __LINE__, i, idx); */\n	    if ( idx < 0 )\n	    {\n		idx = r->elt[old_idx].nxt_idx;\n		i = r->elt[old_idx].nxt_row;\n		continue;\n	    }\n	    /* printf("spILUfactor: checkpoint E\n"); */\n	    /* compute and set multiplier */\n	    r->elt[idx].val = tmp = r->elt[idx].val/piv_val;\n	    /* printf("spILUfactor: piv_val = %g, multiplier = %g\n",\n		   piv_val, tmp); */\n	    /* printf("spLUfactor(l.%d) multiplier = %g\n", __LINE__, tmp); */\n	    if ( tmp == 0.0 )\n	    {\n		idx = r->elt[old_idx].nxt_idx;\n		i = r->elt[old_idx].nxt_row;\n		continue;\n	    }\n	    /* idx = sprow_idx(r,k+1); */\n	    /* if ( idx < 0 )\n		idx = -(idx+2); */\n	    idx_piv++;	idx++;	/* now look beyond the multiplier entry */\n	    /* printf("spILUfactor: checkpoint F: idx = %d, idx_piv = %d\n",\n		   idx, idx_piv); */\n	    while ( idx_piv < r_piv->len && idx < r->len )\n	    {\n		/* printf("spILUfactor: checkpoint G: idx = %d, idx_piv = %d\n",\n		       idx, idx_piv); */\n		if ( r_piv->elt[idx_piv].col < r->elt[idx].col )\n		    idx_piv++;\n		else if ( r_piv->elt[idx_piv].col > r->elt[idx].col )\n		    idx++;\n		else /* column numbers match */\n		{\n		    /* printf("spILUfactor(l.%d) subtract %g times the ",\n			   __LINE__, tmp); */\n		    /* printf("(%d,%d) entry to the (%d,%d) entry\n",\n			   k, r_piv->elt[idx_piv].col,\n			   i, r->elt[idx].col); */\n		    r->elt[idx].val -= tmp*r_piv->elt[idx_piv].val;\n		    idx++;	idx_piv++;\n		}\n	    }\n\n	    /* bump to next row with a non-zero in column k */\n	    /* printf("spILUfactor(l.%d) column = %d, row[%d] =\n",\n		   __LINE__, r->elt[old_idx].col, i); */\n	    /* sprow_foutput(stdout,r); */\n	    i = r->elt[old_idx].nxt_row;\n	    old_idx = idx = r->elt[old_idx].nxt_idx;\n	    /* printf("spILUfactor(l.%d) i = %d, idx = %d\n", __LINE__, i, idx); */\n	    /* and restore idx_piv to index of pivot entry */\n	    idx_piv = old_idx_piv;\n	}\n    }\n    /* printf("spILUfactor: exiting\n"); */\n    return A;\n}\n