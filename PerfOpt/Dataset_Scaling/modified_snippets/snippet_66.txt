\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Sparse matrix swap and permutation routines\n	Modified Mon 09th Nov 1992, 08:50:54 PM\n	to use Karen George's suggestion to use unordered rows\n*/\n\nstatic	char	rcsid[] = "$Id: spswap.c,v 1.3 1994/01/13 05:44:43 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "sparse2.h"\n\n\n#define	btos(x)	((x) ? "TRUE" : "FALSE")\n\n/* scan_to -- updates scan (int) vectors to point to the last row in each\n	column with row # <= max_row, if any */\n#ifndef ANSI_C\nvoid	scan_to(A, scan_row, scan_idx, col_list, max_row)\nSPMAT	*A;\nIVEC	*scan_row, *scan_idx, *col_list;\nint	max_row;\n#else\nvoid	scan_to(SPMAT *A, IVEC *scan_row, IVEC *scan_idx, IVEC *col_list, \n		int max_row)\n#endif\n{\n    int		col, idx, j_idx, row_num;\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( ! A || ! scan_row || ! scan_idx || ! col_list )\n	error(E_NULL,"scan_to");\n    if ( scan_row->dim != scan_idx->dim || scan_idx->dim != col_list->dim )\n	error(E_SIZES,"scan_to");\n\n    if ( max_row < 0 )\n	return;\n\n    if ( ! A->flag_col )\n	sp_col_access(A);\n\n    for ( j_idx = 0; j_idx < scan_row->dim; j_idx++ )\n    {\n	row_num = scan_row->ive[j_idx];\n	idx = scan_idx->ive[j_idx];\n	col = col_list->ive[j_idx];\n\n	if ( col < 0 || col >= A->n )\n	    error(E_BOUNDS,"scan_to");\n	if ( row_num < 0 )\n	{\n	    idx = col;\n	    continue;\n	}\n	r = &(A->row[row_num]);\n	if ( idx < 0 )\n	    error(E_INTERN,"scan_to");\n	e = &(r->elt[idx]);\n	if ( e->col != col )\n	    error(E_INTERN,"scan_to");\n	if ( idx < 0 )\n	{\n	    printf("scan_to: row_num = %d, idx = %d, col = %d\n",\n		   row_num, idx, col);\n	    error(E_INTERN,"scan_to");\n	}\n	/* if ( e->nxt_row <= max_row )\n	    chase_col(A, col, &row_num, &idx, max_row); */\n	while ( e->nxt_row >= 0 && e->nxt_row <= max_row )\n	{\n	    row_num = e->nxt_row;\n	    idx = e->nxt_idx;\n	    e = &(A->row[row_num].elt[idx]);\n	}\n	    \n	/* printf("scan_to: computed j_idx = %d, row_num = %d, idx = %d\n",\n	       j_idx, row_num, idx); */\n	scan_row->ive[j_idx] = row_num;\n	scan_idx->ive[j_idx] = idx;\n    }\n}\n\n/* patch_col -- patches column access paths for fill-in */\n#ifndef ANSI_C\nvoid patch_col(A, col, old_row, old_idx, row_num, idx)\nSPMAT	*A;\nint	col, old_row, old_idx, row_num, idx;\n#else\nvoid patch_col(SPMAT *A, int col, int old_row, int old_idx, int row_num, \n	       int idx)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n    \n    if ( old_row >= 0 )\n    {\n	r = &(A->row[old_row]);\n	old_idx = sprow_idx2(r,col,old_idx);\n	e = &(r->elt[old_idx]);\n	e->nxt_row = row_num;\n	e->nxt_idx = idx;\n    }\n    else\n    {\n	A->start_row[col] = row_num;\n	A->start_idx[col] = idx;\n    }\n}\n\n/* chase_col -- chases column access path in column col, starting with\n   row_num and idx, to find last row # in this column <= max_row\n   -- row_num is returned; idx is also set by this routine\n   -- assumes that the column access paths (possibly without the\n   nxt_idx fields) are set up */\n#ifndef ANSI_C\nrow_elt *chase_col(A, col, row_num, idx, max_row)\nSPMAT	*A;\nint	col, *row_num, *idx, max_row;\n#else\nrow_elt *chase_col(const SPMAT *A, int col, int *row_num, int *idx, \n		   int max_row)\n#endif\n{\n    int		old_idx, old_row, tmp_idx, tmp_row;\n    SPROW	*r;\n    row_elt	*e;\n    \n    if ( col < 0 || col >= A->n )\n	error(E_BOUNDS,"chase_col");\n    tmp_row = *row_num;\n    if ( tmp_row < 0 )\n    {\n	if ( A->start_row[col] > max_row )\n	{\n	    tmp_row = -1;\n	    tmp_idx = col;\n	    return (row_elt *)NULL;\n	}\n	else\n	{\n	    tmp_row = A->start_row[col];\n	    tmp_idx = A->start_idx[col];\n	}\n    }\n    else\n	tmp_idx = *idx;\n    \n    old_row = tmp_row;\n    old_idx = tmp_idx;\n    while ( tmp_row >= 0 && tmp_row < max_row )\n    {\n	r = &(A->row[tmp_row]);\n	/* tmp_idx = sprow_idx2(r,col,tmp_idx); */\n	if ( tmp_idx < 0 || tmp_idx >= r->len ||\n	     r->elt[tmp_idx].col != col )\n	{\n#ifdef DEBUG\n	    printf("chase_col:error: col = %d, row # = %d, idx = %d\n",\n		   col, tmp_row, tmp_idx);\n	    printf("chase_col:error: old_row = %d, old_idx = %d\n",\n		   old_row, old_idx);\n	    printf("chase_col:error: A =\n");\n	    sp_dump(stdout,A);\n#endif\n	    error(E_INTERN,"chase_col");\n	}\n	e = &(r->elt[tmp_idx]);\n	old_row = tmp_row;\n	old_idx = tmp_idx;\n	tmp_row = e->nxt_row;\n	tmp_idx = e->nxt_idx;\n    }\n    if ( old_row > max_row )\n    {\n	old_row = -1;\n	old_idx = col;\n	e = (row_elt *)NULL;\n    }\n    else if ( tmp_row <= max_row && tmp_row >= 0 )\n    {\n	old_row = tmp_row;\n	old_idx = tmp_idx;\n    }\n\n    *row_num = old_row;\n    if ( old_row >= 0 )\n	*idx = old_idx;\n    else\n	*idx = col;\n\n    return e;\n}\n\n/* chase_past -- as for chase_col except that we want the first\n	row whose row # >= min_row; -1 indicates no such row */\n#ifndef ANSI_C\nrow_elt *chase_past(A, col, row_num, idx, min_row)\nSPMAT	*A;\nint	col, *row_num, *idx, min_row;\n#else\nrow_elt *chase_past(const SPMAT *A, int col, int *row_num, int *idx, \n		    int min_row)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n    int		tmp_idx, tmp_row;\n\n    tmp_row = *row_num;\n    tmp_idx = *idx;\n    chase_col(A,col,&tmp_row,&tmp_idx,min_row);\n    if ( tmp_row < 0 )	/* use A->start_row[..] etc. */\n    {\n	if ( A->start_row[col] < 0 )\n	    tmp_row = -1;\n	else\n	{\n	    tmp_row = A->start_row[col];\n	    tmp_idx = A->start_idx[col];\n	}\n    }\n    else if ( tmp_row < min_row )\n    {\n	r = &(A->row[tmp_row]);\n	if ( tmp_idx < 0 || tmp_idx >= r->len ||\n	     r->elt[tmp_idx].col != col )\n	    error(E_INTERN,"chase_past");\n	tmp_row = r->elt[tmp_idx].nxt_row;\n	tmp_idx = r->elt[tmp_idx].nxt_idx;\n    }\n\n    *row_num = tmp_row;\n    *idx = tmp_idx;\n    if ( tmp_row < 0 )\n	e = (row_elt *)NULL;\n    else\n    {\n	if ( tmp_idx < 0 || tmp_idx >= A->row[tmp_row].len ||\n	     A->row[tmp_row].elt[tmp_idx].col != col )\n	    error(E_INTERN,"bump_col");\n	e = &(A->row[tmp_row].elt[tmp_idx]);\n    }\n\n    return e;\n}\n\n/* bump_col -- move along to next nonzero entry in column col after row_num\n	-- update row_num and idx */\n#ifndef ANSI_C\nrow_elt *bump_col(A, col, row_num, idx)\nSPMAT	*A;\nint	col, *row_num, *idx;\n#else\nrow_elt *bump_col(const SPMAT *A, int col, int *row_num, int *idx)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n    int		tmp_row, tmp_idx;\n\n    tmp_row = *row_num;\n    tmp_idx = *idx;\n    /* printf("bump_col: col = %d, row# = %d, idx = %d\n",\n	   col, *row_num, *idx); */\n    if ( tmp_row < 0 )\n    {\n	tmp_row = A->start_row[col];\n	tmp_idx = A->start_idx[col];\n    }\n    else\n    {\n	r = &(A->row[tmp_row]);\n	if ( tmp_idx < 0 || tmp_idx >= r->len ||\n	     r->elt[tmp_idx].col != col )\n	    error(E_INTERN,"bump_col");\n	e = &(r->elt[tmp_idx]);\n	tmp_row = e->nxt_row;\n	tmp_idx = e->nxt_idx;\n    }\n    if ( tmp_row < 0 )\n    {\n	e = (row_elt *)NULL;\n	tmp_idx = col;\n    }\n    else\n    {\n	if ( tmp_idx < 0 || tmp_idx >= A->row[tmp_row].len ||\n	     A->row[tmp_row].elt[tmp_idx].col != col )\n	    error(E_INTERN,"bump_col");\n	e = &(A->row[tmp_row].elt[tmp_idx]);\n    }\n    *row_num = tmp_row;\n    *idx = tmp_idx;\n\n    return e;\n}\n\n\n