\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* CHfactor.c 1.2 11/25/87 */\nstatic	char	rcsid[] = "$Id: chfactor.c,v 1.2 1994/01/13 05:36:36 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* CHfactor -- Cholesky L.L' factorisation of A in-situ */\n#ifndef ANSI_C\nMAT	*CHfactor(A)\nMAT	*A;\n#else\nMAT	*CHfactor(MAT *A)\n#endif\n{\n	unsigned int	i, j, k, n;\n	Real	**A_ent, *A_piv, *A_row, sum, tmp;\n\n	if ( A==(MAT *)NULL )\n		error(E_NULL,"CHfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"CHfactor");\n	n = A->n;	A_ent = A->me;\n\n	for ( k=0; k<n; k++ )\n	{	\n		/* do diagonal element */\n		sum = A_ent[k][k];\n		A_piv = A_ent[k];\n		for ( j=0; j<k; j++ )\n		{\n			/* tmp = A_ent[k][j]; */\n			tmp = *A_piv++;\n			sum -= tmp*tmp;\n		}\n		if ( sum <= 0.0 )\n			error(E_POSDEF,"CHfactor");\n		A_ent[k][k] = sqrt(sum);\n\n		/* set values of column k */\n		for ( i=k+1; i<n; i++ )\n		{\n			sum = A_ent[i][k];\n			A_piv = A_ent[k];\n			A_row = A_ent[i];\n			sum -= __ip__(A_row,A_piv,(int)k);\n			/************************************************\n			for ( j=0; j<k; j++ )\n				sum -= A_ent[i][j]*A_ent[k][j];\n				sum -= (*A_row++)*(*A_piv++);\n			************************************************/\n			A_ent[j][i] = A_ent[i][j] = sum/A_ent[k][k];\n		}\n	}\n\n	return (A);\n}\n\n\n/* CHsolve -- given a CHolesky factorisation in A, solve A.x=b */\n#ifndef ANSI_C\nVEC	*CHsolve(A,b,x)\nMAT	*A;\nVEC	*b,*x;\n#else\nVEC	*CHsolve(const MAT *A, const VEC *b, VEC *x)\n#endif\n{\n	if ( A==MNULL || b==VNULL )\n		error(E_NULL,"CHsolve");\n	if ( A->m != A->n || A->n != b->dim )\n		error(E_SIZES,"CHsolve");\n	x = v_resize(x,b->dim);\n	Lsolve(A,b,x,0.0);\n	Usolve(A,x,x,0.0);\n\n	return (x);\n}\n\n/* LDLfactor -- L.D.L' factorisation of A in-situ */\n#ifndef ANSI_C\nMAT	*LDLfactor(A)\nMAT	*A;\n#else\nMAT	*LDLfactor(MAT *A)\n#endif\n{\n	unsigned int	i, k, n, p;\n	Real	**A_ent;\n	Real d, sum;\n	STATIC VEC	*r = VNULL;\n\n	if ( ! A )\n		error(E_NULL,"LDLfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"LDLfactor");\n	n = A->n;	A_ent = A->me;\n	r = v_resize(r,n);\n	MEM_STAT_REG(r,TYPE_VEC);\n\n	for ( k = 0; k < n; k++ )\n	{\n		sum = 0.0;\n		for ( p = 0; p < k; p++ )\n		{\n		    r->ve[p] = A_ent[p][p]*A_ent[k][p];\n		    sum += r->ve[p]*A_ent[k][p];\n		}\n		d = A_ent[k][k] -= sum;\n\n		if ( d == 0.0 )\n		    error(E_SING,"LDLfactor");\n		for ( i = k+1; i < n; i++ )\n		{\n		    sum = __ip__(A_ent[i],r->ve,(int)k);\n		    /****************************************\n		    sum = 0.0;\n		    for ( p = 0; p < k; p++ )\n			sum += A_ent[i][p]*r->ve[p];\n		    ****************************************/\n		    A_ent[i][k] = (A_ent[i][k] - sum)/d;\n		}\n	}\n\n#ifdef THREADSAFE\n	V_FREE(r);\n#endif\n\n	return A;\n}\n\n/* LDLsolve -- solves linear system A.x = b with A factored by LDLfactor()\n   -- returns x, which is created if it is NULL on entry */\n#ifndef ANSI_C\nVEC	*LDLsolve(LDL,b,x)\nMAT	*LDL;\nVEC	*b, *x;\n#else\nVEC	*LDLsolve(const MAT *LDL, const VEC *b, VEC *x)\n#endif\n{\n	if ( ! LDL || ! b )\n		error(E_NULL,"LDLsolve");\n	if ( LDL->m != LDL->n )\n		error(E_SQUARE,"LDLsolve");\n	if ( LDL->m != b->dim )\n		error(E_SIZES,"LDLsolve");\n	x = v_resize(x,b->dim);\n\n	Lsolve(LDL,b,x,1.0);\n	Dsolve(LDL,x,x);\n	LTsolve(LDL,x,x,1.0);\n\n	return x;\n}\n\n/* MCHfactor -- Modified Cholesky L.L' factorisation of A in-situ */\n#ifndef ANSI_C\nMAT	*MCHfactor(A,tol)\nMAT	*A;\ndouble  tol;\n#else\nMAT	*MCHfactor(MAT *A, double tol)\n#endif\n{\n	unsigned int	i, j, k, n;\n	Real	**A_ent, *A_piv, *A_row, sum, tmp;\n\n	if ( A==(MAT *)NULL )\n		error(E_NULL,"MCHfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"MCHfactor");\n	if ( tol <= 0.0 )\n	        error(E_RANGE,"MCHfactor");\n	n = A->n;	A_ent = A->me;\n\n	for ( k=0; k<n; k++ )\n	{	\n		/* do diagonal element */\n		sum = A_ent[k][k];\n		A_piv = A_ent[k];\n		for ( j=0; j<k; j++ )\n		{\n			/* tmp = A_ent[k][j]; */\n			tmp = *A_piv++;\n			sum -= tmp*tmp;\n		}\n		if ( sum <= tol )\n			sum = tol;\n		A_ent[k][k] = sqrt(sum);\n\n		/* set values of column k */\n		for ( i=k+1; i<n; i++ )\n		{\n			sum = A_ent[i][k];\n			A_piv = A_ent[k];\n			A_row = A_ent[i];\n			sum -= __ip__(A_row,A_piv,(int)k);\n			/************************************************\n			for ( j=0; j<k; j++ )\n				sum -= A_ent[i][j]*A_ent[k][j];\n				sum -= (*A_row++)*(*A_piv++);\n			************************************************/\n			A_ent[j][i] = A_ent[i][j] = sum/A_ent[k][k];\n		}\n	}\n\n	return (A);\n}\n