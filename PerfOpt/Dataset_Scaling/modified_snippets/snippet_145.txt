#include <stdio.h>\n#include <string.h>\n\n#include <fstream>\n\n#define ulong4 uint32_t\n#define int2 int32_t\n#define uint4 uint32_t\n\n#include "omp.h"\n#include "mummergpu.h"\n// Matches are reported as a node in the suffix tree,\n// plus a distance up the node's parent link for partial\n// matches on the patch from the root to the node\n\n#define OMP\n#define N_THREADS 8\n\n\nstatic const int maxdim = 4096;\n\n#define __VERBOSE___no \n\n#ifdef __VERBOSE__\n#define XPRINTF(...)  printf(__VA_ARGS__)\n#else\n#define XPRINTF(...)  do{}while(0)\n#endif\n\n#define WARP_SIZE 16\n\n#if REORDER_TREE            \n#define fNID "%d,%d"\n#define NID(addr) (addr & 0x0000FFFF), ((addr & 0xFFFF0000)>>16)\n#define GOROOT(addr) addr = 0x00010000\n//#define GOROOT(addr) addr.x = 0; addr.y = 1\n#else\n#define fNID "%d"\n#define NID(addr) addr\n#define GOROOT(addr) addr = 1\n#endif\n\n\n#define GETQCHAR(qrypos) queries[qrypos]\n#define RESULT_SPAN 1\n#define MATCH_BASE(match_coords, qryid) (MatchCoord*)match_coords + qryAddr - (qryid * (min_match_len + 1))\n\n#define GETRCHAR(refpos) getRef(refpos, ref)\n\n\n\n#if MERGETEX\n\n#if TREE_ACCESS_HISTOGRAM\n#define GETNODE(addr, two_level)         getMerged(nodes, childrenarr, addr,  0, NULL, NULL).node\n#define GETNODEHIST(addr, two_level)     getMerged(nodes, childrenarr, addr,  0, node_hist, child_hist).node\n#define GETCHILDREN(addr, two_level)     getMerged(nodes, childrenarr, addr,  1, NULL, NULL).children\n#define GETCHILDRENHIST(addr, two_level) getMerged(nodes, childrenarr, addr,  1, node_hist, child_hist).children\n#else\n#define GETNODE(addr, two_level)         getMerged(nodes, childrenarr, addr,  0).node\n#define GETNODEHIST(addr, two_level)     getMerged(nodes, childrenarr, addr,  0).node\n#define GETCHILDREN(addr, two_level)     getMerged(nodes, childrenarr, addr,  1).children\n#define GETCHILDRENHIST(addr, two_level) getMerged(nodes, childrenarr, addr,  1).children\n#endif\n\n#else\n\n#if TREE_ACCESS_HISTOGRAM\n#define GETNODEHIST(addr, two_level)    getNode(addr,  nodes, node_hist)\n#define GETNODE(addr, two_level)        getNode(addr,  nodes, NULL)\n#else\n#define GETNODEHIST(addr, two_level)    getNode(addr,  nodes)\n#define GETNODE(addr, two_level)        getNode(addr,  nodes)\n#endif\n\n\n#if TREE_ACCESS_HISTOGRAM\n#define GETCHILDRENHIST(addr, two_level)    getChildren(addr,  childrenarr, child_hist) \n#define GETCHILDREN(addr, two_level)        getChildren(addr,  childrenarr, NULL)\n#else\n#define GETCHILDRENHIST(addr, two_level)    getChildren(addr,  childrenarr)\n#define GETCHILDREN(addr, two_level)        getChildren(addr,  childrenarr)\n#endif\n\n#endif\n\n#define SHIFT_QUERIES(queries, qryAddr) queries += qryAddr\n#define SET_RESULT(c, r, e, q, m, rc) set_result(c, r, e, q, m, rc)\n//////////////////////////////////\n/// getRef\n//////////////////////////////////\n\nchar getRef(int refpos, char* ref)\n{\n	return ref[refpos];\n}\n\n\nunion SingleNode\n{\n	PixelOfNode node;\n	PixelOfChildren children;\n};\n\n\n//////////////////////////////////\n/// getNode\n//////////////////////////////////\n\nPixelOfNode getNode(unsigned int cur,  PixelOfNode* nodes\n#if TREE_ACCESS_HISTOGRAM\n               , int* node_hist\n#endif\n               ) \n{\n#if TREE_ACCESS_HISTOGRAM\n  int id = addr2id(cur);\n  if (node_hist) { node_hist[id]++; }\n#endif\n\n#if REORDER_TREE\n  return *(nodes + (cur & 0x0000FFFF) + (((cur & 0xFFFF0000)>>16) * MAX_TEXTURE_DIMENSION));\n#else\n  return *(nodes + cur);\n#endif\n}\n\n//////////////////////////////////\n/// getChildren\n//////////////////////////////////\n\nPixelOfChildren getChildren(unsigned int cur, PixelOfChildren* childrenarr\n#if TREE_ACCESS_HISTOGRAM\n                   , int* child_hist\n#endif\n                   )\n{\n#if TREE_ACCESS_HISTOGRAM\n  int id = addr2id(cur);\n  if (child_hist) { child_hist[id]++; }\n#endif\n\n#if REORDER_TREE\n  return *(childrenarr +  (cur & 0x0000FFFF) + (((cur & 0xFFFF0000)>>16) * MAX_TEXTURE_DIMENSION));\n#else\n  return *(childrenarr + cur);\n#endif\n}\n\n#if MERGETEX\n\n//////////////////////////////////\n/// getMerged\n//////////////////////////////////\n\nSingleNode getMerged(PixelOfNode * nodes,\n                 PixelOfChildren * childrenarr,\n                 unsigned int cur, \n                 int   getChildrenData\n#if TREE_ACCESS_HISTOGRAM\n               , int* node_hist\n               , int* child_hist\n#endif\n                            )\n{\n	SingleNode n;\n//	TextureAddress cur = _cur;\n#if !REORDER_TREE\n  //cur.x *= 2;\n	unsigned int x = cur * 2;\n  int useChildrenForData = 0;\n\n  if (x >= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION)\n  {\n    x -= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION;\n    useChildrenForData = 1;\n  }\n\n#else\n	unsigned short x = cur & 0x0000FFFF;\n	unsigned short y = (cur & 0xFFFF0000) >> 16;\n  int useChildrenForData = 0; \n\n  // WARNING INSANE HACK TO WORK AROUND NVCC BUG\n\n  goto TEST;\n  MASK:\n\n  x &= 0x7FF;\n  x *= 2;\n\n  goto INC;\n  TEST:\n\n  if (x >= 2048)\n  {\n    useChildrenForData = 1;\n  }\n\n  goto MASK;\n  INC:\n\n#endif\n\n  x += getChildrenData;\n\n#if !REORDER_TREE\n	cur = x;\n#else\n	cur = (y << 16) | x;\n#endif\n\n	  if (useChildrenForData)\n	  {\n	    n.children = getChildren(cur, childrenarr\n	#if TREE_ACCESS_HISTOGRAM\n	                       , child_hist\n	#endif\n	                       );\n	  }\n	  else\n	  {\n	    n.node =  getNode(cur, nodes\n	#if TREE_ACCESS_HISTOGRAM\n	                   , node_hist\n	#endif\n	                   );\n	  }\n	return n;\n}\n\n#endif\n\n\n//////////////////////////////////\n/// set_result\n//////////////////////////////////\n\nvoid set_result(unsigned int cur,\n					   MatchCoord* result, \n					   int edge_match_length,\n                       int qry_match_len,\n                       int min_match_len,\n                       int rc\n                       )\n{\n  if (qry_match_len > min_match_len)\n  {\n    edge_match_length |= rc;\n	result->node.data = cur;\n	result->edge_match_length = edge_match_length;\n  }\n  else\n  {\n    XPRINTF("  match too short (%d < %d)\n", qry_match_len, min_match_len);\n  }\n}\n\nvoid arrayToAddress(unsigned char arr[3], unsigned int& addr)\n{\n#if REORDER_TREE\n  addr = (arr[0] | ((arr[2] & 0xF) << 8)) | ((arr[1] | ((arr[2] & 0xF0) << 4)) << 16); \n#else\n  addr = MK3(arr);\n#endif\n}\n\ntemplate<typename T>\ninline T min(T x, T y)\n{\n	return x < y ? x : y;\n}\n\ntemplate<typename T>\ninline T max(T x, T y)\n{\n	return x < y ? y : x;\n}\n\nint kernel_gold(int qryid,\n				MatchResults* results, 		\n				char* queries,\n                PixelOfNode* nodes,\n                PixelOfChildren* childrenarr,\n                char* ref,\n                const int* queryAddrs,\n                const int* queryLengths,\n                const int numQueries,\n                const int min_match_len\n#if TREE_ACCESS_HISTOGRAM\n				,int* node_hist,\n				int* child_hist\n#endif\n				)\n{\n	    if (qryid >= numQueries) { return 0; }\n	    XPRINTF("> qryid: %d\n", qryid);\n\n	    int qlen = queryLengths[qryid];\n	    int qryAddr = queryAddrs[qryid];\n \n		unsigned int cur = 0;\n\n	    int mustmatch = 0;\n	    int qry_match_len = 0;\n		MatchCoord* match_coords = results->h_match_coords;\n	    MatchCoord * result = MATCH_BASE(match_coords, qryid);\n\n	    SHIFT_QUERIES(queries, qryAddr);\n\n	    int last = qlen - min_match_len;\n	    for (int qrystart = 0;\n	             qrystart <= last;\n	             qrystart++, \n	             result += RESULT_SPAN) \n	    {\n			//PixelOfNode node;\n			unsigned int node_start;\n	        unsigned int prev;\n\n	        if ((cur == 0) || (qry_match_len < 1)) \n	        {\n	            // start at root of tree\n	            GOROOT(cur);\n	            qry_match_len = 1;\n	            mustmatch = 0;\n	        }\n\n	        char c = GETQCHAR(qrystart + qry_match_len);\n\n	        XPRINTF("In node ("fNID"): starting with %c [%d] =>  \n",\n	                NID(cur), c, qry_match_len);\n\n	        unsigned int refpos = 0;\n	        while ((c != '\0')) \n	        {\n	            XPRINTF("Next edge to follow: %c (%d)\n", c, qry_match_len);\n\n				PixelOfChildren children;\n	            children = GETCHILDRENHIST(cur, false);\n				prev = cur;\n\n				switch (c) \n	            {\n					case 'A': arrayToAddress(children.a,cur); break;\n	                case 'C': arrayToAddress(children.c,cur); break;\n	                case 'G': arrayToAddress(children.g,cur); break;\n	                case 'T': arrayToAddress(children.t,cur); break;\n					default: cur = 0; break;\n	            };\n\n				//arrayToAddress(next, cur);\n\n	            XPRINTF(" In node: ("fNID")\n", NID(cur));\n\n	            // No edge to follow out of the node\n	            if (cur == 0) {\n	                XPRINTF(" no edge\n");\n	                SET_RESULT(prev, result, 0, qry_match_len, min_match_len, FORWARD);\n\n	                qry_match_len -= 1;\n	                mustmatch = 0;\n\n	                goto NEXT_SUBSTRING;\n	            }\n\n				PixelOfNode node;\n				node = GETNODEHIST(cur, true);\n				node_start = MK3(node.start);\n				unsigned int node_end = MK3(node.end);\n\n	            XPRINTF(" Edge coordinates: %d - %d\n", node_start, node_end);\n	            {\n	                int edgelen = node_end - node_start + 1;\n	                int edge_matchlen = node_start + mustmatch;\n	                int past_node_end = node_end + 1;\n	                int dist_to_edge_end = mustmatch - edgelen;\n	                if (mustmatch) {\n	                    refpos = min(edge_matchlen, past_node_end);\n	                    qry_match_len += min(edgelen, mustmatch);\n	                    mustmatch = max(dist_to_edge_end, 0);\n	                }\n	                else {\n	                    // Try to walk the edge, the first char definitely matches\n	                    qry_match_len++;\n	                    refpos = node_start + 1;\n	                }\n	            }\n\n	            c = GETQCHAR(qrystart + qry_match_len);\n\n	            while (refpos <= node_end && c != '\0') \n	            {\n	                char r = GETRCHAR(refpos);\n\n	                XPRINTF(" Edge cmp ref: %d %c, qry: %d %c\n", refpos, r, qry_match_len, c);\n\n	                if (r != c) \n	                {\n	                    // mismatch on edge\n	                    XPRINTF("mismatch on edge: %d, edge_pos: %d\n", qry_match_len, refpos - (node_start));\n	                    goto RECORD_RESULT;\n	                }\n\n	                qry_match_len++;\n	                refpos++;\n\n	                c = GETQCHAR(qrystart + qry_match_len);\n	            }\n	        }\n\n	        XPRINTF("end of string\n");\n\n	RECORD_RESULT:\n			{\n				//PixelOfNode node;\n				//node.data = getnodehist(cur, false);\n		        SET_RESULT(cur, result, refpos - node_start, qry_match_len,\n		                   min_match_len, FORWARD);\n\n		        mustmatch = refpos - node_start;\n		        qry_match_len -= mustmatch + 1;\n	    	}\n	NEXT_SUBSTRING:\n			{\n				PixelOfNode node;\n				node = GETNODEHIST(prev, false);\n		        arrayToAddress(node.suffix, cur);\n			}\n	        //XPRINTF(" following suffix link. mustmatch:%d qry_match_len:%d sl:("fNID")\n",\n	        //       mustmatch, qry_match_len, NID(cur));\n	        do {} while (0);\n	    }\n\n	    return 0;\n\n#if 0\n\n   XPRINTF("> qryid: %d\n", qryid);\n\n   int qlen = queryLengths[qryid];\n\n   // start at root for first query character\n   TextureAddress cur;\n   cur.data = 0;\n   int mustmatch = 0;\n   int qry_match_len = 0;\n\n   int qryAddr=queryAddrs[qryid];\n   MatchCoord * result = results->h_match_coords + qryAddr - (qryid * ( min_match_len + 1));\n   queries += qryAddr;\n\n   int last = qlen - min_match_len;\n   for (int qrystart = 0;\n       qrystart <= last;\n       qrystart++, result++, queries++)\n   {\n	  XPRINTF("qry: %s\n", queries + 1);\n\n	  PixelOfNode node;\n      TextureAddress prev;\n\n      if ((cur.data == 0) || (qry_match_len < 1))\n      {\n	    // start at root of tree\n	    cur.x = 0; cur.y = 1;\n	    qry_match_len = 1; \n        mustmatch = 0;\n      }\n\n	  char c = queries[qry_match_len];\n\n	  XPRINTF("In node (%d,%d): starting with %c [%d] =>  \n", cur.x, cur.y, c, qry_match_len);\n\n	  int refpos = 0;\n	  while ((c != '\0'))\n	  {\n		 XPRINTF("Next edge to follow: %c (%d)\n", c, qry_match_len);\n\n	     PixelOfChildren children;\n		 children = *(childrenTexture +  (cur.x) + ((cur.y) * maxdim));\n		 prev = cur;\n\n		 switch(c)\n		 {\n			case 'A': cur=children.children[0]; break;\n			case 'C': cur=children.children[1]; break;\n			case 'G': cur=children.children[2]; break;\n			case 'T': cur=children.children[3]; break;\n            default: cur.data = 0; break;\n		 };		 \n\n		 XPRINTF(" In node: (%d,%d)\n", cur.x, cur.y);\n\n		 // No edge to follow out of the node\n         if (cur.data == 0)\n		 {\n			XPRINTF(" no edge\n");\n	        set_result(prev, result, 0, qry_match_len, min_match_len, FORWARD);\n\n            qry_match_len -= 1;\n            mustmatch = 0;\n\n			goto NEXT_SUBSTRING;\n		 }\n\n         {\n           unsigned short xval = cur.data & 0xFFFF;\n           unsigned short yval = (cur.data & 0xFFFF0000) >> 16;\n		   node = *(nodeTexture +  (xval) + (yval * maxdim));\n         }\n\n		 XPRINTF(" Edge coordinates: %d - %d\n", node.start, node.end);\n\n         if (mustmatch)\n         {\n           int edgelen = node.end - node.start+1;\n           if (mustmatch >= edgelen)\n           {\n             XPRINTF(" mustmatch(%d) >= edgelen(%d), skipping edge\n", mustmatch, edgelen);\n\n             refpos = node.end+1;\n             qry_match_len += edgelen;\n             mustmatch -= edgelen;\n           }\n           else\n           {\n             XPRINTF(" mustmatch(%d) < edgelen(%d), skipping to:%d\n", \n                     mustmatch, edgelen, node.start+mustmatch);\n\n             qry_match_len += mustmatch;\n             refpos = node.start + mustmatch;\n             mustmatch = 0;\n           }\n         }\n         else\n         {\n           // Try to walk the edge, the first char definitely matches\n           qry_match_len++;\n           refpos = node.start+1;\n         }\n\n		 c = queries[qry_match_len];\n\n		 while (refpos <= node.end && c != '\0')\n		 { \n            //char r = getRef(refpos);\n			char r = refstr[refpos];\n			XPRINTF(" Edge cmp ref: %d %c, qry: %d %c\n", refpos, r, qry_match_len, c);\n						\n			if (r != c)\n			{\n			   // mismatch on edge\n			   XPRINTF("mismatch on edge: %d, edge_pos: %d\n", qry_match_len,refpos - (node.start));\n               goto RECORD_RESULT;\n			}\n\n	        qry_match_len++;\n			refpos++;\n			c = queries[qry_match_len];\n		 }\n	  }\n\n	  XPRINTF("end of string\n");\n\n      RECORD_RESULT:\n	\n      set_result(cur, result, refpos - node.start, qry_match_len, min_match_len, FORWARD);\n      mustmatch = refpos - node.start;\n      qry_match_len -= mustmatch + 1;\n\n      NEXT_SUBSTRING:\n\n      //node.data = texfetch(nodetex, prev.x, prev.y);\n	  node = *(nodeTexture +  (prev.x) + ((prev.y) * maxdim));\n      cur = node.suffix;\n\n      XPRINTF(" following suffix link. mustmatch:%d qry_match_len:%d sl:(%d,%d)\n", \n              mustmatch, qry_match_len, cur.x, cur.y);\n\n      do {} while(0);\n   }\n\n#endif\n	\n   return 0 ;\n}\n\n\n\ninline char rc(char c)\n{\n  switch(c)\n  {\n    case 'A': return 'T';\n    case 'C': return 'G';\n    case 'G': return 'C';\n    case 'T': return 'A';\n    case 'q': return '\0';\n    default:  return c;\n  };\n}\n\n///////////////////////////////////////\n//// Compute reverse substring matches\n///////////////////////////////////////\n\n\nvoid\nrc_kernel_gold(int qryid,\n			   MatchResults* results,\n			   char* refstr,\n               char* queries, \n               const int* queryAddrs,\n			   const int* queryLengths,\n			   PixelOfNode* nodeTexture,\n				PixelOfChildren* childrenTexture,\n               const int numQueries,\n			   const int min_match_len) \n{\n   \n   if (qryid >= numQueries) { return; }\n\n#if 0\n\n   int qlen = queryLengths[qryid];\n\n   XPRINTF("> rc qryid: %d\n", qryid);\n\n   queries++; // skip the 'q' character\n\n\n   // start at root for first query character\n   TextureAddress cur;\n\n   int mustmatch = 0;\n   int qry_match_len = 0;\n\n   int qryAddr=queryAddrs[qryid]; \n   MatchCoord * result = results->h_match_coords + qryAddr - (qryid * ( min_match_len + 1));\n   queries += qryAddr;\n\n   for (int qrystart = qlen;\n       qrystart >= min_match_len ;\n       qrystart--, result++)\n   {\n      #ifdef VERBOSE\n      queries[qrystart] = '\0';\n	  XPRINTF("qry: ", queries);\n      for (int j = qrystart-1; j >= 0; j--)\n      { XPRINTF("%c", rc(queries[j])); }\n      XPRINTF("\n");\n      #endif\n\n	  PixelOfNode node;\n      TextureAddress prev;\n\n      if (((cur.data == 0)) || (qry_match_len < 1))\n      {\n	    // start at root of tree\n	    cur.x = 0; cur.y = 1;\n	    qry_match_len = 1; \n        mustmatch = 0;\n      }\n\n	  char c = rc(queries[qrystart-qry_match_len]);\n\n	  XPRINTF("In node (%d,%d): starting with %c [%d] =>  \n", cur.x, cur.y, c, qry_match_len);\n\n	  int refpos = 0;\n	  while ((c != '\0'))\n	  {\n		 XPRINTF("Next edge to follow: %c (%d)\n", c, qry_match_len);\n\n	     PixelOfChildren children;\n		 children = *(childrenTexture +  (cur.x) + ((cur.y) * maxdim));\n		 prev = cur;\n\n		 switch(c)\n		 {\n			case 'A': cur=children.children[0]; break;\n			case 'C': cur=children.children[1]; break;\n			case 'G': cur=children.children[2]; break;\n			case 'T': cur=children.children[3]; break;\n            default: cur.data = 0; break;\n		 };		 \n\n		 XPRINTF(" In node: (%d,%d)\n", cur.x, cur.y);\n\n		 // No edge to follow out of the node\n         if (cur.data == 0)\n		 {\n			XPRINTF(" no edge\n");\n	        set_result(prev, result, 0, qry_match_len, min_match_len, \n                       REVERSE);\n\n            qry_match_len -= 1;\n            mustmatch = 0;\n\n			goto NEXT_SUBSTRING;\n		 }\n\n         {\n           unsigned short xval = cur.data & 0xFFFF;\n           unsigned short yval = (cur.data & 0xFFFF0000) >> 16;\n		   node = *(nodeTexture +  (xval) + (yval * maxdim));\n         }\n\n		 XPRINTF(" Edge coordinates: %d - %d\n", node.start, node.end);\n\n         if (mustmatch)\n         {\n           int edgelen = node.end - node.start+1;\n           if (mustmatch >= edgelen)\n           {\n             XPRINTF(" mustmatch(%d) >= edgelen(%d), skipping edge\n", mustmatch, edgelen);\n\n             refpos = node.end+1;\n             qry_match_len += edgelen;\n             mustmatch -= edgelen;\n           }\n           else\n           {\n             XPRINTF(" mustmatch(%d) < edgelen(%d), skipping to:%d\n", \n                     mustmatch, edgelen, node.start+mustmatch);\n\n             qry_match_len += mustmatch;\n             refpos = node.start + mustmatch;\n             mustmatch = 0;\n           }\n         }\n         else\n         {\n           // Try to walk the edge, the first char definitely matches\n           qry_match_len++;\n           refpos = node.start+1;\n         }\n\n		 c = rc(queries[qrystart-qry_match_len]);\n\n		 while (refpos <= node.end && c != '\0')\n		 { \n            //char r = getRef(refstr, refpos);\n			char r = refstr[refpos];\n			XPRINTF(" Edge cmp ref: %d %c, qry: %d %c\n", refpos, r, qry_match_len, c);\n						\n			if (r != c)\n			{\n			   // mismatch on edge\n			   XPRINTF("mismatch on edge: %d, edge_pos: %d\n", qry_match_len,refpos - (node.start));\n               goto RECORD_RESULT;\n			}\n\n	        qry_match_len++;\n			refpos++;\n			c = rc(queries[qrystart-qry_match_len]);\n		 }\n	  }\n\n	  XPRINTF("end of string\n");\n\n      RECORD_RESULT:\n	\n      set_result(cur, result, refpos - node.start, qry_match_len, \n                 min_match_len, REVERSE);\n\n      mustmatch = refpos - node.start;\n      qry_match_len -= mustmatch + 1;\n\n      NEXT_SUBSTRING:\n\n	  node = *(nodeTexture +  (prev.x) + ((prev.y) * maxdim));\n      cur = node.suffix;\n\n      XPRINTF(" following suffix link. mustmatch:%d qry_match_len:%d sl:(%d,%d)\n", \n              mustmatch, qry_match_len, cur.x, cur.y);\n\n      do {} while(0);\n   }\n\n#endif\n	\n   return;\n}\n\n\nextern "C" \nvoid computeGold(MatchResults* results,\n				 char* refstr, \n				 char* queries, \n				 int* queryAddrs,\n				 int* queryLengths,\n				 PixelOfNode* nodeTexture,\n				 PixelOfChildren* childrenTexture,\n				 int numQueries,\n				 int match_length,\n				 int rc)\n{\n\n   if (rc == REVERSE)\n   {\n   \n#ifdef OMP\n    omp_set_num_threads(N_THREADS);\n	//fprintf(stderr, "num of omp threads: %d\n", omp_get_num_threads());\n   #pragma omp parallel for \n#endif\n	  for (int i = 0; i < numQueries; ++i)\n	  {\n		 rc_kernel_gold(i, \n					 results, \n					 refstr, \n					 queries, \n					 queryAddrs, \n					 queryLengths,\n					 nodeTexture, \n					 childrenTexture,\n					 numQueries, \n					 match_length);\n	  }\n\n	  \n   }\n   else\n   {\n    \n#ifdef OMP\n	omp_set_num_threads(N_THREADS);\n	fprintf(stderr, "num of omp threads: %d\n", omp_get_num_threads());\n	#pragma omp parallel for \n#endif\n	  for (int i = 0; i < numQueries; ++i)\n	  {\n		\n		/*\n		int qryid,\n						MatchResults* results, 		\n						char* queries,\n		                PixelOfNode* nodes,\n		                PixelOfChildren* childrenarr,\n		                char* ref,\n		                const int* queryAddrs,\n		                const int* queryLengths,\n		                const int numQueries,\n		                const int min_match_len\n		#if TREE_ACCESS_HISTOGRAM\n						,int* node_hist,\n						int* child_hist\n		#endif\n		*/\n		 kernel_gold(i, \n					 results, \n					 queries, \n					 nodeTexture, \n					 childrenTexture,\n					 refstr, \n					 queryAddrs, \n					 queryLengths,\n					 numQueries, \n					 match_length\n#if TREE_ACCESS_HISTOGRAM\n					 ,int* node_hist,\n					 int* child_hist\n#endif\n					 );\n	  }\n   }\n}\n\n