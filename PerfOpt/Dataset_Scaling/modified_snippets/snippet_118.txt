\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* matop.c 1.3 11/25/87 */\n\n\n#include	<stdio.h>\n#include	"matrix.h"\n\nstatic	char	rcsid[] = "$Id: matop.c,v 1.4 1995/03/27 15:43:57 des Exp $";\n\n\n/* m_add -- matrix addition -- may be in-situ */\n#ifndef ANSI_C\nMAT	*m_add(mat1,mat2,out)\nMAT	*mat1,*mat2,*out;\n#else\nMAT	*m_add(const MAT *mat1, const MAT *mat2, MAT *out)\n#endif\n{\n	unsigned int	m,n,i;\n\n	if ( mat1==(MAT *)NULL || mat2==(MAT *)NULL )\n		error(E_NULL,"m_add");\n	if ( mat1->m != mat2->m || mat1->n != mat2->n )\n		error(E_SIZES,"m_add");\n	if ( out==(MAT *)NULL || out->m != mat1->m || out->n != mat1->n )\n		out = m_resize(out,mat1->m,mat1->n);\n	m = mat1->m;	n = mat1->n;\n	for ( i=0; i<m; i++ )\n	{\n		__add__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n		/**************************************************\n		for ( j=0; j<n; j++ )\n			out->me[i][j] = mat1->me[i][j]+mat2->me[i][j];\n		**************************************************/\n	}\n\n	return (out);\n}\n\n/* m_sub -- matrix subtraction -- may be in-situ */\n#ifndef ANSI_C\nMAT	*m_sub(mat1,mat2,out)\nMAT	*mat1,*mat2,*out;\n#else\nMAT	*m_sub(const MAT *mat1, const MAT *mat2, MAT *out)\n#endif\n{\n	unsigned int	m,n,i;\n\n	if ( mat1==(MAT *)NULL || mat2==(MAT *)NULL )\n		error(E_NULL,"m_sub");\n	if ( mat1->m != mat2->m || mat1->n != mat2->n )\n		error(E_SIZES,"m_sub");\n	if ( out==(MAT *)NULL || out->m != mat1->m || out->n != mat1->n )\n		out = m_resize(out,mat1->m,mat1->n);\n	m = mat1->m;	n = mat1->n;\n	for ( i=0; i<m; i++ )\n	{\n		__sub__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n		/**************************************************\n		for ( j=0; j<n; j++ )\n			out->me[i][j] = mat1->me[i][j]-mat2->me[i][j];\n		**************************************************/\n	}\n\n	return (out);\n}\n\n/* m_mlt -- matrix-matrix multiplication */\n#ifndef ANSI_C\nMAT	*m_mlt(A,B,OUT)\nMAT	*A,*B,*OUT;\n#else\nMAT	*m_mlt(const MAT *A, const MAT *B, MAT *OUT)\n#endif\n{\n	unsigned int	i, /* j, */ k, m, n, p;\n	Real	**A_v, **B_v /*, *B_row, *OUT_row, sum, tmp */;\n\n	if ( A==(MAT *)NULL || B==(MAT *)NULL )\n		error(E_NULL,"m_mlt");\n	if ( A->n != B->m )\n		error(E_SIZES,"m_mlt");\n	if ( A == OUT || B == OUT )\n		error(E_INSITU,"m_mlt");\n	m = A->m;	n = A->n;	p = B->n;\n	A_v = A->me;		B_v = B->me;\n\n	if ( OUT==(MAT *)NULL || OUT->m != A->m || OUT->n != B->n )\n		OUT = m_resize(OUT,A->m,B->n);\n\n/****************************************************************\n	for ( i=0; i<m; i++ )\n		for  ( j=0; j<p; j++ )\n		{\n			sum = 0.0;\n			for ( k=0; k<n; k++ )\n				sum += A_v[i][k]*B_v[k][j];\n			OUT->me[i][j] = sum;\n		}\n****************************************************************/\n	m_zero(OUT);\n	for ( i=0; i<m; i++ )\n		for ( k=0; k<n; k++ )\n		{\n		    if ( A_v[i][k] != 0.0 )\n		        __mltadd__(OUT->me[i],B_v[k],A_v[i][k],(int)p);\n		    /**************************************************\n		    B_row = B_v[k];	OUT_row = OUT->me[i];\n		    for ( j=0; j<p; j++ )\n			(*OUT_row++) += tmp*(*B_row++);\n		    **************************************************/\n		}\n\n	return OUT;\n}\n\n/* mmtr_mlt -- matrix-matrix transposed multiplication\n	-- A.B^T is returned, and stored in OUT */\n#ifndef ANSI_C\nMAT	*mmtr_mlt(A,B,OUT)\nMAT	*A, *B, *OUT;\n#else\nMAT	*mmtr_mlt(const MAT *A, const MAT *B, MAT *OUT)\n#endif\n{\n	int	i, j, limit;\n	/* Real	*A_row, *B_row, sum; */\n\n	if ( ! A || ! B )\n		error(E_NULL,"mmtr_mlt");\n	if ( A == OUT || B == OUT )\n		error(E_INSITU,"mmtr_mlt");\n	if ( A->n != B->n )\n		error(E_SIZES,"mmtr_mlt");\n	if ( ! OUT || OUT->m != A->m || OUT->n != B->m )\n		OUT = m_resize(OUT,A->m,B->m);\n\n	limit = A->n;\n	for ( i = 0; i < A->m; i++ )\n		for ( j = 0; j < B->m; j++ )\n		{\n		    OUT->me[i][j] = __ip__(A->me[i],B->me[j],(int)limit);\n		    /**************************************************\n		    sum = 0.0;\n		    A_row = A->me[i];\n		    B_row = B->me[j];\n		    for ( k = 0; k < limit; k++ )\n			sum += (*A_row++)*(*B_row++);\n		    OUT->me[i][j] = sum;\n		    **************************************************/\n		}\n\n	return OUT;\n}\n\n/* mtrm_mlt -- matrix transposed-matrix multiplication\n	-- A^T.B is returned, result stored in OUT */\n#ifndef ANSI_C\nMAT	*mtrm_mlt(A,B,OUT)\nMAT	*A, *B, *OUT;\n#else\nMAT	*mtrm_mlt(const MAT *A, const MAT *B, MAT *OUT)\n#endif\n{\n	int	i, k, limit;\n	/* Real	*B_row, *OUT_row, multiplier; */\n\n	if ( ! A || ! B )\n		error(E_NULL,"mmtr_mlt");\n	if ( A == OUT || B == OUT )\n		error(E_INSITU,"mtrm_mlt");\n	if ( A->m != B->m )\n		error(E_SIZES,"mmtr_mlt");\n	if ( ! OUT || OUT->m != A->n || OUT->n != B->n )\n		OUT = m_resize(OUT,A->n,B->n);\n\n	limit = B->n;\n	m_zero(OUT);\n	for ( k = 0; k < A->m; k++ )\n		for ( i = 0; i < A->n; i++ )\n		{\n		    if ( A->me[k][i] != 0.0 )\n			__mltadd__(OUT->me[i],B->me[k],A->me[k][i],(int)limit);\n		    /**************************************************\n		    multiplier = A->me[k][i];\n		    OUT_row = OUT->me[i];\n		    B_row   = B->me[k];\n		    for ( j = 0; j < limit; j++ )\n			*(OUT_row++) += multiplier*(*B_row++);\n		    **************************************************/\n		}\n\n	return OUT;\n}\n\n/* mv_mlt -- matrix-vector multiplication \n		-- Note: b is treated as a column vector */\n#ifndef ANSI_C\nVEC	*mv_mlt(A,b,out)\nMAT	*A;\nVEC	*b,*out;\n#else\nVEC	*mv_mlt(const MAT *A, const VEC *b, VEC *out)\n#endif\n{\n	unsigned int	i, m, n;\n	Real	**A_v, *b_v /*, *A_row */;\n	/* register Real	sum; */\n\n	if ( A==(MAT *)NULL || b==(VEC *)NULL )\n		error(E_NULL,"mv_mlt");\n	if ( A->n != b->dim )\n		error(E_SIZES,"mv_mlt");\n	if ( b == out )\n		error(E_INSITU,"mv_mlt");\n	if ( out == (VEC *)NULL || out->dim != A->m )\n		out = v_resize(out,A->m);\n\n	m = A->m;		n = A->n;\n	A_v = A->me;		b_v = b->ve;\n	for ( i=0; i<m; i++ )\n	{\n		/* for ( j=0; j<n; j++ )\n			sum += A_v[i][j]*b_v[j]; */\n		out->ve[i] = __ip__(A_v[i],b_v,(int)n);\n		/**************************************************\n		A_row = A_v[i];		b_v = b->ve;\n		for ( j=0; j<n; j++ )\n			sum += (*A_row++)*(*b_v++);\n		out->ve[i] = sum;\n		**************************************************/\n	}\n\n	return out;\n}\n\n/* sm_mlt -- scalar-matrix multiply -- may be in-situ */\n#ifndef ANSI_C\nMAT	*sm_mlt(scalar,matrix,out)\ndouble	scalar;\nMAT	*matrix,*out;\n#else\nMAT	*sm_mlt(double scalar, const MAT *matrix, MAT *out)\n#endif\n{\n	unsigned int	m,n,i;\n\n	if ( matrix==(MAT *)NULL )\n		error(E_NULL,"sm_mlt");\n	if ( out==(MAT *)NULL || out->m != matrix->m || out->n != matrix->n )\n		out = m_resize(out,matrix->m,matrix->n);\n	m = matrix->m;	n = matrix->n;\n	for ( i=0; i<m; i++ )\n		__smlt__(matrix->me[i],(double)scalar,out->me[i],(int)n);\n		/**************************************************\n		for ( j=0; j<n; j++ )\n			out->me[i][j] = scalar*matrix->me[i][j];\n		**************************************************/\n	return (out);\n}\n\n/* vm_mlt -- vector-matrix multiplication \n		-- Note: b is treated as a row vector */\n#ifndef ANSI_C\nVEC	*vm_mlt(A,b,out)\nMAT	*A;\nVEC	*b,*out;\n#else\nVEC	*vm_mlt(const MAT *A, const VEC *b, VEC *out)\n#endif\n{\n	unsigned int	j,m,n;\n	/* Real	sum,**A_v,*b_v; */\n\n	if ( A==(MAT *)NULL || b==(VEC *)NULL )\n		error(E_NULL,"vm_mlt");\n	if ( A->m != b->dim )\n		error(E_SIZES,"vm_mlt");\n	if ( b == out )\n		error(E_INSITU,"vm_mlt");\n	if ( out == (VEC *)NULL || out->dim != A->n )\n		out = v_resize(out,A->n);\n\n	m = A->m;		n = A->n;\n\n	v_zero(out);\n	for ( j = 0; j < m; j++ )\n		if ( b->ve[j] != 0.0 )\n		    __mltadd__(out->ve,A->me[j],b->ve[j],(int)n);\n	/**************************************************\n	A_v = A->me;		b_v = b->ve;\n	for ( j=0; j<n; j++ )\n	{\n		sum = 0.0;\n		for ( i=0; i<m; i++ )\n			sum += b_v[i]*A_v[i][j];\n		out->ve[j] = sum;\n	}\n	**************************************************/\n\n	return out;\n}\n\n/* m_transp -- transpose matrix */\n#ifndef ANSI_C\nMAT	*m_transp(in,out)\nMAT	*in, *out;\n#else\nMAT	*m_transp(const MAT *in, MAT *out)\n#endif\n{\n	int	i, j;\n	int	in_situ;\n	Real	tmp;\n\n	if ( in == (MAT *)NULL )\n		error(E_NULL,"m_transp");\n	if ( in == out && in->n != in->m )\n		error(E_INSITU2,"m_transp");\n	in_situ = ( in == out );\n	if ( out == (MAT *)NULL || out->m != in->n || out->n != in->m )\n		out = m_resize(out,in->n,in->m);\n\n	if ( ! in_situ )\n		for ( i = 0; i < in->m; i++ )\n			for ( j = 0; j < in->n; j++ )\n				out->me[j][i] = in->me[i][j];\n	else\n		for ( i = 1; i < in->m; i++ )\n			for ( j = 0; j < i; j++ )\n			{	tmp = in->me[i][j];\n				in->me[i][j] = in->me[j][i];\n				in->me[j][i] = tmp;\n			}\n\n	return out;\n}\n\n/* swap_rows -- swaps rows i and j of matrix A for cols lo through hi */\n#ifndef ANSI_C\nMAT	*swap_rows(A,i,j,lo,hi)\nMAT	*A;\nint	i, j, lo, hi;\n#else\nMAT	*swap_rows(MAT *A, int i, int j, int lo, int hi)\n#endif\n{\n	int	k;\n	Real	**A_me, tmp;\n\n	if ( ! A )\n		error(E_NULL,"swap_rows");\n	if ( i < 0 || j < 0 || i >= A->m || j >= A->m )\n		error(E_SIZES,"swap_rows");\n	lo = max(0,lo);\n	hi = min(hi,A->n-1);\n	A_me = A->me;\n\n	for ( k = lo; k <= hi; k++ )\n	{\n		tmp = A_me[k][i];\n		A_me[k][i] = A_me[k][j];\n		A_me[k][j] = tmp;\n	}\n	return A;\n}\n\n/* swap_cols -- swap columns i and j of matrix A for cols lo through hi */\n#ifndef ANSI_C\nMAT	*swap_cols(A,i,j,lo,hi)\nMAT	*A;\nint	i, j, lo, hi;\n#else\nMAT	*swap_cols(MAT *A, int i, int j, int lo, int hi)\n#endif\n{\n	int	k;\n	Real	**A_me, tmp;\n\n	if ( ! A )\n		error(E_NULL,"swap_cols");\n	if ( i < 0 || j < 0 || i >= A->n || j >= A->n )\n		error(E_SIZES,"swap_cols");\n	lo = max(0,lo);\n	hi = min(hi,A->m-1);\n	A_me = A->me;\n\n	for ( k = lo; k <= hi; k++ )\n	{\n		tmp = A_me[i][k];\n		A_me[i][k] = A_me[j][k];\n		A_me[j][k] = tmp;\n	}\n	return A;\n}\n\n/* ms_mltadd -- matrix-scalar multiply and add\n	-- may be in situ\n	-- returns out == A1 + s*A2 */\n#ifndef ANSI_C\nMAT	*ms_mltadd(A1,A2,s,out)\nMAT	*A1, *A2, *out;\ndouble	s;\n#else\nMAT	*ms_mltadd(const MAT *A1, const MAT *A2, double s, MAT *out)\n#endif\n{\n	/* register Real	*A1_e, *A2_e, *out_e; */\n	/* register int	j; */\n	int	i, m, n;\n\n	if ( ! A1 || ! A2 )\n		error(E_NULL,"ms_mltadd");\n	if ( A1->m != A2->m || A1->n != A2->n )\n		error(E_SIZES,"ms_mltadd");\n\n	if ( out != A1 && out != A2 )\n		out = m_resize(out,A1->m,A1->n);\n\n	if ( s == 0.0 )\n		return m_copy(A1,out);\n	if ( s == 1.0 )\n		return m_add(A1,A2,out);\n\n	tracecatch(out = m_copy(A1,out),"ms_mltadd");\n\n	m = A1->m;	n = A1->n;\n	for ( i = 0; i < m; i++ )\n	{\n		__mltadd__(out->me[i],A2->me[i],s,(int)n);\n		/**************************************************\n		A1_e = A1->me[i];\n		A2_e = A2->me[i];\n		out_e = out->me[i];\n		for ( j = 0; j < n; j++ )\n		    out_e[j] = A1_e[j] + s*A2_e[j];\n		**************************************************/\n	}\n\n	return out;\n}\n\n/* mv_mltadd -- matrix-vector multiply and add\n	-- may not be in situ\n	-- returns out == v1 + alpha*A*v2 */\n#ifndef ANSI_C\nVEC	*mv_mltadd(v1,v2,A,alpha,out)\nVEC	*v1, *v2, *out;\nMAT	*A;\ndouble	alpha;\n#else\nVEC	*mv_mltadd(const VEC *v1, const VEC *v2, const MAT *A,\n		   double alpha, VEC *out)\n#endif\n{\n	/* register	int	j; */\n	int	i, m, n;\n	Real	*v2_ve, *out_ve;\n\n	if ( ! v1 || ! v2 || ! A )\n		error(E_NULL,"mv_mltadd");\n	if ( out == v2 )\n		error(E_INSITU,"mv_mltadd");\n	if ( v1->dim != A->m || v2->dim != A->n )\n		error(E_SIZES,"mv_mltadd");\n\n	tracecatch(out = v_copy(v1,out),"mv_mltadd");\n\n	v2_ve = v2->ve;	out_ve = out->ve;\n	m = A->m;	n = A->n;\n\n	if ( alpha == 0.0 )\n	    return out;\n\n	for ( i = 0; i < m; i++ )\n	{\n		out_ve[i] += alpha*__ip__(A->me[i],v2_ve,(int)n);\n		/**************************************************\n		A_e = A->me[i];\n		sum = 0.0;\n		for ( j = 0; j < n; j++ )\n		    sum += A_e[j]*v2_ve[j];\n		out_ve[i] = v1->ve[i] + alpha*sum;\n		**************************************************/\n	}\n\n	return out;\n}\n\n/* vm_mltadd -- vector-matrix multiply and add\n	-- may not be in situ\n	-- returns out' == v1' + v2'*A */\n#ifndef ANSI_C\nVEC	*vm_mltadd(v1,v2,A,alpha,out)\nVEC	*v1, *v2, *out;\nMAT	*A;\ndouble	alpha;\n#else\nVEC	*vm_mltadd(const VEC *v1, const VEC *v2, const MAT *A,\n		   double alpha, VEC *out)\n#endif\n{\n	int	/* i, */ j, m, n;\n	Real	tmp, /* *A_e, */ *out_ve;\n\n	if ( ! v1 || ! v2 || ! A )\n		error(E_NULL,"vm_mltadd");\n	if ( v2 == out )\n		error(E_INSITU,"vm_mltadd");\n	if ( v1->dim != A->n || A->m != v2->dim )\n		error(E_SIZES,"vm_mltadd");\n\n	tracecatch(out = v_copy(v1,out),"vm_mltadd");\n\n	out_ve = out->ve;	m = A->m;	n = A->n;\n	for ( j = 0; j < m; j++ )\n	{\n		tmp = v2->ve[j]*alpha;\n		if ( tmp != 0.0 )\n		    __mltadd__(out_ve,A->me[j],tmp,(int)n);\n		/**************************************************\n		A_e = A->me[j];\n		for ( i = 0; i < n; i++ )\n		    out_ve[i] += A_e[i]*tmp;\n		**************************************************/\n	}\n\n	return out;\n}\n\n