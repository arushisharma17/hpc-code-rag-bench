\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* memory.c 1.3 11/25/87 */\n\n#include 	"matrix.h"\n\n\nstatic	char	rcsid[] = "$Id: memory.c,v 1.13 1994/04/05 02:10:37 des Exp $";\n\n/* m_get -- gets an mxn matrix (in MAT form) by dynamic memory allocation\n	-- normally ALL matrices should be obtained this way\n	-- if either m or n is negative this will raise an error\n	-- note that 0 x n and m x 0 matrices can be created */\n#ifndef ANSI_C\nMAT	*m_get(m,n)\nint	m,n;\n#else\nMAT	*m_get(int m, int n)\n#endif\n{\n   MAT	*matrix;\n   int	i;\n   \n   if (m < 0 || n < 0)\n     error(E_NEG,"m_get");\n\n   if ((matrix=NEW(MAT)) == (MAT *)NULL )\n     error(E_MEM,"m_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,0,sizeof(MAT));\n      mem_numvar(TYPE_MAT,1);\n   }\n   \n   matrix->m = m;		matrix->n = matrix->max_n = n;\n   matrix->max_m = m;	matrix->max_size = m*n;\n#ifndef SEGMENTED\n   if ((matrix->base = NEW_A(m*n,Real)) == (Real *)NULL )\n   {\n      free(matrix);\n      error(E_MEM,"m_get");\n   }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,0,m*n*sizeof(Real));\n   }\n#else\n   matrix->base = (Real *)NULL;\n#endif\n   if ((matrix->me = (Real **)calloc(m,sizeof(Real *))) == \n       (Real **)NULL )\n   {	free(matrix->base);	free(matrix);\n	error(E_MEM,"m_get");\n     }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,0,m*sizeof(Real *));\n   }\n   \n#ifndef SEGMENTED\n   /* set up pointers */\n   for ( i=0; i<m; i++ )\n     matrix->me[i] = &(matrix->base[i*n]);\n#else\n   for ( i = 0; i < m; i++ )\n     if ( (matrix->me[i]=NEW_A(n,Real)) == (Real *)NULL )\n       error(E_MEM,"m_get");\n     else if (mem_info_is_on()) {\n	mem_bytes(TYPE_MAT,0,n*sizeof(Real));\n       }\n#endif\n   \n   return (matrix);\n}\n\n\n/* px_get -- gets a PERM of given 'size' by dynamic memory allocation\n	-- Note: initialized to the identity permutation\n	-- the permutation is on the set {0,1,2,...,size-1} */\n#ifndef ANSI_C\nPERM	*px_get(size)\nint	size;\n#else\nPERM	*px_get(int size)\n#endif\n{\n   PERM	*permute;\n   int	i;\n\n   if (size < 0)\n     error(E_NEG,"px_get");\n\n   if ((permute=NEW(PERM)) == (PERM *)NULL )\n     error(E_MEM,"px_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_PERM,0,sizeof(PERM));\n      mem_numvar(TYPE_PERM,1);\n   }\n   \n   permute->size = permute->max_size = size;\n   if ((permute->pe = NEW_A(size,unsigned int)) == (unsigned int *)NULL )\n     error(E_MEM,"px_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_PERM,0,size*sizeof(unsigned int));\n   }\n   \n   for ( i=0; i<size; i++ )\n     permute->pe[i] = i;\n   \n   return (permute);\n}\n\n/* v_get -- gets a VEC of dimension 'size'\n   -- Note: initialized to zero */\n#ifndef ANSI_C\nVEC	*v_get(size)\nint	size;\n#else\nVEC	*v_get(int size)\n#endif\n{\n   VEC	*vector;\n   \n   if (size < 0)\n     error(E_NEG,"v_get");\n\n   if ((vector=NEW(VEC)) == (VEC *)NULL )\n     error(E_MEM,"v_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_VEC,0,sizeof(VEC));\n      mem_numvar(TYPE_VEC,1);\n   }\n   \n   vector->dim = vector->max_dim = size;\n   if ((vector->ve=NEW_A(size,Real)) == (Real *)NULL )\n   {\n      free(vector);\n      error(E_MEM,"v_get");\n   }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_VEC,0,size*sizeof(Real));\n   }\n   \n   return (vector);\n}\n\n/* m_free -- returns MAT & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	m_free(mat)\nMAT	*mat;\n#else\nint	m_free(MAT *mat)\n#endif\n{\n#ifdef SEGMENTED\n   int	i;\n#endif\n   \n   if ( mat==(MAT *)NULL || (int)(mat->m) < 0 ||\n       (int)(mat->n) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n#ifndef SEGMENTED\n   if ( mat->base != (Real *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,mat->max_m*mat->max_n*sizeof(Real),0);\n      }\n      free((char *)(mat->base));\n   }\n#else\n   for ( i = 0; i < mat->max_m; i++ )\n     if ( mat->me[i] != (Real *)NULL ) {\n	if (mem_info_is_on()) {\n	   mem_bytes(TYPE_MAT,mat->max_n*sizeof(Real),0);\n	}\n	free((char *)(mat->me[i]));\n     }\n#endif\n   if ( mat->me != (Real **)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,mat->max_m*sizeof(Real *),0);\n      }\n      free((char *)(mat->me));\n   }\n   \n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,sizeof(MAT),0);\n      mem_numvar(TYPE_MAT,-1);\n   }\n   free((char *)mat);\n   \n   return (0);\n}\n\n\n\n/* px_free -- returns PERM & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	px_free(px)\nPERM	*px;\n#else\nint	px_free(PERM *px)\n#endif\n{\n   if ( px==(PERM *)NULL || (int)(px->size) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n   if ( px->pe == (unsigned int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_PERM,sizeof(PERM),0);\n	 mem_numvar(TYPE_PERM,-1);\n      }      \n      free((char *)px);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_PERM,sizeof(PERM)+px->max_size*sizeof(unsigned int),0);\n	 mem_numvar(TYPE_PERM,-1);\n      }\n      free((char *)px->pe);\n      free((char *)px);\n   }\n   \n   return (0);\n}\n\n\n\n/* v_free -- returns VEC & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	v_free(vec)\nVEC	*vec;\n#else\nint	v_free(VEC *vec)\n#endif\n{\n   if ( vec==(VEC *)NULL || (int)(vec->dim) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n   if ( vec->ve == (Real *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_VEC,sizeof(VEC),0);\n	 mem_numvar(TYPE_VEC,-1);\n      }\n      free((char *)vec);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_VEC,sizeof(VEC)+vec->max_dim*sizeof(Real),0);\n	 mem_numvar(TYPE_VEC,-1);\n      }\n      free((char *)vec->ve);\n      free((char *)vec);\n   }\n   \n   return (0);\n}\n\n\n\n/* m_resize -- returns the matrix A of size new_m x new_n; A is zeroed\n   -- if A == NULL on entry then the effect is equivalent to m_get() */\n#ifndef ANSI_C\nMAT	*m_resize(A,new_m,new_n)\nMAT	*A;\nint	new_m, new_n;\n#else\nMAT	*m_resize(MAT *A,int new_m, int new_n)\n#endif\n{\n   int	i;\n   int	new_max_m, new_max_n, new_size, old_m, old_n;\n   \n   if (new_m < 0 || new_n < 0)\n     error(E_NEG,"m_resize");\n\n   if ( ! A )\n     return m_get(new_m,new_n);\n\n   /* nothing was changed */\n   if (new_m == A->m && new_n == A->n)\n     return A;\n\n   old_m = A->m;	old_n = A->n;\n   if ( new_m > A->max_m )\n   {	/* re-allocate A->me */\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,A->max_m*sizeof(Real *),\n		      new_m*sizeof(Real *));\n      }\n\n      A->me = RENEW(A->me,new_m,Real *);\n      if ( ! A->me )\n	error(E_MEM,"m_resize");\n   }\n   new_max_m = max(new_m,A->max_m);\n   new_max_n = max(new_n,A->max_n);\n   \n#ifndef SEGMENTED\n   new_size = new_max_m*new_max_n;\n   if ( new_size > A->max_size )\n   {	/* re-allocate A->base */\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,A->max_m*A->max_n*sizeof(Real),\n		      new_size*sizeof(Real));\n      }\n\n      A->base = RENEW(A->base,new_size,Real);\n      if ( ! A->base )\n	error(E_MEM,"m_resize");\n      A->max_size = new_size;\n   }\n   \n   /* now set up A->me[i] */\n   for ( i = 0; i < new_m; i++ )\n     A->me[i] = &(A->base[i*new_n]);\n   \n   /* now shift data in matrix */\n   if ( old_n > new_n )\n   {\n      for ( i = 1; i < min(old_m,new_m); i++ )\n	MEM_COPY((char *)&(A->base[i*old_n]),\n		 (char *)&(A->base[i*new_n]),\n		 sizeof(Real)*new_n);\n   }\n   else if ( old_n < new_n )\n   {\n      for ( i = (int)(min(old_m,new_m))-1; i > 0; i-- )\n      {   /* copy & then zero extra space */\n	 MEM_COPY((char *)&(A->base[i*old_n]),\n		  (char *)&(A->base[i*new_n]),\n		  sizeof(Real)*old_n);\n	 __zero__(&(A->base[i*new_n+old_n]),(new_n-old_n));\n      }\n      __zero__(&(A->base[old_n]),(new_n-old_n));\n      A->max_n = new_n;\n   }\n   /* zero out the new rows.. */\n   for ( i = old_m; i < new_m; i++ )\n     __zero__(&(A->base[i*new_n]),new_n);\n#else\n   if ( A->max_n < new_n )\n   {\n      Real	*tmp;\n      \n      for ( i = 0; i < A->max_m; i++ )\n      {\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_MAT,A->max_n*sizeof(Real),\n			 new_max_n*sizeof(Real));\n	 }	\n\n	 if ( (tmp = RENEW(A->me[i],new_max_n,Real)) == NULL )\n	   error(E_MEM,"m_resize");\n	 else {	\n	    A->me[i] = tmp;\n	 }\n      }\n      for ( i = A->max_m; i < new_max_m; i++ )\n      {\n	 if ( (tmp = NEW_A(new_max_n,Real)) == NULL )\n	   error(E_MEM,"m_resize");\n	 else {\n	    A->me[i] = tmp;\n\n	    if (mem_info_is_on()) {\n	       mem_bytes(TYPE_MAT,0,new_max_n*sizeof(Real));\n	    }	    \n	 }\n      }\n   }\n   else if ( A->max_m < new_m )\n   {\n      for ( i = A->max_m; i < new_m; i++ ) \n	if ( (A->me[i] = NEW_A(new_max_n,Real)) == NULL )\n	  error(E_MEM,"m_resize");\n	else if (mem_info_is_on()) {\n	   mem_bytes(TYPE_MAT,0,new_max_n*sizeof(Real));\n	}\n      \n   }\n   \n   if ( old_n < new_n )\n   {\n      for ( i = 0; i < old_m; i++ )\n	__zero__(&(A->me[i][old_n]),new_n-old_n);\n   }\n   \n   /* zero out the new rows.. */\n   for ( i = old_m; i < new_m; i++ )\n     __zero__(A->me[i],new_n);\n#endif\n   \n   A->max_m = new_max_m;\n   A->max_n = new_max_n;\n   A->max_size = A->max_m*A->max_n;\n   A->m = new_m;	A->n = new_n;\n   \n   return A;\n}\n\n/* px_resize -- returns the permutation px with size new_size\n   -- px is set to the identity permutation */\n#ifndef ANSI_C\nPERM	*px_resize(px,new_size)\nPERM	*px;\nint	new_size;\n#else\nPERM	*px_resize(PERM *px, int new_size)\n#endif\n{\n   int	i;\n   \n   if (new_size < 0)\n     error(E_NEG,"px_resize");\n\n   if ( ! px )\n     return px_get(new_size);\n   \n   /* nothing is changed */\n   if (new_size == px->size)\n     return px;\n\n   if ( new_size > px->max_size )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_PERM,px->max_size*sizeof(unsigned int),\n		      new_size*sizeof(unsigned int));\n      }\n      px->pe = RENEW(px->pe,new_size,unsigned int);\n      if ( ! px->pe )\n	error(E_MEM,"px_resize");\n      px->max_size = new_size;\n   }\n   if ( px->size <= new_size )\n     /* extend permutation */\n     for ( i = px->size; i < new_size; i++ )\n       px->pe[i] = i;\n   else\n     for ( i = 0; i < new_size; i++ )\n       px->pe[i] = i;\n   \n   px->size = new_size;\n   \n   return px;\n}\n\n/* v_resize -- returns the vector x with dim new_dim\n   -- x is set to the zero vector */\n#ifndef ANSI_C\nVEC	*v_resize(x,new_dim)\nVEC	*x;\nint	new_dim;\n#else\nVEC	*v_resize(VEC *x, int new_dim)\n#endif\n{\n   \n   if (new_dim < 0)\n     error(E_NEG,"v_resize");\n\n   if ( ! x )\n     return v_get(new_dim);\n\n   /* nothing is changed */\n   if (new_dim == x->dim)\n     return x;\n\n   if ( x->max_dim == 0 )	/* assume that it's from sub_vec */\n     return v_get(new_dim);\n   \n   if ( new_dim > x->max_dim )\n   {\n      if (mem_info_is_on()) { \n	 mem_bytes(TYPE_VEC,x->max_dim*sizeof(Real),\n			 new_dim*sizeof(Real));\n      }\n\n      x->ve = RENEW(x->ve,new_dim,Real);\n      if ( ! x->ve )\n	error(E_MEM,"v_resize");\n      x->max_dim = new_dim;\n   }\n   \n   if ( new_dim > x->dim )\n     __zero__(&(x->ve[x->dim]),new_dim - x->dim);\n   x->dim = new_dim;\n   \n   return x;\n}\n\n\n\n\n/* Varying number of arguments */\n/* other functions of this type are in sparse.c and zmemory.c */\n\n\n\n#ifdef ANSI_C\n\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,NULL);\n   where \n     int dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     dim is the length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables\n     Other gec_... functions are similar.\n*/\n\nint v_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint iv_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   IVEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_get_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   MAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_get(m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint px_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   PERM **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n\nint v_resize_vars(int new_dim,...)\n{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint iv_resize_vars(int new_dim,...) \n{\n   va_list ap;\n   int i=0;\n   IVEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_resize_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   MAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint px_resize_vars(int new_dim,...) \n{\n   va_list ap;\n   int i=0;\n   PERM **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n\n\nint v_free_vars(VEC **pv,...)\n{\n   va_list ap;\n   int i=1;\n   VEC **par;\n   \n   v_free(*pv);\n   *pv = VNULL;\n   va_start(ap, pv);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      v_free(*par); \n      *par = VNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint iv_free_vars(IVEC **ipv,...)\n{\n   va_list ap;\n   int i=1;\n   IVEC **par;\n   \n   iv_free(*ipv);\n   *ipv = IVNULL;\n   va_start(ap, ipv);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      iv_free(*par); \n      *par = IVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint px_free_vars(PERM **vpx,...)\n{\n   va_list ap;\n   int i=1;\n   PERM **par;\n   \n   px_free(*vpx);\n   *vpx = PNULL;\n   va_start(ap, vpx);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      px_free(*par); \n      *par = PNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_free_vars(MAT **va,...)\n{\n   va_list ap;\n   int i=1;\n   MAT **par;\n   \n   m_free(*va);\n   *va = MNULL;\n   va_start(ap, va);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      m_free(*par); \n      *par = MNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#elif VARARGS\n/* old varargs is used */\n\n\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,VNULL);\n   where \n     int dim;\n     VEC *x, *y, *z,...;\n     The last argument should be VNULL ! \n     dim is the length of vectors x,y,z,...\n*/\n\nint v_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int dim,i=0;\n   VEC **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint iv_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, dim;\n   IVEC **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, n, m;\n   MAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_get(m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint px_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, dim;\n   PERM **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n\nint v_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   VEC **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint iv_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   IVEC **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n;\n   MAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint px_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   PERM **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n\n\nint v_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      v_free(*par); \n      *par = VNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint iv_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   IVEC **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      iv_free(*par); \n      *par = IVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint px_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   PERM **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      px_free(*par); \n      *par = PNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   MAT **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      m_free(*par); \n      *par = MNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n#endif /* VARARGS */\n  \n\n