\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n		Files for matrix computations\n\n	Householder transformation file. Contains routines for calculating\n	householder transformations, applying them to vectors and matrices\n	by both row & column.\n*/\n\n/* hsehldr.c 1.3 10/8/87 */\nstatic	char	rcsid[] = "$Id: hsehldr.c,v 1.2 1994/01/13 05:36:29 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n\n/* hhvec -- calulates Householder vector to eliminate all entries after the\n	i0 entry of the vector vec. It is returned as out. May be in-situ */\n#ifndef ANSI_C\nVEC	*hhvec(vec,i0,beta,out,newval)\nVEC	*vec,*out;\nunsigned int	i0;\nReal	*beta,*newval;\n#else\nVEC	*hhvec(const VEC *vec, unsigned int i0, Real *beta,\n	       VEC *out, Real *newval)\n#endif\n{\n	Real	norm;\n\n	out = _v_copy(vec,out,i0);\n	norm = sqrt(_in_prod(out,out,i0));\n	if ( norm <= 0.0 )\n	{\n		*beta = 0.0;\n		return (out);\n	}\n	*beta = 1.0/(norm * (norm+fabs(out->ve[i0])));\n	if ( out->ve[i0] > 0.0 )\n		*newval = -norm;\n	else\n		*newval = norm;\n	out->ve[i0] -= *newval;\n\n	return (out);\n}\n\n/* hhtrvec -- apply Householder transformation to vector \n	-- that is, out <- (I-beta.hh(i0:n).hh(i0:n)^T).in\n	-- may be in-situ */\n#ifndef ANSI_C\nVEC	*hhtrvec(hh,beta,i0,in,out)\nVEC	*hh,*in,*out;	/* hh = Householder vector */\nunsigned int	i0;\ndouble	beta;\n#else\nVEC	*hhtrvec(const VEC *hh, double beta, unsigned int i0,\n		 const VEC *in, VEC *out)\n#endif\n{\n	Real	scale;\n	/* unsigned int	i; */\n\n	if ( hh==VNULL || in==VNULL )\n		error(E_NULL,"hhtrvec");\n	if ( in->dim != hh->dim )\n		error(E_SIZES,"hhtrvec");\n	if ( i0 > in->dim )\n		error(E_BOUNDS,"hhtrvec");\n\n	scale = beta*_in_prod(hh,in,i0);\n	out = v_copy(in,out);\n	__mltadd__(&(out->ve[i0]),&(hh->ve[i0]),-scale,(int)(in->dim-i0));\n	/************************************************************\n	for ( i=i0; i<in->dim; i++ )\n		out->ve[i] = in->ve[i] - scale*hh->ve[i];\n	************************************************************/\n\n	return (out);\n}\n\n/* hhtrrows -- transform a matrix by a Householder vector by rows\n	starting at row i0 from column j0 -- in-situ\n	-- that is, M(i0:m,j0:n) <- M(i0:m,j0:n)(I-beta.hh(j0:n).hh(j0:n)^T) */\n#ifndef ANSI_C\nMAT	*hhtrrows(M,i0,j0,hh,beta)\nMAT	*M;\nunsigned int	i0, j0;\nVEC	*hh;\ndouble	beta;\n#else\nMAT	*hhtrrows(MAT *M, unsigned int i0, unsigned int j0,\n		  const VEC *hh, double beta)\n#endif\n{\n	Real	ip, scale;\n	int	i /*, j */;\n\n	if ( M==MNULL || hh==VNULL )\n		error(E_NULL,"hhtrrows");\n	if ( M->n != hh->dim )\n		error(E_RANGE,"hhtrrows");\n	if ( i0 > M->m || j0 > M->n )\n		error(E_BOUNDS,"hhtrrows");\n\n	if ( beta == 0.0 )	return (M);\n\n	/* for each row ... */\n	for ( i = i0; i < M->m; i++ )\n	{	/* compute inner product */\n		ip = __ip__(&(M->me[i][j0]),&(hh->ve[j0]),(int)(M->n-j0));\n		/**************************************************\n		ip = 0.0;\n		for ( j = j0; j < M->n; j++ )\n			ip += M->me[i][j]*hh->ve[j];\n		**************************************************/\n		scale = beta*ip;\n		if ( scale == 0.0 )\n		    continue;\n\n		/* do operation */\n		__mltadd__(&(M->me[i][j0]),&(hh->ve[j0]),-scale,\n							(int)(M->n-j0));\n		/**************************************************\n		for ( j = j0; j < M->n; j++ )\n			M->me[i][j] -= scale*hh->ve[j];\n		**************************************************/\n	}\n\n	return (M);\n}\n\n/* hhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- calls _hhtrcols() with the scratch vector w\n	-- Meschach internal routines should call _hhtrcols() to\n	avoid excessive memory allocation/de-allocation\n*/\n#ifndef ANSI_C\nMAT	*hhtrcols(M,i0,j0,hh,beta)\nMAT	*M;\nunsigned int	i0, j0;\nVEC	*hh;\ndouble	beta;\n#else\nMAT	*hhtrcols(MAT *M, unsigned int i0, unsigned int j0,\n		  const VEC *hh, double beta)\n#endif\n{\n  STATIC VEC	*w = VNULL;\n\n  if ( M == MNULL || hh == VNULL || w == VNULL )\n    error(E_NULL,"hhtrcols");\n  if ( M->m != hh->dim )\n    error(E_SIZES,"hhtrcols");\n  if ( i0 > M->m || j0 > M->n )\n    error(E_BOUNDS,"hhtrcols");\n\n  if ( ! w || w->dim < M->n )\n    w = v_resize(w,M->n);\n  MEM_STAT_REG(w,TYPE_VEC);\n\n  M = _hhtrcols(M,i0,j0,hh,beta,w);\n\n#ifdef THREADSAFE\n  V_FREE(w);\n#endif\n\n  return M;\n}\n\n/* _hhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- scratch vector w passed as argument\n	-- raises error if w == NULL\n*/\n#ifndef ANSI_C\nMAT	*_hhtrcols(M,i0,j0,hh,beta,w)\nMAT	*M;\nunsigned int	i0, j0;\nVEC	*hh;\ndouble	beta;\nVEC	*w;\n#else\nMAT	*_hhtrcols(MAT *M, unsigned int i0, unsigned int j0,\n		   const VEC *hh, double beta, VEC *w)\n#endif\n{\n	/* Real	ip, scale; */\n	int	i /*, k */;\n	/*  STATIC	VEC	*w = VNULL; */\n\n	if ( M == MNULL || hh == VNULL || w == VNULL )\n		error(E_NULL,"_hhtrcols");\n	if ( M->m != hh->dim )\n		error(E_SIZES,"_hhtrcols");\n	if ( i0 > M->m || j0 > M->n )\n		error(E_BOUNDS,"_hhtrcols");\n\n	if ( beta == 0.0 )	return (M);\n\n	if ( w->dim < M->n )\n	  w = v_resize(w,M->n);\n	/*  MEM_STAT_REG(w,TYPE_VEC); */\n	v_zero(w);\n\n	for ( i = i0; i < M->m; i++ )\n	    if ( hh->ve[i] != 0.0 )\n		__mltadd__(&(w->ve[j0]),&(M->me[i][j0]),hh->ve[i],\n							(int)(M->n-j0));\n	for ( i = i0; i < M->m; i++ )\n	    if ( hh->ve[i] != 0.0 )\n		__mltadd__(&(M->me[i][j0]),&(w->ve[j0]),-beta*hh->ve[i],\n							(int)(M->n-j0));\n	return (M);\n}\n\n