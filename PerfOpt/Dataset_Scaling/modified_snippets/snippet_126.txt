\n\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* iter.c 17/09/93 */\n\n/* \n  ITERATIVE METHODS - implementation of several iterative methods;\n  see also iter0.c\n*/\n\n#include        <stdio.h>\n#include	<math.h>\n#include        "matrix.h"\n#include        "matrix2.h"\n#include	"sparse.h"\n#include        "iter.h"\n\nstatic char rcsid[] = "$Header: iternsym.c,v 1.6 1995/01/30 14:53:01 des Exp $";\n\n\n#ifdef ANSI_C\nVEC	*spCHsolve(SPMAT *,VEC *,VEC *);\n#else\nVEC	*spCHsolve();\n#endif\n\n\n/* \n  iter_cgs -- uses CGS to compute a solution x to A.x=b\n*/\n#ifndef ANSI_C\nVEC	*iter_cgs(ip,r0)\nITER *ip;\nVEC *r0;\n#else\nVEC	*iter_cgs(ITER *ip, VEC *r0)\n#endif\n{\n   STATIC VEC  *p = VNULL, *q = VNULL, *r = VNULL, *u = VNULL;\n   STATIC VEC  *v = VNULL, *z = VNULL;\n   VEC  *tmp;\n   Real	alpha, beta, nres, rho, old_rho, sigma, inner;\n\n   if (ip == INULL)\n     error(E_NULL,"iter_cgs");\n   if (!ip->Ax || !ip->b || !r0)\n     error(E_NULL,"iter_cgs");\n   if ( ip->x == ip->b )\n     error(E_INSITU,"iter_cgs");\n   if (!ip->stop_crit)\n     error(E_NULL,"iter_cgs");\n   if ( r0->dim != ip->b->dim )\n     error(E_SIZES,"iter_cgs");\n   \n   if ( ip->eps <= 0.0 ) ip->eps = MACHEPS;\n   \n   p = v_resize(p,ip->b->dim);\n   q = v_resize(q,ip->b->dim);\n   r = v_resize(r,ip->b->dim);\n   u = v_resize(u,ip->b->dim);\n   v = v_resize(v,ip->b->dim);\n\n   MEM_STAT_REG(p,TYPE_VEC);\n   MEM_STAT_REG(q,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(v,TYPE_VEC);\n\n   if (ip->Bx) {\n      z = v_resize(z,ip->b->dim);\n      MEM_STAT_REG(z,TYPE_VEC); \n   }\n\n   if (ip->x != VNULL) {\n      if (ip->x->dim != ip->b->dim)\n	error(E_SIZES,"iter_cgs");\n      ip->Ax(ip->A_par,ip->x,v);    		/* v = A*x */\n      if (ip->Bx) {\n	 v_sub(ip->b,v,v);			/* v = b - A*x */\n	 (ip->Bx)(ip->B_par,v,r);		/* r = B*(b-A*x) */\n      }\n      else v_sub(ip->b,v,r);			/* r = b-A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);		/* x == 0 */\n      ip->shared_x = FALSE;\n      if (ip->Bx) (ip->Bx)(ip->B_par,ip->b,r);    /* r = B*b */\n      else v_copy(ip->b,r);                       /* r = b */\n   }\n\n   v_zero(p);	\n   v_zero(q);\n   old_rho = 1.0;\n   \n   for (ip->steps = 0; ip->steps <= ip->limit; ip->steps++) {\n\n      inner = in_prod(r,r);\n      nres = sqrt(fabs(inner));\n      if (ip->steps == 0) ip->init_res = nres;\n\n      if (ip->info) ip->info(ip,nres,r,VNULL);\n      if ( ip->stop_crit(ip,nres,r,VNULL) ) break;\n\n      rho = in_prod(r0,r);\n      if ( old_rho == 0.0 )\n	error(E_BREAKDOWN,"iter_cgs");\n      beta = rho/old_rho;\n      v_mltadd(r,q,beta,u);\n      v_mltadd(q,p,beta,v);\n      v_mltadd(u,v,beta,p);\n      \n      (ip->Ax)(ip->A_par,p,q);\n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,q,z);\n	 tmp = z;\n      }\n      else tmp = q;\n      \n      sigma = in_prod(r0,tmp);\n      if ( sigma == 0.0 )\n	error(E_BREAKDOWN,"iter_cgs");\n      alpha = rho/sigma;\n      v_mltadd(u,tmp,-alpha,q);\n      v_add(u,q,v);\n      \n      (ip->Ax)(ip->A_par,v,u);\n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,u,z);\n	 tmp = z;\n      }\n      else tmp = u;\n      \n      v_mltadd(r,tmp,-alpha,r);\n      v_mltadd(ip->x,v,alpha,ip->x);\n      \n      old_rho = rho;\n   }\n\n#ifdef THREADSAFE\n   V_FREE(p);	V_FREE(q);	V_FREE(r);	V_FREE(u);\n   V_FREE(v);	V_FREE(z);\n#endif\n\n   return ip->x;\n}\n\n\n\n/* iter_spcgs -- simple interface for SPMAT data structures \n   use always as follows:\n      x = iter_spcgs(A,B,b,r0,tol,x,limit,steps);\n   or \n      x = iter_spcgs(A,B,b,r0,tol,VNULL,limit,steps);\n   In the second case the solution vector is created.  \n   If B is not NULL then it is a preconditioner. \n*/\n#ifndef ANSI_C\nVEC	*iter_spcgs(A,B,b,r0,tol,x,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *r0, *x;\ndouble	tol;\nint     *steps,limit;\n#else\nVEC	*iter_spcgs(SPMAT *A, SPMAT *B, VEC *b, VEC *r0, double tol,\n		    VEC *x, int limit, int *steps)\n#endif\n{	\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *) B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n   ip->info = (Fun_info) NULL;\n   ip->limit = limit;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_cgs(ip,r0);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;   \n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n\n}\n\n/*\n  Routine for performing LSQR -- the least squares QR algorithm\n  of Paige and Saunders:\n  "LSQR: an algorithm for sparse linear equations and\n  sparse least squares", ACM Trans. Math. Soft., v. 8\n  pp. 43--71 (1982)\n  */\n/* iter_lsqr -- sparse CG-like least squares routine:\n   -- finds min_x ||A.x-b||_2 using A defined through A & AT\n   -- returns x (if x != NULL) */\n#ifndef ANSI_C\nVEC	*iter_lsqr(ip)\nITER *ip;\n#else\nVEC	*iter_lsqr(ITER *ip)\n#endif\n{\n   STATIC VEC	*u = VNULL, *v = VNULL, *w = VNULL, *tmp = VNULL;\n   Real	alpha, beta, phi, phi_bar;\n   Real rho, rho_bar, rho_max, theta, nres;\n   Real	s, c;	/* for Givens' rotations */\n   int  m, n;\n   \n   if ( ! ip || ! ip->b || !ip->Ax || !ip->ATx )\n     error(E_NULL,"iter_lsqr");\n   if ( ip->x == ip->b )\n     error(E_INSITU,"iter_lsqr");\n   if (!ip->stop_crit || !ip->x)\n     error(E_NULL,"iter_lsqr");\n\n   if ( ip->eps <= 0.0 ) ip->eps = MACHEPS;\n   \n   m = ip->b->dim;	\n   n = ip->x->dim;\n\n   u = v_resize(u,(unsigned int)m);\n   v = v_resize(v,(unsigned int)n);\n   w = v_resize(w,(unsigned int)n);\n   tmp = v_resize(tmp,(unsigned int)n);\n\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(v,TYPE_VEC);\n   MEM_STAT_REG(w,TYPE_VEC);\n   MEM_STAT_REG(tmp,TYPE_VEC);  \n\n   if (ip->x != VNULL) {\n      ip->Ax(ip->A_par,ip->x,u);    		/* u = A*x */\n      v_sub(ip->b,u,u);				/* u = b-A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n      v_copy(ip->b,u);                       /* u = b */\n   }\n \n   beta = v_norm2(u); \n   if ( beta == 0.0 ) return ip->x;\n\n   sv_mlt(1.0/beta,u,u);\n   (ip->ATx)(ip->AT_par,u,v);\n   alpha = v_norm2(v);\n   if ( alpha == 0.0 ) return ip->x;\n\n   sv_mlt(1.0/alpha,v,v);\n   v_copy(v,w);\n   phi_bar = beta;\n   rho_bar = alpha;\n   \n   rho_max = 1.0;\n   for (ip->steps = 0; ip->steps <= ip->limit; ip->steps++) {\n\n      tmp = v_resize(tmp,m);\n      (ip->Ax)(ip->A_par,v,tmp);\n      \n      v_mltadd(tmp,u,-alpha,u);\n      beta = v_norm2(u);	\n      sv_mlt(1.0/beta,u,u);\n      \n      tmp = v_resize(tmp,n);\n      (ip->ATx)(ip->AT_par,u,tmp);\n      v_mltadd(tmp,v,-beta,v);\n      alpha = v_norm2(v);	\n      sv_mlt(1.0/alpha,v,v);\n      \n      rho = sqrt(rho_bar*rho_bar+beta*beta);\n      if ( rho > rho_max )\n	rho_max = rho;\n      c   = rho_bar/rho;\n      s   = beta/rho;\n      theta   =  s*alpha;\n      rho_bar = -c*alpha;\n      phi     =  c*phi_bar;\n      phi_bar =  s*phi_bar;\n      \n      /* update ip->x & w */\n      if ( rho == 0.0 )\n	error(E_BREAKDOWN,"iter_lsqr");\n      v_mltadd(ip->x,w,phi/rho,ip->x);\n      v_mltadd(v,w,-theta/rho,w);\n\n      nres = fabs(phi_bar*alpha*c)*rho_max;\n\n      if (ip->info) ip->info(ip,nres,w,VNULL);\n      if (ip->steps == 0) ip->init_res = nres;\n      if ( ip->stop_crit(ip,nres,w,VNULL) ) break;\n   } \n\n#ifdef THREADSAFE\n   V_FREE(u);	V_FREE(v);	V_FREE(w);	V_FREE(tmp);\n#endif\n\n   return ip->x;\n}\n\n/* iter_splsqr -- simple interface for SPMAT data structures */\n#ifndef ANSI_C\nVEC	*iter_splsqr(A,b,tol,x,limit,steps)\nSPMAT	*A;\nVEC	*b, *x;\ndouble	tol;\nint *steps,limit;\n#else\nVEC	*iter_splsqr(SPMAT *A, VEC *b, double tol, \n		     VEC *x, int limit, int *steps)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   ip->ATx = (Fun_Ax) sp_vm_mlt;\n   ip->AT_par = (void *) A;\n   ip->Bx = (Fun_Ax) NULL;\n   ip->B_par = NULL;\n\n   ip->info = (Fun_info) NULL;\n   ip->limit = limit;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_lsqr(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n\n/* iter_arnoldi -- an implementation of the Arnoldi method;\n   iterative refinement is applied.\n*/\n#ifndef ANSI_C\nMAT	*iter_arnoldi_iref(ip,h_rem,Q,H)\nITER  *ip;\nReal  *h_rem;\nMAT   *Q, *H;\n#else\nMAT	*iter_arnoldi_iref(ITER *ip, Real *h_rem, MAT *Q, MAT *H)\n#endif\n{\n   STATIC VEC *u=VNULL, *r=VNULL, *s=VNULL, *tmp=VNULL;\n   VEC v;     /* auxiliary vector */\n   int	i,j;\n   Real	h_val, c;\n   \n   if (ip == INULL)\n     error(E_NULL,"iter_arnoldi_iref");\n   if ( ! ip->Ax || ! Q || ! ip->x )\n     error(E_NULL,"iter_arnoldi_iref");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,"iter_arnoldi_iref");\n   if ( Q->n != ip->x->dim ||	Q->m != ip->k )\n     error(E_SIZES,"iter_arnoldi_iref");\n   \n   m_zero(Q);\n   H = m_resize(H,ip->k,ip->k);\n   m_zero(H);\n\n   u = v_resize(u,ip->x->dim);\n   r = v_resize(r,ip->k);\n   s = v_resize(s,ip->k);\n   tmp = v_resize(tmp,ip->x->dim);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(s,TYPE_VEC);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n\n   v.dim = v.max_dim = ip->x->dim;\n\n   c = v_norm2(ip->x);\n   if ( c <= 0.0)\n     return H;\n   else {\n      v.ve = Q->me[0];\n      sv_mlt(1.0/c,ip->x,&v);\n   }\n\n   v_zero(r);\n   v_zero(s);\n   for ( i = 0; i < ip->k; i++ )\n   {\n      v.ve = Q->me[i];\n      u = (ip->Ax)(ip->A_par,&v,u);\n      for (j = 0; j <= i; j++) {\n	 v.ve = Q->me[j];\n	 /* modified Gram-Schmidt */\n	 r->ve[j] = in_prod(&v,u);\n	 v_mltadd(u,&v,-r->ve[j],u);\n      }\n      h_val = v_norm2(u);\n      /* if u == 0 then we have an exact subspace */\n      if ( h_val <= 0.0 )\n      {\n	 *h_rem = h_val;\n	 return H;\n      }\n      /* iterative refinement -- ensures near orthogonality */\n      do {\n	 v_zero(tmp);\n	 for (j = 0; j <= i; j++) {\n	    v.ve = Q->me[j];\n	    s->ve[j] = in_prod(&v,u);\n	    v_mltadd(tmp,&v,s->ve[j],tmp);\n	 }\n	 v_sub(u,tmp,u);\n         v_add(r,s,r);\n      } while ( v_norm2(s) > 0.1*(h_val = v_norm2(u)) );\n      /* now that u is nearly orthogonal to Q, update H */\n      set_col(H,i,r);\n      /* check once again if h_val is zero */\n      if ( h_val <= 0.0 )\n      {\n	 *h_rem = h_val;\n	 return H;\n      }\n      if ( i == ip->k-1 )\n      {\n	 *h_rem = h_val;\n	 continue;\n      }\n      /* H->me[i+1][i] = h_val; */\n      m_set_val(H,i+1,i,h_val);\n      v.ve = Q->me[i+1];\n      sv_mlt(1.0/h_val,u,&v);\n   }\n\n#ifdef THREADSAFE\n   V_FREE(u);   V_FREE(r);   V_FREE(s);   V_FREE(tmp);\n#endif\n\n   return H;\n}\n\n/* iter_arnoldi -- an implementation of the Arnoldi method;\n   modified Gram-Schmidt algorithm\n*/\n#ifndef ANSI_C\nMAT	*iter_arnoldi(ip,h_rem,Q,H)\nITER  *ip;\nReal  *h_rem;\nMAT   *Q, *H;\n#else\nMAT	*iter_arnoldi(ITER *ip, Real *h_rem, MAT *Q, MAT *H)\n#endif\n{\n   STATIC VEC *u=VNULL, *r=VNULL;\n   VEC v;     /* auxiliary vector */\n   int	i,j;\n   Real	h_val, c;\n   \n   if (ip == INULL)\n     error(E_NULL,"iter_arnoldi");\n   if ( ! ip->Ax || ! Q || ! ip->x )\n     error(E_NULL,"iter_arnoldi");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,"iter_arnoldi");\n   if ( Q->n != ip->x->dim ||	Q->m != ip->k )\n     error(E_SIZES,"iter_arnoldi");\n   \n   m_zero(Q);\n   H = m_resize(H,ip->k,ip->k);\n   m_zero(H);\n\n   u = v_resize(u,ip->x->dim);\n   r = v_resize(r,ip->k);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_VEC);\n\n   v.dim = v.max_dim = ip->x->dim;\n\n   c = v_norm2(ip->x);\n   if ( c <= 0.0)\n     return H;\n   else {\n      v.ve = Q->me[0];\n      sv_mlt(1.0/c,ip->x,&v);\n   }\n\n   v_zero(r);\n   for ( i = 0; i < ip->k; i++ )\n   {\n      v.ve = Q->me[i];\n      u = (ip->Ax)(ip->A_par,&v,u);\n      for (j = 0; j <= i; j++) {\n	 v.ve = Q->me[j];\n	 /* modified Gram-Schmidt */\n	 r->ve[j] = in_prod(&v,u);\n	 v_mltadd(u,&v,-r->ve[j],u);\n      }\n      h_val = v_norm2(u);\n      /* if u == 0 then we have an exact subspace */\n      if ( h_val <= 0.0 )\n      {\n	 *h_rem = h_val;\n	 return H;\n      }\n      set_col(H,i,r);\n      if ( i == ip->k-1 )\n      {\n	 *h_rem = h_val;\n	 continue;\n      }\n      /* H->me[i+1][i] = h_val; */\n      m_set_val(H,i+1,i,h_val);\n      v.ve = Q->me[i+1];\n      sv_mlt(1.0/h_val,u,&v);\n   }\n\n#ifdef THREADSAFE\n   V_FREE(u);	V_FREE(r);\n#endif\n   \n   return H;\n}\n\n\n\n/* iter_sparnoldi -- uses arnoldi() with an explicit representation of A */\n#ifndef ANSI_C\nMAT	*iter_sparnoldi(A,x0,m,h_rem,Q,H)\nSPMAT	*A;\nVEC	*x0;\nint	m;\nReal	*h_rem;\nMAT	*Q, *H;\n#else\nMAT	*iter_sparnoldi(SPMAT *A, VEC *x0, int m, Real *h_rem, MAT *Q, MAT *H)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   ip->x = x0;\n   ip->k = m;\n   iter_arnoldi_iref(ip,h_rem,Q,H);\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return H;	\n}\n\n\n/* for testing gmres */\n#ifndef ANSI_C\nstatic void test_gmres(ip,i,Q,R,givc,givs,h_val)\nITER *ip;\nint i;\nMAT *Q, *R;\nVEC *givc, *givs;\ndouble h_val;\n#else\nstatic void test_gmres(ITER *ip, int i, MAT *Q, MAT *R,\n		       VEC *givc, VEC *givs, double h_val)\n#endif\n{\n   VEC vt, vt1;\n   STATIC MAT *Q1=MNULL, *R1=MNULL;\n   int j;\n   \n   /* test Q*A*Q^T = R  */\n\n   Q = m_resize(Q,i+1,ip->b->dim);\n   Q1 = m_resize(Q1,i+1,ip->b->dim);\n   R1 = m_resize(R1,i+1,i+1);\n   MEM_STAT_REG(Q1,TYPE_MAT);\n   MEM_STAT_REG(R1,TYPE_MAT);\n\n   vt.dim = vt.max_dim = ip->b->dim;\n   vt1.dim = vt1.max_dim = ip->b->dim;\n   for (j=0; j <= i; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      ip->Ax(ip->A_par,&vt,&vt1);\n   }\n\n   mmtr_mlt(Q,Q1,R1);\n   R1 = m_resize(R1,i+2,i+1);\n   for (j=0; j < i; j++)\n     R1->me[i+1][j] = 0.0;\n   R1->me[i+1][i] = h_val;\n   \n   for (j = 0; j <= i; j++) {\n      rot_rows(R1,j,j+1,givc->ve[j],givs->ve[j],R1);\n   }\n\n   R1 = m_resize(R1,i+1,i+1);\n   m_sub(R,R1,R1);\n   /* if (m_norm_inf(R1) > MACHEPS*ip->b->dim)  */\n#ifndef MEX\n   printf(" %d. ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n",\n	  ip->steps,m_norm_inf(R1),MACHEPS);\n#endif\n   \n   /* check Q*Q^T = I */\n   \n   Q = m_resize(Q,i+1,ip->b->dim);\n   mmtr_mlt(Q,Q,R1);\n   for (j=0; j <= i; j++)\n     R1->me[j][j] -= 1.0;\n#ifndef MEX\n   if (m_norm_inf(R1) > MACHEPS*ip->b->dim)\n     printf(" ! m_norm_inf(Q*Q^T) = %g\n",m_norm_inf(R1));  \n#endif\n#ifdef THREADSAFE\n   M_FREE(Q1);	M_FREE(R1);\n#endif\n}\n\n\n/* gmres -- generalised minimum residual algorithm of Saad & Schultz\n   SIAM J. Sci. Stat. Comp. v.7, pp.856--869 (1986)\n*/\n#ifndef ANSI_C\nVEC	*iter_gmres(ip)\nITER *ip;\n#else\nVEC	*iter_gmres(ITER *ip)\n#endif\n{\n   STATIC VEC *u=VNULL, *r=VNULL, *rhs = VNULL;\n   STATIC VEC *givs=VNULL, *givc=VNULL, *z = VNULL;\n   STATIC MAT *Q = MNULL, *R = MNULL;\n   VEC *rr, v, v1;   /* additional pointers (not real vectors) */\n   int	i,j, done;\n   Real	nres;\n/*   Real last_h;  */\n   \n   if (ip == INULL)\n     error(E_NULL,"iter_gmres");\n   if ( ! ip->Ax || ! ip->b )\n     error(E_NULL,"iter_gmres");\n   if ( ! ip->stop_crit )\n     error(E_NULL,"iter_gmres");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,"iter_gmres");\n   if (ip->x != VNULL && ip->x->dim != ip->b->dim)\n     error(E_SIZES,"iter_gmres");\n   if (ip->eps <= 0.0) ip->eps = MACHEPS;\n\n   r = v_resize(r,ip->k+1);\n   u = v_resize(u,ip->b->dim);\n   rhs = v_resize(rhs,ip->k+1);\n   givs = v_resize(givs,ip->k);  /* Givens rotations */\n   givc = v_resize(givc,ip->k); \n   \n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(rhs,TYPE_VEC);\n   MEM_STAT_REG(givs,TYPE_VEC);\n   MEM_STAT_REG(givc,TYPE_VEC);\n   \n   R = m_resize(R,ip->k+1,ip->k);\n   Q = m_resize(Q,ip->k,ip->b->dim);\n   MEM_STAT_REG(R,TYPE_MAT);\n   MEM_STAT_REG(Q,TYPE_MAT);		\n\n   if (ip->x == VNULL) {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n   }   \n\n   v.dim = v.max_dim = ip->b->dim;      /* v and v1 are pointers to rows */\n   v1.dim = v1.max_dim = ip->b->dim;  	/* of matrix Q */\n   \n   if (ip->Bx != (Fun_Ax)NULL) {    /* if precondition is defined */\n      z = v_resize(z,ip->b->dim);\n      MEM_STAT_REG(z,TYPE_VEC);\n   }\n   \n   done = FALSE;\n   for (ip->steps = 0; ip->steps < ip->limit; ) {\n\n      /* restart */\n\n      ip->Ax(ip->A_par,ip->x,u);    		/* u = A*x */\n      v_sub(ip->b,u,u);		 		/* u = b - A*x */\n      rr = u;				/* rr is a pointer only */\n      \n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,u,z);            /* tmp = B*(b-A*x)  */\n	 rr = z;\n      }\n      \n      nres = v_norm2(rr);\n      if (ip->steps == 0) {\n	 if (ip->info) ip->info(ip,nres,VNULL,VNULL);\n	 ip->init_res = nres;\n      }\n\n      if ( nres == 0.0 ) {\n	 done = TRUE;\n	 break;\n      }\n\n      v.ve = Q->me[0];\n      sv_mlt(1.0/nres,rr,&v);\n      \n      v_zero(r);\n      v_zero(rhs);\n      rhs->ve[0] = nres;\n\n      for ( i = 0; i < ip->k && ip->steps < ip->limit; i++ ) {\n	 ip->steps++;\n	 v.ve = Q->me[i];	\n	 (ip->Ax)(ip->A_par,&v,u);\n	 rr = u;\n	 if (ip->Bx) {\n	    (ip->Bx)(ip->B_par,u,z);\n	    rr = z;\n	 }\n	 \n	 if (i < ip->k - 1) {\n	    v1.ve = Q->me[i+1];\n	    v_copy(rr,&v1);\n	    for (j = 0; j <= i; j++) {\n	       v.ve = Q->me[j];\n	       /* r->ve[j] = in_prod(&v,rr); */\n	       /* modified Gram-Schmidt algorithm */\n	       r->ve[j] = in_prod(&v,&v1);\n	       v_mltadd(&v1,&v,-r->ve[j],&v1);\n	    }\n	    \n	    r->ve[i+1] = nres = v_norm2(&v1);\n	    if (nres <= MACHEPS*ip->init_res) {\n	       for (j = 0; j < i; j++) \n		 rot_vec(r,j,j+1,givc->ve[j],givs->ve[j],r);\n	       set_col(R,i,r);\n	       done = TRUE;\n	       break;\n	    }\n	    sv_mlt(1.0/nres,&v1,&v1);\n	 }\n	 else {  /* i == ip->k - 1 */\n	    /* Q->me[ip->k] need not be computed */\n\n	    for (j = 0; j <= i; j++) {\n	       v.ve = Q->me[j];\n	       r->ve[j] = in_prod(&v,rr);\n	    }\n	    \n	    nres = in_prod(rr,rr) - in_prod(r,r);\n	    if (sqrt(fabs(nres)) <= MACHEPS*ip->init_res) { \n	       for (j = 0; j < i; j++) \n		 rot_vec(r,j,j+1,givc->ve[j],givs->ve[j],r);\n	       set_col(R,i,r);\n	       done = TRUE;\n	       break;\n	    }\n	    if (nres < 0.0) { /* do restart */\n	       i--; \n	       ip->steps--;\n	       break;\n	    } \n	    r->ve[i+1] = sqrt(nres);\n	 }\n\n	 /* QR update */\n\n	 /* last_h = r->ve[i+1]; */ /* for test only */\n	 for (j = 0; j < i; j++) \n	   rot_vec(r,j,j+1,givc->ve[j],givs->ve[j],r);\n	 givens(r->ve[i],r->ve[i+1],&givc->ve[i],&givs->ve[i]);\n	 rot_vec(r,i,i+1,givc->ve[i],givs->ve[i],r);\n	 rot_vec(rhs,i,i+1,givc->ve[i],givs->ve[i],rhs);\n	 \n	 set_col(R,i,r);\n\n	 nres = fabs((double) rhs->ve[i+1]);\n	 if (ip->info) ip->info(ip,nres,VNULL,VNULL);\n	 if ( ip->stop_crit(ip,nres,VNULL,VNULL) ) {\n	    done = TRUE;\n	    break;\n	 }\n      }\n      \n      /* use ixi submatrix of R */\n\n      if (i >= ip->k) i = ip->k - 1;\n\n      R = m_resize(R,i+1,i+1);\n      rhs = v_resize(rhs,i+1);\n      \n      /* test only */\n      /* test_gmres(ip,i,Q,R,givc,givs,last_h);  */\n      \n      Usolve(R,rhs,rhs,0.0); 	 /* solve a system: R*x = rhs */\n\n      /* new approximation */\n\n      for (j = 0; j <= i; j++) {\n	 v.ve = Q->me[j]; \n	 v_mltadd(ip->x,&v,rhs->ve[j],ip->x);\n      }\n\n      if (done) break;\n\n      /* back to old dimensions */\n\n      rhs = v_resize(rhs,ip->k+1);\n      R = m_resize(R,ip->k+1,ip->k);\n\n   }\n\n#ifdef THREADSAFE\n   V_FREE(u);		V_FREE(r);	V_FREE(rhs);\n   V_FREE(givs);	V_FREE(givc);	V_FREE(z);\n   M_FREE(Q);		M_FREE(R);\n#endif\n\n   return ip->x;\n}\n\n/* iter_spgmres - a simple interface to iter_gmres */\n#ifndef ANSI_C\nVEC	*iter_spgmres(A,B,b,tol,x,k,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *x;\ndouble	tol;\nint *steps,k,limit;\n#else\nVEC	*iter_spgmres(SPMAT *A, SPMAT *B, VEC *b, double tol,\n		      VEC *x, int k, int limit, int *steps)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *) B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n   ip->k = k;\n   ip->limit = limit;\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_gmres(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n/* for testing mgcr */\n#ifndef ANSI_C\nstatic void test_mgcr(ip,i,Q,R)\nITER *ip;\nint i;\nMAT *Q, *R;\n#else\nstatic void test_mgcr(ITER *ip, int i, MAT *Q, MAT *R)\n#endif\n{\n   VEC vt, vt1;\n   static MAT *R1=MNULL;\n   static VEC *r=VNULL, *r1=VNULL;\n   VEC *rr;\n   int k,j;\n   Real sm;\n   \n   \n   /* check Q*Q^T = I */\n   vt.dim = vt.max_dim = ip->b->dim;\n   vt1.dim = vt1.max_dim = ip->b->dim;\n   \n   Q = m_resize(Q,i+1,ip->b->dim);\n   R1 = m_resize(R1,i+1,i+1);\n   r = v_resize(r,ip->b->dim);\n   r1 = v_resize(r1,ip->b->dim);\n   MEM_STAT_REG(R1,TYPE_MAT);\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(r1,TYPE_VEC);\n\n   m_zero(R1);\n   for (k=1; k <= i; k++)\n     for (j=1; j <= i; j++) {\n	vt.ve = Q->me[k];\n	vt1.ve = Q->me[j];\n	R1->me[k][j] = in_prod(&vt,&vt1);\n     }\n   for (j=1; j <= i; j++)\n     R1->me[j][j] -= 1.0;\n#ifndef MEX\n   if (m_norm_inf(R1) > MACHEPS*ip->b->dim)\n     printf(" ! (mgcr:) m_norm_inf(Q*Q^T) = %g\n",m_norm_inf(R1));  \n#endif\n\n   /* check (r_i,Ap_j) = 0 for j <= i */\n   \n   ip->Ax(ip->A_par,ip->x,r);\n   v_sub(ip->b,r,r);\n   rr = r;\n   if (ip->Bx) {\n      ip->Bx(ip->B_par,r,r1);\n      rr = r1;\n   }\n   \n#ifndef MEX\n   printf(" ||r|| = %g\n",v_norm2(rr));\n#endif\n   sm = 0.0;\n   for (j = 1; j <= i; j++) {\n      vt.ve = Q->me[j];\n      sm = max(sm,in_prod(&vt,rr));\n   }\n#ifndef MEX\n   if (sm >= MACHEPS*ip->b->dim)\n     printf(" ! (mgcr:) max_j (r,Ap_j) = %g\n",sm);\n#endif\n\n}\n\n\n\n\n/* \n  iter_mgcr -- modified generalized conjugate residual algorithm;\n  fast version of GCR;\n*/\n#ifndef ANSI_C\nVEC *iter_mgcr(ip)\nITER *ip;\n#else\nVEC *iter_mgcr(ITER *ip)\n#endif\n{\n   STATIC VEC *As=VNULL, *beta=VNULL, *alpha=VNULL, *z=VNULL;\n   STATIC MAT *N=MNULL, *H=MNULL;\n   \n   VEC *rr, v, s;  /* additional pointer and structures */\n   Real nres;      /* norm of a residual */\n   Real dd;        /* coefficient d_i */\n   int i,j;\n   int done;      /* if TRUE then stop the iterative process */\n   int dim;       /* dimension of the problem */\n   \n   /* ip cannot be NULL */\n   if (ip == INULL) error(E_NULL,"mgcr");\n   /* Ax, b and stopping criterion must be given */\n   if (! ip->Ax || ! ip->b || ! ip->stop_crit) \n     error(E_NULL,"mgcr");\n   /* at least one direction vector must exist */\n   if ( ip->k <= 0) error(E_BOUNDS,"mgcr");\n   /* if the vector x is given then b and x must have the same dimension */\n   if ( ip->x && ip->x->dim != ip->b->dim)\n     error(E_SIZES,"mgcr");\n   if (ip->eps <= 0.0) ip->eps = MACHEPS;\n   \n   dim = ip->b->dim;\n   As = v_resize(As,dim);\n   alpha = v_resize(alpha,ip->k);\n   beta = v_resize(beta,ip->k);\n   \n   MEM_STAT_REG(As,TYPE_VEC);\n   MEM_STAT_REG(alpha,TYPE_VEC);\n   MEM_STAT_REG(beta,TYPE_VEC);\n   \n   H = m_resize(H,ip->k,ip->k);\n   N = m_resize(N,ip->k,dim);\n   \n   MEM_STAT_REG(H,TYPE_MAT);\n   MEM_STAT_REG(N,TYPE_MAT);\n   \n   /* if a preconditioner is defined */\n   if (ip->Bx) {\n      z = v_resize(z,dim);\n      MEM_STAT_REG(z,TYPE_VEC);\n   }\n   \n   /* if x is NULL then it is assumed that x has \n      entries with value zero */\n   if ( ! ip->x ) {\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n   }\n   \n   /* v and s are additional pointers to rows of N */\n   /* they must have the same dimension as rows of N */\n   v.dim = v.max_dim = s.dim = s.max_dim = dim;\n   \n   \n   done = FALSE;\n   for (ip->steps = 0; ip->steps < ip->limit; ) {\n      (*ip->Ax)(ip->A_par,ip->x,As);         /* As = A*x */\n      v_sub(ip->b,As,As);                    /* As = b - A*x */\n      rr = As;                               /* rr is an additional pointer */\n      \n      /* if a preconditioner is defined */\n      if (ip->Bx) {\n	 (*ip->Bx)(ip->B_par,As,z);               /* z = B*(b-A*x)  */\n	 rr = z;                                  \n      }\n      \n      /* norm of the residual */\n      nres = v_norm2(rr);\n      dd = nres;                            /* dd = ||r_i||  */\n      \n      /* check if the norm of the residual is zero */\n      if (ip->steps == 0) {                \n	 /* information for a user */\n	 if (ip->info) (*ip->info)(ip,nres,As,rr); \n	 ip->init_res = fabs(nres);\n      }\n\n      if (nres == 0.0) { \n	 /* iterative process is finished */\n	 done = TRUE; \n	 break;\n      }\n      \n      /* save this residual in the first row of N */\n      v.ve = N->me[0];\n      v_copy(rr,&v);\n      \n      for (i = 0; i < ip->k && ip->steps < ip->limit; i++) {\n	 ip->steps++;\n	 v.ve = N->me[i];                /* pointer to a row of N (=s_i) */\n	 /* note that we must use here &v, not v */\n	 (*ip->Ax)(ip->A_par,&v,As); \n	 rr = As;                        /* As = A*s_i */\n	 if (ip->Bx) {\n	    (*ip->Bx)(ip->B_par,As,z);    /* z = B*A*s_i  */\n	    rr = z;\n	 }\n	 \n	 if (i < ip->k - 1) {\n	    s.ve = N->me[i+1];         /* pointer to a row of N (=s_{i+1}) */\n	    v_copy(rr,&s);                   /* s_{i+1} = B*A*s_i */\n	    for (j = 0; j <= i-1; j++) {\n	       v.ve = N->me[j+1];      /* pointer to a row of N (=s_{j+1}) */\n	       /* beta->ve[j] = in_prod(&v,rr); */      /* beta_{j,i} */\n	       /* modified Gram-Schmidt algorithm */\n	       beta->ve[j] = in_prod(&v,&s);  	         /* beta_{j,i} */\n	                                 /* s_{i+1} -= beta_{j,i}*s_{j+1} */\n	       v_mltadd(&s,&v,- beta->ve[j],&s);    \n	    }\n	    \n	     /* beta_{i,i} = ||s_{i+1}||_2 */\n	    beta->ve[i] = nres = v_norm2(&s);     \n	    if ( nres <= MACHEPS*ip->init_res) { \n	       /* s_{i+1} == 0 */\n	       i--;\n	       done = TRUE;\n	       break;\n	    }\n	    sv_mlt(1.0/nres,&s,&s);           /* normalize s_{i+1} */\n	    \n	    v.ve = N->me[0];\n	    alpha->ve[i] = in_prod(&v,&s);     /* alpha_i = (s_0 , s_{i+1}) */\n	    \n	 }\n	 else {\n	    for (j = 0; j <= i-1; j++) {\n	       v.ve = N->me[j+1];      /* pointer to a row of N (=s_{j+1}) */\n	       beta->ve[j] = in_prod(&v,rr);       /* beta_{j,i} */\n	    }\n	    \n	    nres = in_prod(rr,rr);                 /* rr = B*A*s_{k-1} */\n	    for (j = 0; j <= i-1; j++)\n              nres -= beta->ve[j]*beta->ve[j];\n\n	    if (sqrt(fabs(nres)) <= MACHEPS*ip->init_res)  {\n	       /* s_k is zero */\n	       i--;\n	       done = TRUE;\n	       break;\n	    }\n	    if (nres < 0.0) { /* do restart */\n	       i--; \n	       ip->steps--;\n	       break; \n	    }   \n	    beta->ve[i] = sqrt(nres);         /* beta_{k-1,k-1} */\n	    \n	    v.ve = N->me[0];\n	    alpha->ve[i] = in_prod(&v,rr); \n	    for (j = 0; j <= i-1; j++)\n              alpha->ve[i] -= beta->ve[j]*alpha->ve[j];\n	    alpha->ve[i] /= beta->ve[i];                /* alpha_{k-1} */\n	    \n	 }\n	 \n	 set_col(H,i,beta);\n\n	 /* other method of computing dd */\n	/* if (fabs((double)alpha->ve[i]) > dd)  {     \n	    nres = - dd*dd + alpha->ve[i]*alpha->ve[i];\n	    nres = sqrt((double) nres); \n	    if (ip->info) (*ip->info)(ip,-nres,VNULL,VNULL);  	\n	    break;     \n	 }  */\n	 /* to avoid overflow/underflow in computing dd */\n	 /* dd *= cos(asin((double)(alpha->ve[i]/dd))); */\n	 \n	 nres = alpha->ve[i]/dd;\n	 if (fabs(nres-1.0) <= MACHEPS*ip->init_res) \n	   dd = 0.0;\n	 else {\n	    nres = 1.0 - nres*nres;\n	    if (nres < 0.0) {\n	       nres = sqrt((double) -nres); \n	       if (ip->info) (*ip->info)(ip,-dd*nres,VNULL,VNULL);  	\n	       break;\n	    }\n	    dd *= sqrt((double) nres);  \n	 }\n\n	 if (ip->info) (*ip->info)(ip,dd,VNULL,VNULL);     \n	 if ( ip->stop_crit(ip,dd,VNULL,VNULL) ) {\n	    /* stopping criterion is satisfied */\n	    done = TRUE;\n	    break;\n	 }\n	 \n      } /* end of for */\n      \n      if (i >= ip->k) i = ip->k - 1;\n      \n      /* use (i+1) by (i+1) submatrix of H */\n      H = m_resize(H,i+1,i+1);\n      alpha = v_resize(alpha,i+1);\n      Usolve(H,alpha,alpha,0.0);       /* c_i is saved in alpha */\n      \n      for (j = 0; j <= i; j++) {\n	 v.ve = N->me[j];\n	 v_mltadd(ip->x,&v,alpha->ve[j],ip->x);\n      }\n      \n      \n      if (done) break;              /* stop the iterative process */\n      alpha = v_resize(alpha,ip->k);\n      H = m_resize(H,ip->k,ip->k);\n      \n   }  /* end of while */\n\n#ifdef THREADSAFE\n   V_FREE(As);		V_FREE(beta);	V_FREE(alpha);	V_FREE(z);\n   M_FREE(N);		M_FREE(H);\n#endif\n\n   return ip->x;                    /* return the solution */\n}\n\n\n\n/* iter_spmgcr - a simple interface to iter_mgcr */\n/* no preconditioner */\n#ifndef ANSI_C\nVEC	*iter_spmgcr(A,B,b,tol,x,k,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *x;\ndouble	tol;\nint *steps,k,limit;\n#else\nVEC	*iter_spmgcr(SPMAT *A, SPMAT *B, VEC *b, double tol,\n		     VEC *x, int k, int limit, int *steps)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *) B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n\n   ip->k = k;\n   ip->limit = limit;\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_mgcr(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n\n/* \n  Conjugate gradients method for a normal equation\n  a preconditioner B must be symmetric !!\n*/\n#ifndef ANSI_C\nVEC  *iter_cgne(ip)\nITER *ip;\n#else\nVEC  *iter_cgne(ITER *ip)\n#endif\n{\n   STATIC VEC *r = VNULL, *p = VNULL, *q = VNULL, *z = VNULL;\n   Real	alpha, beta, inner, old_inner, nres;\n   VEC *rr1;   /* pointer only */\n   \n   if (ip == INULL)\n     error(E_NULL,"iter_cgne");\n   if (!ip->Ax || ! ip->ATx || !ip->b)\n     error(E_NULL,"iter_cgne");\n   if ( ip->x == ip->b )\n     error(E_INSITU,"iter_cgne");\n   if (!ip->stop_crit)\n     error(E_NULL,"iter_cgne");\n   \n   if ( ip->eps <= 0.0 ) ip->eps = MACHEPS;\n   \n   r = v_resize(r,ip->b->dim);\n   p = v_resize(p,ip->b->dim);\n   q = v_resize(q,ip->b->dim);\n\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(p,TYPE_VEC);\n   MEM_STAT_REG(q,TYPE_VEC);\n\n   z = v_resize(z,ip->b->dim);\n   MEM_STAT_REG(z,TYPE_VEC);\n\n   if (ip->x) {\n      if (ip->x->dim != ip->b->dim)\n	error(E_SIZES,"iter_cgne");\n      ip->Ax(ip->A_par,ip->x,p);    		/* p = A*x */\n      v_sub(ip->b,p,z);		 		/* z = b - A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n      v_copy(ip->b,z);\n   }\n   rr1 = z;\n   if (ip->Bx) {\n      (ip->Bx)(ip->B_par,rr1,p);\n      rr1 = p;\n   }\n   (ip->ATx)(ip->AT_par,rr1,r);		/* r = A^T*B*(b-A*x)  */\n\n\n   old_inner = 0.0;\n   for ( ip->steps = 0; ip->steps <= ip->limit; ip->steps++ )\n   {\n      rr1 = r;\n      if ( ip->Bx ) {\n	 (ip->Bx)(ip->B_par,r,z);		/* rr = B*r */\n	 rr1 = z;\n      }\n\n      inner = in_prod(r,rr1);\n      nres = sqrt(fabs(inner));\n      if (ip->info) ip->info(ip,nres,r,rr1);\n      if (ip->steps == 0) ip->init_res = nres;\n      if ( ip->stop_crit(ip,nres,r,rr1) ) break;\n\n      if ( ip->steps )	/* if ( ip->steps > 0 ) ... */\n      {\n	 beta = inner/old_inner;\n	 p = v_mltadd(rr1,p,beta,p);\n      }\n      else		/* if ( ip->steps == 0 ) ... */\n      {\n	 beta = 0.0;\n	 p = v_copy(rr1,p);\n	 old_inner = 0.0;\n      }\n      (ip->Ax)(ip->A_par,p,q);     /* q = A*p */\n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,q,z);\n	 (ip->ATx)(ip->AT_par,z,q);\n	 rr1 = q;			/* q = A^T*B*A*p */\n      }\n      else {\n	 (ip->ATx)(ip->AT_par,q,z);	/* z = A^T*A*p */\n	 rr1 = z;\n      }\n\n      alpha = inner/in_prod(rr1,p);\n      v_mltadd(ip->x,p,alpha,ip->x);\n      v_mltadd(r,rr1,-alpha,r);\n      old_inner = inner;\n   }\n\n#ifdef THREADSAFE\n   V_FREE(r);   V_FREE(p);   V_FREE(q);   V_FREE(z);\n#endif\n\n   return ip->x;\n}\n\n/* iter_spcgne -- a simple interface to iter_cgne() which \n   uses sparse matrix data structures\n   -- assumes that B contains an actual preconditioner (or NULL)\n   use always as follows:\n      x = iter_spcgne(A,B,b,eps,x,limit,steps);\n   or \n      x = iter_spcgne(A,B,b,eps,VNULL,limit,steps);\n   In the second case the solution vector is created.\n*/\n#ifndef ANSI_C\nVEC  *iter_spcgne(A,B,b,eps,x,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *x;\ndouble	eps;\nint *steps, limit;\n#else\nVEC  *iter_spcgne(SPMAT *A,SPMAT *B, VEC *b, double eps,\n		  VEC *x, int limit, int *steps)\n#endif\n{	\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *)A;\n   ip->ATx = (Fun_Ax) sp_vm_mlt;\n   ip->AT_par = (void *)A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *)B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = eps;\n   ip->limit = limit;\n   ip->x = x;\n   iter_cgne(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n\n