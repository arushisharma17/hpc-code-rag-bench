\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File containing routines for computing the SVD of matrices\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n\nstatic char rcsid[] = "$Id: svd.c,v 1.7 1995/09/08 14:45:43 des Exp $";\n\n\n\n#define	sgn(x)	((x) >= 0 ? 1 : -1)\n#define	MAX_STACK	100\n\n/* fixsvd -- fix minor details about SVD\n	-- make singular values non-negative\n	-- sort singular values in decreasing order\n	-- variables as for bisvd()\n	-- no argument checking */\n#ifndef ANSI_C\nstatic void	fixsvd(d,U,V)\nVEC	*d;\nMAT	*U, *V;\n#else\nstatic void	fixsvd(VEC *d, MAT *U, MAT *V)\n#endif\n{\n    int		i, j, k, l, r, stack[MAX_STACK], sp;\n    Real	tmp, v;\n\n    /* make singular values non-negative */\n    for ( i = 0; i < d->dim; i++ )\n	if ( d->ve[i] < 0.0 )\n	{\n	    d->ve[i] = - d->ve[i];\n	    if ( U != MNULL )\n		for ( j = 0; j < U->m; j++ )\n		    U->me[i][j] = - U->me[i][j];\n	}\n\n    /* sort singular values */\n    /* nonrecursive implementation of quicksort due to R.Sedgewick,\n       "Algorithms in C", p. 122 (1990) */\n    sp = -1;\n    l = 0;	r = d->dim - 1;\n    for ( ; ; )\n    {\n	while ( r > l )\n	{\n	    /* i = partition(d->ve,l,r) */\n	    v = d->ve[r];\n\n	    i = l - 1;	    j = r;\n	    for ( ; ; )\n	    {	/* inequalities are "backwards" for **decreasing** order */\n		while ( d->ve[++i] > v )\n		    ;\n		while ( d->ve[--j] < v )\n		    ;\n		if ( i >= j )\n		    break;\n		/* swap entries in d->ve */\n		tmp = d->ve[i];	  d->ve[i] = d->ve[j];	d->ve[j] = tmp;\n		/* swap rows of U & V as well */\n		if ( U != MNULL )\n		    for ( k = 0; k < U->n; k++ )\n		    {\n			tmp = U->me[i][k];\n			U->me[i][k] = U->me[j][k];\n			U->me[j][k] = tmp;\n		    }\n		if ( V != MNULL )\n		    for ( k = 0; k < V->n; k++ )\n		    {\n			tmp = V->me[i][k];\n			V->me[i][k] = V->me[j][k];\n			V->me[j][k] = tmp;\n		    }\n	    }\n	    tmp = d->ve[i];    d->ve[i] = d->ve[r];    d->ve[r] = tmp;\n	    if ( U != MNULL )\n		for ( k = 0; k < U->n; k++ )\n		{\n		    tmp = U->me[i][k];\n		    U->me[i][k] = U->me[r][k];\n		    U->me[r][k] = tmp;\n		}\n	    if ( V != MNULL )\n		for ( k = 0; k < V->n; k++ )\n		{\n		    tmp = V->me[i][k];\n		    V->me[i][k] = V->me[r][k];\n		    V->me[r][k] = tmp;\n		}\n	    /* end i = partition(...) */\n	    if ( i - l > r - i )\n	    {	stack[++sp] = l;    stack[++sp] = i-1;	l = i+1;    }\n	    else\n	    {	stack[++sp] = i+1;  stack[++sp] = r;	r = i-1;    }\n	}\n	if ( sp < 0 )\n	    break;\n	r = stack[sp--];	l = stack[sp--];\n    }\n}\n\n\n/* bisvd -- svd of a bidiagonal m x n matrix represented by d (diagonal) and\n			f (super-diagonals)\n	-- returns with d set to the singular values, f zeroed\n	-- if U, V non-NULL, the orthogonal operations are accumulated\n		in U, V; if U, V == I on entry, then SVD == U^T.A.V\n		where A is initial matrix\n	-- returns d on exit */\n#ifndef ANSI_C\nVEC	*bisvd(d,f,U,V)\nVEC	*d, *f;\nMAT	*U, *V;\n#else\nVEC	*bisvd(VEC *d, VEC *f, MAT *U, MAT *V)\n#endif\n{\n	int	i, j, n;\n	int	i_min, i_max, split;\n	Real	c, s, shift, size, z;\n	Real	d_tmp, diff, t11, t12, t22, *d_ve, *f_ve;\n\n	if ( ! d || ! f )\n		error(E_NULL,"bisvd");\n	if ( d->dim != f->dim + 1 )\n		error(E_SIZES,"bisvd");\n	n = d->dim;\n	if ( ( U && U->n < n ) || ( V && V->m < n ) )\n		error(E_SIZES,"bisvd");\n	if ( ( U && U->m != U->n ) || ( V && V->m != V->n ) )\n		error(E_SQUARE,"bisvd");\n\n\n	if ( n == 1 )\n	  {\n	    if ( d->ve[0] < 0.0 )\n	      {\n		d->ve[0] = - d->ve[0];\n		if ( U != MNULL )\n		  sm_mlt(-1.0,U,U);\n	      }\n	    return d;\n	  }\n	d_ve = d->ve;	f_ve = f->ve;\n\n	size = v_norm_inf(d) + v_norm_inf(f);\n\n	i_min = 0;\n	while ( i_min < n )	/* outer while loop */\n	{\n	    /* find i_max to suit;\n		submatrix i_min..i_max should be irreducible */\n	    i_max = n - 1;\n	    for ( i = i_min; i < n - 1; i++ )\n		if ( d_ve[i] == 0.0 || f_ve[i] == 0.0 )\n		{   i_max = i;\n		    if ( f_ve[i] != 0.0 )\n		    {\n			/* have to ``chase'' f[i] element out of matrix */\n			z = f_ve[i];	f_ve[i] = 0.0;\n			for ( j = i; j < n-1 && z != 0.0; j++ )\n			{\n			    givens(d_ve[j+1],z, &c, &s);\n			    s = -s;\n			    d_ve[j+1] =  c*d_ve[j+1] - s*z;\n			    if ( j+1 < n-1 )\n			    {\n				z         = s*f_ve[j+1];\n				f_ve[j+1] = c*f_ve[j+1];\n			    }\n			    if ( U )\n				rot_rows(U,i,j+1,c,s,U);\n			}\n		    }\n		    break;\n		}\n	    if ( i_max <= i_min )\n	    {\n		i_min = i_max + 1;\n		continue;\n	    }\n	    /* printf("bisvd: i_min = %d, i_max = %d\n",i_min,i_max); */\n\n	    split = FALSE;\n	    while ( ! split )\n	    {\n		/* compute shift */\n		t11 = d_ve[i_max-1]*d_ve[i_max-1] +\n			(i_max > i_min+1 ? f_ve[i_max-2]*f_ve[i_max-2] : 0.0);\n		t12 = d_ve[i_max-1]*f_ve[i_max-1];\n		t22 = d_ve[i_max]*d_ve[i_max] + f_ve[i_max-1]*f_ve[i_max-1];\n		/* use e-val of [[t11,t12],[t12,t22]] matrix\n				closest to t22 */\n		diff = (t11-t22)/2;\n		shift = t22 - t12*t12/(diff +\n			sgn(diff)*sqrt(diff*diff+t12*t12));\n\n		/* initial Givens' rotation */\n		givens(d_ve[i_min]*d_ve[i_min]-shift,\n			d_ve[i_min]*f_ve[i_min], &c, &s);\n\n		/* do initial Givens' rotations */\n		d_tmp         = c*d_ve[i_min] + s*f_ve[i_min];\n		f_ve[i_min]   = c*f_ve[i_min] - s*d_ve[i_min];\n		d_ve[i_min]   = d_tmp;\n		z             = s*d_ve[i_min+1];\n		d_ve[i_min+1] = c*d_ve[i_min+1];\n		if ( V )\n		    rot_rows(V,i_min,i_min+1,c,s,V);\n		/* 2nd Givens' rotation */\n		givens(d_ve[i_min],z, &c, &s);\n		d_ve[i_min]   = c*d_ve[i_min] + s*z;\n		d_tmp         = c*d_ve[i_min+1] - s*f_ve[i_min];\n		f_ve[i_min]   = s*d_ve[i_min+1] + c*f_ve[i_min];\n		d_ve[i_min+1] = d_tmp;\n		if ( i_min+1 < i_max )\n		{\n		    z             = s*f_ve[i_min+1];\n		    f_ve[i_min+1] = c*f_ve[i_min+1];\n		}\n		if ( U )\n		    rot_rows(U,i_min,i_min+1,c,s,U);\n\n		for ( i = i_min+1; i < i_max; i++ )\n		{\n		    /* get Givens' rotation for zeroing z */\n		    givens(f_ve[i-1],z, &c, &s);\n		    f_ve[i-1] = c*f_ve[i-1] + s*z;\n		    d_tmp     = c*d_ve[i] + s*f_ve[i];\n		    f_ve[i]   = c*f_ve[i] - s*d_ve[i];\n		    d_ve[i]   = d_tmp;\n		    z         = s*d_ve[i+1];\n		    d_ve[i+1] = c*d_ve[i+1];\n		    if ( V )\n			rot_rows(V,i,i+1,c,s,V);\n		    /* get 2nd Givens' rotation */\n		    givens(d_ve[i],z, &c, &s);\n		    d_ve[i]   = c*d_ve[i] + s*z;\n		    d_tmp     = c*d_ve[i+1] - s*f_ve[i];\n		    f_ve[i]   = c*f_ve[i] + s*d_ve[i+1];\n		    d_ve[i+1] = d_tmp;\n		    if ( i+1 < i_max )\n		    {\n			z         = s*f_ve[i+1];\n			f_ve[i+1] = c*f_ve[i+1];\n		    }\n		    if ( U )\n			rot_rows(U,i,i+1,c,s,U);\n		}\n		/* should matrix be split? */\n		for ( i = i_min; i < i_max; i++ )\n		    if ( fabs(f_ve[i]) <\n				MACHEPS*(fabs(d_ve[i])+fabs(d_ve[i+1])) )\n		    {\n			split = TRUE;\n			f_ve[i] = 0.0;\n		    }\n		    else if ( fabs(d_ve[i]) < MACHEPS*size )\n		    {\n			split = TRUE;\n			d_ve[i] = 0.0;\n		    }\n		    /* printf("bisvd: d =\n");	v_output(d); */\n		    /* printf("bisvd: f = \n");	v_output(f); */\n		}\n	}\n	fixsvd(d,U,V);\n\n	return d;\n}\n\n/* bifactor -- perform preliminary factorisation for bisvd\n	-- updates U and/or V, which ever is not NULL */\n#ifndef ANSI_C\nMAT	*bifactor(A,U,V)\nMAT	*A, *U, *V;\n#else\nMAT	*bifactor(MAT *A, MAT *U, MAT *V)\n#endif\n{\n	int	k;\n	STATIC VEC	*tmp1=VNULL, *tmp2=VNULL, *w=VNULL;\n	Real	beta;\n\n	if ( ! A )\n		error(E_NULL,"bifactor");\n	if ( ( U && ( U->m != U->n ) ) || ( V && ( V->m != V->n ) ) )\n		error(E_SQUARE,"bifactor");\n	if ( ( U && U->m != A->m ) || ( V && V->m != A->n ) )\n		error(E_SIZES,"bifactor");\n	tmp1 = v_resize(tmp1,A->m);\n	tmp2 = v_resize(tmp2,A->n);\n	w    = v_resize(w,   max(A->m,A->n));\n	MEM_STAT_REG(tmp1,TYPE_VEC);\n	MEM_STAT_REG(tmp2,TYPE_VEC);\n	MEM_STAT_REG(w,   TYPE_VEC);\n\n	if ( A->m >= A->n )\n	    for ( k = 0; k < A->n; k++ )\n	    {\n		get_col(A,k,tmp1);\n		hhvec(tmp1,k,&beta,tmp1,&(A->me[k][k]));\n		_hhtrcols(A,k,k+1,tmp1,beta,w);\n		if ( U )\n		    _hhtrcols(U,k,0,tmp1,beta,w);\n		if ( k+1 >= A->n )\n		    continue;\n		get_row(A,k,tmp2);\n		hhvec(tmp2,k+1,&beta,tmp2,&(A->me[k][k+1]));\n		hhtrrows(A,k+1,k+1,tmp2,beta);\n		if ( V )\n		    _hhtrcols(V,k+1,0,tmp2,beta,w);\n	    }\n	else\n	    for ( k = 0; k < A->m; k++ )\n	    {\n		get_row(A,k,tmp2);\n		hhvec(tmp2,k,&beta,tmp2,&(A->me[k][k]));\n		hhtrrows(A,k+1,k,tmp2,beta);\n		if ( V )\n		    _hhtrcols(V,k,0,tmp2,beta,w);\n		if ( k+1 >= A->m )\n		    continue;\n		get_col(A,k,tmp1);\n		hhvec(tmp1,k+1,&beta,tmp1,&(A->me[k+1][k]));\n		_hhtrcols(A,k+1,k+1,tmp1,beta,w);\n		if ( U )\n		    _hhtrcols(U,k+1,0,tmp1,beta,w);\n	    }\n\n#ifdef	THREADSAFE\n	V_FREE(tmp1);	V_FREE(tmp2);\n#endif\n\n	return A;\n}\n\n/* svd -- returns vector of singular values in d\n	-- also updates U and/or V, if one or the other is non-NULL\n	-- destroys A */\n#ifndef ANSI_C\nVEC	*svd(A,U,V,d)\nMAT	*A, *U, *V;\nVEC	*d;\n#else\nVEC	*svd(MAT *A, MAT *U, MAT *V, VEC *d)\n#endif\n{\n	STATIC VEC	*f=VNULL;\n	int	i, limit;\n	MAT	*A_tmp;\n\n	if ( ! A )\n		error(E_NULL,"svd");\n	if ( ( U && ( U->m != U->n ) ) || ( V && ( V->m != V->n ) ) )\n		error(E_SQUARE,"svd");\n	if ( ( U && U->m != A->m ) || ( V && V->m != A->n ) )\n		error(E_SIZES,"svd");\n\n	A_tmp = m_copy(A,MNULL);\n	if ( U != MNULL )\n	    m_ident(U);\n	if ( V != MNULL )\n	    m_ident(V);\n	limit = min(A_tmp->m,A_tmp->n);\n	d = v_resize(d,limit);\n	f = v_resize(f,limit-1);\n	MEM_STAT_REG(f,TYPE_VEC);\n\n	bifactor(A_tmp,U,V);\n	if ( A_tmp->m >= A_tmp->n )\n	    for ( i = 0; i < limit; i++ )\n	    {\n		d->ve[i] = A_tmp->me[i][i];\n		if ( i+1 < limit )\n		    f->ve[i] = A_tmp->me[i][i+1];\n	    }\n	else\n	    for ( i = 0; i < limit; i++ )\n	    {\n		d->ve[i] = A_tmp->me[i][i];\n		if ( i+1 < limit )\n		    f->ve[i] = A_tmp->me[i+1][i];\n	    }\n\n\n	if ( A_tmp->m >= A_tmp->n )\n	    bisvd(d,f,U,V);\n	else\n	    bisvd(d,f,V,U);\n\n	M_FREE(A_tmp);\n#ifdef	THREADSAFE\n	V_FREE(f);\n#endif\n\n	return d;\n}\n\n