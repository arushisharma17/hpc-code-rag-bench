\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  Sparse rows package\n  See also: sparse.h, matrix.h\n  */\n\n#include	<stdio.h>\n#include	<math.h>\n#include        <stdlib.h>\n#include	"sparse.h"\n\n\nstatic char	rcsid[] = "$Id: sprow.c,v 1.1 1994/01/13 05:35:36 des Exp $";\n\n#define	MINROWLEN	10\n\n\n#ifndef MEX\n/* sprow_dump - prints relevant information about the sparse row r */\n#ifndef ANSI_C\nvoid sprow_dump(fp,r)\nFILE *fp;\nSPROW *r;\n#else\nvoid sprow_dump(FILE *fp, const SPROW *r)\n#endif\n{\n   int  j_idx;\n   row_elt *elts;\n   \n   fprintf(fp,"SparseRow dump:\n");\n   if ( ! r )\n   {       fprintf(fp,"*** NULL row ***\n");   return; }\n   \n   fprintf(fp,"row: len = %d, maxlen = %d, diag idx = %d\n",\n	   r->len,r->maxlen,r->diag);\n   fprintf(fp,"element list @ 0x%lx\n",(long)(r->elt));\n   if ( ! r->elt )\n   {\n      fprintf(fp,"*** NULL element list ***\n");\n      return;\n   }\n   elts = r->elt;\n   for ( j_idx = 0; j_idx < r->len; j_idx++, elts++ )\n     fprintf(fp,"Col: %d, Val: %g, nxt_row = %d, nxt_idx = %d\n",\n	     elts->col,elts->val,elts->nxt_row,elts->nxt_idx);\n   fprintf(fp,"\n");\n}\n#endif /* MEX */\n\n/* sprow_idx -- get index into row for a given column in a given row\n   -- return -1 on error\n   -- return -(idx+2) where idx is index to insertion point */\n#ifndef ANSI_C\nint	sprow_idx(r,col)\nSPROW	*r;\nint	col;\n#else\nint	sprow_idx(const SPROW *r, int col)\n#endif\n{\n   register int		lo, hi, mid;\n   int			tmp;\n   register row_elt	*r_elt;\n   \n   /*******************************************\n     if ( r == (SPROW *)NULL )\n     return -1;\n     if ( col < 0 )\n     return -1;\n     *******************************************/\n   \n   r_elt = r->elt;\n   if ( r->len <= 0 )\n     return -2;\n   \n   /* try the hint */\n   /* if ( hint >= 0 && hint < r->len && r_elt[hint].col == col )\n      return hint; */\n   \n   /* otherwise use binary search... */\n   /* code from K&R Ch. 6, p. 125 */\n   lo = 0;		hi = r->len - 1;	mid = lo;\n   while ( lo <= hi )\n   {\n      mid = (hi + lo)/2;\n      if ( (tmp=r_elt[mid].col-col) > 0 )\n	hi = mid-1;\n      else if ( tmp < 0 )\n	lo = mid+1;\n      else /* tmp == 0 */\n	return mid;\n   }\n   tmp = r_elt[mid].col - col;\n   \n   if ( tmp > 0 )\n     return -(mid+2);	/* insert at mid   */\n   else /* tmp < 0 */\n     return -(mid+3);	/* insert at mid+1 */\n}\n\n\n/* sprow_get -- gets, initialises and returns a SPROW structure\n   -- max. length is maxlen */\n#ifndef ANSI_C\nSPROW	*sprow_get(maxlen)\nint	maxlen;\n#else\nSPROW	*sprow_get(int maxlen)\n#endif\n{\n   SPROW	*r;\n   \n   if ( maxlen < 0 )\n     error(E_NEG,"sprow_get");\n\n   r = NEW(SPROW);\n   if ( ! r )\n     error(E_MEM,"sprow_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPROW,0,sizeof(SPROW));\n      mem_numvar(TYPE_SPROW,1);\n   }\n   r->elt = NEW_A(maxlen,row_elt);\n   if ( ! r->elt )\n     error(E_MEM,"sprow_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPROW,0,maxlen*sizeof(row_elt));\n   }\n   r->len = 0;\n   r->maxlen = maxlen;\n   r->diag = -1;\n   \n   return r;\n}\n\n\n/* sprow_xpd -- expand row by means of realloc()\n   -- type must be TYPE_SPMAT if r is a row of a SPMAT structure,\n      otherwise it must be TYPE_SPROW\n   -- returns r */\n#ifndef ANSI_C\nSPROW	*sprow_xpd(r,n,type)\nSPROW	*r;\nint	n,type;\n#else\nSPROW	*sprow_xpd(SPROW *r, int n, int type)\n#endif\n{\n   int	newlen;\n   \n   if ( ! r ) {\n     r = NEW(SPROW);\n     if (! r ) \n       error(E_MEM,"sprow_xpd");\n     else if ( mem_info_is_on()) {\n	if (type != TYPE_SPMAT && type != TYPE_SPROW)\n	  warning(WARN_WRONG_TYPE,"sprow_xpd");\n	mem_bytes(type,0,sizeof(SPROW));\n	if (type == TYPE_SPROW)\n	  mem_numvar(type,1);\n     }\n   }\n\n   if ( ! r->elt )\n   {\n      r->elt = NEW_A((unsigned)n,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,"sprow_xpd");\n      else if (mem_info_is_on()) {\n	 mem_bytes(type,0,n*sizeof(row_elt));\n      }\n      r->len = 0;\n      r->maxlen = n;\n      return r;\n   }\n   if ( n <= r->len )\n     newlen = max(2*r->len + 1,MINROWLEN);\n   else\n     newlen = n;\n   if ( newlen <= r->maxlen )\n   {\n      MEM_ZERO((char *)(&(r->elt[r->len])),\n	       (newlen-r->len)*sizeof(row_elt));\n      r->len = newlen;\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(type,r->maxlen*sizeof(row_elt),\n		     newlen*sizeof(row_elt)); \n      }\n      r->elt = RENEW(r->elt,newlen,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,"sprow_xpd");\n      r->maxlen = newlen;\n      r->len = newlen;\n   }\n   \n   return r;\n}\n\n/* sprow_resize -- resize a SPROW variable by means of realloc()\n   -- n is a new size\n   -- returns r */\n#ifndef ANSI_C\nSPROW	*sprow_resize(r,n,type)\nSPROW	*r;\nint	n,type;\n#else\nSPROW	*sprow_resize(SPROW *r, int n, int type)\n#endif\n{\n   if (n < 0)\n     error(E_NEG,"sprow_resize");\n\n   if ( ! r ) \n     return sprow_get(n);\n   \n   if (n == r->len)\n     return r;\n\n   if ( ! r->elt )\n   {\n      r->elt = NEW_A((unsigned)n,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,"sprow_resize");\n      else if (mem_info_is_on()) {\n	 mem_bytes(type,0,n*sizeof(row_elt));\n      }\n      r->maxlen = r->len = n;\n      return r;\n   }\n\n   if ( n <= r->maxlen )\n     r->len = n;\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(type,r->maxlen*sizeof(row_elt),\n		   n*sizeof(row_elt)); \n      }\n      r->elt = RENEW(r->elt,n,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,"sprow_resize");\n      r->maxlen = r->len = n;\n   }\n   \n   return r;\n}\n\n\n/* release a row of a matrix */\n#ifndef ANSI_C\nint sprow_free(r)\nSPROW	*r;\n#else\nint sprow_free(SPROW *r)\n#endif\n{\n   if ( ! r )\n     return -1;\n\n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPROW,sizeof(SPROW),0);\n      mem_numvar(TYPE_SPROW,-1);\n   }\n   \n   if ( r->elt )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPROW,r->maxlen*sizeof(row_elt),0);\n      }\n      free((char *)r->elt);\n   }\n   free((char *)r);\n   return 0;\n}\n\n\n/* sprow_merge -- merges r1 and r2 into r_out\n   -- cannot be done in-situ\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_merge(r1,r2,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint type;\n#else\nSPROW	*sprow_merge(const SPROW *r1, const SPROW *r2, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,"sprow_merge");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,"sprow_merge");\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   idx1 = idx2 = idx_out = 0;\n   elt1 = r1->elt;	elt2 = r2->elt;	elt_out = r_out->elt;\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->len;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( elt1->col == elt2->col && idx2 < len2 )\n	 {	elt2++;		idx2++;	}\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_copy -- copies r1 and r2 into r_out\n   -- cannot be done in-situ\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_copy(r1,r2,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint type;\n#else\nSPROW	*sprow_copy(const SPROW *r1, const SPROW *r2, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,"sprow_copy");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,"sprow_copy");\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   idx1 = idx2 = idx_out = 0;\n   elt1 = r1->elt;	elt2 = r2->elt;	elt_out = r_out->elt;\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      while ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( elt1->col == elt2->col && idx2 < len2 )\n	 {	elt2++;		idx2++;	}\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = 0.0;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_mltadd -- sets r_out <- r1 + alpha.r2\n   -- cannot be in situ\n   -- only for columns j0, j0+1, ...\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_mltadd(r1,r2,alpha,j0,r_out,type)\nSPROW	*r1, *r2, *r_out;\ndouble	alpha;\nint	j0, type;\n#else\nSPROW	*sprow_mltadd(const SPROW *r1,const SPROW *r2, double alpha,\n		      int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,"sprow_mltadd");\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,"sprow_mltadd");\n   if ( j0 < 0 )\n     error(E_BOUNDS,"sprow_mltadd");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   /* idx1 = idx2 = idx_out = 0; */\n   idx1    = sprow_idx(r1,j0);\n   idx2    = sprow_idx(r2,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx2    = (idx2 < 0) ? -(idx2+2) : idx2;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n   elt2    = &(r2->elt[idx2]);\n   elt_out = &(r_out->elt[idx_out]);\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( idx2 < len2 && elt1->col == elt2->col )\n	 {\n	    elt_out->val += alpha*elt2->val;\n	    elt2++;		idx2++;\n	 }\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = alpha*elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_add -- sets r_out <- r1 + r2\n   -- cannot be in situ\n   -- only for columns j0, j0+1, ...\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_add(r1,r2,j0,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint	j0, type;\n#else\nSPROW	*sprow_add(const SPROW *r1,const SPROW *r2, \n		   int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,"sprow_add");\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,"sprow_add");\n   if ( j0 < 0 )\n     error(E_BOUNDS,"sprow_add");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   /* idx1 = idx2 = idx_out = 0; */\n   idx1    = sprow_idx(r1,j0);\n   idx2    = sprow_idx(r2,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx2    = (idx2 < 0) ? -(idx2+2) : idx2;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n   elt2    = &(r2->elt[idx2]);\n   elt_out = &(r_out->elt[idx_out]);\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( idx2 < len2 && elt1->col == elt2->col )\n	 {\n	    elt_out->val += elt2->val;\n	    elt2++;		idx2++;\n	 }\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_sub -- sets r_out <- r1 - r2\n   -- cannot be in situ\n   -- only for columns j0, j0+1, ...\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_sub(r1,r2,j0,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint	j0, type;\n#else\nSPROW	*sprow_sub(const SPROW *r1, const SPROW *r2,\n		   int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,"sprow_sub");\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,"sprow_sub");\n   if ( j0 < 0 )\n     error(E_BOUNDS,"sprow_sub");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   /* idx1 = idx2 = idx_out = 0; */\n   idx1    = sprow_idx(r1,j0);\n   idx2    = sprow_idx(r2,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx2    = (idx2 < 0) ? -(idx2+2) : idx2;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n   elt2    = &(r2->elt[idx2]);\n   elt_out = &(r_out->elt[idx_out]);\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( idx2 < len2 && elt1->col == elt2->col )\n	 {\n	    elt_out->val -= elt2->val;\n	    elt2++;		idx2++;\n	 }\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = -elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n\n/* sprow_smlt -- sets r_out <- alpha*r1 \n   -- can be in situ\n   -- only for columns j0, j0+1, ...\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_smlt(r1,alpha,j0,r_out,type)\nSPROW	*r1, *r_out;\ndouble	alpha;\nint	j0, type;\n#else\nSPROW	*sprow_smlt(const SPROW *r1, double alpha, int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx_out, len1;\n   row_elt	*elt1, *elt_out;\n   \n   if ( ! r1 )\n     error(E_NULL,"sprow_smlt");\n   if ( j0 < 0 )\n     error(E_BOUNDS,"sprow_smlt");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;\n   idx1    = sprow_idx(r1,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n\n   r_out = sprow_resize(r_out,idx_out+len1-idx1,type);  \n   elt_out = &(r_out->elt[idx_out]);\n\n   for ( ; idx1 < len1; elt1++,elt_out++,idx1++,idx_out++ )\n   {\n      elt_out->col = elt1->col;\n      elt_out->val = alpha*elt1->val;\n   }\n\n   r_out->len = idx_out;\n\n   return r_out;\n}\n\n#ifndef MEX\n/* sprow_foutput -- print a representation of r on stream fp */\n#ifndef ANSI_C\nvoid	sprow_foutput(fp,r)\nFILE	*fp;\nSPROW	*r;\n#else\nvoid	sprow_foutput(FILE *fp, const SPROW *r)\n#endif\n{\n   int	i, len;\n   row_elt	*e;\n   \n   if ( ! r )\n   {\n      fprintf(fp,"SparseRow: **** NULL ****\n");\n      return;\n   }\n   len = r->len;\n   fprintf(fp,"SparseRow: length: %d\n",len);\n   for ( i = 0, e = r->elt; i < len; i++, e++ )\n     fprintf(fp,"Column %d: %g, next row: %d, next index %d\n",\n	     e->col, e->val, e->nxt_row, e->nxt_idx);\n}\n#endif\n\n\n/* sprow_set_val -- sets the j-th column entry of the sparse row r\n   -- Note: destroys the usual column & row access paths */\n#ifndef ANSI_C\ndouble  sprow_set_val(r,j,val)\nSPROW   *r;\nint     j;\ndouble  val;\n#else\ndouble  sprow_set_val(SPROW *r, int j, double val)\n#endif\n{\n   int  idx, idx2, new_len;\n   \n   if ( ! r )\n     error(E_NULL,"sprow_set_val");\n   \n   idx = sprow_idx(r,j);\n   if ( idx >= 0 )\n   {    r->elt[idx].val = val;  return val;     }\n   /* else */ if ( idx < -1 )\n   {\n      /* shift & insert new value */\n      idx = -(idx+2);   /* this is the intended insertion index */\n      if ( r->len >= r->maxlen )\n      {\n         r->len = r->maxlen;\n         new_len = max(2*r->maxlen+1,5);\n         if (mem_info_is_on()) {\n            mem_bytes(TYPE_SPROW,r->maxlen*sizeof(row_elt),\n                        new_len*sizeof(row_elt)); \n         }\n         \n         r->elt = RENEW(r->elt,new_len,row_elt);\n         if ( ! r->elt )        /* can't allocate */\n           error(E_MEM,"sprow_set_val");\n         r->maxlen = 2*r->maxlen+1;\n      }\n      for ( idx2 = r->len-1; idx2 >= idx; idx2-- )\n        MEM_COPY((char *)(&(r->elt[idx2])),\n                 (char *)(&(r->elt[idx2+1])),sizeof(row_elt));\n      /************************************************************\n        if ( idx < r->len )\n        MEM_COPY((char *)(&(r->elt[idx])),(char *)(&(r->elt[idx+1])),\n        (r->len-idx)*sizeof(row_elt));\n        ************************************************************/\n      r->len++;\n      r->elt[idx].col = j;\n      r->elt[idx].nxt_row = -1;\n      r->elt[idx].nxt_idx = -1;\n      return r->elt[idx].val = val;\n   }\n   /* else -- idx == -1, error in index/matrix! */\n   return 0.0;\n}\n\n\n