\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* meminfo.c  revised  22/11/93 */\n\n/* \n  contains basic functions, types and arrays \n  to keep track of memory allocation/deallocation\n*/\n\n#include <stdio.h>\n#include  "matrix.h"\n#include  "meminfo.h"\n#ifdef COMPLEX   \n#include  "zmatrix.h"\n#endif\n#ifdef SPARSE\n#include  "sparse.h"\n#include  "iter.h"\n#endif\n\nstatic char rcsid[] = "$Id: meminfo.c,v 1.1 1994/01/13 05:31:39 des Exp $";\n\n/* this array is defined further in this file */\nextern MEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS];\n\n\n/* names of types */\nstatic char *mem_type_names[] = {\n   "MAT",\n   "BAND",\n   "PERM",\n   "VEC",\n   "IVEC"\n#ifdef SPARSE\n     ,"ITER",\n     "SPROW",\n     "SPMAT"\n#endif\n#ifdef COMPLEX   \n       ,"ZVEC",\n       "ZMAT"\n#endif\n      };\n\n\n#define MEM_NUM_STD_TYPES  (sizeof(mem_type_names)/sizeof(mem_type_names[0]))\n\n\n/* local array for keeping track of memory */\nstatic MEM_ARRAY   mem_info_sum[MEM_NUM_STD_TYPES];  \n\n\n/* for freeing various types */\nstatic int (*mem_free_funcs[MEM_NUM_STD_TYPES])() = {\n   m_free,\n   bd_free,\n   px_free,    \n   v_free,	\n   iv_free\n#ifdef SPARSE\n     ,iter_free,	\n     sprow_free, \n     sp_free\n#endif\n#ifdef COMPLEX\n       ,zv_free,	\n       zm_free\n#endif\n      };\n\n\n\n/* it is a global variable for passing \n   pointers to local arrays defined here */\nMEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS] = {\n { mem_type_names, mem_free_funcs, MEM_NUM_STD_TYPES, \n     mem_info_sum } \n};\n\n\n/* attach a new list of types */\n#ifndef ANSI_C\nint mem_attach_list(list, ntypes, type_names, free_funcs, info_sum)\nint list,ntypes;         /* number of a list and number of types there */\nchar *type_names[];      /* list of names of types */\nint (*free_funcs[])();   /* list of releasing functions */\nMEM_ARRAY info_sum[];    /* local table */\n#else\nint mem_attach_list(int list, int ntypes, \n		    char *type_names[], \n		    int (*free_funcs[])(void *), \n		    MEM_ARRAY info_sum[])\n#endif\n{\n   if (list < 0 || list >= MEM_CONNECT_MAX_LISTS)\n     return -1;\n\n   if (type_names == NULL || free_funcs == NULL \n       || info_sum == NULL || ntypes < 0)\n     return -1;\n   \n   /* if a list exists do not overwrite */\n   if ( mem_connect[list].ntypes != 0 )\n     error(E_OVERWRITE,"mem_attach_list");\n   \n   mem_connect[list].ntypes = ntypes;\n   mem_connect[list].type_names = type_names;\n   mem_connect[list].free_funcs = free_funcs;\n   mem_connect[list].info_sum = info_sum;\n   return 0;\n}\n\n\n/* release a list of types */\n#ifndef ANSI_C\nint mem_free_vars(list)\nint list;\n#else\nint mem_free_vars(int list)\n#endif\n{	\n   if (list < 0 || list >= MEM_CONNECT_MAX_LISTS)\n     return -1;\n   \n   mem_connect[list].ntypes = 0;\n   mem_connect[list].type_names = NULL;\n   mem_connect[list].free_funcs = NULL;\n   mem_connect[list].info_sum = NULL;\n   \n   return 0;\n}\n\n\n\n/* check if list is attached */\n#ifndef ANSI_C\nint mem_is_list_attached(list)\nint list;\n#else\nint mem_is_list_attached(int list)\n#endif\n{\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n   return FALSE;\n\n   if ( mem_connect[list].type_names != NULL &&\n        mem_connect[list].free_funcs != NULL &&\n        mem_connect[list].info_sum != NULL)\n     return TRUE;\n   else return FALSE;\n}\n\n/* to print out the contents of mem_connect[list] */\n#ifndef MEX\n\n#ifndef ANSI_C\nvoid mem_dump_list(fp,list)\nFILE *fp;\nint list;\n#else\nvoid mem_dump_list(FILE *fp, int list)\n#endif\n{\n   int i;\n   MEM_CONNECT *mlist;\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n\n   mlist = &mem_connect[list];\n   fprintf(fp," %15s[%d]:\n","CONTENTS OF mem_connect",list);\n   fprintf(fp," %-7s   %-12s   %-9s   %s\n",\n	   "name of",\n	   "alloc.", "# alloc.",\n	   "address"\n	   );\n   fprintf(fp," %-7s   %-12s   %-9s   %s\n",\n	   " type",\n	   "bytes", "variables",\n	   "of *_free()"\n	   );\n\n   for (i=0; i < mlist->ntypes; i++) \n     fprintf(fp,"  %-7s   %-12ld   %-9d   %p\n",\n	     mlist->type_names[i], mlist->info_sum[i].bytes,\n	     mlist->info_sum[i].numvar, mlist->free_funcs[i]\n	     );\n   \n   fprintf(fp,"\n");\n}\n#endif /* MEX */\n\n\n\n/*=============================================================*/\n\n\n/* local variables */\n\nstatic int	mem_switched_on = MEM_SWITCH_ON_DEF;  /* on/off */\n\n\n/* switch on/off memory info */\n#ifndef ANSI_C\nint mem_info_on(sw)\nint sw;\n#else\nint mem_info_on(int sw)\n#endif\n{\n   int old = mem_switched_on;\n   \n   mem_switched_on = sw;\n   return old;\n}\n\n#ifdef ANSI_C\nint mem_info_is_on(void)\n#else\nint mem_info_is_on()\n#endif\n{\n   return mem_switched_on;\n}\n\n\n/* information about allocated memory */\n\n/* return the number of allocated bytes for type 'type' */\n#ifndef ANSI_C\nlong mem_info_bytes(type,list)\nint type,list;\n#else\nlong mem_info_bytes(int type, int list)\n#endif\n{\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return 0l;\n   if ( !mem_switched_on || type < 0 \n       || type >= mem_connect[list].ntypes\n       || mem_connect[list].free_funcs[type] == NULL )\n     return 0l;\n   \n   return mem_connect[list].info_sum[type].bytes;\n}\n\n/* return the number of allocated variables for type 'type' */\n#ifndef ANSI_C\nint mem_info_numvar(type,list)\nint type,list;\n#else\nint mem_info_numvar(int type, int list)\n#endif\n{\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return 0l;\n   if ( !mem_switched_on || type < 0 \n       || type >= mem_connect[list].ntypes\n       || mem_connect[list].free_funcs[type] == NULL )\n     return 0l;\n   \n   return mem_connect[list].info_sum[type].numvar;\n}\n\n\n#ifndef MEX\n\n/* print out memory info to the file fp */\n#ifndef ANSI_C\nvoid mem_info_file(fp,list)\nFILE *fp;\nint list;\n#else\nvoid mem_info_file(FILE *fp, int list)\n#endif\n{\n   unsigned int type;\n   long t = 0l, d;\n   int n = 0, nt = 0;\n   MEM_CONNECT *mlist;\n   \n   if (!mem_switched_on) return;\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n   \n   if (list == 0)\n     fprintf(fp," MEMORY INFORMATION (standard types):\n");\n   else\n     fprintf(fp," MEMORY INFORMATION (list no. %d):\n",list);\n\n   mlist = &mem_connect[list];\n\n   for (type=0; type < mlist->ntypes; type++) {\n      if (mlist->type_names[type] == NULL ) continue;\n      d = mlist->info_sum[type].bytes;\n      t += d;\n      n = mlist->info_sum[type].numvar;\n      nt += n;\n      fprintf(fp," type %-7s %10ld alloc. byte%c  %6d alloc. variable%c\n",\n	      mlist->type_names[type], d, (d!=1 ? 's' : ' '),\n	      n, (n!=1 ? 's' : ' '));\n   }\n\n   fprintf(fp," %-12s %10ld alloc. byte%c  %6d alloc. variable%c\n\n",\n	   "total:",t, (t!=1 ? 's' : ' '),\n	   nt, (nt!=1 ? 's' : ' '));\n}\n#endif\n\n\n/* function for memory information */\n\n\n/* mem_bytes_list\n   \n   Arguments:\n   type - the number of type;\n   old_size - old size of allocated memory (in bytes);\n   new_size - new size of allocated memory (in bytes);\n   list - list of types\n   */\n#ifndef ANSI_C\nvoid mem_bytes_list(type,old_size,new_size,list)\nint type,list;\nint old_size,new_size;\n#else\nvoid mem_bytes_list(int type, int old_size, int new_size, int list)\n#endif\n{\n   MEM_CONNECT *mlist;\n   \n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n   \n   mlist = &mem_connect[list];\n   if (  type < 0 || type >= mlist->ntypes\n       || mlist->free_funcs[type] == NULL )\n     return;\n\n   if ( old_size < 0 || new_size < 0 )\n     error(E_NEG,"mem_bytes_list");\n\n   mlist->info_sum[type].bytes += new_size - old_size;\n   \n   /* check if the number of bytes is non-negative */\n   if ( old_size > 0 ) {\n\n      if (mlist->info_sum[type].bytes < 0)\n      {\n#ifndef MEX\n	 fprintf(stderr,\n	   "\n WARNING !! memory info: allocated memory is less than 0\n");\n	 fprintf(stderr,"\t TYPE %s \n\n", mlist->type_names[type]);\n\n	 if ( !isatty(fileno(stdout)) ) {\n	    fprintf(stdout,\n	      "\n WARNING !! memory info: allocated memory is less than 0\n");\n	    fprintf(stdout,"\t TYPE %s \n\n", mlist->type_names[type]);\n	 }\n#else\n	 mexPrintf("\n WARNING !! memory info: allocated memory < 0\n");\n	 mexPrintf("\t TYPE %s \n\n", mlist->type_names[type]);\n#endif\n      }\n   }\n}\n\n\n\n/* mem_numvar_list\n   \n   Arguments:\n   type - the number of type;\n   num - # of variables allocated (> 0) or deallocated ( < 0)\n   list - list of types\n   */\n\n#ifndef ANSI_C\nvoid mem_numvar_list(type,num,list)\nint type,list,num;\n#else\nvoid mem_numvar_list(int type, int num, int list)\n#endif\n{\n   MEM_CONNECT *mlist;\n   \n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n   \n   mlist = &mem_connect[list];\n   if (  type < 0 || type >= mlist->ntypes\n       || mlist->free_funcs[type] == NULL )\n     return;\n\n   mlist->info_sum[type].numvar += num;\n   \n   /* check if the number of variables is non-negative */\n   if ( num < 0 ) {\n\n      if (mlist->info_sum[type].numvar < 0)\n      {\n#ifndef MEX\n	 fprintf(stderr,\n       "\n WARNING !! memory info: allocated # of variables is less than 0\n");\n	 fprintf(stderr,"\t TYPE %s \n\n", mlist->type_names[type]);\n	 if ( !isatty(fileno(stdout)) ) {\n	    fprintf(stdout,\n      "\n WARNING !! memory info: allocated # of variables is less than 0\n");\n	    fprintf(stdout,"\t TYPE %s \n\n", mlist->type_names[type]);\n	 }\n#else\n	 mexPrintf("\n WARNING !! memory info: allocated # of variables < 0\n");\n	 mexPrintf(stderr,"\t TYPE %s \n\n", mlist->type_names[type]);\n#endif\n      }\n   }\n}\n\n