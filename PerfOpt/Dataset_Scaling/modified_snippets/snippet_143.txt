#include "PoolMalloc.hh"\n//#include "CUtilities.h"\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstatic const size_t POOLBLOCKSIZE = 10*1024*1024;\n\n/// Print current line and exit\n#define DIE()                                                           \\n  do {                                                                  \\n    fprintf(stderr,"Aborted. File: %s, Line: %d\n",__FILE__,__LINE__);  \\n    exit(EXIT_FAILURE);                                                 \\n  } while(0)\n\n/// Print a message and then DIE()\n#define DIEM(m) do { fprintf(stderr,m"\n"); DIE(); } while(0)\n\n/// DIE() if the pointer is NULL\n#define DIENULL(p) do { if ( !(p) ) { DIEM("Out of memory"); } } while(0)\n\n\n/// Malloc memory, DIE() if NULL\n#define MALLOC(p,t,s) DIENULL( (p) = (t) malloc(s) )\n\n/// Malloc memory for objects of type t, DIE() if NULL\n#define NEW(p,t) MALLOC(p, t*, sizeof(t))\n\n\n#include <cstdlib>\n\nstruct PoolNode_t\n{\n  char *block;\n  size_t offset;\n  size_t remaining;\n  size_t size;\n  \n  PoolNode_t *next;\n};\n\n\n\n//============================================================ PoolMalloc_t ====\n//------------------------------------------------------------ PoolMalloc_t ----\nPoolMalloc_t::PoolMalloc_t()\n{\n  head_m = NULL;\n}\n\n\n//----------------------------------------------------------- ~PoolMalloc_t ----\nPoolMalloc_t::~PoolMalloc_t()\n{\n  pfree();\n}\n\n\n//-------------------------------------------------------------------- free ----\nvoid PoolMalloc_t::pfree()\n{\n  PoolNode_t * next;\n\n  while ( head_m )\n    {\n      next = head_m->next;\n      free(head_m->block);\n      free(head_m);\n      head_m = next;\n    }\n\n  head_m = NULL;\n}\n\n\n//------------------------------------------------------------------ malloc ----\n///\n/// Parcel memory from big byte buckets. Return all memory with 8 byte\n/// alignment to silence the bus errors on Alpha and Solaris.\n///\nvoid * PoolMalloc_t::pmalloc(size_t size)\n{\n  size_t remainder = size % 8;\n\n  //-- Make sure the next block is 8 byte aligned\n  if ( remainder ) size += 8 - remainder;\n\n  if ( head_m == NULL || size > head_m->remaining )\n    {\n      size_t blockSize = POOLBLOCKSIZE;\n      if ( size > blockSize ) blockSize = size;\n\n      PoolNode_t *newHead;\n      NEW(newHead, PoolNode_t);\n      MALLOC(newHead->block, char*, blockSize);\n      newHead->size = blockSize;\n      newHead->remaining = blockSize;\n      newHead->offset = 0;\n      newHead->next = head_m;\n      head_m = newHead;\n    }\n\n  void *retval = head_m->block + head_m->offset;\n  head_m->offset += size;\n  head_m->remaining -= size;\n\n  return retval;\n}\n\n\n//------------------------------------------------------------------ strdup ----\nchar * PoolMalloc_t::pstrdup(const char * s)\n{\n  size_t size = strlen(s) + 1;\n  char *retval = (char *) pmalloc(size);\n  memcpy(retval, s, size);\n  return retval;\n}\n