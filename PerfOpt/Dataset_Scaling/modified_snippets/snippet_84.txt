\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* ivecop.c  */\n\n#include	<stdio.h>\n#include 	"matrix.h"\n\nstatic	char	rcsid[] = "$Id: ivecop.c,v 1.6 1996/08/20 18:19:21 stewart Exp $";\n\nstatic char    line[MAXLINE];\n\n\n\n/* iv_get -- get integer vector -- see also memory.c */\n#ifndef ANSI_C\nIVEC	*iv_get(dim)\nint	dim;\n#else\nIVEC	*iv_get(int dim)\n#endif\n{\n   IVEC	*iv;\n   /* unsigned int	i; */\n   \n   if (dim < 0)\n     error(E_NEG,"iv_get");\n\n   if ((iv=NEW(IVEC)) == IVNULL )\n     error(E_MEM,"iv_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_IVEC,0,sizeof(IVEC));\n      mem_numvar(TYPE_IVEC,1);\n   }\n   \n   iv->dim = iv->max_dim = dim;\n   if ((iv->ive = NEW_A(dim,int)) == (int *)NULL )\n     error(E_MEM,"iv_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_IVEC,0,dim*sizeof(int));\n   }\n   \n   return (iv);\n}\n\n/* iv_free -- returns iv & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	iv_free(iv)\nIVEC	*iv;\n#else\nint	iv_free(IVEC *iv)\n#endif\n{\n   if ( iv==IVNULL || iv->dim > MAXDIM )\n     /* don't trust it */\n     return (-1);\n   \n   if ( iv->ive == (int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_IVEC,sizeof(IVEC),0);\n	 mem_numvar(TYPE_IVEC,-1);\n      }\n      free((char *)iv);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_IVEC,sizeof(IVEC)+iv->max_dim*sizeof(int),0);\n	 mem_numvar(TYPE_IVEC,-1);\n      }	\n      free((char *)iv->ive);\n      free((char *)iv);\n   }\n   \n   return (0);\n}\n\n/* iv_resize -- returns the IVEC with dimension new_dim\n   -- iv is set to the zero vector */\n#ifndef ANSI_C\nIVEC	*iv_resize(iv,new_dim)\nIVEC	*iv;\nint	new_dim;\n#else\nIVEC	*iv_resize(IVEC *iv, int new_dim)\n#endif\n{\n   int	i;\n   \n   if (new_dim < 0)\n     error(E_NEG,"iv_resize");\n\n   if ( ! iv )\n     return iv_get(new_dim);\n   \n   if (new_dim == iv->dim)\n     return iv;\n\n   if ( new_dim > iv->max_dim )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_IVEC,iv->max_dim*sizeof(int),\n		      new_dim*sizeof(int));\n      }\n      iv->ive = RENEW(iv->ive,new_dim,int);\n      if ( ! iv->ive )\n	error(E_MEM,"iv_resize");\n      iv->max_dim = new_dim;\n   }\n   if ( iv->dim <= new_dim )\n     for ( i = iv->dim; i < new_dim; i++ )\n       iv->ive[i] = 0;\n   iv->dim = new_dim;\n   \n   return iv;\n}\n\n/* iv_copy -- copy integer vector in to out\n   -- out created/resized if necessary */\n#ifndef ANSI_C\nIVEC	*iv_copy(in,out)\nIVEC	*in, *out;\n#else\nIVEC	*iv_copy(const IVEC *in, IVEC *out)\n#endif\n{\n   int		i;\n   \n   if ( ! in )\n     error(E_NULL,"iv_copy");\n   out = iv_resize(out,in->dim);\n   for ( i = 0; i < in->dim; i++ )\n     out->ive[i] = in->ive[i];\n   \n   return out;\n}\n\n/* iv_move -- move selected pieces of an IVEC\n	-- moves the length dim0 subvector with initial index i0\n	   to the corresponding subvector of out with initial index i1\n	-- out is resized if necessary */\n#ifndef ANSI_C\nIVEC	*iv_move(in,i0,dim0,out,i1)\nIVEC	*in, *out;\nint	i0, dim0, i1;\n#else\nIVEC	*iv_move(const IVEC *in, int i0, int dim0, IVEC *out, int i1)\n#endif\n{\n    if ( ! in )\n	error(E_NULL,"iv_move");\n    if ( i0 < 0 || dim0 < 0 || i1 < 0 ||\n	 i0+dim0 > in->dim )\n	error(E_BOUNDS,"iv_move");\n\n    if ( (! out) || i1+dim0 > out->dim )\n	out = iv_resize(out,i1+dim0);\n\n    MEM_COPY(&(in->ive[i0]),&(out->ive[i1]),dim0*sizeof(int));\n\n    return out;\n}\n\n/* iv_add -- integer vector addition -- may be in-situ */\n#ifndef ANSI_C\nIVEC	*iv_add(iv1,iv2,out)\nIVEC	*iv1,*iv2,*out;\n#else\nIVEC	*iv_add(const IVEC *iv1, const IVEC *iv2, IVEC *out)\n#endif\n{\n   unsigned int	i;\n   int	*out_ive, *iv1_ive, *iv2_ive;\n   \n   if ( iv1==IVNULL || iv2==IVNULL )\n     error(E_NULL,"iv_add");\n   if ( iv1->dim != iv2->dim )\n     error(E_SIZES,"iv_add");\n   if ( out==IVNULL || out->dim != iv1->dim )\n     out = iv_resize(out,iv1->dim);\n   \n   out_ive = out->ive;\n   iv1_ive = iv1->ive;\n   iv2_ive = iv2->ive;\n   \n   for ( i = 0; i < iv1->dim; i++ )\n     out_ive[i] = iv1_ive[i] + iv2_ive[i];\n   \n   return (out);\n}\n\n\n\n/* iv_sub -- integer vector addition -- may be in-situ */\n#ifndef ANSI_C\nIVEC	*iv_sub(iv1,iv2,out)\nIVEC	*iv1,*iv2,*out;\n#else\nIVEC	*iv_sub(const IVEC *iv1, const IVEC *iv2, IVEC *out)\n#endif\n{\n   unsigned int	i;\n   int	*out_ive, *iv1_ive, *iv2_ive;\n   \n   if ( iv1==IVNULL || iv2==IVNULL )\n     error(E_NULL,"iv_sub");\n   if ( iv1->dim != iv2->dim )\n     error(E_SIZES,"iv_sub");\n   if ( out==IVNULL || out->dim != iv1->dim )\n     out = iv_resize(out,iv1->dim);\n   \n   out_ive = out->ive;\n   iv1_ive = iv1->ive;\n   iv2_ive = iv2->ive;\n   \n   for ( i = 0; i < iv1->dim; i++ )\n     out_ive[i] = iv1_ive[i] - iv2_ive[i];\n   \n   return (out);\n}\n\n#define	MAX_STACK	60\n\n\n/* iv_sort -- sorts vector x, and generates permutation that gives the order\n   of the components; x = [1.3, 3.7, 0.5] -> [0.5, 1.3, 3.7] and\n   the permutation is order = [2, 0, 1].\n   -- if order is NULL on entry then it is ignored\n   -- the sorted vector x is returned */\n#ifndef ANSI_C\nIVEC	*iv_sort(x, order)\nIVEC	*x;\nPERM	*order;\n#else\nIVEC	*iv_sort(IVEC *x, PERM *order)\n#endif\n{\n   int		*x_ive, tmp, v;\n   /* int		*order_pe; */\n   int		dim, i, j, l, r, tmp_i;\n   int		stack[MAX_STACK], sp;\n   \n   if ( ! x )\n     error(E_NULL,"iv_sort");\n   if ( order != PNULL && order->size != x->dim )\n     order = px_resize(order, x->dim);\n   \n   x_ive = x->ive;\n   dim = x->dim;\n   if ( order != PNULL )\n     px_ident(order);\n   \n   if ( dim <= 1 )\n     return x;\n   \n   /* using quicksort algorithm in Sedgewick,\n      "Algorithms in C", Ch. 9, pp. 118--122 (1990) */\n   sp = 0;\n   l = 0;	r = dim-1;	v = x_ive[0];\n   for ( ; ; )\n   {\n      while ( r > l )\n      {\n	 /* "i = partition(x_ive,l,r);" */\n	 v = x_ive[r];\n	 i = l-1;\n	 j = r;\n	 for ( ; ; )\n	 {\n	    while ( x_ive[++i] < v )\n	      ;\n	    --j;\n	    while ( x_ive[j] > v && j != 0 )\n	      --j;\n	    if ( i >= j )	break;\n	    \n	    tmp = x_ive[i];\n	    x_ive[i] = x_ive[j];\n	    x_ive[j] = tmp;\n	    if ( order != PNULL )\n	    {\n	       tmp_i = order->pe[i];\n	       order->pe[i] = order->pe[j];\n	       order->pe[j] = tmp_i;\n	    }\n	 }\n	 tmp = x_ive[i];\n	 x_ive[i] = x_ive[r];\n	 x_ive[r] = tmp;\n	 if ( order != PNULL )\n	 {\n	    tmp_i = order->pe[i];\n	    order->pe[i] = order->pe[r];\n	    order->pe[r] = tmp_i;\n	 }\n	 \n	 if ( i-l > r-i )\n	 {   stack[sp++] = l;   stack[sp++] = i-1;   l = i+1;   }\n	 else\n	 {   stack[sp++] = i+1;   stack[sp++] = r;   r = i-1;   }\n      }\n      \n      /* recursion elimination */\n      if ( sp == 0 )\n	break;\n      r = stack[--sp];\n      l = stack[--sp];\n   }\n   \n   return x;\n}\n