\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* \n  Tests for mem_info.c functions\n  */\n\nstatic char rcsid[] = "$Id: $";\n\n#include        <stdio.h>\n#include        <math.h>\n#include        "matrix2.h"\n#include 	"sparse2.h"\n#include  	"zmatrix2.h"\n\n\n#define errmesg(mesg)   printf("Error: %s error: line %d\n",mesg,__LINE__)\n#define notice(mesg)    printf("# Testing %s...\n",mesg)\n\n\n/*  new types list */\n\nextern MEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS];\n\n/* the number of a new list */\n#define FOO_LIST 1\n\n/* numbers of types */\n#define TYPE_FOO_1    1\n#define TYPE_FOO_2    2\n\ntypedef struct {\n   int dim;\n   int fix_dim;\n   Real (*a)[10];\n} FOO_1;\n\ntypedef struct {\n  int dim;\n  int fix_dim;\n  Real (*a)[2];\n} FOO_2;\n\n\n\nFOO_1 *foo_1_get(dim)\nint dim;\n{\n   FOO_1 *f;\n   \n   if ((f = (FOO_1 *)malloc(sizeof(FOO_1))) == NULL)\n     error(E_MEM,"foo_1_get");\n   else if (mem_info_is_on()) {\n      mem_bytes_list(TYPE_FOO_1,0,sizeof(FOO_1),FOO_LIST);\n      mem_numvar_list(TYPE_FOO_1,1,FOO_LIST);\n   }\n   \n   f->dim = dim;\n   f->fix_dim = 10;\n   if ((f->a = (Real (*)[10])malloc(dim*sizeof(Real [10]))) == NULL)\n      error(E_MEM,"foo_1_get");\n   else if (mem_info_is_on())\n     mem_bytes_list(TYPE_FOO_1,0,dim*sizeof(Real [10]),FOO_LIST); \n\n   return f;\n}\n\n\nFOO_2 *foo_2_get(dim)\nint dim;\n{\n   FOO_2 *f;\n   \n   if ((f = (FOO_2 *)malloc(sizeof(FOO_2))) == NULL)\n     error(E_MEM,"foo_2_get");\n   else if (mem_info_is_on()) {\n      mem_bytes_list(TYPE_FOO_2,0,sizeof(FOO_2),FOO_LIST);\n      mem_numvar_list(TYPE_FOO_2,1,FOO_LIST);\n   }\n\n   f->dim = dim;\n   f->fix_dim = 2;\n   if ((f->a = (Real (*)[2])malloc(dim*sizeof(Real [2]))) == NULL)\n      error(E_MEM,"foo_2_get");\n   else if (mem_info_is_on())\n     mem_bytes_list(TYPE_FOO_2,0,dim*sizeof(Real [2]),FOO_LIST); \n\n   return f;\n}\n\n\n\nint foo_1_free(f)\nFOO_1 *f;\n{\n   if ( f != NULL) {\n      if (mem_info_is_on()) {\n	 mem_bytes_list(TYPE_FOO_1,sizeof(FOO_1)+\n			f->dim*sizeof(Real [10]),0,FOO_LIST);\n	 mem_numvar_list(TYPE_FOO_1,-1,FOO_LIST);\n      }\n\n      free(f->a);\n      free(f);\n   }\n   return 0;\n}\n\nint foo_2_free(f)\nFOO_2 *f;\n{\n   if ( f != NULL) {\n      if (mem_info_is_on()) {\n	 mem_bytes_list(TYPE_FOO_2,sizeof(FOO_2)+\n			f->dim*sizeof(Real [2]),0,FOO_LIST);\n	 mem_numvar_list(TYPE_FOO_2,-1,FOO_LIST);\n      }\n\n      free(f->a);\n      free(f);\n   }\n   return 0;\n}\n\n\n\n\nchar *foo_type_name[] = {\n   "nothing",\n   "FOO_1",\n   "FOO_2"\n};\n\n\n#define FOO_NUM_TYPES  (sizeof(foo_type_name)/sizeof(*foo_type_name))\n\n\nint (*foo_free_func[FOO_NUM_TYPES])() = {\n   NULL, \n   foo_1_free, \n   foo_2_free\n  };\n\n\n\nstatic MEM_ARRAY foo_info_sum[FOO_NUM_TYPES];\n\n\n\n  /* px_rand -- generates sort-of random permutation */\nPERM    *px_rand(pi)\nPERM    *pi;\n{\n   int         i, j, k;\n   \n   if ( ! pi )\n     error(E_NULL,"px_rand");\n   \n   for ( i = 0; i < 3*pi->size; i++ )\n   {\n      j = (rand() >> 8) % pi->size;\n      k = (rand() >> 8) % pi->size;\n      px_transp(pi,j,k);\n   }\n   \n   return pi;\n}\n\n#ifdef SPARSE\nSPMAT  *gen_non_symm(m,n)\nint     m, n;\n{\n    SPMAT      *A;\n    static      PERM    *px = PNULL;\n    int         i, j, k, k_max;\n    Real        s1;\n\n    A = sp_get(m,n,8);\n    px = px_resize(px,n);\n    MEM_STAT_REG(px,TYPE_PERM);\n    for ( i = 0; i < A->m; i++ )\n    {\n        k_max = 1 + ((rand() >> 8) % 10);\n        for ( k = 0; k < k_max; k++ )\n        {\n            j = (rand() >> 8) % A->n;\n            s1 = rand()/((double)MAX_RAND);\n            sp_set_val(A,i,j,s1);\n        }\n    }\n    /* to make it likely that A is nonsingular, use pivot... */\n    for ( i = 0; i < 2*A->n; i++ )\n    {\n        j = (rand() >> 8) % A->n;\n        k = (rand() >> 8) % A->n;\n        px_transp(px,j,k);\n    }\n    for ( i = 0; i < A->n; i++ )\n        sp_set_val(A,i,px->pe[i],1.0);\n\n    \n    return A;\n}\n#endif\n\nvoid stat_test1(par)\nint par;\n{\n   static MAT *AT = MNULL;\n   static VEC *xt1 = VNULL, *yt1 = VNULL;\n   static VEC *xt2 = VNULL, *yt2 = VNULL;\n   static VEC *xt3 = VNULL, *yt3 = VNULL;\n   static VEC *xt4 = VNULL, *yt4 = VNULL;\n\n   AT = m_resize(AT,10,10);\n   xt1 = v_resize(xt1,10);\n   yt1 = v_resize(yt1,10);\n   xt2 = v_resize(xt2,10);\n   yt2 = v_resize(yt2,10);\n   xt3 = v_resize(xt3,10);\n   yt3 = v_resize(yt3,10);\n   xt4 = v_resize(xt4,10);\n   yt4 = v_resize(yt4,10);\n\n   MEM_STAT_REG(AT,TYPE_MAT);\n\n#ifdef ANSI_C\n   mem_stat_reg_vars(0,TYPE_VEC,__FILE__,__LINE__,&xt1,&xt2,&xt3,&xt4,&yt1,\n		     &yt2,&yt3,&yt4,NULL);\n#else\n#ifdef VARARGS\n   mem_stat_reg_vars(0,TYPE_VEC,__FILE__,__LINE__,&xt1,&xt2,&xt3,&xt4,&yt1,\n		     &yt2,&yt3,&yt4,NULL);\n#else\n   MEM_STAT_REG(xt1,TYPE_VEC);\n   MEM_STAT_REG(yt1,TYPE_VEC);\n   MEM_STAT_REG(xt2,TYPE_VEC);\n   MEM_STAT_REG(yt2,TYPE_VEC);\n   MEM_STAT_REG(xt3,TYPE_VEC);\n   MEM_STAT_REG(yt3,TYPE_VEC);\n   MEM_STAT_REG(xt4,TYPE_VEC);\n   MEM_STAT_REG(yt4,TYPE_VEC);\n#endif\n#endif\n\n   v_rand(xt1);\n   m_rand(AT);\n   mv_mlt(AT,xt1,yt1);\n   \n}\n\n\nvoid stat_test2(par)\nint par;\n{\n   static PERM *px = PNULL;\n   static IVEC *ixt = IVNULL, *iyt = IVNULL;\n   \n   px = px_resize(px,10);\n   ixt = iv_resize(ixt,10);\n   iyt = iv_resize(iyt,10);\n\n   MEM_STAT_REG(px,TYPE_PERM);\n   MEM_STAT_REG(ixt,TYPE_IVEC);\n   MEM_STAT_REG(iyt,TYPE_IVEC);\n\n   px_rand(px);\n   px_inv(px,px);\n}\n\n#ifdef SPARSE\nvoid stat_test3(par)\nint par;\n{\n   static SPMAT *AT = (SPMAT *)NULL;\n   static VEC *xt = VNULL, *yt = VNULL;\n   static SPROW *r = (SPROW *) NULL;\n   \n   if (AT == (SPMAT *)NULL)\n     AT = gen_non_symm(100,100);\n   else\n     AT = sp_resize(AT,100,100);\n   xt = v_resize(xt,100);\n   yt = v_resize(yt,100);\n   if (r == NULL) r = sprow_get(100);\n\n   MEM_STAT_REG(AT,TYPE_SPMAT);\n   MEM_STAT_REG(xt,TYPE_VEC);\n   MEM_STAT_REG(yt,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_SPROW);\n\n   v_rand(xt);\n   sp_mv_mlt(AT,xt,yt);\n   \n}\n#endif\n\n#ifdef COMPLEX\nvoid stat_test4(par)\nint par;\n{\n   static ZMAT *AT = ZMNULL;\n   static ZVEC *xt = ZVNULL, *yt = ZVNULL;\n   \n   AT = zm_resize(AT,10,10);\n   xt = zv_resize(xt,10);\n   yt = zv_resize(yt,10);\n\n   MEM_STAT_REG(AT,TYPE_ZMAT);\n   MEM_STAT_REG(xt,TYPE_ZVEC);\n   MEM_STAT_REG(yt,TYPE_ZVEC);\n\n   zv_rand(xt);\n   zm_rand(AT);\n   zmv_mlt(AT,xt,yt);\n   \n}\n#endif\n\n\nvoid main(argc, argv)\nint     argc;\nchar    *argv[];\n{\n   VEC  *x = VNULL, *y = VNULL, *z = VNULL;\n   PERM  *pi1 = PNULL, *pi2 = PNULL, *pi3 = PNULL;\n   MAT   *A = MNULL, *B = MNULL, *C = MNULL;\n#ifdef SPARSE\n   SPMAT *sA, *sB;\n   SPROW *r;\n#endif\n   IVEC *ix = IVNULL, *iy = IVNULL, *iz = IVNULL;\n   int m,n,i,j,deg,k;\n   Real s1,s2;\n#ifdef COMPLEX\n   ZVEC        *zx = ZVNULL, *zy = ZVNULL, *zz = ZVNULL;\n   ZMAT        *zA = ZMNULL, *zB = ZMNULL, *zC = ZMNULL;\n   complex     ONE;\n#endif\n   /* variables for testing attaching new lists of types  */\n   FOO_1 *foo_1;\n   FOO_2 *foo_2;\n\n\n   mem_info_on(TRUE);\n\n#if defined(ANSI_C) || defined(VARARGS)\n\n   notice("vector initialize, copy & resize");\n   \n   n = v_get_vars(15,&x,&y,&z,(VEC **)NULL);\n   if (n != 3) {\n      errmesg("v_get_vars");\n      printf(" n = %d (should be 3)\n",n);\n   }\n\n   v_rand(x);\n   v_rand(y);\n   z = v_copy(x,z);\n   if ( v_norm2(v_sub(x,z,z)) >= MACHEPS )\n     errmesg("v_get_vars");\n   v_copy(x,y);\n   n = v_resize_vars(10,&x,&y,&z,NULL);\n   if ( n != 3 || v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg("VEC copy/resize");\n\n   n = v_resize_vars(20,&x,&y,&z,NULL);\n   if ( n != 3 || v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg("VEC resize"); \n\n   n = v_free_vars(&x,&y,&z,NULL);\n   if (n != 3)\n     errmesg("v_free_vars");\n   \n   /* IVEC */\n   notice("int vector initialise, copy & resize");\n   n = iv_get_vars(15,&ix,&iy,&iz,NULL);\n\n   if (n != 3) {\n      errmesg("iv_get_vars");\n      printf(" n = %d (should be 3)\n",n);\n   }\n   for (i=0; i < ix->dim; i++) {\n      ix->ive[i] = 2*i-1;\n      iy->ive[i] = 3*i+2;\n   }\n   iz = iv_add(ix,iy,iz);\n   for (i=0; i < ix->dim; i++) \n     if ( iz->ive[i] != 5*i+1)\n       errmesg("iv_get_vars");\n   \n   n = iv_resize_vars(10,&ix,&iy,&iz,NULL);\n   if ( n != 3) errmesg("IVEC copy/resize");\n   \n   iv_add(ix,iy,iz);\n   for (i=0; i < ix->dim; i++)\n     if (iz->ive[i] != 5*i+1)\n       errmesg("IVEC copy/resize");\n   \n   n = iv_resize_vars(20,&ix,&iy,&iz,NULL);\n   if ( n != 3 ) errmesg("IVEC resize");\n   \n   iv_add(ix,iy,iz);\n   for (i=0; i < 10; i++)\n     if (iz->ive[i] != 5*i+1)\n       errmesg("IVEC copy/resize");\n   \n   n = iv_free_vars(&ix,&iy,&iz,NULL);\n   if (n != 3) \n     errmesg("iv_free_vars");\n   \n   /* MAT */\n   notice("matrix initialise, copy & resize");\n   n = m_get_vars(10,10,&A,&B,&C,NULL);\n   if (n != 3) {\n      errmesg("m_get_vars");\n      printf(" n = %d (should be 3)\n",n);\n   }\n   \n   m_rand(A);\n   m_rand(B);\n   C = m_copy(A,C);\n   if ( m_norm_inf(m_sub(A,C,C)) >= MACHEPS )\n     errmesg("MAT copy");\n   m_copy(A,B);\n   n = m_resize_vars(5,5,&A,&B,&C,NULL);\n   if ( n != 3 || m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n     errmesg("MAT copy/resize");\n   \n   n = m_resize_vars(20,20,&A,&B,NULL);\n   if ( m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n     errmesg("MAT resize"); \n   \n   k = m_free_vars(&A,&B,&C,NULL);\n   if ( k != 3 )\n     errmesg("MAT free");\n   \n   /* PERM */\n   notice("permutation initialise, inverting & permuting vectors");\n   n = px_get_vars(15,&pi1,&pi2,&pi3,NULL);\n   if (n != 3) {\n      errmesg("px_get_vars");\n      printf(" n = %d (should be 3)\n",n);\n   }\n\n   v_get_vars(15,&x,&y,&z,NULL);\n   \n   px_rand(pi1);\n   v_rand(x);\n   px_vec(pi1,x,z);\n   y = v_resize(y,x->dim);\n   pxinv_vec(pi1,z,y);\n   if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg("PERMute vector");\n   pi2 = px_inv(pi1,pi2);\n   pi3 = px_mlt(pi1,pi2,pi3);\n   for ( i = 0; i < pi3->size; i++ )\n     if ( pi3->pe[i] != i )\n       errmesg("PERM inverse/multiply");\n   \n   px_resize_vars(20,&pi1,&pi2,&pi3,NULL);\n   v_resize_vars(20,&x,&y,&z,NULL);\n   \n   px_rand(pi1);\n   v_rand(x);\n   px_vec(pi1,x,z);\n   pxinv_vec(pi1,z,y);\n   if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg("PERMute vector");\n   pi2 = px_inv(pi1,pi2);\n   pi3 = px_mlt(pi1,pi2,pi3);\n   for ( i = 0; i < pi3->size; i++ )\n     if ( pi3->pe[i] != i )\n       errmesg("PERM inverse/multiply");\n   \n   n = px_free_vars(&pi1,&pi2,&pi3,NULL);\n   if ( n != 3 )\n     errmesg("PERM px_free_vars"); \n\n#ifdef SPARSE   \n   /* set up two random sparse matrices */\n   m = 120;\n   n = 100;\n   deg = 5;\n   notice("allocating sparse matrices");\n   k = sp_get_vars(m,n,deg,&sA,&sB,NULL);\n   if (k != 2) {\n      errmesg("sp_get_vars");\n      printf(" n = %d (should be 2)\n",k);\n   }\n   \n   notice("setting and getting matrix entries");\n   for ( k = 0; k < m*deg; k++ )\n   {\n      i = (rand() >> 8) % m;\n      j = (rand() >> 8) % n;\n      sp_set_val(sA,i,j,rand()/((Real)MAX_RAND));\n      i = (rand() >> 8) % m;\n      j = (rand() >> 8) % n;\n      sp_set_val(sB,i,j,rand()/((Real)MAX_RAND));\n   }\n   for ( k = 0; k < 10; k++ )\n   {\n      s1 = rand()/((Real)MAX_RAND);\n      i = (rand() >> 8) % m;\n      j = (rand() >> 8) % n;\n      sp_set_val(sA,i,j,s1);\n      s2 = sp_get_val(sA,i,j);\n      if ( fabs(s1 - s2) >= MACHEPS ) {\n	 printf(" s1 = %g, s2 = %g, |s1 - s2| = %g\n", \n		s1,s2,fabs(s1-s2));\n	 break;\n      }\n   }\n   if ( k < 10 )\n     errmesg("sp_set_val()/sp_get_val()");\n   \n   /* check column access paths */\n   notice("resizing and access paths");\n   k = sp_resize_vars(sA->m+10,sA->n+10,&sA,&sB,NULL);\n   if (k != 2) {\n      errmesg("sp_get_vars");\n      printf(" n = %d (should be 2)\n",k);\n   }\n   \n   for ( k = 0 ; k < 20; k++ )\n   {\n      i = sA->m - 1 - ((rand() >> 8) % 10);\n      j = sA->n - 1 - ((rand() >> 8) % 10);\n      s1 = rand()/((Real)MAX_RAND);\n      sp_set_val(sA,i,j,s1);\n      if ( fabs(s1 - sp_get_val(sA,i,j)) >= MACHEPS )\n	break;\n   }\n   if ( k < 20 )\n     errmesg("sp_resize()");\n   sp_col_access(sA);\n   if ( ! chk_col_access(sA) )\n   {\n      errmesg("sp_col_access()");\n   }\n   sp_diag_access(sA);\n   for ( i = 0; i < sA->m; i++ )\n   {\n      r = &(sA->row[i]);\n      if ( r->diag != sprow_idx(r,i) )\n	break;\n   }\n   if ( i < sA->m )\n   {\n      errmesg("sp_diag_access()");\n   }\n   \n   k = sp_free_vars(&sA,&sB,NULL);\n   if (k != 2)\n     errmesg("sp_free_vars");\n#endif  /* SPARSE */   \n\n\n#ifdef COMPLEX\n   /* complex stuff */\n   \n   ONE = zmake(1.0,0.0);\n   printf("# ONE = "); z_output(ONE);\n   printf("# Check: MACHEPS = %g\n",MACHEPS);\n   /* allocate, initialise, copy and resize operations */\n   /* ZVEC */\n   notice("vector initialise, copy & resize");\n   zv_get_vars(12,&zx,&zy,&zz,NULL);\n   \n   zv_rand(zx);\n   zv_rand(zy);\n   zz = zv_copy(zx,zz);\n   if ( zv_norm2(zv_sub(zx,zz,zz)) >= MACHEPS )\n     errmesg("ZVEC copy");\n   zv_copy(zx,zy);\n   \n   zv_resize_vars(10,&zx,&zy,NULL);\n   if ( zv_norm2(zv_sub(zx,zy,zz)) >= MACHEPS )\n     errmesg("ZVEC copy/resize");\n   \n   zv_resize_vars(20,&zx,&zy,NULL);\n   if ( zv_norm2(zv_sub(zx,zy,zz)) >= MACHEPS )\n     errmesg("VZEC resize");\n   zv_free_vars(&zx,&zy,&zz,NULL);\n\n   \n   /* ZMAT */\n   notice("matrix initialise, copy & resize");\n   zm_get_vars(8,5,&zA,&zB,&zC,NULL);\n   \n   zm_rand(zA);\n   zm_rand(zB);\n   zC = zm_copy(zA,zC);\n   if ( zm_norm_inf(zm_sub(zA,zC,zC)) >= MACHEPS )\n     errmesg("ZMAT copy");\n   \n   zm_copy(zA,zB);\n   zm_resize_vars(3,5,&zA,&zB,&zC,NULL);\n   \n   if ( zm_norm_inf(zm_sub(zA,zB,zC)) >= MACHEPS )\n     errmesg("ZMAT copy/resize");\n   zm_resize_vars(20,20,&zA,&zB,&zC,NULL);\n   \n   if ( zm_norm_inf(zm_sub(zA,zB,zC)) >= MACHEPS )\n     errmesg("ZMAT resize");\n   \n   zm_free_vars(&zA,&zB,&zC,NULL);\n#endif /* COMPLEX */\n\n#endif  /* if defined(ANSI_C) || defined(VARARGS) */\n\n   printf("# test of mem_info_bytes and mem_info_numvar\n");\n   printf("  TYPE VEC: %ld bytes allocated, %d variables allocated\n",\n	  mem_info_bytes(TYPE_VEC,0),mem_info_numvar(TYPE_VEC,0));\n\n   notice("static memory test");\n   mem_info_on(TRUE);\n   mem_stat_mark(1);\n   for (i=0; i < 100; i++)\n     stat_test1(i);\n   mem_stat_free(1);\n\n   mem_stat_mark(1);\n   for (i=0; i < 100; i++) {\n     stat_test1(i);\n#ifdef COMPLEX\n     stat_test4(i);\n#endif\n  }\n\n   mem_stat_mark(2);\n   for (i=0; i < 100; i++)\n     stat_test2(i);\n\n   mem_stat_mark(3);\n#ifdef SPARSE\n   for (i=0; i < 100; i++)\n     stat_test3(i);\n#endif\n\n   mem_info();\n   mem_dump_list(stdout,0);\n\n   mem_stat_free(1);\n   mem_stat_free(3);\n   mem_stat_mark(4);\n\n   for (i=0; i < 100; i++) {\n      stat_test1(i);\n#ifdef COMPLEX\n      stat_test4(i);\n#endif\n   } \n\n   mem_stat_dump(stdout,0);\n   if (mem_stat_show_mark() != 4) {\n      errmesg("not 4 in mem_stat_show_mark()");\n   }\n   \n   mem_stat_free(2);\n   mem_stat_free(4);\n\n   if (mem_stat_show_mark() != 0) {\n      errmesg("not 0 in mem_stat_show_mark()");\n   }\n\n   /* add new list of types */\n\n   mem_attach_list(FOO_LIST,FOO_NUM_TYPES,foo_type_name,\n		   foo_free_func,foo_info_sum);\n   if (!mem_is_list_attached(FOO_LIST))\n     errmesg("list FOO_LIST is not attached");\n\n   mem_dump_list(stdout,FOO_LIST);\n   foo_1 = foo_1_get(6);\n   foo_2 = foo_2_get(3);\n   for (i=0; i < foo_1->dim; i++)\n     for (j=0; j < foo_1->fix_dim; j++)\n       foo_1->a[i][j] = i+j;\n   for (i=0; i < foo_2->dim; i++)\n     for (j=0; j < foo_2->fix_dim; j++)\n       foo_2->a[i][j] = i+j;\n   printf(" foo_1->a[%d][%d] = %g\n",5,9,foo_1->a[5][9]);\n   printf(" foo_2->a[%d][%d] = %g\n",2,1,foo_2->a[2][1]);\n   \n   mem_stat_mark(5);\n   mem_stat_reg_list((void **)&foo_1,TYPE_FOO_1,FOO_LIST,__FILE__,__LINE__);\n   mem_stat_reg_list((void **)&foo_2,TYPE_FOO_2,FOO_LIST,__FILE__,__LINE__);\n   mem_stat_dump(stdout,FOO_LIST);\n   mem_info_file(stdout,FOO_LIST);\n   mem_stat_free_list(5,FOO_LIST);\n   mem_stat_dump(stdout,FOO_LIST);\n   if ( foo_1 != NULL )\n     errmesg(" foo_1 is not released");\n   if ( foo_2 != NULL )\n     errmesg(" foo_2 is not released");\n   mem_dump_list(stdout,FOO_LIST);\n   mem_info_file(stdout,FOO_LIST);\n\n   mem_free_vars(FOO_LIST);\n   if ( mem_is_list_attached(FOO_LIST) )\n     errmesg("list FOO_LIST is not detached");\n\n   mem_info();\n   \n#if REAL == FLOAT\n   printf("# SINGLE PRECISION was used\n");\n#elif REAL == DOUBLE\n   printf("# DOUBLE PRECISION was used\n");\n#endif\n\n#define ANSI_OR_VAR\n\n#ifndef ANSI_C\n#ifndef VARARGS\n#undef ANSI_OR_VAR\n#endif\n#endif\n\n#ifdef ANSI_OR_VAR\n\n   printf("# you should get: \n");\n#if (REAL == FLOAT)\n     printf("#   type VEC: 276 bytes allocated, 3 variables allocated\n");\n#elif (REAL == DOUBLE)\n     printf("#   type VEC: 516 bytes allocated, 3 variables allocated\n");\n#endif\n   printf("#   and other types are zeros\n");\n\n#endif /*#if defined(ANSI_C) || defined(VARAGS) */\n\n   printf("# Finished memory torture test\n");\n\n   dmalloc_shutdown();\n   return;\n}\n