\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  This file contains basic routines which are used by the functions\n  in matrix.a etc.\n  These are the routines that should be modified in order to take\n  full advantage of specialised architectures (pipelining, vector\n  processors etc).\n  */\nstatic	char	*rcsid = "$Header: /usr/local/home/des/meschach/meschach/RCS/machine.c,v 1.3 1991/08/29 06:42:11 des Exp $";\n\n#include	"machine.h"\n\n/* __ip__ -- inner product */\ndouble	__ip__(dp1,dp2,len)\nregister double	*dp1, *dp2;\nint	len;\n{\n    register int	len4;\n    register int	i;\n    register double	sum0, sum1, sum2, sum3;\n    \n    sum0 = sum1 = sum2 = sum3 = 0.0;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    \n    for ( i = 0; i < len4; i++ )\n    {\n	sum0 += dp1[4*i]*dp2[4*i];\n	sum1 += dp1[4*i+1]*dp2[4*i+1];\n	sum2 += dp1[4*i+2]*dp2[4*i+2];\n	sum3 += dp1[4*i+3]*dp2[4*i+3];\n    }\n    sum0 += sum1 + sum2 + sum3;\n    dp1 += 4*len4;	dp2 += 4*len4;\n    \n    for ( i = 0; i < len; i++ )\n	sum0 += (*dp1++)*(*dp2++);\n    \n    return sum0;\n}\n\n/* __mltadd__ -- scalar multiply and add c.f. v_mltadd() */\nvoid	__mltadd__(dp1,dp2,s,len)\nregister double	*dp1, *dp2, s;\nregister int	len;\n{\n    register int	i, len4;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    for ( i = 0; i < len4; i++ )\n    {\n	dp1[4*i]   += s*dp2[4*i];\n	dp1[4*i+1] += s*dp2[4*i+1];\n	dp1[4*i+2] += s*dp2[4*i+2];\n	dp1[4*i+3] += s*dp2[4*i+3];\n    }\n    dp1 += 4*len4;	dp2 += 4*len4;\n    \n    for ( i = 0; i < len; i++ )\n	(*dp1++) += s*(*dp2++);\n}\n\n/* __smlt__ scalar multiply array c.f. sv_mlt() */\nvoid	__smlt__(dp,s,out,len)\nregister double	*dp, s, *out;\nregister int	len;\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	(*out++) = s*(*dp++);\n}\n\n/* __add__ -- add arrays c.f. v_add() */\nvoid	__add__(dp1,dp2,out,len)\nregister double	*dp1, *dp2, *out;\nregister int	len;\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	(*out++) = (*dp1++) + (*dp2++);\n}\n\n/* __sub__ -- subtract arrays c.f. v_sub() */\nvoid	__sub__(dp1,dp2,out,len)\nregister double	*dp1, *dp2, *out;\nregister int	len;\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	(*out++) = (*dp1++) - (*dp2++);\n}\n\n/* __zero__ -- zeros an array of double precision numbers */\nvoid	__zero__(dp,len)\nregister double	*dp;\nregister int	len;\n{\n    /* if a double precision zero is equivalent to a string of nulls */\n    MEM_ZERO((char *)dp,len*sizeof(double));\n    /* else, need to zero the array entry by entry */\n    /*************************************************\n      while ( len-- )\n      *dp++ = 0.0;\n      *************************************************/\n}\n\n/***********************************************************************\n ******			Faster versions				********\n ***********************************************************************/\n\n/* __ip4__ -- compute 4 inner products in one go */\nvoid	__ip4__(v0,v1,v2,v3,w,out,len)\ndouble	*v0, *v1, *v2, *v3, *w;\ndouble	out[4];\nint	len;\n{\n    register int	i, len2;\n    register double	sum00, sum10, sum20, sum30, w_val0;\n    register double	sum01, sum11, sum21, sum31, w_val1;\n    \n    len2 = len / 2;\n    len  = len % 2;\n    sum00 = sum10 = sum20 = sum30 = 0.0;\n    sum01 = sum11 = sum21 = sum31 = 0.0;\n    for ( i = 0; i < len2; i++ )\n    {\n	w_val0 = w[2*i];\n	w_val1 = w[2*i+1];\n	sum00 += v0[2*i]  *w_val0;\n	sum01 += v0[2*i+1]*w_val1;\n	sum10 += v1[2*i]  *w_val0;\n	sum11 += v1[2*i+1]*w_val1;\n	sum20 += v2[2*i]  *w_val0;\n	sum21 += v2[2*i+1]*w_val1;\n	sum30 += v3[2*i]  *w_val0;\n	sum31 += v3[2*i+1]*w_val1;\n    }\n    w += 2*len2;\n    v0 += 2*len2;\n    v1 += 2*len2;\n    v2 += 2*len2;\n    v3 += 2*len2;\n    for ( i = 0; i < len; i++ )\n    {\n	w_val0 = w[i];\n	sum00 += v0[i]*w_val0;\n	sum10 += v1[i]*w_val0;\n	sum20 += v2[i]*w_val0;\n	sum30 += v3[i]*w_val0;\n    }\n    out[0] = sum00 + sum01;\n    out[1] = sum10 + sum11;\n    out[2] = sum20 + sum21;\n    out[3] = sum30 + sum31;\n}\n\n/* __lc4__ -- linear combinations: w <- w+a[0]*v0+ ... + a[3]*v3 */\nvoid	__lc4__(v0,v1,v2,v3,w,a,len)\ndouble	*v0, *v1, *v2, *v3, *w;\ndouble	a[4];\nint	len;\n{\n    register int	i, len2;\n    register double	a0, a1, a2, a3, tmp0, tmp1;\n    \n    len2 = len / 2;\n    len  = len % 2;\n    \n    a0 = a[0];	a1 = a[1];\n    a2 = a[2];	a3 = a[3];\n    for ( i = 0; i < len2; i++ )\n    {\n	tmp0 = w[2*i]   + a0*v0[2*i];\n	tmp1 = w[2*i+1] + a0*v0[2*i+1];\n	tmp0 += a1*v1[2*i];\n	tmp1 += a1*v1[2*i+1];\n	tmp0 += a2*v2[2*i];\n	tmp1 += a2*v2[2*i+1];\n	tmp0 += a3*v3[2*i];\n	tmp1 += a3*v3[2*i+1];\n	w[2*i]   = tmp0;\n	w[2*i+1] = tmp1;\n    }\n    w += 2*len2;\n    v0 += 2*len2;\n    v1 += 2*len2;\n    v2 += 2*len2;\n    v3 += 2*len2;\n    for ( i = 0; i < len; i++ )\n	w[i] += a0*v0[i] + a1*v1[i] + a2*v2[i] + a3*v3[i];\n}\n\n/* __ma4__ -- multiply and add with 4 vectors: vi <- vi + ai*w */\nvoid	__ma4__(v0,v1,v2,v3,w,a,len)\ndouble	*v0, *v1, *v2, *v3, *w;\ndouble	a[4];\nint	len;\n{\n    register int	i;\n    register double	a0, a1, a2, a3, w0, w1, w2, w3;\n\n    a0 = a[0];	a1 = a[1];\n    a2 = a[2];	a3 = a[3];\n    for ( i = 0; i < len; i++ )\n    {\n	w0 = w[i];\n	v0[i] += a0*w0;\n	v1[i] += a1*w0;\n	v2[i] += a2*w0;\n	v3[i] += a3*w0;\n    }\n}\n