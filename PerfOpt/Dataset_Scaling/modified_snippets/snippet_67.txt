\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file has the routines for sparse matrix input/output\n	It works in conjunction with sparse.c, sparse.h etc\n*/\n\n#include        <stdio.h>\n#include        "sparse.h"\n\nstatic char rcsid[] = "$Id: sparseio.c,v 1.4 1994/01/13 05:34:25 des Exp $";\n\n\n\n/* local variables */\nstatic char line[MAXLINE];\n\n/* sp_foutput -- output sparse matrix A to file/stream fp */\n#ifndef ANSI_C\nvoid    sp_foutput(fp,A)\nFILE    *fp;\nSPMAT  *A;\n#else\nvoid    sp_foutput(FILE *fp, const SPMAT *A)\n#endif\n{\n	int     i, j_idx, m /* , n */;\n	SPROW  *rows;\n	row_elt *elts;\n\n	fprintf(fp,"SparseMatrix: ");\n	if ( A == SMNULL )\n	{\n		fprintf(fp,"*** NULL ***\n");\n		error(E_NULL,"sp_foutput");    return;\n	}\n	fprintf(fp,"%d by %d\n",A->m,A->n);\n	m = A->m;       /* n = A->n; */\n	if ( ! (rows=A->row) )\n	{\n		fprintf(fp,"*** NULL rows ***\n");\n		error(E_NULL,"sp_foutput");    return;\n	}\n\n	for ( i = 0; i < m; i++ )\n	{\n		fprintf(fp,"row %d: ",i);\n		if ( ! (elts=rows[i].elt) )\n		{\n			fprintf(fp,"*** NULL element list ***\n");\n			continue;\n		}\n		for ( j_idx = 0; j_idx < rows[i].len; j_idx++ )\n		{\n			fprintf(fp,"%d:%-20.15g ",elts[j_idx].col,\n							elts[j_idx].val);\n			if ( j_idx % 3 == 2 && j_idx != rows[i].len-1 )\n				fprintf(fp,"\n     ");\n		}\n		fprintf(fp,"\n");\n	}\n	fprintf(fp,"#\n");	/* to stop looking beyond for next entry */\n}\n\n/* sp_foutput2 -- print out sparse matrix **as a dense matrix**\n	-- see output format used in matrix.h etc */\n/******************************************************************\nvoid    sp_foutput2(fp,A)\nFILE    *fp;\nSPMAT  *A;\n{\n	int     cnt, i, j, j_idx;\n	SPROW  *r;\n	row_elt *elt;\n\n	if ( A == SMNULL )\n	{\n		fprintf(fp,"Matrix: *** NULL ***\n");\n		return;\n	}\n	fprintf(fp,"Matrix: %d by %d\n",A->m,A->n);\n	for ( i = 0; i < A->m; i++ )\n	{\n		fprintf(fp,"row %d:",i);\n		r = &(A->row[i]);\n		elt = r->elt;\n		cnt = j = j_idx = 0;\n		while ( j_idx < r->len || j < A->n )\n		{\n			if ( j_idx >= r->len )\n				fprintf(fp,"%14.9g ",0.0);\n			else if ( j < elt[j_idx].col )\n				fprintf(fp,"%14.9g ",0.0);\n			else\n				fprintf(fp,"%14.9g ",elt[j_idx++].val);\n			if ( cnt++ % 4 == 3 )\n				fprintf(fp,"\n");\n			j++;\n		}\n		fprintf(fp,"\n");\n	}\n}\n******************************************************************/\n\n/* sp_dump -- prints ALL relevant information about the sparse matrix A */\n#ifndef ANSI_C\nvoid    sp_dump(fp,A)\nFILE    *fp;\nSPMAT  *A;\n#else\nvoid    sp_dump(FILE *fp, const SPMAT *A)\n#endif\n{\n	int     i, j, j_idx;\n	SPROW  *rows;\n	row_elt *elts;\n\n	fprintf(fp,"SparseMatrix dump:\n");\n	if ( ! A )\n	{       fprintf(fp,"*** NULL ***\n");   return; }\n	fprintf(fp,"Matrix at 0x%lx\n",(long)A);\n	fprintf(fp,"Dimensions: %d by %d\n",A->m,A->n);\n	fprintf(fp,"MaxDimensions: %d by %d\n",A->max_m,A->max_n);\n	fprintf(fp,"flag_col = %d, flag_diag = %d\n",A->flag_col,A->flag_diag);\n	fprintf(fp,"start_row @ 0x%lx:\n",(long)(A->start_row));\n	for ( j = 0; j < A->n; j++ )\n	{\n		fprintf(fp,"%d ",A->start_row[j]);\n		if ( j % 10 == 9 )\n			fprintf(fp,"\n");\n	}\n	fprintf(fp,"\n");\n	fprintf(fp,"start_idx @ 0x%lx:\n",(long)(A->start_idx));\n	for ( j = 0; j < A->n; j++ )\n	{\n		fprintf(fp,"%d ",A->start_idx[j]);\n		if ( j % 10 == 9 )\n			fprintf(fp,"\n");\n	}\n	fprintf(fp,"\n");\n	fprintf(fp,"Rows @ 0x%lx:\n",(long)(A->row));\n	if ( ! A->row )\n	{       fprintf(fp,"*** NULL row ***\n");       return; }\n	rows = A->row;\n	for ( i = 0; i < A->m; i++ )\n	{\n		fprintf(fp,"row %d: len = %d, maxlen = %d, diag idx = %d\n",\n			i,rows[i].len,rows[i].maxlen,rows[i].diag);\n		fprintf(fp,"element list @ 0x%lx\n",(long)(rows[i].elt));\n		if ( ! rows[i].elt )\n		{\n			fprintf(fp,"*** NULL element list ***\n");\n			continue;\n		}\n		elts = rows[i].elt;\n		for ( j_idx = 0; j_idx < rows[i].len; j_idx++, elts++ )\n		    fprintf(fp,"Col: %d, Val: %g, nxt_row = %d, nxt_idx = %d\n",\n			elts->col,elts->val,elts->nxt_row,elts->nxt_idx);\n		fprintf(fp,"\n");\n	}\n}\n\n#define MINSCRATCH      100\n\n/* sp_finput -- input sparse matrix from stream/file fp\n	-- uses friendly input routine if fp is a tty\n	-- uses format identical to output format otherwise */\n#ifndef ANSI_C\nSPMAT  *sp_finput(fp)\nFILE    *fp;\n#else\nSPMAT  *sp_finput(FILE *fp)\n#endif\n{\n	int     i, len, ret_val;\n	int     col, curr_col, m, n, tmp, tty;\n	Real  val;\n	SPMAT  *A;\n	SPROW  *rows;\n\n	static row_elt *scratch;\n	static int	scratch_len = 0;\n\n	if ( ! scratch )\n	  {\n	    scratch = NEW_A(MINSCRATCH,row_elt);\n	    if ( scratch == NULL )\n	      error(E_MEM,"sp_finput");\n	    scratch_len = MINSCRATCH;\n	  }\n\n	for ( i = 0; i < scratch_len; i++ )\n	  scratch[i].nxt_row = scratch[i].nxt_idx = -1;\n\n	tty = isatty(fileno(fp));\n\n	if ( tty )\n	{\n		fprintf(stderr,"SparseMatrix: ");\n		do {\n			fprintf(stderr,"input rows cols: ");\n			if ( ! fgets(line,MAXLINE,fp) )\n			    error(E_INPUT,"sp_finput");\n		} while ( sscanf(line,"%u %u",&m,&n) != 2 );\n		A = sp_get(m,n,5);\n		rows = A->row;\n\n		for ( i = 0; i < m; i++ )\n		{\n		    /* get a row... */\n		    fprintf(stderr,"Row %d:\n",i);\n		    fprintf(stderr,"Enter <col> <val> or 'e' to end row\n");\n		    curr_col = -1;\n\n		    len = 0;\n		    for ( ; ; )  /* forever do... */\n		      {\n		      /* if we need more scratch space, let's get it!\n		       -- using amortized doubling */\n		      if ( len >= scratch_len )\n			{\n			  scratch = RENEW(scratch,2*scratch_len,row_elt);\n			  if ( ! scratch )\n			    error(E_MEM,"sp_finput");\n			  scratch_len = 2*scratch_len;\n			}\n			do {  /* get an entry... */\n			    fprintf(stderr,"Entry %d: ",len);\n			    if ( ! fgets(line,MAXLINE,fp) )\n				error(E_INPUT,"sp_finput");\n			    if ( *line == 'e' || *line == 'E' )\n				break;\n#if REAL == DOUBLE\n			} while ( sscanf(line,"%u %lf",&col,&val) != 2 ||\n#elif REAL == FLOAT\n			} while ( sscanf(line,"%u %f",&col,&val) != 2 ||\n#endif\n				    col >= n || col <= curr_col );\n\n			if ( *line == 'e' || *line == 'E' )\n			    break;\n\n			scratch[len].col = col;\n			scratch[len].val = val;\n			curr_col = col;\n\n			len++;\n		    }\n\n		    /* Note: len = # elements in row */\n		    if ( len > 5 )\n		     {\n			if (mem_info_is_on()) {\n			   mem_bytes(TYPE_SPMAT,\n					   A->row[i].maxlen*sizeof(row_elt),\n					   len*sizeof(row_elt));  \n			}\n\n			rows[i].elt = (row_elt *)realloc((char *)rows[i].elt,\n							 len*sizeof(row_elt));\n			rows[i].maxlen = len;\n		    }\n		    MEM_COPY(scratch,rows[i].elt,len*sizeof(row_elt));\n		    rows[i].len  = len;\n		    rows[i].diag = sprow_idx(&(rows[i]),i);\n		}\n	}\n	else /* not tty */\n	{\n	        ret_val = 0;\n		skipjunk(fp);\n		fscanf(fp,"SparseMatrix:");\n		skipjunk(fp);\n		if ( (ret_val=fscanf(fp,"%u by %u",&m,&n)) != 2 )\n		    error((ret_val == EOF) ? E_EOF : E_FORMAT,"sp_finput");\n		A = sp_get(m,n,5);\n\n		/* initialise start_row */\n		for ( i = 0; i < A->n; i++ )\n			A->start_row[i] = -1;\n\n		rows = A->row;\n		for ( i = 0; i < m; i++ )\n		{\n		    /* printf("Reading row # %d\n",i); */\n		    rows[i].diag = -1;\n		    skipjunk(fp);\n		    if ( (ret_val=fscanf(fp,"row %d :",&tmp)) != 1 ||\n			 tmp != i )\n			error((ret_val == EOF) ? E_EOF : E_FORMAT,\n			      "sp_finput");\n		    curr_col = -1;\n		    len = 0;\n		    for ( ; ; )  /* forever do... */\n		      {\n		      /* if we need more scratch space, let's get it!\n		       -- using amortized doubling */\n		      if ( len >= scratch_len )\n			{\n			  scratch = RENEW(scratch,2*scratch_len,row_elt);\n			  if ( ! scratch )\n			    error(E_MEM,"sp_finput");\n			  scratch_len = 2*scratch_len;\n			}\n#if REAL == DOUBLE\n			if ( (ret_val=fscanf(fp,"%u : %lf",&col,&val)) != 2 )\n#elif REAL == FLOAT\n			if ( (ret_val=fscanf(fp,"%u : %f",&col,&val)) != 2 )\n#endif\n			    break;\n			if ( col <= curr_col || col >= n )\n			    error(E_FORMAT,"sp_finput");\n			scratch[len].col = col;\n			scratch[len].val = val;\n\n			len++;\n		    }\n		    if ( ret_val == EOF )\n			error(E_EOF,"sp_finput");\n\n		    if ( len > rows[i].maxlen )\n		    {\n			rows[i].elt = (row_elt *)realloc((char *)rows[i].elt,\n							len*sizeof(row_elt));\n			rows[i].maxlen = len;\n		    }\n		    MEM_COPY(scratch,rows[i].elt,len*sizeof(row_elt));\n		    rows[i].len  = len;\n		    /* printf("Have read row # %d\n",i); */\n		    rows[i].diag = sprow_idx(&(rows[i]),i);\n		    /* printf("Have set diag index for row # %d\n",i); */\n		}\n	}\n\n	return A;\n}\n\n