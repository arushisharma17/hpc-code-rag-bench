\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  Sparse matrix package\n  See also: sparse.h, matrix.h\n  */\n\n#include	<stdio.h>\n#include	<math.h>\n#include        <stdlib.h>\n#include	"sparse.h"\n\n\nstatic char	rcsid[] = "$Id: sparse.c,v 1.10 1994/03/08 05:46:07 des Exp $";\n\n#define	MINROWLEN	10\n\n\n\n/* sp_get_val -- returns the (i,j) entry of the sparse matrix A */\n#ifndef ANSI_C\ndouble	sp_get_val(A,i,j)\nSPMAT	*A;\nint	i, j;\n#else\ndouble	sp_get_val(const SPMAT *A, int i, int j)\n#endif\n{\n   SPROW	*r;\n   int	idx;\n   \n   if ( A == SMNULL )\n     error(E_NULL,"sp_get_val");\n   if ( i < 0 || i >= A->m || j < 0 || j >= A->n )\n     error(E_SIZES,"sp_get_val");\n   \n   r = A->row+i;\n   idx = sprow_idx(r,j);\n   if ( idx < 0 )\n     return 0.0;\n   /* else */\n   return r->elt[idx].val;\n}\n\n/* sp_set_val -- sets the (i,j) entry of the sparse matrix A */\n#ifndef ANSI_C\ndouble	sp_set_val(A,i,j,val)\nSPMAT	*A;\nint	i, j;\ndouble	val;\n#else\ndouble	sp_set_val(SPMAT *A, int i, int j, double val)\n#endif\n{\n   SPROW	*r;\n   int	idx, idx2, new_len;\n   \n   if ( A == SMNULL )\n     error(E_NULL,"sp_set_val");\n   if ( i < 0 || i >= A->m || j < 0 || j >= A->n )\n     error(E_SIZES,"sp_set_val");\n   \n   r = A->row+i;\n   idx = sprow_idx(r,j);\n   /* printf("sp_set_val: idx = %d\n",idx); */\n   if ( idx >= 0 )\n   {	r->elt[idx].val = val;	return val;	}\n   /* else */ if ( idx < -1 )\n   {\n      /* Note: this destroys the column & diag access paths */\n      A->flag_col = A->flag_diag = FALSE;\n      /* shift & insert new value */\n      idx = -(idx+2);	/* this is the intended insertion index */\n      if ( r->len >= r->maxlen )\n      {\n	 r->len = r->maxlen;\n	 new_len = max(2*r->maxlen+1,5);\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,A->row[i].maxlen*sizeof(row_elt),\n			    new_len*sizeof(row_elt));\n	 }\n\n	 r->elt = RENEW(r->elt,new_len,row_elt);\n	 if ( ! r->elt )	/* can't allocate */\n	   error(E_MEM,"sp_set_val");\n	 r->maxlen = 2*r->maxlen+1;\n      }\n      for ( idx2 = r->len-1; idx2 >= idx; idx2-- )\n	MEM_COPY((char *)(&(r->elt[idx2])),\n		 (char *)(&(r->elt[idx2+1])),sizeof(row_elt));\n      /************************************************************\n	if ( idx < r->len )\n	MEM_COPY((char *)(&(r->elt[idx])),(char *)(&(r->elt[idx+1])),\n	(r->len-idx)*sizeof(row_elt));\n	************************************************************/\n      r->len++;\n      r->elt[idx].col = j;\n      return r->elt[idx].val = val;\n   }\n   /* else -- idx == -1, error in index/matrix! */\n   return 0.0;\n}\n\n/* sp_mv_mlt -- sparse matrix/dense vector multiply\n   -- result is in out, which is returned unless out==NULL on entry\n   --  if out==NULL on entry then the result vector is created */\n#ifndef ANSI_C\nVEC	*sp_mv_mlt(A,x,out)\nSPMAT	*A;\nVEC	*x, *out;\n#else\nVEC	*sp_mv_mlt(const SPMAT *A, const VEC *x, VEC *out)\n#endif\n{\n   int	i, j_idx, m, n, max_idx;\n   Real	sum, *x_ve;\n   SPROW	*r;\n   row_elt	*elts;\n   \n   if ( ! A || ! x )\n     error(E_NULL,"sp_mv_mlt");\n   if ( x->dim != A->n )\n     error(E_SIZES,"sp_mv_mlt");\n   if ( ! out || out->dim < A->m )\n     out = v_resize(out,A->m);\n   if ( out == x )\n     error(E_INSITU,"sp_mv_mlt");\n   m = A->m;	n = A->n;\n   x_ve = x->ve;\n   \n   for ( i = 0; i < m; i++ )\n   {\n      sum = 0.0;\n      r = &(A->row[i]);\n      max_idx = r->len;\n      elts    = r->elt;\n      for ( j_idx = 0; j_idx < max_idx; j_idx++, elts++ )\n	sum += elts->val*x_ve[elts->col];\n      out->ve[i] = sum;\n   }\n   return out;\n}\n\n/* sp_vm_mlt -- sparse matrix/dense vector multiply from left\n   -- result is in out, which is returned unless out==NULL on entry\n   -- if out==NULL on entry then result vector is created & returned */\n#ifndef ANSI_C\nVEC	*sp_vm_mlt(A,x,out)\nSPMAT	*A;\nVEC	*x, *out;\n#else\nVEC	*sp_vm_mlt(const SPMAT *A, const VEC *x, VEC *out)\n#endif\n{\n   int	i, j_idx, m, n, max_idx;\n   Real	tmp, *x_ve, *out_ve;\n   SPROW	*r;\n   row_elt	*elts;\n   \n   if ( ! A || ! x )\n     error(E_NULL,"sp_vm_mlt");\n   if ( x->dim != A->m )\n     error(E_SIZES,"sp_vm_mlt");\n   if ( ! out || out->dim < A->n )\n     out = v_resize(out,A->n);\n   if ( out == x )\n     error(E_INSITU,"sp_vm_mlt");\n   \n   m = A->m;	n = A->n;\n   v_zero(out);\n   x_ve = x->ve;	out_ve = out->ve;\n   \n   for ( i = 0; i < m; i++ )\n   {\n      r = A->row+i;\n      max_idx = r->len;\n      elts    = r->elt;\n      tmp = x_ve[i];\n      for ( j_idx = 0; j_idx < max_idx; j_idx++, elts++ )\n	out_ve[elts->col] += elts->val*tmp;\n   }\n   \n   return out;\n}\n\n\n/* sp_get -- get sparse matrix\n   -- len is number of elements available for each row without\n   allocating further memory */\n#ifndef ANSI_C\nSPMAT	*sp_get(m,n,maxlen)\nint	m, n, maxlen;\n#else\nSPMAT	*sp_get(int m, int n, int maxlen)\n#endif\n{\n   SPMAT	*A;\n   SPROW	*rows;\n   int	i;\n   \n   if ( m < 0 || n < 0 )\n     error(E_NEG,"sp_get");\n\n   maxlen = max(maxlen,1);\n   \n   A = NEW(SPMAT);\n   if ( ! A )		/* can't allocate */\n     error(E_MEM,"sp_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,sizeof(SPMAT));\n      mem_numvar(TYPE_SPMAT,1);\n   }\n   /* fprintf(stderr,"Have SPMAT structure\n"); */\n   \n   A->row = rows = NEW_A(m,SPROW);\n   if ( ! A->row )		/* can't allocate */\n     error(E_MEM,"sp_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,m*sizeof(SPROW));\n   }\n   /* fprintf(stderr,"Have row structure array\n"); */\n   \n   A->start_row = NEW_A(n,int);\n   A->start_idx = NEW_A(n,int);\n   if ( ! A->start_row || ! A->start_idx )	/* can't allocate */\n     error(E_MEM,"sp_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,2*n*sizeof(int));\n   }\n   for ( i = 0; i < n; i++ )\n     A->start_row[i] = A->start_idx[i] = -1;\n   /* fprintf(stderr,"Have start_row array\n"); */\n   \n   A->m = A->max_m = m;\n   A->n = A->max_n = n;\n   \n   for ( i = 0; i < m; i++, rows++ )\n   {\n      rows->elt = NEW_A(maxlen,row_elt);\n      if ( ! rows->elt )\n	error(E_MEM,"sp_get");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,0,maxlen*sizeof(row_elt));\n      }\n      /* fprintf(stderr,"Have row %d element array\n",i); */\n      rows->len = 0;\n      rows->maxlen = maxlen;\n      rows->diag = -1;\n   }\n   \n   return A;\n}\n\n\n/* sp_free -- frees up the memory for a sparse matrix */\n#ifndef ANSI_C\nint	sp_free(A)\nSPMAT	*A;\n#else\nint	sp_free(SPMAT *A)\n#endif\n{\n   SPROW	*r;\n   int	i;\n   \n   if ( ! A )\n     return -1;\n   if ( A->start_row != (int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_n*sizeof(int),0);\n      }\n      free((char *)(A->start_row));\n   }\n   if ( A->start_idx != (int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_n*sizeof(int),0);\n      }\n      \n      free((char *)(A->start_idx));\n   }\n   if ( ! A->row )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,sizeof(SPMAT),0);\n	 mem_numvar(TYPE_SPMAT,-1);\n      }\n      \n      free((char *)A);\n      return 0;\n   }\n   for ( i = 0; i < A->m; i++ )\n   {\n      r = &(A->row[i]);\n      if ( r->elt != (row_elt *)NULL ) {\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,A->row[i].maxlen*sizeof(row_elt),0);\n	 }\n	 free((char *)(r->elt));\n      }\n   }\n   \n   if (mem_info_is_on()) {\n      if (A->row) \n	mem_bytes(TYPE_SPMAT,A->max_m*sizeof(SPROW),0);\n      mem_bytes(TYPE_SPMAT,sizeof(SPMAT),0);\n      mem_numvar(TYPE_SPMAT,-1);\n   }\n   \n   free((char *)(A->row));\n   free((char *)A);\n\n   return 0;\n}\n\n\n/* sp_copy -- constructs a copy of a given matrix\n   -- note that the max_len fields (etc) are no larger in the copy\n   than necessary\n   -- result is returned */\n#ifndef ANSI_C\nSPMAT	*sp_copy(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_copy(const SPMAT *A)\n#endif\n{\n   SPMAT	*out;\n   SPROW	*row1, *row2;\n   int	i;\n   \n   if ( A == SMNULL )\n     error(E_NULL,"sp_copy");\n   if ( ! (out=NEW(SPMAT)) )\n     error(E_MEM,"sp_copy");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,sizeof(SPMAT));\n      mem_numvar(TYPE_SPMAT,1);\n   }\n   out->m = out->max_m = A->m;	out->n = out->max_n = A->n;\n   \n   /* set up rows */\n   if ( ! (out->row=NEW_A(A->m,SPROW)) )\n     error(E_MEM,"sp_copy");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,A->m*sizeof(SPROW));\n   }\n   for ( i = 0; i < A->m; i++ )\n   {\n      row1 = &(A->row[i]);\n      row2 = &(out->row[i]);\n      if ( ! (row2->elt=NEW_A(max(row1->len,3),row_elt)) )\n	error(E_MEM,"sp_copy");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,0,max(row1->len,3)*sizeof(row_elt));\n      }\n      row2->len = row1->len;\n      row2->maxlen = max(row1->len,3);\n      row2->diag = row1->diag;\n      MEM_COPY((char *)(row1->elt),(char *)(row2->elt),\n	       row1->len*sizeof(row_elt));\n   }\n   \n   /* set up start arrays -- for column access */\n   if ( ! (out->start_idx=NEW_A(A->n,int)) ||\n       ! (out->start_row=NEW_A(A->n,int)) )\n     error(E_MEM,"sp_copy");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,2*A->n*sizeof(int));\n   }\n   MEM_COPY((char *)(A->start_idx),(char *)(out->start_idx),\n	    A->n*sizeof(int));\n   MEM_COPY((char *)(A->start_row),(char *)(out->start_row),\n	    A->n*sizeof(int));\n   \n   return out;\n}\n\n/* sp_col_access -- set column access path; i.e. nxt_row, nxt_idx fields\n   -- returns A */\n#ifndef ANSI_C\nSPMAT	*sp_col_access(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_col_access(SPMAT *A)\n#endif\n{\n   int	i, j, j_idx, len, m, n;\n   SPROW	*row;\n   row_elt	*r_elt;\n   int	*start_row, *start_idx;\n   \n   if ( A == SMNULL )\n     error(E_NULL,"sp_col_access");\n   \n   m = A->m;	n = A->n;\n   \n   /* initialise start_row and start_idx */\n   start_row = A->start_row;	start_idx = A->start_idx;\n   for ( j = 0; j < n; j++ )\n   {	*start_row++ = -1;	*start_idx++ = -1;	}\n   \n   start_row = A->start_row;	start_idx = A->start_idx;\n   \n   /* now work UP the rows, setting nxt_row, nxt_idx fields */\n   for ( i = m-1; i >= 0; i-- )\n   {\n      row = &(A->row[i]);\n      r_elt = row->elt;\n      len   = row->len;\n      for ( j_idx = 0; j_idx < len; j_idx++, r_elt++ )\n      {\n	 j = r_elt->col;\n	 r_elt->nxt_row = start_row[j];\n	 r_elt->nxt_idx = start_idx[j];\n	 start_row[j] = i;\n	 start_idx[j] = j_idx;\n      }\n   }\n   \n   A->flag_col = TRUE;\n   return A;\n}\n\n/* sp_diag_access -- set diagonal access path(s) */\n#ifndef ANSI_C\nSPMAT	*sp_diag_access(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_diag_access(SPMAT *A)\n#endif\n{\n   int	i, m;\n   SPROW	*row;\n   \n   if ( A == SMNULL )\n     error(E_NULL,"sp_diag_access");\n   \n   m = A->m;\n   \n   row = A->row;\n   for ( i = 0; i < m; i++, row++ )\n     row->diag = sprow_idx(row,i);\n   \n   A->flag_diag = TRUE;\n   \n   return A;\n}\n\n/* sp_m2dense -- convert a sparse matrix to a dense one */\n#ifndef ANSI_C\nMAT	*sp_m2dense(A,out)\nSPMAT	*A;\nMAT	*out;\n#else\nMAT	*sp_m2dense(const SPMAT *A, MAT *out)\n#endif\n{\n   int	i, j_idx;\n   SPROW	*row;\n   row_elt	*elt;\n   \n   if ( ! A )\n     error(E_NULL,"sp_m2dense");\n   if ( ! out || out->m < A->m || out->n < A->n )\n     out = m_get(A->m,A->n);\n   \n   m_zero(out);\n   for ( i = 0; i < A->m; i++ )\n   {\n      row = &(A->row[i]);\n      elt = row->elt;\n      for ( j_idx = 0; j_idx < row->len; j_idx++, elt++ )\n	out->me[i][elt->col] = elt->val;\n   }\n   \n   return out;\n}\n\n\n/*  C = A+B, can be in situ */\n#ifndef ANSI_C\nSPMAT *sp_add(A,B,C)\nSPMAT *A, *B, *C;\n#else\nSPMAT *sp_add(const SPMAT *A, const SPMAT *B, SPMAT *C)\n#endif\n{\n   int i, in_situ;\n   SPROW *rc;\n   STATIC SPROW *tmp = NULL;\n\n   if ( ! A || ! B )\n     error(E_NULL,"sp_add");\n   if ( A->m != B->m || A->n != B->n )\n     error(E_SIZES,"sp_add");\n   if (C == A || C == B)\n     in_situ = TRUE;\n   else in_situ = FALSE;\n\n   if ( ! C )\n     C = sp_get(A->m,A->n,5);\n   else {\n      if ( C->m != A->m || C->n != A->n  )\n	error(E_SIZES,"sp_add");\n      if (!in_situ) sp_zero(C);\n   }\n\n   if (tmp == (SPROW *)NULL && in_situ) {\n      tmp = sprow_get(MINROWLEN);\n      MEM_STAT_REG(tmp,TYPE_SPROW);\n   }\n\n   if (in_situ)\n     for (i=0; i < A->m; i++) {\n	rc = &(C->row[i]);\n	sprow_add(&(A->row[i]),&(B->row[i]),0,tmp,TYPE_SPROW);\n	sprow_resize(rc,tmp->len,TYPE_SPMAT);\n	MEM_COPY(tmp->elt,rc->elt,tmp->len*sizeof(row_elt));\n	rc->len = tmp->len;\n     }\n   else\n     for (i=0; i < A->m; i++) {\n	sprow_add(&(A->row[i]),&(B->row[i]),0,&(C->row[i]),TYPE_SPMAT);\n     }\n\n   C->flag_col = C->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n   sprow_free(tmp);\n#endif\n\n   return C;\n}\n\n/*  C = A-B, cannot be in situ */\n#ifndef ANSI_C\nSPMAT *sp_sub(A,B,C)\nSPMAT *A, *B, *C;\n#else\nSPMAT *sp_sub(const SPMAT *A, const SPMAT *B, SPMAT *C)\n#endif\n{\n   int i, in_situ;\n   SPROW *rc;\n   STATIC SPROW *tmp = NULL;\n   \n   if ( ! A || ! B )\n     error(E_NULL,"sp_sub");\n   if ( A->m != B->m || A->n != B->n )\n     error(E_SIZES,"sp_sub");\n   if (C == A || C == B)\n     in_situ = TRUE;\n   else in_situ = FALSE;\n\n   if ( ! C )\n     C = sp_get(A->m,A->n,5);\n   else {\n      if ( C->m != A->m || C->n != A->n  )\n	error(E_SIZES,"sp_sub");\n      if (!in_situ) sp_zero(C);\n   }\n\n   if (tmp == (SPROW *)NULL && in_situ) {\n      tmp = sprow_get(MINROWLEN);\n      MEM_STAT_REG(tmp,TYPE_SPROW);\n   }\n\n   if (in_situ)\n     for (i=0; i < A->m; i++) {\n	rc = &(C->row[i]);\n	sprow_sub(&(A->row[i]),&(B->row[i]),0,tmp,TYPE_SPROW);\n	sprow_resize(rc,tmp->len,TYPE_SPMAT);\n	MEM_COPY(tmp->elt,rc->elt,tmp->len*sizeof(row_elt));\n	rc->len = tmp->len;\n     }\n   else\n     for (i=0; i < A->m; i++) {\n	sprow_sub(&(A->row[i]),&(B->row[i]),0,&(C->row[i]),TYPE_SPMAT);\n     }\n\n   C->flag_col = C->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n   sprow_free(tmp);\n#endif\n\n   return C;\n}\n\n/*  C = A+alpha*B, cannot be in situ */\n#ifndef ANSI_C\nSPMAT *sp_mltadd(A,B,alpha,C)\nSPMAT *A, *B, *C;\ndouble alpha;\n#else\nSPMAT *sp_mltadd(const SPMAT *A, const SPMAT *B, double alpha, SPMAT *C)\n#endif\n{\n   int i, in_situ;\n   SPROW *rc;\n   STATIC SPROW *tmp = NULL;\n\n   if ( ! A || ! B )\n     error(E_NULL,"sp_mltadd");\n   if ( A->m != B->m || A->n != B->n )\n     error(E_SIZES,"sp_mltadd");\n   if (C == A || C == B)\n     in_situ = TRUE;\n   else in_situ = FALSE;\n\n   if ( ! C )\n     C = sp_get(A->m,A->n,5);\n   else {\n      if ( C->m != A->m || C->n != A->n  )\n	error(E_SIZES,"sp_mltadd");\n      if (!in_situ) sp_zero(C);\n   }\n\n   if (tmp == (SPROW *)NULL && in_situ) {\n      tmp = sprow_get(MINROWLEN);\n      MEM_STAT_REG(tmp,TYPE_SPROW);\n   }\n\n   if (in_situ)\n     for (i=0; i < A->m; i++) {\n	rc = &(C->row[i]);\n	sprow_mltadd(&(A->row[i]),&(B->row[i]),alpha,0,tmp,TYPE_SPROW);\n	sprow_resize(rc,tmp->len,TYPE_SPMAT);\n	MEM_COPY(tmp->elt,rc->elt,tmp->len*sizeof(row_elt));\n	rc->len = tmp->len;\n     }\n   else\n     for (i=0; i < A->m; i++) {\n	sprow_mltadd(&(A->row[i]),&(B->row[i]),alpha,0,\n		     &(C->row[i]),TYPE_SPMAT);\n     }\n   \n   C->flag_col = C->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n   sprow_free(tmp);\n#endif\n   \n   return C;\n}\n\n\n\n/*  B = alpha*A, can be in situ */\n#ifndef ANSI_C\nSPMAT *sp_smlt(A,alpha,B)\nSPMAT *A, *B;\ndouble alpha;\n#else\nSPMAT *sp_smlt(const SPMAT *A, double alpha, SPMAT *B)\n#endif\n{\n   int i;\n\n   if ( ! A )\n     error(E_NULL,"sp_smlt");\n   if ( ! B )\n     B = sp_get(A->m,A->n,5);\n   else\n     if ( A->m != B->m || A->n != B->n )\n       error(E_SIZES,"sp_smlt");\n\n   for (i=0; i < A->m; i++) {\n      sprow_smlt(&(A->row[i]),alpha,0,&(B->row[i]),TYPE_SPMAT);\n   }\n   return B;\n}\n\n\n\n/* sp_zero -- zero all the (represented) elements of a sparse matrix */\n#ifndef ANSI_C\nSPMAT	*sp_zero(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_zero(SPMAT *A)\n#endif\n{\n   int	i, idx, len;\n   row_elt	*elt;\n   \n   if ( ! A )\n     error(E_NULL,"sp_zero");\n   \n   for ( i = 0; i < A->m; i++ )\n   {\n      elt = A->row[i].elt;\n      len = A->row[i].len;\n      for ( idx = 0; idx < len; idx++ )\n	(*elt++).val = 0.0;\n   }\n   \n   return A;\n}\n\n/* sp_copy2 -- copy sparse matrix (type 2) \n   -- keeps structure of the OUT matrix */\n#ifndef ANSI_C\nSPMAT	*sp_copy2(A,OUT)\nSPMAT	*A, *OUT;\n#else\nSPMAT	*sp_copy2(const SPMAT *A, SPMAT *OUT)\n#endif\n{\n   int	i /* , idx, len1, len2 */;\n   SPROW	*r1, *r2;\n   STATIC SPROW	*scratch = (SPROW *)NULL;\n   /* row_elt	*e1, *e2; */\n   \n   if ( ! A )\n     error(E_NULL,"sp_copy2");\n   if ( ! OUT )\n     OUT = sp_get(A->m,A->n,10);\n   if ( ! scratch ) {\n      scratch = sprow_xpd(scratch,MINROWLEN,TYPE_SPROW);\n      MEM_STAT_REG(scratch,TYPE_SPROW);\n   }\n\n   if ( OUT->m < A->m )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_m*sizeof(SPROW),\n		      A->m*sizeof(SPROW));\n      }\n\n      OUT->row = RENEW(OUT->row,A->m,SPROW);\n      if ( ! OUT->row )\n	error(E_MEM,"sp_copy2");\n      \n      for ( i = OUT->m; i < A->m; i++ )\n      {\n	 OUT->row[i].elt = NEW_A(MINROWLEN,row_elt);\n	 if ( ! OUT->row[i].elt )\n	   error(E_MEM,"sp_copy2");\n	 else if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,0,MINROWLEN*sizeof(row_elt));\n	 }\n	 \n	 OUT->row[i].maxlen = MINROWLEN;\n	 OUT->row[i].len = 0;\n      }\n      OUT->m = A->m;\n   }\n   \n   OUT->flag_col = OUT->flag_diag = FALSE;\n   /* sp_zero(OUT); */\n\n   for ( i = 0; i < A->m; i++ )\n   {\n      r1 = &(A->row[i]);	r2 = &(OUT->row[i]);\n      sprow_copy(r1,r2,scratch,TYPE_SPROW);\n      if ( r2->maxlen < scratch->len )\n	sprow_xpd(r2,scratch->len,TYPE_SPMAT);\n      MEM_COPY((char *)(scratch->elt),(char *)(r2->elt),\n	       scratch->len*sizeof(row_elt));\n      r2->len = scratch->len;\n      /*******************************************************\n	e1 = r1->elt;		e2 = r2->elt;\n	len1 = r1->len;		len2 = r2->len;\n	for ( idx = 0; idx < len2; idx++, e2++ )\n	e2->val = 0.0;\n	for ( idx = 0; idx < len1; idx++, e1++ )\n	sprow_set_val(r2,e1->col,e1->val);\n	*******************************************************/\n   }\n\n   sp_col_access(OUT);\n\n#ifdef	THREADSAFE\n   sprow_free(scratch);\n#endif\n\n   return OUT;\n}\n\n/* sp_resize -- resize a sparse matrix\n   -- don't destroying any contents if possible\n   -- returns resized matrix */\n#ifndef ANSI_C\nSPMAT	*sp_resize(A,m,n)\nSPMAT	*A;\nint	m, n;\n#else\nSPMAT	*sp_resize(SPMAT *A, int m, int n)\n#endif\n{\n   int	i, len;\n   SPROW	*r;\n   \n   if (m < 0 || n < 0)\n     error(E_NEG,"sp_resize");\n\n   if ( ! A )\n     return sp_get(m,n,10);\n\n   if (m == A->m && n == A->n)\n     return A;\n\n   if ( m <= A->max_m )\n   {\n      for ( i = A->m; i < m; i++ )\n	A->row[i].len = 0;\n      A->m = m;\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_m*sizeof(SPROW),\n			 m*sizeof(SPROW));\n      }\n\n      A->row = RENEW(A->row,(unsigned)m,SPROW);\n      if ( ! A->row )\n	error(E_MEM,"sp_resize");\n      for ( i = A->m; i < m; i++ )\n      {\n	 if ( ! (A->row[i].elt = NEW_A(MINROWLEN,row_elt)) )\n	   error(E_MEM,"sp_resize");\n	 else if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,0,MINROWLEN*sizeof(row_elt));\n	 }\n	 A->row[i].len = 0;	A->row[i].maxlen = MINROWLEN;\n      }\n      A->m = A->max_m = m;\n   }\n\n   /* update number of rows */\n   A->n = n;\n\n   /* do we need to increase the size of start_idx[] and start_row[] ? */\n   if ( n > A->max_n )\n   {	/* only have to update the start_idx & start_row arrays */\n      if (mem_info_is_on())\n      {\n	  mem_bytes(TYPE_SPMAT,2*A->max_n*sizeof(int),\n		    2*n*sizeof(int));\n      }\n\n      A->start_row = RENEW(A->start_row,(unsigned)n,int);\n      A->start_idx = RENEW(A->start_idx,(unsigned)n,int);\n      if ( ! A->start_row || ! A->start_idx )\n	error(E_MEM,"sp_resize");\n      A->max_n = n;	/* ...and update max_n */\n\n      return A;\n   }\n\n   if ( n <= A->n )\n       /* make sure that all rows are truncated just before column n */\n       for ( i = 0; i < A->m; i++ )\n       {\n	   r = &(A->row[i]);\n	   len = sprow_idx(r,n);\n	   if ( len < 0 )\n	       len = -(len+2);\n	   if ( len < 0 )\n	       error(E_MEM,"sp_resize");\n	   r->len = len;\n       }\n   \n   return A;\n}\n\n\n/* sp_compact -- removes zeros and near-zeros from a sparse matrix */\n#ifndef ANSI_C\nSPMAT	*sp_compact(A,tol)\nSPMAT	*A;\ndouble	tol;\n#else\nSPMAT	*sp_compact(SPMAT *A, double tol)\n#endif\n{\n   int	i, idx1, idx2;\n   SPROW	*r;\n   row_elt	*elt1, *elt2;\n   \n   if (  ! A )\n     error(E_NULL,"sp_compact");\n   if ( tol < 0.0 )\n     error(E_RANGE,"sp_compact");\n   \n   A->flag_col = A->flag_diag = FALSE;\n   \n   for ( i = 0; i < A->m; i++ )\n   {\n      r = &(A->row[i]);\n      elt1 = elt2 = r->elt;\n      idx1 = idx2 = 0;\n      while ( idx1 < r->len )\n      {\n	 /* printf("# sp_compact: idx1 = %d, idx2 = %d\n",idx1,idx2); */\n	 if ( fabs(elt1->val) <= tol )\n	 {	idx1++;	elt1++;	continue;	}\n	 if ( elt1 != elt2 )\n	   MEM_COPY(elt1,elt2,sizeof(row_elt));\n	 idx1++;	elt1++;\n	 idx2++;	elt2++;\n      }\n      r->len = idx2;\n   }\n   \n   return A;\n}\n\n/* sp_mlt (C) Copyright David Stewart and Fabrizio Novalis <novalis@mars.elet.polimi.it> */\n/* sp_mlt -- computes out = A*B and returns out */\nSPMAT   *sp_mlt(const SPMAT *A, const SPMAT *B, SPMAT *out)\n{\n  int     i, j, k, idx, cp;\n  SPROW   *rA, *rB, *rout, *rtemp;\n  double  valA;\n\n  if ( ! A || ! B )\n    error(E_NULL,"sp_mlt");\n  if ( A->n != B->m )\n    error(E_SIZES,"sp_mlt");\n  out = sp_resize(out,A->m,B->n);\n  sp_zero(out);\n  rtemp = sprow_get(B->n);\n  for ( i = 0; i < A->m; i++ ) /* per ogni riga */\n    {\n      rtemp = sprow_resize(rtemp,0,TYPE_SPROW);\n      rA = &(A->row[i]);\n      rout = &(out->row[i]);\n      for ( idx = 0; idx < rA->len; idx++ ) /* per ogni elemento != 0\n					       della riga corrente */\n	{\n	  j = rA->elt[idx].col;\n	  valA = rA->elt[idx].val;\n	  rB = &(B->row[j]);\n	  sprow_mltadd(rtemp,rB,valA,0,rout,TYPE_SPMAT);\n\n	  for ( cp = 0; cp < rout->len; cp++ )\n	    {\n	      rtemp->elt[cp].col = rout->elt[cp].col;\n	      rtemp->elt[cp].val = rout->elt[cp].val;\n	    }\n	  rtemp->len=rout->len;\n	}\n    }\n  return out;\n}\n\n/* varying number of arguments */\n\n#ifdef ANSI_C\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   sp_get_vars(m,n,deg,&x,&y,&z,...,NULL);\n   where \n     int m,n,deg;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m x n is the dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables\n*/\n\nint sp_get_vars(int m,int n,int deg,...) \n{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap, deg);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_get(m,n,deg);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   sp_resize_vars(m,n,&x,&y,&z,...,NULL);\n   where \n     int m,n;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m X n is the resized dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n*/\n  \nint sp_resize_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   sp_free_vars(&x,&y,&z,...,NULL);\n   where \n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n*/\n\nint sp_free_vars(SPMAT **va,...)\n{\n   va_list ap;\n   int i=1;\n   SPMAT **par;\n   \n   sp_free(*va);\n   *va = (SPMAT *) NULL;\n   va_start(ap, va);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      sp_free(*par); \n      *par = (SPMAT *)NULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#elif VARARGS\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   sp_get_vars(m,n,deg,&x,&y,&z,...,NULL);\n   where \n     int m,n,deg;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m x n is the dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables\n*/\n\nint sp_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n, deg;\n   SPMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   deg = va_arg(ap,int);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_get(m,n,deg);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   sp_resize_vars(m,n,&x,&y,&z,...,NULL);\n   where \n     int m,n;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m X n is the resized dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n*/\n\nint sp_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n;\n   SPMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   sp_free_vars(&x,&y,&z,...,NULL);\n   where \n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n*/\n\nint sp_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      sp_free(*par); \n      *par = (SPMAT *)NULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n#endif\n\n