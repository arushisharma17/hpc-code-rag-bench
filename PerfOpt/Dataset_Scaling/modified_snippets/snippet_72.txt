\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n	Complex version\n*/\n\nstatic	char	rcsid[] = "$Id: zlufctr.c,v 1.3 1996/08/20 20:07:09 stewart Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"zmatrix.h"\n#include        "zmatrix2.h"\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* zLUfactor -- Gaussian elimination with scaled partial pivoting\n		-- Note: returns LU matrix which is A */\nZMAT	*zLUfactor(A,pivot)\nZMAT	*A;\nPERM	*pivot;\n{\n	unsigned int	i, j, m, n;\n	int	i_max, k, k_max;\n	Real	dtemp, max1;\n	complex	**A_v, *A_piv, *A_row, temp;\n	STATIC	VEC	*scale = VNULL;\n\n	if ( A==ZMNULL || pivot==PNULL )\n		error(E_NULL,"zLUfactor");\n	if ( pivot->size != A->m )\n		error(E_SIZES,"zLUfactor");\n	m = A->m;	n = A->n;\n	scale = v_resize(scale,A->m);\n	MEM_STAT_REG(scale,TYPE_VEC);\n	A_v = A->me;\n\n	/* initialise pivot with identity permutation */\n	for ( i=0; i<m; i++ )\n	    pivot->pe[i] = i;\n\n	/* set scale parameters */\n	for ( i=0; i<m; i++ )\n	{\n		max1 = 0.0;\n		for ( j=0; j<n; j++ )\n		{\n			dtemp = zabs(A_v[i][j]);\n			max1 = max(max1,dtemp);\n		}\n		scale->ve[i] = max1;\n	}\n\n	/* main loop */\n	k_max = min(m,n)-1;\n	for ( k=0; k<k_max; k++ )\n	{\n	    /* find best pivot row */\n	    max1 = 0.0;	i_max = -1;\n	    for ( i=k; i<m; i++ )\n		if ( scale->ve[i] > 0.0 )\n		{\n		    dtemp = zabs(A_v[i][k])/scale->ve[i];\n		    if ( dtemp > max1 )\n		    { max1 = dtemp;	i_max = i;	}\n		}\n	    \n	    /* if no pivot then ignore column k... */\n	    if ( i_max == -1 )\n		continue;\n\n	    /* do we pivot ? */\n	    if ( i_max != k )	/* yes we do... */\n	    {\n		px_transp(pivot,i_max,k);\n		for ( j=0; j<n; j++ )\n		{\n		    temp = A_v[i_max][j];\n		    A_v[i_max][j] = A_v[k][j];\n		    A_v[k][j] = temp;\n		}\n	    }\n	    \n	    /* row operations */\n	    for ( i=k+1; i<m; i++ )	/* for each row do... */\n	    {	/* Note: divide by zero should never happen */\n		temp = A_v[i][k] = zdiv(A_v[i][k],A_v[k][k]);\n		A_piv = &(A_v[k][k+1]);\n		A_row = &(A_v[i][k+1]);\n		temp.re = - temp.re;\n		temp.im = - temp.im;\n		if ( k+1 < n )\n		    __zmltadd__(A_row,A_piv,temp,(int)(n-(k+1)),Z_NOCONJ);\n		/*********************************************\n		  for ( j=k+1; j<n; j++ )\n		  A_v[i][j] -= temp*A_v[k][j];\n		  (*A_row++) -= temp*(*A_piv++);\n		*********************************************/\n	    }\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(scale);\n#endif\n\n	return A;\n}\n\n\n/* zLUsolve -- given an LU factorisation in A, solve Ax=b */\nZVEC	*zLUsolve(A,pivot,b,x)\nZMAT	*A;\nPERM	*pivot;\nZVEC	*b,*x;\n{\n	if ( A==ZMNULL || b==ZVNULL || pivot==PNULL )\n		error(E_NULL,"zLUsolve");\n	if ( A->m != A->n || A->n != b->dim )\n		error(E_SIZES,"zLUsolve");\n\n	x = px_zvec(pivot,b,x);	/* x := P.b */\n	zLsolve(A,x,x,1.0);	/* implicit diagonal = 1 */\n	zUsolve(A,x,x,0.0);	/* explicit diagonal */\n\n	return (x);\n}\n\n/* zLUAsolve -- given an LU factorisation in A, solve A^*.x=b */\nZVEC	*zLUAsolve(LU,pivot,b,x)\nZMAT	*LU;\nPERM	*pivot;\nZVEC	*b,*x;\n{\n	if ( ! LU || ! b || ! pivot )\n		error(E_NULL,"zLUAsolve");\n	if ( LU->m != LU->n || LU->n != b->dim )\n		error(E_SIZES,"zLUAsolve");\n\n	x = zv_copy(b,x);\n	zUAsolve(LU,x,x,0.0);	/* explicit diagonal */\n	zLAsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */\n	pxinv_zvec(pivot,x,x);	/* x := P^*.x */\n\n	return (x);\n}\n\n/* zm_inverse -- returns inverse of A, provided A is not too rank deficient\n	-- uses LU factorisation */\nZMAT	*zm_inverse(A,out)\nZMAT	*A, *out;\n{\n	int	i;\n	STATIC ZVEC	*tmp=ZVNULL, *tmp2=ZVNULL;\n	STATIC ZMAT	*A_cp=ZMNULL;\n	STATIC PERM	*pivot=PNULL;\n\n	if ( ! A )\n	    error(E_NULL,"zm_inverse");\n	if ( A->m != A->n )\n	    error(E_SQUARE,"zm_inverse");\n	if ( ! out || out->m < A->m || out->n < A->n )\n	    out = zm_resize(out,A->m,A->n);\n\n	A_cp = zm_resize(A_cp,A->m,A->n);\n	A_cp = zm_copy(A,A_cp);\n	tmp = zv_resize(tmp,A->m);\n	tmp2 = zv_resize(tmp2,A->m);\n	pivot = px_resize(pivot,A->m);\n	MEM_STAT_REG(A_cp,TYPE_ZMAT);\n	MEM_STAT_REG(tmp, TYPE_ZVEC);\n	MEM_STAT_REG(tmp2,TYPE_ZVEC);\n	MEM_STAT_REG(pivot,TYPE_PERM);\n	tracecatch(zLUfactor(A_cp,pivot),"zm_inverse");\n	for ( i = 0; i < A->n; i++ )\n	{\n	    zv_zero(tmp);\n	    tmp->ve[i].re = 1.0;\n	    tmp->ve[i].im = 0.0;\n	    tracecatch(zLUsolve(A_cp,pivot,tmp,tmp2),"zm_inverse");\n	    zset_col(out,i,tmp2);\n	}\n\n#ifdef	THREADSAFE\n	ZV_FREE(tmp);	ZV_FREE(tmp2);\n	ZM_FREE(A_cp);	PX_FREE(pivot);\n#endif\n\n	return out;\n}\n\n/* zLUcondest -- returns an estimate of the condition number of LU given the\n	LU factorisation in compact form */\ndouble	zLUcondest(LU,pivot)\nZMAT	*LU;\nPERM	*pivot;\n{\n    STATIC	ZVEC	*y = ZVNULL, *z = ZVNULL;\n    Real	cond_est, L_norm, U_norm, norm, sn_inv;\n    complex	sum;\n    int		i, j, n;\n\n    if ( ! LU || ! pivot )\n	error(E_NULL,"zLUcondest");\n    if ( LU->m != LU->n )\n	error(E_SQUARE,"zLUcondest");\n    if ( LU->n != pivot->size )\n	error(E_SIZES,"zLUcondest");\n\n    n = LU->n;\n    y = zv_resize(y,n);\n    z = zv_resize(z,n);\n    MEM_STAT_REG(y,TYPE_ZVEC);\n    MEM_STAT_REG(z,TYPE_ZVEC);\n\n    cond_est = 0.0;		/* should never be returned */\n\n    for ( i = 0; i < n; i++ )\n    {\n	sum.re = 1.0;\n	sum.im = 0.0;\n	for ( j = 0; j < i; j++ )\n	    /* sum -= LU->me[j][i]*y->ve[j]; */\n	    sum = zsub(sum,zmlt(LU->me[j][i],y->ve[j]));\n	/* sum -= (sum < 0.0) ? 1.0 : -1.0; */\n	sn_inv = 1.0 / zabs(sum);\n	sum.re += sum.re * sn_inv;\n	sum.im += sum.im * sn_inv;\n	if ( is_zero(LU->me[i][i]) )\n	    return HUGE_VAL;\n	/* y->ve[i] = sum / LU->me[i][i]; */\n	y->ve[i] = zdiv(sum,LU->me[i][i]);\n    }\n\n    zLAsolve(LU,y,y,1.0);\n    zLUsolve(LU,pivot,y,z);\n\n    /* now estimate norm of A (even though it is not directly available) */\n    /* actually computes ||L||_inf.||U||_inf */\n    U_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	norm = 0.0;\n	for ( j = i; j < n; j++ )\n	    norm += zabs(LU->me[i][j]);\n	if ( norm > U_norm )\n	    U_norm = norm;\n    }\n    L_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	norm = 1.0;\n	for ( j = 0; j < i; j++ )\n	    norm += zabs(LU->me[i][j]);\n	if ( norm > L_norm )\n	    L_norm = norm;\n    }\n\n    tracecatch(cond_est = U_norm*L_norm*zv_norm_inf(z)/zv_norm_inf(y),\n	       "zLUcondest");\n#ifdef	THREADSAFE\n    ZV_FREE(y);		ZV_FREE(z);\n#endif\n\n    return cond_est;\n}\n