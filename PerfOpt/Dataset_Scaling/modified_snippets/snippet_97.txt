\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* LUfactor.c 1.5 11/25/87 */\nstatic	char	rcsid[] = "$Id: lufactor.c,v 1.10 1995/05/16 17:26:44 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* LUfactor -- gaussian elimination with scaled partial pivoting\n		-- Note: returns LU matrix which is A */\n#ifndef ANSI_C\nMAT	*LUfactor(A,pivot)\nMAT	*A;\nPERM	*pivot;\n#else\nMAT	*LUfactor(MAT *A, PERM *pivot)\n#endif\n{\n	unsigned int	i, j, m, n;\n	int	i_max, k, k_max;\n	Real	**A_v, *A_piv, *A_row;\n	Real	max1, temp, tiny;\n	STATIC	VEC	*scale = VNULL;\n\n	if ( A==(MAT *)NULL || pivot==(PERM *)NULL )\n		error(E_NULL,"LUfactor");\n	if ( pivot->size != A->m )\n		error(E_SIZES,"LUfactor");\n	m = A->m;	n = A->n;\n	scale = v_resize(scale,A->m);\n	MEM_STAT_REG(scale,TYPE_VEC);\n	A_v = A->me;\n\n	tiny = 10.0/HUGE_VAL;\n\n	/* initialise pivot with identity permutation */\n	for ( i=0; i<m; i++ )\n		pivot->pe[i] = i;\n\n	/* set scale parameters */\n	for ( i=0; i<m; i++ )\n	{\n		max1 = 0.0;\n		for ( j=0; j<n; j++ )\n		{\n			temp = fabs(A_v[i][j]);\n			max1 = max(max1,temp);\n		}\n		scale->ve[i] = max1;\n	}\n\n	/* main loop */\n	k_max = min(m,n)-1;\n	for ( k=0; k<k_max; k++ )\n	{\n	    /* find best pivot row */\n	    max1 = 0.0;	i_max = -1;\n	    for ( i=k; i<m; i++ )\n		if ( fabs(scale->ve[i]) >= tiny*fabs(A_v[i][k]) )\n		{\n		    temp = fabs(A_v[i][k])/scale->ve[i];\n		    if ( temp > max1 )\n		    { max1 = temp;	i_max = i;	}\n		}\n	    \n	    /* if no pivot then ignore column k... */\n	    if ( i_max == -1 )\n	    {\n		/* set pivot entry A[k][k] exactly to zero,\n		   rather than just "small" */\n		A_v[k][k] = 0.0;\n		continue;\n	    }\n	    \n	    /* do we pivot ? */\n	    if ( i_max != k )	/* yes we do... */\n	    {\n		px_transp(pivot,i_max,k);\n		for ( j=0; j<n; j++ )\n		{\n		    temp = A_v[i_max][j];\n		    A_v[i_max][j] = A_v[k][j];\n		    A_v[k][j] = temp;\n		}\n	    }\n	    \n	    /* row operations */\n	    for ( i=k+1; i<m; i++ )	/* for each row do... */\n	    {	/* Note: divide by zero should never happen */\n		temp = A_v[i][k] = A_v[i][k]/A_v[k][k];\n		A_piv = &(A_v[k][k+1]);\n		A_row = &(A_v[i][k+1]);\n		if ( k+1 < n )\n		    __mltadd__(A_row,A_piv,-temp,(int)(n-(k+1)));\n		/*********************************************\n		  for ( j=k+1; j<n; j++ )\n		  A_v[i][j] -= temp*A_v[k][j];\n		  (*A_row++) -= temp*(*A_piv++);\n		  *********************************************/\n	    }\n	    \n	}\n\n#ifdef	THREADSAFE\n	V_FREE(scale);\n#endif\n\n	return A;\n}\n\n\n/* LUsolve -- given an LU factorisation in A, solve Ax=b */\n#ifndef ANSI_C\nVEC	*LUsolve(LU,pivot,b,x)\nMAT	*LU;\nPERM	*pivot;\nVEC	*b,*x;\n#else\nVEC	*LUsolve(const MAT *LU, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	if ( ! LU || ! b || ! pivot )\n		error(E_NULL,"LUsolve");\n	if ( LU->m != LU->n || LU->n != b->dim )\n		error(E_SIZES,"LUsolve");\n\n	x = v_resize(x,b->dim);\n	px_vec(pivot,b,x);	/* x := P.b */\n	Lsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */\n	Usolve(LU,x,x,0.0);	/* explicit diagonal */\n\n	return (x);\n}\n\n/* LUTsolve -- given an LU factorisation in A, solve A^T.x=b */\n#ifndef ANSI_C\nVEC	*LUTsolve(LU,pivot,b,x)\nMAT	*LU;\nPERM	*pivot;\nVEC	*b,*x;\n#else\nVEC	*LUTsolve(const MAT *LU, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	if ( ! LU || ! b || ! pivot )\n		error(E_NULL,"LUTsolve");\n	if ( LU->m != LU->n || LU->n != b->dim )\n		error(E_SIZES,"LUTsolve");\n\n	x = v_copy(b,x);\n	UTsolve(LU,x,x,0.0);	/* explicit diagonal */\n	LTsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */\n	pxinv_vec(pivot,x,x);	/* x := P^T.tmp */\n\n	return (x);\n}\n\n/* m_inverse -- returns inverse of A, provided A is not too rank deficient\n	-- uses LU factorisation */\n#ifndef ANSI_C\nMAT	*m_inverse(A,out)\nMAT	*A, *out;\n#else\nMAT	*m_inverse(const MAT *A, MAT *out)\n#endif\n{\n	int	i;\n	STATIC VEC	*tmp = VNULL, *tmp2 = VNULL;\n	STATIC MAT	*A_cp = MNULL;\n	STATIC PERM	*pivot = PNULL;\n\n	if ( ! A )\n	    error(E_NULL,"m_inverse");\n	if ( A->m != A->n )\n	    error(E_SQUARE,"m_inverse");\n	if ( ! out || out->m < A->m || out->n < A->n )\n	    out = m_resize(out,A->m,A->n);\n\n	A_cp = m_resize(A_cp,A->m,A->n);\n	A_cp = m_copy(A,A_cp);\n	tmp = v_resize(tmp,A->m);\n	tmp2 = v_resize(tmp2,A->m);\n	pivot = px_resize(pivot,A->m);\n	MEM_STAT_REG(A_cp,TYPE_MAT);\n	MEM_STAT_REG(tmp, TYPE_VEC);\n	MEM_STAT_REG(tmp2,TYPE_VEC);\n	MEM_STAT_REG(pivot,TYPE_PERM);\n	tracecatch(LUfactor(A_cp,pivot),"m_inverse");\n	for ( i = 0; i < A->n; i++ )\n	{\n	    v_zero(tmp);\n	    tmp->ve[i] = 1.0;\n	    tracecatch(LUsolve(A_cp,pivot,tmp,tmp2),"m_inverse");\n	    set_col(out,i,tmp2);\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(tmp);	V_FREE(tmp2);\n	M_FREE(A_cp);	PX_FREE(pivot);\n#endif\n\n	return out;\n}\n\n/* LUcondest -- returns an estimate of the condition number of LU given the\n	LU factorisation in compact form */\n#ifndef ANSI_C\ndouble	LUcondest(LU,pivot)\nMAT	*LU;\nPERM	*pivot;\n#else\ndouble	LUcondest(const MAT *LU, PERM *pivot)\n#endif\n{\n    STATIC	VEC	*y = VNULL, *z = VNULL;\n    Real	cond_est, L_norm, U_norm, sum, tiny;\n    int		i, j, n;\n\n    if ( ! LU || ! pivot )\n	error(E_NULL,"LUcondest");\n    if ( LU->m != LU->n )\n	error(E_SQUARE,"LUcondest");\n    if ( LU->n != pivot->size )\n	error(E_SIZES,"LUcondest");\n\n    tiny = 10.0/HUGE_VAL;\n\n    n = LU->n;\n    y = v_resize(y,n);\n    z = v_resize(z,n);\n    MEM_STAT_REG(y,TYPE_VEC);\n    MEM_STAT_REG(z,TYPE_VEC);\n\n    for ( i = 0; i < n; i++ )\n    {\n	sum = 0.0;\n	for ( j = 0; j < i; j++ )\n	    sum -= LU->me[j][i]*y->ve[j];\n	sum -= (sum < 0.0) ? 1.0 : -1.0;\n	if ( fabs(LU->me[i][i]) <= tiny*fabs(sum) )\n	    return HUGE_VAL;\n	y->ve[i] = sum / LU->me[i][i];\n    }\n\n    catch(E_SING,\n	  LTsolve(LU,y,y,1.0);\n	  LUsolve(LU,pivot,y,z);\n	  ,\n	  return HUGE_VAL);\n\n    /* now estimate norm of A (even though it is not directly available) */\n    /* actually computes ||L||_inf.||U||_inf */\n    U_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	sum = 0.0;\n	for ( j = i; j < n; j++ )\n	    sum += fabs(LU->me[i][j]);\n	if ( sum > U_norm )\n	    U_norm = sum;\n    }\n    L_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	sum = 1.0;\n	for ( j = 0; j < i; j++ )\n	    sum += fabs(LU->me[i][j]);\n	if ( sum > L_norm )\n	    L_norm = sum;\n    }\n\n    tracecatch(cond_est = U_norm*L_norm*v_norm_inf(z)/v_norm_inf(y),\n	       "LUcondest");\n\n#ifdef	THREADSAFE\n    V_FREE(y);    V_FREE(z);\n#endif\n\n    return cond_est;\n}\n