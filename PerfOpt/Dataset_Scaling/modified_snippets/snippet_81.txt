\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This is a file of routines for zero-ing, and initialising\n	vectors, matrices and permutations.\n	This is to be included in the matrix.a library\n*/\n\nstatic	char	rcsid[] = "$Id: init.c,v 1.6 1994/01/13 05:36:58 des Exp $";\n\n#include	<stdio.h>\n#include	"matrix.h"\n\n/* v_zero -- zero the vector x */\n#ifndef ANSI_C\nVEC	*v_zero(x)\nVEC	*x;\n#else\nVEC	*v_zero(VEC *x)\n#endif\n{\n	if ( x == VNULL )\n		error(E_NULL,"v_zero");\n\n	__zero__(x->ve,x->dim);\n	/* for ( i = 0; i < x->dim; i++ )\n		x->ve[i] = 0.0; */\n\n	return x;\n}\n\n\n/* iv_zero -- zero the vector ix */\n#ifndef ANSI_C\nIVEC	*iv_zero(ix)\nIVEC	*ix;\n#else\nIVEC	*iv_zero(IVEC *ix)\n#endif\n{\n   int i;\n   \n   if ( ix == IVNULL )\n     error(E_NULL,"iv_zero");\n   \n   for ( i = 0; i < ix->dim; i++ )\n     ix->ive[i] = 0; \n   \n   return ix;\n}\n\n\n/* m_zero -- zero the matrix A */\n#ifndef ANSI_C\nMAT	*m_zero(A)\nMAT	*A;\n#else\nMAT	*m_zero(MAT *A)\n#endif\n{\n	int	i, A_m, A_n;\n	Real	**A_me;\n\n	if ( A == MNULL )\n		error(E_NULL,"m_zero");\n\n	A_m = A->m;	A_n = A->n;	A_me = A->me;\n	for ( i = 0; i < A_m; i++ )\n		__zero__(A_me[i],A_n);\n		/* for ( j = 0; j < A_n; j++ )\n			A_me[i][j] = 0.0; */\n\n	return A;\n}\n\n/* mat_id -- set A to being closest to identity matrix as possible\n	-- i.e. A[i][j] == 1 if i == j and 0 otherwise */\n#ifndef ANSI_C\nMAT	*m_ident(A)\nMAT	*A;\n#else\nMAT	*m_ident(MAT *A)\n#endif\n{\n	int	i, size;\n\n	if ( A == MNULL )\n		error(E_NULL,"m_ident");\n\n	m_zero(A);\n	size = min(A->m,A->n);\n	for ( i = 0; i < size; i++ )\n		A->me[i][i] = 1.0;\n\n	return A;\n}\n	\n/* px_ident -- set px to identity permutation */\n#ifndef ANSI_C\nPERM	*px_ident(px)\nPERM	*px;\n#else\nPERM	*px_ident(PERM *px)\n#endif\n{\n	int	i, px_size;\n	unsigned int	*px_pe;\n\n	if ( px == PNULL )\n		error(E_NULL,"px_ident");\n\n	px_size = px->size;	px_pe = px->pe;\n	for ( i = 0; i < px_size; i++ )\n		px_pe[i] = i;\n\n	return px;\n}\n\n/* Pseudo random number generator data structures */\n/* Knuth's lagged Fibonacci-based generator: See "Seminumerical Algorithms:\n   The Art of Computer Programming" sections 3.2-3.3 */\n\n#ifdef ANSI_C\n#ifndef LONG_MAX\n#include	<limits.h>\n#endif\n#endif\n\n#ifdef LONG_MAX\n#define MODULUS	LONG_MAX\n#else\n#define MODULUS	1000000000L	/* assuming long's at least 32 bits long */\n#endif\n#define MZ	0L\n\nstatic long mrand_list[56];\nstatic int  started = FALSE;\nstatic int  inext = 0, inextp = 31;\n\n\n/* mrand -- pseudo-random number generator */\n#ifdef ANSI_C\ndouble mrand(void)\n#else\ndouble mrand()\n#endif\n{\n    long	lval;\n    static Real  factor = 1.0/((Real)MODULUS);\n    \n    if ( ! started )\n	smrand(3127);\n    \n    inext = (inext >= 54) ? 0 : inext+1;\n    inextp = (inextp >= 54) ? 0 : inextp+1;\n\n    lval = mrand_list[inext]-mrand_list[inextp];\n    if ( lval < 0L )\n	lval += MODULUS;\n    mrand_list[inext] = lval;\n    \n    return (double)lval*factor;\n}\n\n/* mrandlist -- fills the array a[] with len random numbers */\n#ifndef ANSI_C\nvoid	mrandlist(a, len)\nReal	a[];\nint	len;\n#else\nvoid	mrandlist(Real a[], int len)\n#endif\n{\n    int		i;\n    long	lval;\n    static Real  factor = 1.0/((Real)MODULUS);\n    \n    if ( ! started )\n	smrand(3127);\n    \n    for ( i = 0; i < len; i++ )\n    {\n	inext = (inext >= 54) ? 0 : inext+1;\n	inextp = (inextp >= 54) ? 0 : inextp+1;\n	\n	lval = mrand_list[inext]-mrand_list[inextp];\n	if ( lval < 0L )\n	    lval += MODULUS;\n	mrand_list[inext] = lval;\n	\n	a[i] = (Real)lval*factor;\n    }\n}\n\n\n/* smrand -- set seed for mrand() */\n#ifndef ANSI_C\nvoid smrand(seed)\nint	seed;\n#else\nvoid smrand(int seed)\n#endif\n{\n    int		i;\n\n    mrand_list[0] = (123413*seed) % MODULUS;\n    for ( i = 1; i < 55; i++ )\n	mrand_list[i] = (123413*mrand_list[i-1]) % MODULUS;\n\n    started = TRUE;\n\n    /* run mrand() through the list sufficient times to\n       thoroughly randomise the array */\n    for ( i = 0; i < 55*55; i++ )\n	mrand();\n}\n#undef MODULUS\n#undef MZ\n#undef FAC\n\n/* v_rand -- initialises x to be a random vector, components\n	independently & uniformly ditributed between 0 and 1 */\n#ifndef ANSI_C\nVEC	*v_rand(x)\nVEC	*x;\n#else\nVEC	*v_rand(VEC *x)\n#endif\n{\n	/* int	i; */\n\n	if ( ! x )\n		error(E_NULL,"v_rand");\n\n	/* for ( i = 0; i < x->dim; i++ ) */\n	    /* x->ve[i] = rand()/((Real)MAX_RAND); */\n	    /* x->ve[i] = mrand(); */\n	mrandlist(x->ve,x->dim);\n\n	return x;\n}\n\n/* m_rand -- initialises A to be a random vector, components\n	independently & uniformly distributed between 0 and 1 */\n#ifndef ANSI_C\nMAT	*m_rand(A)\nMAT	*A;\n#else\nMAT	*m_rand(MAT *A)\n#endif\n{\n	int	i /* , j */;\n\n	if ( ! A )\n		error(E_NULL,"m_rand");\n\n	for ( i = 0; i < A->m; i++ )\n		/* for ( j = 0; j < A->n; j++ ) */\n		    /* A->me[i][j] = rand()/((Real)MAX_RAND); */\n		    /* A->me[i][j] = mrand(); */\n	    mrandlist(A->me[i],A->n);\n\n	return A;\n}\n\n/* v_ones -- fills x with one's */\n#ifndef ANSI_C\nVEC	*v_ones(x)\nVEC	*x;\n#else\nVEC	*v_ones(VEC *x)\n#endif\n{\n	int	i;\n\n	if ( ! x )\n		error(E_NULL,"v_ones");\n\n	for ( i = 0; i < x->dim; i++ )\n		x->ve[i] = 1.0;\n\n	return x;\n}\n\n/* m_ones -- fills matrix with one's */\n#ifndef ANSI_C\nMAT	*m_ones(A)\nMAT	*A;\n#else\nMAT	*m_ones(MAT *A)\n#endif\n{\n	int	i, j;\n\n	if ( ! A )\n		error(E_NULL,"m_ones");\n\n	for ( i = 0; i < A->m; i++ )\n		for ( j = 0; j < A->n; j++ )\n		    A->me[i][j] = 1.0;\n\n	return A;\n}\n\n/* v_count -- initialises x so that x->ve[i] == i */\n#ifndef ANSI_C\nVEC	*v_count(x)\nVEC	*x;\n#else\nVEC	*v_count(VEC *x)\n#endif\n{\n	int	i;\n\n	if ( ! x )\n	    error(E_NULL,"v_count");\n\n	for ( i = 0; i < x->dim; i++ )\n	    x->ve[i] = (Real)i;\n\n	return x;\n}\n