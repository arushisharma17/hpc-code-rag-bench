\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	This file contains a series of tests for the Meschach matrix\n	library, parts 1 and 2\n*/\n\nstatic char rcsid[] = "$Id: torture.c,v 1.6 1994/08/25 15:22:11 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix2.h"\n#include        "matlab.h"\n\n#define	errmesg(mesg)	printf("Error: %s error: line %d\n",mesg,__LINE__)\n#define notice(mesg)	printf("# Testing %s...\n",mesg);\n\nstatic char *test_err_list[] = {\n   "unknown error",			/* 0 */\n   "testing error messages",		/* 1 */\n   "unexpected end-of-file"		/* 2 */\n};\n\n\n#define MAX_TEST_ERR   (sizeof(test_err_list)/sizeof(char *))\n\n/* extern	int	malloc_chain_check(); */\n/* #define MEMCHK() if ( malloc_chain_check(0) ) \\n{ printf("Error in malloc chain: \"%s\", line %d\n", \\n	 __FILE__, __LINE__); exit(0); } */\n#define	MEMCHK() \n\n/* cmp_perm -- returns 1 if pi1 == pi2, 0 otherwise */\nint	cmp_perm(pi1, pi2)\nPERM	*pi1, *pi2;\n{\n    int		i;\n\n    if ( ! pi1 || ! pi2 )\n	error(E_NULL,"cmp_perm");\n    if ( pi1->size != pi2->size )\n	return 0;\n    for ( i = 0; i < pi1->size; i++ )\n	if ( pi1->pe[i] != pi2->pe[i] )\n	    return 0;\n    return 1;\n}\n\n/* px_rand -- generates sort-of random permutation */\nPERM	*px_rand(pi)\nPERM	*pi;\n{\n    int		i, j, k;\n\n    if ( ! pi )\n	error(E_NULL,"px_rand");\n\n    for ( i = 0; i < 3*pi->size; i++ )\n    {\n	j = (rand() >> 8) % pi->size;\n	k = (rand() >> 8) % pi->size;\n	px_transp(pi,j,k);\n    }\n\n    return pi;\n}\n\n#define	SAVE_FILE	"asx5213a.mat"\n#define	MATLAB_NAME	"alpha"\nchar	name[81] = MATLAB_NAME;\n\nint main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n   VEC	*x = VNULL, *y = VNULL, *z = VNULL, *u = VNULL, *v = VNULL, \n        *w = VNULL;\n   VEC	*diag = VNULL, *beta = VNULL;\n   PERM	*pi1 = PNULL, *pi2 = PNULL, *pi3 = PNULL, *pivot = PNULL, \n        *blocks = PNULL;\n   MAT	*A = MNULL, *B = MNULL, *C = MNULL, *D = MNULL, *Q = MNULL, \n        *U = MNULL;\n   BAND *bA, *bB, *bC;\n   Real	cond_est, s1, s2, s3;\n   int	i, j, seed;\n   FILE	*fp;\n   char	*cp;\n\n\n    mem_info_on(TRUE);\n\n    setbuf(stdout,(char *)NULL);\n\n    seed = 1111;\n    if ( argc > 2 )\n    {\n	printf("usage: %s [seed]\n",argv[0]);\n	exit(0);\n    }\n    else if ( argc == 2 )\n	sscanf(argv[1], "%d", &seed);\n\n    /* set seed for rand() */\n    smrand(seed);\n\n    mem_stat_mark(1);\n\n    /* print version information */\n    m_version();\n\n    printf("# grep \"^Error\" the output for a listing of errors\n");\n    printf("# Don't panic if you see \"Error\" appearing; \n");\n    printf("# Also check the reported size of error\n");\n    printf("# This program uses randomly generated problems and therefore\n");\n    printf("# may occasionally produce ill-conditioned problems\n");\n    printf("# Therefore check the size of the error compared with MACHEPS\n");\n    printf("# If the error is within 1000*MACHEPS then don't worry\n");\n    printf("# If you get an error of size 0.1 or larger there is \n");\n    printf("# probably a bug in the code or the compilation procedure\n\n");\n    printf("# seed = %d\n",seed);\n\n    printf("# Check: MACHEPS = %g\n",MACHEPS);\n    /* allocate, initialise, copy and resize operations */\n    /* VEC */\n    notice("vector initialise, copy & resize");\n    x = v_get(12);\n    y = v_get(15);\n    z = v_get(12);\n    v_rand(x);\n    v_rand(y);\n    z = v_copy(x,z);\n    if ( v_norm2(v_sub(x,z,z)) >= MACHEPS )\n	errmesg("VEC copy");\n    v_copy(x,y);\n    x = v_resize(x,10);\n    y = v_resize(y,10);\n    if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n	errmesg("VEC copy/resize");\n    x = v_resize(x,15);\n    y = v_resize(y,15);\n    if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n	errmesg("VEC resize");\n\n    /* MAT */\n    notice("matrix initialise, copy & resize");\n    A = m_get(8,5);\n    B = m_get(3,9);\n    C = m_get(8,5);\n    m_rand(A);\n    m_rand(B);\n    C = m_copy(A,C);\n    if ( m_norm_inf(m_sub(A,C,C)) >= MACHEPS )\n	errmesg("MAT copy");\n    m_copy(A,B);\n    A = m_resize(A,3,5);\n    B = m_resize(B,3,5);\n    if ( m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n	errmesg("MAT copy/resize");\n    A = m_resize(A,10,10);\n    B = m_resize(B,10,10);\n    if ( m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n	errmesg("MAT resize");\n\n    MEMCHK();\n\n    /* PERM */\n    notice("permutation initialise, inverting & permuting vectors");\n    pi1 = px_get(15);\n    pi2 = px_get(12);\n    px_rand(pi1);\n    v_rand(x);\n    px_vec(pi1,x,z);\n    y = v_resize(y,x->dim);\n    pxinv_vec(pi1,z,y);\n    if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n	errmesg("PERMute vector");\n    pi2 = px_inv(pi1,pi2);\n    pi3 = px_mlt(pi1,pi2,PNULL);\n    for ( i = 0; i < pi3->size; i++ )\n	if ( pi3->pe[i] != i )\n	    errmesg("PERM inverse/multiply");\n\n    /* testing catch() etc */\n    notice("error handling routines");\n    catch(E_NULL,\n	  catchall(v_add(VNULL,VNULL,VNULL);\n		     errmesg("tracecatch() failure"),\n		     printf("# tracecatch() caught error\n");\n		     error(E_NULL,"main"));\n	             errmesg("catch() failure"),\n	  printf("# catch() caught E_NULL error\n"));\n\n    /* testing attaching a new error list (error list 2) */\n\n    notice("attaching error lists");\n    printf("# IT IS NOT A REAL WARNING ... \n");\n    err_list_attach(2,MAX_TEST_ERR,test_err_list,TRUE);\n    if (!err_is_list_attached(2)) \n       errmesg("attaching the error list 2");\n    ev_err(__FILE__,1,__LINE__,"main",2);\n    err_list_free(2);\n    if (err_is_list_attached(2)) \n       errmesg("detaching the error list 2");\n\n    /* testing inner products and v_mltadd() etc */\n    notice("inner products and linear combinations");\n    u = v_get(x->dim);\n    v_rand(u);\n    v_rand(x);\n    v_resize(y,x->dim);\n    v_rand(y);\n    v_mltadd(y,x,-in_prod(x,y)/in_prod(x,x),z);\n    if ( fabs(in_prod(x,z)) >= MACHEPS*x->dim )\n	errmesg("v_mltadd()/in_prod()");\n    s1 = -in_prod(x,y)/(v_norm2(x)*v_norm2(x));\n    sv_mlt(s1,x,u);\n    v_add(y,u,u);\n    if ( v_norm2(v_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg("sv_mlt()/v_norm2()");\n\n#ifdef ANSI_C \n    v_linlist(u,x,s1,y,1.0,VNULL);\n    if ( v_norm2(v_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg("v_linlist()");\n#endif\n#ifdef VARARGS\n    v_linlist(u,x,s1,y,1.0,VNULL);\n    if ( v_norm2(v_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg("v_linlist()");\n#endif\n\n\n    MEMCHK();\n\n    /* vector norms */\n    notice("vector norms");\n    x = v_resize(x,12);\n    v_rand(x);\n    for ( i = 0; i < x->dim; i++ )\n	if ( v_entry(x,i) >= 0.5 )\n	    v_set_val(x,i,1.0);\n        else\n	    v_set_val(x,i,-1.0);\n    s1 = v_norm1(x);\n    s2 = v_norm2(x);	\n    s3 = v_norm_inf(x);\n    if ( fabs(s1 - x->dim) >= MACHEPS*x->dim ||\n	 fabs(s2 - sqrt((Real)(x->dim))) >= MACHEPS*x->dim ||\n	 fabs(s3 - 1.0) >= MACHEPS )\n	errmesg("v_norm1/2/_inf()");\n\n    /* test matrix multiply etc */\n    notice("matrix multiply and invert");\n    A = m_resize(A,10,10);\n    B = m_resize(B,10,10);\n    m_rand(A);\n    m_inverse(A,B);\n    m_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("m_inverse()/m_mlt()");\n\n    MEMCHK();\n\n    /* ... and transposes */\n    notice("transposes and transpose-multiplies");\n    m_transp(A,A);	/* can do square matrices in situ */\n    mtrm_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("m_transp()/mtrm_mlt()");\n    m_transp(A,A);\n    m_transp(B,B);\n    mmtr_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("m_transp()/mmtr_mlt()");\n    sm_mlt(3.71,B,B);\n    mmtr_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-3.71);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("sm_mlt()/mmtr_mlt()");\n    m_transp(B,B);\n    sm_mlt(1.0/3.71,B,B);\n\n    MEMCHK();\n\n    /* ... and matrix-vector multiplies */\n    notice("matrix-vector multiplies");\n    x = v_resize(x,A->n);\n    y = v_resize(y,A->m);\n    z = v_resize(z,A->m);\n    u = v_resize(u,A->n);\n    v_rand(x);\n    v_rand(y);\n    mv_mlt(A,x,z);\n    s1 = in_prod(y,z);\n    vm_mlt(A,y,u);\n    s2 = in_prod(u,x);\n    if ( fabs(s1 - s2) >= (MACHEPS*x->dim)*x->dim )\n	errmesg("mv_mlt()/vm_mlt()");\n    mv_mlt(B,z,u);\n    if ( v_norm2(v_sub(u,x,u)) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("mv_mlt()/m_inverse()");\n\n    MEMCHK();\n\n    /* get/set row/col */\n    notice("getting and setting rows and cols");\n    x = v_resize(x,A->n);\n    y = v_resize(y,B->m);\n    x = get_row(A,3,x);\n    y = get_col(B,3,y);\n    if ( fabs(in_prod(x,y) - 1.0) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("get_row()/get_col()");\n    sv_mlt(-1.0,x,x);\n    sv_mlt(-1.0,y,y);\n    set_row(A,3,x);\n    set_col(B,3,y);\n    m_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg("set_row()/set_col()");\n\n    MEMCHK();\n\n    /* matrix norms */\n    notice("matrix norms");\n    A = m_resize(A,11,15);\n    m_rand(A);\n    s1 = m_norm_inf(A);\n    B = m_transp(A,B);\n    s2 = m_norm1(B);\n    if ( fabs(s1 - s2) >= MACHEPS*A->m )\n	errmesg("m_norm1()/m_norm_inf()");\n    C = mtrm_mlt(A,A,C);\n    s1 = 0.0;\n    for ( i = 0; i < C->m && i < C->n; i++ )\n	s1 += m_entry(C,i,i);\n    if ( fabs(sqrt(s1) - m_norm_frob(A)) >= MACHEPS*A->m*A->n )\n	errmesg("m_norm_frob");\n\n    MEMCHK();\n    \n    /* permuting rows and columns */\n    notice("permuting rows & cols");\n    A = m_resize(A,11,15);\n    B = m_resize(B,11,15);\n    pi1 = px_resize(pi1,A->m);\n    px_rand(pi1);\n    x = v_resize(x,A->n);\n    y = mv_mlt(A,x,y);\n    px_rows(pi1,A,B);\n    px_vec(pi1,y,z);\n    mv_mlt(B,x,u);\n    if ( v_norm2(v_sub(z,u,u)) >= MACHEPS*A->m )\n	errmesg("px_rows()");\n    pi1 = px_resize(pi1,A->n);\n    px_rand(pi1);\n    px_cols(pi1,A,B);\n    pxinv_vec(pi1,x,z);\n    mv_mlt(B,z,u);\n    if ( v_norm2(v_sub(y,u,u)) >= MACHEPS*A->n )\n	errmesg("px_cols()");\n\n    MEMCHK();\n\n    /* MATLAB save/load */\n    notice("MATLAB save/load");\n    A = m_resize(A,12,11);\n    if ( (fp=fopen(SAVE_FILE,"w")) == (FILE *)NULL )\n	printf("Cannot perform MATLAB save/load test\n");\n    else\n    {\n	m_rand(A);\n	m_save(fp, A, name);\n	fclose(fp);\n	if ( (fp=fopen(SAVE_FILE,"r")) == (FILE *)NULL )\n	    printf("Cannot open save file \"%s\"\n",SAVE_FILE);\n	else\n	{\n	    M_FREE(B);\n	    B = m_load(fp,&cp);\n	    if ( strcmp(name,cp) || m_norm1(m_sub(A,B,B)) >= MACHEPS*A->m )\n		errmesg("mload()/m_save()");\n	}\n    }\n\n    MEMCHK();\n\n    /* Now, onto matrix factorisations */\n    A = m_resize(A,10,10);\n    B = m_resize(B,A->m,A->n);\n    m_copy(A,B);\n    x = v_resize(x,A->n);\n    y = v_resize(y,A->m);\n    z = v_resize(z,A->n);\n    u = v_resize(u,A->m);\n    v_rand(x);\n    mv_mlt(B,x,y);\n    z = v_copy(x,z);\n\n    notice("LU factor/solve");\n    pivot = px_get(A->m);\n    LUfactor(A,pivot);\n    tracecatch(LUsolve(A,pivot,y,x),"main");\n    tracecatch(cond_est = LUcondest(A,pivot),"main");\n    printf("# cond(A) approx= %g\n", cond_est);\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est)\n    {\n	errmesg("LUfactor()/LUsolve()");\n	printf("# LU solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n\n    v_copy(y,x);\n    tracecatch(LUsolve(A,pivot,x,x),"main");\n    tracecatch(cond_est = LUcondest(A,pivot),"main");\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est)\n    {\n	errmesg("LUfactor()/LUsolve()");\n	printf("# LU solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n\n    vm_mlt(B,z,y);\n    v_copy(y,x);\n    tracecatch(LUTsolve(A,pivot,x,x),"main");\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est)\n    {\n	errmesg("LUfactor()/LUTsolve()");\n	printf("# LU solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n \n    MEMCHK();\n\n    /* QR factorisation */\n    m_copy(B,A);\n    mv_mlt(B,z,y);\n    notice("QR factor/solve:");\n    diag = v_get(A->m);\n    beta = v_get(A->m);\n    QRfactor(A,diag);\n    QRsolve(A,diag,y,x);\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est )\n    {\n	errmesg("QRfactor()/QRsolve()");\n	printf("# QR solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n    Q = m_get(A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_mlt(Q,A,C);\n    m_sub(B,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(Q)*m_norm1(B) )\n    {\n	errmesg("QRfactor()/makeQ()/makeR()");\n	printf("# QR reconstruction error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(C), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now try with a non-square matrix */\n    A = m_resize(A,15,7);\n    m_rand(A);\n    B = m_copy(A,B);\n    diag = v_resize(diag,A->n);\n    beta = v_resize(beta,A->n);\n    x = v_resize(x,A->n);\n    y = v_resize(y,A->m);\n    v_rand(y);\n    QRfactor(A,diag);\n    x = QRsolve(A,diag,y,x);\n    /* z is the residual vector */\n    mv_mlt(B,x,z);	v_sub(z,y,z);\n    /* check B^T.z = 0 */\n    vm_mlt(B,z,u);\n    if ( v_norm2(u) >= MACHEPS*m_norm1(B)*v_norm2(y) )\n    {\n	errmesg("QRfactor()/QRsolve()");\n	printf("# QR solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(u), MACHEPS);\n    }\n    Q = m_resize(Q,A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_mlt(Q,A,C);\n    m_sub(B,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(Q)*m_norm1(B) )\n    {\n	errmesg("QRfactor()/makeQ()/makeR()");\n	printf("# QR reconstruction error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(C), MACHEPS);\n    }\n    D = m_get(A->m,Q->m);\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q) )\n    {\n	errmesg("QRfactor()/makeQ()/makeR()");\n	printf("# QR orthogonality error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* QRCP factorisation */\n    m_copy(B,A);\n    notice("QR factor/solve with column pivoting");\n    pivot = px_resize(pivot,A->n);\n    QRCPfactor(A,diag,pivot);\n    z = v_resize(z,A->n);\n    QRCPsolve(A,diag,pivot,y,z);\n    /* pxinv_vec(pivot,z,x); */\n    /* now compute residual (z) vector */\n    mv_mlt(B,x,z);	v_sub(z,y,z);\n    /* check B^T.z = 0 */\n    vm_mlt(B,z,u);\n    if ( v_norm2(u) >= MACHEPS*m_norm1(B)*v_norm2(y) )\n    {\n	errmesg("QRCPfactor()/QRsolve()");\n	printf("# QR solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(u), MACHEPS);\n    }\n\n    Q = m_resize(Q,A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_mlt(Q,A,C);\n    M_FREE(D);\n    D = m_get(B->m,B->n);\n    px_cols(pivot,C,D);\n    m_sub(B,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm1(B) )\n    {\n	errmesg("QRCPfactor()/makeQ()/makeR()");\n	printf("# QR reconstruction error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* Cholesky and LDL^T factorisation */\n    /* Use these for normal equations approach */\n    notice("Cholesky factor/solve");\n    mtrm_mlt(B,B,A);\n    CHfactor(A);\n    u = v_resize(u,B->n);\n    vm_mlt(B,y,u);\n    z = v_resize(z,B->n);\n    CHsolve(A,u,z);\n    v_sub(x,z,z);\n    if ( v_norm2(z) >= MACHEPS*v_norm2(x)*100 )\n    {\n	errmesg("CHfactor()/CHsolve()");\n	printf("# Cholesky solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(z), MACHEPS);\n    }\n    /* modified Cholesky factorisation should be identical with Cholesky\n       factorisation provided the matrix is "sufficiently positive definite" */\n    mtrm_mlt(B,B,C);\n    MCHfactor(C,MACHEPS);\n    m_sub(A,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(A) )\n    {\n	errmesg("MCHfactor()");\n	printf("# Modified Cholesky error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(C), MACHEPS);\n    }\n    /* now test the LDL^T factorisation -- using a negative def. matrix */\n    mtrm_mlt(B,B,A);\n    sm_mlt(-1.0,A,A);\n    m_copy(A,C);\n    LDLfactor(A);\n    LDLsolve(A,u,z);\n    w = v_get(A->m);\n    mv_mlt(C,z,w);\n    v_sub(w,u,w);\n    if ( v_norm2(w) >= MACHEPS*v_norm2(u)*m_norm1(C) )\n    {\n	errmesg("LDLfactor()/LDLsolve()");\n	printf("# LDL^T residual = %g [cf MACHEPS = %g]\n",\n	       v_norm2(w), MACHEPS);\n    }\n    v_add(x,z,z);\n    if ( v_norm2(z) >= MACHEPS*v_norm2(x)*100 )\n    {\n	errmesg("LDLfactor()/LDLsolve()");\n	printf("# LDL^T solution error = %g [cf MACHEPS = %g]\n",\n	       v_norm2(z), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* and now the Bunch-Kaufman-Parlett method */\n    /* set up D to be an indefinite diagonal matrix */\n    notice("Bunch-Kaufman-Parlett factor/solve");\n\n    D = m_resize(D,B->m,B->m);\n    m_zero(D);\n    w = v_resize(w,B->m);\n    v_rand(w);\n    for ( i = 0; i < w->dim; i++ )\n	if ( v_entry(w,i) >= 0.5 )\n	    m_set_val(D,i,i,1.0);\n	else\n	    m_set_val(D,i,i,-1.0);\n    /* set A <- B^T.D.B */\n    C = m_resize(C,B->n,B->n);\n    C = mtrm_mlt(B,D,C);\n    A = m_mlt(C,B,A);\n    C = m_resize(C,B->n,B->n);\n    C = m_copy(A,C);\n    /* ... and use BKPfactor() */\n    blocks = px_get(A->m);\n    pivot = px_resize(pivot,A->m);\n    x = v_resize(x,A->m);\n    y = v_resize(y,A->m);\n    z = v_resize(z,A->m);\n    v_rand(x);\n    mv_mlt(A,x,y);\n    BKPfactor(A,pivot,blocks);\n    printf("# BKP pivot =\n");	px_output(pivot);\n    printf("# BKP blocks =\n");	px_output(blocks);\n    BKPsolve(A,pivot,blocks,y,z);\n    /* compute & check residual */\n    mv_mlt(C,z,w);\n    v_sub(w,y,w);\n    if ( v_norm2(w) >= MACHEPS*m_norm1(C)*v_norm2(z) )\n    {\n	errmesg("BKPfactor()/BKPsolve()");\n	printf("# BKP residual size = %g [cf MACHEPS = %g]\n",\n	       v_norm2(w), MACHEPS);\n    }\n\n    /* check update routines */\n    /* check LDLupdate() first */\n    notice("update L.D.L^T routine");\n    A = mtrm_mlt(B,B,A);\n    m_resize(C,A->m,A->n);\n    C = m_copy(A,C);\n    LDLfactor(A);\n    s1 = 3.7;\n    w = v_resize(w,A->m);\n    v_rand(w);\n    for ( i = 0; i < C->m; i++ )\n	for ( j = 0; j < C->n; j++ )\n	    m_set_val(C,i,j,m_entry(C,i,j)+s1*v_entry(w,i)*v_entry(w,j));\n    LDLfactor(C);\n    LDLupdate(A,w,s1);\n    /* zero out strictly upper triangular parts of A and C */\n    for ( i = 0; i < A->m; i++ )\n	for ( j = i+1; j < A->n; j++ )\n	{\n	    m_set_val(A,i,j,0.0);\n	    m_set_val(C,i,j,0.0);\n	}\n    if ( m_norm1(m_sub(A,C,C)) >= sqrt(MACHEPS)*m_norm1(A) )\n    {\n	errmesg("LDLupdate()");\n	printf("# LDL update matrix error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(C), MACHEPS);\n    }\n\n\n    /* BAND MATRICES */\n\n#define COL 40\n#define UDIAG  5\n#define LDIAG  2\n\n   smrand(101);\n   bA = bd_get(LDIAG,UDIAG,COL);\n   bB = bd_get(LDIAG,UDIAG,COL);\n   bC = bd_get(LDIAG,UDIAG,COL);\n   A = m_resize(A,COL,COL);\n   B = m_resize(B,COL,COL);\n   pivot = px_resize(pivot,COL);\n   x = v_resize(x,COL);\n   w = v_resize(w,COL);\n   z = v_resize(z,COL);\n\n   m_rand(A); \n   /* generate band matrix */\n   mat2band(A,LDIAG,UDIAG,bA);\n   band2mat(bA,A);    /* now A is banded */\n   bB = bd_copy(bA,bB); \n\n   v_rand(x);  \n   mv_mlt(A,x,w);\n   /* test of bd_mv_mlt */\n   notice("bd_mv_mlt");\n   bd_mv_mlt(bA,x,z);\n   v_sub(z,w,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg("incorrect vector (bd_mv_mlt)");\n      printf(" ||exact vector. - computed vector.|| = %g [MACHEPS = %g]\n",\n             v_norm2(z),MACHEPS);\n   }   \n\n   z = v_copy(w,z);\n\n   notice("band LU factorization");\n   bdLUfactor(bA,pivot);\n\n   /* pivot will be changed */\n   bdLUsolve(bA,pivot,z,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg("incorrect solution (band LU factorization)");\n      printf(" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n",\n	     v_norm2(z),MACHEPS);\n   }\n\n   /* solve transpose system */\n\n   notice("band LU factorization for transpose system");\n   m_transp(A,B);\n   mv_mlt(B,x,w);\n\n   bd_copy(bB,bA);\n   bd_transp(bA,bA);  \n   /* transposition in situ */\n   bd_transp(bA,bB);\n   bd_transp(bB,bB);\n\n   bdLUfactor(bB,pivot);\n\n   bdLUsolve(bB,pivot,w,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg("incorrect solution (band transposed LU factorization)");\n      printf(" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n",\n	     v_norm2(z),MACHEPS);\n   }\n\n\n   /* Cholesky factorization */\n\n   notice("band Choleski LDL' factorization");\n   m_add(A,B,A);  /* symmetric matrix */\n   for (i=0; i < COL; i++)     /* positive definite */\n     A->me[i][i] += 2*LDIAG;   \n\n   mat2band(A,LDIAG,LDIAG,bA);\n   band2mat(bA,A);              /* corresponding matrix A */\n\n   v_rand(x);\n   mv_mlt(A,x,w);\n   z = v_copy(w,z);\n   \n   bdLDLfactor(bA);\n\n   z = bdLDLsolve(bA,z,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg("incorrect solution (band LDL' factorization)");\n      printf(" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n",\n	     v_norm2(z),MACHEPS);\n   }\n\n   /* new bandwidths */\n   m_rand(A);\n   bA = bd_resize(bA,UDIAG,LDIAG,COL);\n   bB = bd_resize(bB,UDIAG,LDIAG,COL);\n   mat2band(A,UDIAG,LDIAG,bA);\n   band2mat(bA,A);\n   bd_copy(bA,bB);\n\n   mv_mlt(A,x,w);\n\n   notice("band LU factorization (resized)");\n   bdLUfactor(bA,pivot);\n\n   /* pivot will be changed */\n   bdLUsolve(bA,pivot,w,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg("incorrect solution (band LU factorization)");\n      printf(" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n",\n	     v_norm2(z),MACHEPS);\n   }\n\n   /* testing transposition */\n\n   notice("band matrix transposition");\n   m_zero(bA->mat);\n   bd_copy(bB,bA);\n   m_zero(bB->mat);\n   bd_copy(bA,bB);\n\n   bd_transp(bB,bB);\n   bd_transp(bB,bB);\n\n   m_zero(bC->mat);\n   bd_copy(bB,bC);\n\n   m_sub(bA->mat,bC->mat,bC->mat);\n   if (m_norm_inf(bC->mat) > MACHEPS*bC->mat->n) {\n      errmesg("band transposition");\n      printf(" difference ||A - (A')'|| = %g\n",m_norm_inf(bC->mat));\n   }\n \n   bd_free(bA);\n   bd_free(bB);\n   bd_free(bC);\n\n\n    MEMCHK();\n\n    /* now check QRupdate() routine */\n    notice("update QR routine");\n\n    B = m_resize(B,15,7);\n    A = m_resize(A,B->m,B->n);\n    m_copy(B,A);\n    diag = v_resize(diag,A->n);\n    beta = v_resize(beta,A->n);\n    QRfactor(A,diag);\n    Q = m_resize(Q,A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_resize(C,A->m,A->n);\n    w = v_resize(w,A->m);\n    v = v_resize(v,A->n);\n    u = v_resize(u,A->m);\n    v_rand(w);\n    v_rand(v);\n    vm_mlt(Q,w,u);\n    QRupdate(Q,A,u,v);\n    m_mlt(Q,A,C);\n    for ( i = 0; i < B->m; i++ )\n	for ( j = 0; j < B->n; j++ )\n	    m_set_val(B,i,j,m_entry(B,i,j)+v_entry(w,i)*v_entry(v,j));\n    m_sub(B,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(A)*m_norm1(Q)*2 )\n    {\n	errmesg("QRupdate()");\n	printf("# Reconstruction error in QR update = %g [cf MACHEPS = %g]\n",\n	       m_norm1(C), MACHEPS);\n    }\n    m_resize(D,Q->m,Q->n);\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= 10*MACHEPS*m_norm1(Q)*m_norm_inf(Q) )\n    {\n	errmesg("QRupdate()");\n	printf("# QR update orthogonality error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n\n    /* Now check eigenvalue/SVD routines */\n    notice("eigenvalue and SVD routines");\n    A = m_resize(A,11,11);\n    B = m_resize(B,A->m,A->n);\n    C = m_resize(C,A->m,A->n);\n    D = m_resize(D,A->m,A->n);\n    Q = m_resize(Q,A->m,A->n);\n\n    m_rand(A);\n    /* A <- A + A^T  for symmetric case */\n    m_add(A,m_transp(A,C),A);\n    u = v_resize(u,A->m);\n    u = symmeig(A,Q,u);\n    m_zero(B);\n    for ( i = 0; i < B->m; i++ )\n	m_set_val(B,i,i,v_entry(u,i));\n    m_mlt(Q,B,C);\n    mmtr_mlt(C,Q,D);\n    m_sub(A,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*v_norm_inf(u)*3 )\n    {\n	errmesg("symmeig()");\n	printf("# Reconstruction error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*3 )\n    {\n	errmesg("symmeig()");\n	printf("# symmeig() orthogonality error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now test (real) Schur decomposition */\n    /* m_copy(A,B); */\n    M_FREE(A);\n    A = m_get(11,11);\n    m_rand(A);\n    B = m_copy(A,B);\n    MEMCHK();\n\n    B = schur(B,Q);\n    MEMCHK();\n\n    m_mlt(Q,B,C);\n    mmtr_mlt(C,Q,D);\n    MEMCHK();\n    m_sub(A,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*m_norm1(B)*5 )\n    {\n	errmesg("schur()");\n	printf("# Schur reconstruction error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n\n    /* orthogonality check */\n    mmtr_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*10 )\n    {\n	errmesg("schur()");\n	printf("# Schur orthogonality error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now test SVD */\n    A = m_resize(A,11,7);\n    m_rand(A);\n    U = m_get(A->n,A->n);\n    Q = m_resize(Q,A->m,A->m);\n    u = v_resize(u,max(A->m,A->n));\n    svd(A,Q,U,u);\n    /* check reconstruction of A */\n    D = m_resize(D,A->m,A->n);\n    C = m_resize(C,A->m,A->n);\n    m_zero(D);\n    for ( i = 0; i < min(A->m,A->n); i++ )\n	m_set_val(D,i,i,v_entry(u,i));\n    mtrm_mlt(Q,D,C);\n    m_mlt(C,U,D);\n    m_sub(A,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(U)*m_norm_inf(Q)*m_norm1(A) )\n    {\n	errmesg("svd()");\n	printf("# SVD reconstruction error = %g [cf MACHEPS = %g]\n",\n	       m_norm1(D), MACHEPS);\n    }\n    /* check orthogonality of Q and U */\n    D = m_resize(D,Q->n,Q->n);\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*5 )\n    {\n	errmesg("svd()");\n	printf("# SVD orthognality error (Q) = %g [cf MACHEPS = %g\n",\n	       m_norm1(D), MACHEPS);\n    }\n    D = m_resize(D,U->n,U->n);\n    mtrm_mlt(U,U,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(U)*m_norm_inf(U)*5 )\n    {\n	errmesg("svd()");\n	printf("# SVD orthognality error (U) = %g [cf MACHEPS = %g\n",\n	       m_norm1(D), MACHEPS);\n    }\n    for ( i = 0; i < u->dim; i++ )\n	if ( v_entry(u,i) < 0 || (i < u->dim-1 &&\n				  v_entry(u,i+1) > v_entry(u,i)) )\n	    break;\n    if ( i < u->dim )\n    {\n	errmesg("svd()");\n	printf("# SVD sorting error\n");\n    }\n\n\n    /* test of long vectors */\n    notice("Long vectors");\n    x = v_resize(x,100000);\n    y = v_resize(y,100000);\n    z = v_resize(z,100000);\n    v_rand(x);\n    v_rand(y);\n    v_mltadd(x,y,3.0,z);\n    sv_mlt(1.0/3.0,z,z);\n    v_mltadd(z,x,-1.0/3.0,z);\n    v_sub(z,y,x);\n    if (v_norm2(x) >= MACHEPS*(x->dim)) {\n       errmesg("long vectors");\n       printf(" norm = %g\n",v_norm2(x));\n    }\n\n    mem_stat_free(1);\n\n    MEMCHK();\n\n    /**************************************************\n    VEC		*x, *y, *z, *u, *v, *w;\n    VEC		*diag, *beta;\n    PERM	*pi1, *pi2, *pi3, *pivot, *blocks;\n    MAT		*A, *B, *C, *D, *Q, *U;\n    **************************************************/\n    V_FREE(x);		V_FREE(y);	V_FREE(z);\n    V_FREE(u);		V_FREE(v);	V_FREE(w);\n    V_FREE(diag);	V_FREE(beta);\n    PX_FREE(pi1);	PX_FREE(pi2);	PX_FREE(pi3);\n    PX_FREE(pivot);	PX_FREE(blocks);\n    M_FREE(A);		M_FREE(B);	M_FREE(C);\n    M_FREE(D);		M_FREE(Q);	M_FREE(U);\n\n    MEMCHK();\n    printf("# Finished torture test\n");\n    mem_info();\n\n    return 0;\n}\n\n\n