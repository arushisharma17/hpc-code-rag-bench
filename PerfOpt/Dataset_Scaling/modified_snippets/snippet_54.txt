#include "find_ellipse.h"\n#include <sys/time.h>\n\n\n// The number of sample points per ellipse\n#define NPOINTS 150\n// The expected radius (in pixels) of a cell\n#define RADIUS 10\n// The range of acceptable radii\n#define MIN_RAD RADIUS - 2\n#define MAX_RAD RADIUS * 2\n// The number of different sample ellipses to try\n#define NCIRCLES 7\n\n\nextern MAT * m_inverse(MAT * A, MAT * out);\n\n\n// Returns the current system time in microseconds\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\n\n// Returns the specified frame from the specified video file\n// If cropped == true, the frame is cropped to pre-determined dimensions\n//  (hardcoded to the boundaries of the blood vessel in the test video)\n// If scaled == true, all values are scaled to the range [0.0, 1.0]\nMAT * get_frame(avi_t *cell_file, int frame_num, int cropped, int scaled) {\n	int dummy;\n	int width = AVI_video_width(cell_file);\n	int height = AVI_video_height(cell_file);\n	unsigned char *image_buf = (unsigned char *) malloc(width * height);\n\n	// There are 600 frames in this file (i.e. frame_num = 600 causes an error)\n	AVI_set_video_position(cell_file, frame_num);\n\n	//Read in the frame from the AVI\n	if(AVI_read_frame(cell_file, (char *)image_buf, &dummy) == -1) {\n		AVI_print_error("Error with AVI_read_frame");\n		exit(-1);\n	}\n\n	MAT * image_chopped;\n	if (cropped) {\n		// Crop and flip image so we deal only with the interior of the vein\n		image_chopped = chop_flip_image(image_buf, height, width, TOP, BOTTOM, 0, width - 1, scaled);\n	} else {\n		// Just flip the image\n		image_chopped = chop_flip_image(image_buf, height, width, 0, height - 1, 0, width - 1, scaled);\n	}\n	\n	free(image_buf);\n	\n	return image_chopped;\n}\n\n\n// Flips the specified image and crops it to the specified dimensions\nMAT * chop_flip_image(unsigned char *image, int height, int width, int top, int bottom, int left, int right, int scaled) {\n	MAT * result = m_get(bottom - top + 1, right - left + 1);\n	int i, j;\n	if (scaled) {\n		double scale = 1.0 / 255.0;\n		for(i = 0; i <= (bottom - top); i++)\n			for(j = 0; j <= (right - left); j++)\n				//m_set_val(result, i, j, (double) image[((height - (i + top)) * width) + (j + left)] * scale);\n				  m_set_val(result, i, j, (double) image[((height - 1 - (i + top)) * width) + (j + left)] * scale);\n	} else {\n		for(i = 0; i <= (bottom - top); i++)\n			for(j = 0; j <= (right - left); j++)\n				//m_set_val(result, i, j, (double) image[((height - (i + top)) * width) + (j + left)]);\n				  m_set_val(result, i, j, (double) image[((height - 1 - (i + top)) * width) + (j + left)]);\n	}\n\n	return result;\n}\n\n\n// Given x- and y-gradients of a video frame, computes the GICOV\n//  score for each sample ellipse at every pixel in the frame\nMAT * ellipsematching(MAT * grad_x, MAT * grad_y) {\n	int i, n, k;\n	// Compute the sine and cosine of the angle to each point in each sample circle\n	//  (which are the same across all sample circles)\n	double sin_angle[NPOINTS], cos_angle[NPOINTS], theta[NPOINTS];\n	for (n = 0; n < NPOINTS; n++) {\n		theta[n] = (double) n * 2.0 * PI / (double) NPOINTS;\n		sin_angle[n] = sin(theta[n]);\n		cos_angle[n] = cos(theta[n]);\n	}\n\n	// Compute the (x,y) pixel offsets of each sample point in each sample circle\n	int tX[NCIRCLES][NPOINTS], tY[NCIRCLES][NPOINTS];\n	for (k = 0; k < NCIRCLES; k++) {\n		double rad = (double) (MIN_RAD + 2 * k); \n		for (n = 0; n < NPOINTS; n++) {\n			tX[k][n] = (int) (cos(theta[n]) * rad);\n			tY[k][n] = (int) (sin(theta[n]) * rad);\n		}\n	}\n	\n	int MaxR = MAX_RAD + 2;\n	\n	// Allocate memory for the result matrix\n	int height = grad_x->m, width = grad_x->n;\n	MAT * gicov = m_get(height, width);\n	\n	// Split the work among multiple threads, if OPEN is defined\n	#ifdef OPEN\n	#pragma omp parallel for num_threads(omp_num_threads)\n	#endif\n	// Scan from left to right, top to bottom, computing GICOV values\n	for (i = MaxR; i < width - MaxR; i++) {\n		double Grad[NPOINTS];\n		int j, k, n, x, y;\n		\n		for (j = MaxR; j < height - MaxR; j++) {\n			// Initialize the maximal GICOV score to 0\n			double max_GICOV = 0;	\n			\n			// Iterate across each stencil\n			for (k = 0; k < NCIRCLES; k++) {\n				// Iterate across each sample point in the current stencil\n				for (n = 0; n < NPOINTS; n++)	{\n					// Determine the x- and y-coordinates of the current sample point\n					y = j + tY[k][n];\n					x = i + tX[k][n];\n					\n					// Compute the combined gradient value at the current sample point\n					Grad[n] = m_get_val(grad_x, y, x) * cos_angle[n] + m_get_val(grad_y, y, x) * sin_angle[n];\n				}\n				\n				// Compute the mean gradient value across all sample points\n				double sum = 0.0;\n				for (n = 0; n < NPOINTS; n++) sum += Grad[n];\n				double mean = sum / (double)NPOINTS;\n				\n				// Compute the variance of the gradient values\n				double var = 0.0;				\n				for (n = 0; n < NPOINTS; n++)	{\n					sum = Grad[n] - mean;\n					var += sum * sum;\n				}				\n				var = var / (double) (NPOINTS - 1);\n				\n				// Keep track of the maximal GICOV value seen so far\n				if (mean * mean / var > max_GICOV) {\n					m_set_val(gicov, j, i, mean / sqrt(var));\n					max_GICOV = mean * mean / var;\n				}\n			}\n		}\n	}\n	\n	return gicov;\n}\n\n\n// Returns a circular structuring element of the specified radius\nMAT * structuring_element(int radius) {\n	MAT * result = m_get(radius*2+1, radius*2+1);\n	\n	int i, j;\n	for(i = 0; i < result->m; i++) {\n		for(j = 0; j < result->n; j++) {\n			if(sqrt((float)((i-radius)*(i-radius)+(j-radius)*(j-radius))) <= radius)\n				m_set_val(result, i, j, 1.0);\n			else\n				m_set_val(result, i, j, 0.0);\n		}\n	}\n\n	return result;\n}\n\n\n// Performs an image dilation on the specified matrix\n//  using the specified structuring element\nMAT * dilate_f(MAT * img_in, MAT * strel) {\n	MAT * dilated = m_get(img_in->m, img_in->n);\n	\n	// Find the center of the structuring element\n	int el_center_i = strel->m / 2, el_center_j = strel->n / 2, i;\n	\n	// Split the work among multiple threads, if OPEN is defined\n	#ifdef OPEN\n	#pragma omp parallel for num_threads(omp_num_threads)\n	#endif\n	// Iterate across the input matrix\n	for (i = 0; i < img_in->m; i++) {\n		int j, el_i, el_j, x, y;\n		for (j = 0; j < img_in->n; j++) {\n			double max = 0.0, temp;\n			// Iterate across the structuring element\n			for (el_i = 0; el_i < strel->m; el_i++) {\n				for (el_j = 0; el_j < strel->n; el_j++) {\n					y = i - el_center_i + el_i;\n					x = j - el_center_j + el_j;\n					// Make sure we have not gone off the edge of the matrix\n					if (y >=0 && x >= 0 && y < img_in->m && x < img_in->n && m_get_val(strel, el_i, el_j) != 0) {\n						// Determine if this is maximal value seen so far\n						temp = m_get_val(img_in, y, x);\n						if (temp > max)	max = temp;\n					}\n				}\n			}\n			// Store the maximum value found\n			m_set_val(dilated, i, j, max);\n		}\n	}\n\n	return dilated;\n}\n\n\n//M = # of sampling points in each segment\n//N = number of segment of curve\n//Get special TMatrix\nMAT * TMatrix(unsigned int N, unsigned int M)\n{\n	MAT * B = NULL, * LB = NULL, * B_TEMP = NULL, * B_TEMP_INV = NULL, * B_RET = NULL;\n	int * aindex, * bindex, * cindex, * dindex;\n	int i, j;\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n\n	B = m_get(N*M, N);\n	LB = m_get(M, N);\n\n	for(i = 0; i < N; i++)\n	{\n		m_zero(LB);\n		\n		for(j = 0; j < M; j++)\n		{\n			double s = (double)j / (double)M;\n			double a, b, c, d;\n\n			a = (-1.0*s*s*s + 3.0*s*s - 3.0*s + 1.0) / 6.0;\n			b = (3.0*s*s*s - 6.0*s*s + 4.0) / 6.0;\n			c = (-3.0*s*s*s + 3.0*s*s + 3.0*s + 1.0) / 6.0;\n			d = s*s*s / 6.0;\n\n			m_set_val(LB, j, aindex[i], a);\n			m_set_val(LB, j, bindex[i], b);\n			m_set_val(LB, j, cindex[i], c);\n			m_set_val(LB, j, dindex[i], d);\n		}\n		int m, n;\n\n		for(m = i*M; m < (i+1)*M; m++)\n			for(n = 0; n < N; n++)\n				m_set_val(B, m, n, m_get_val(LB, m%M, n));\n	}\n\n	B_TEMP = mtrm_mlt(B, B, B_TEMP);\n	B_TEMP_INV = m_inverse(B_TEMP, B_TEMP_INV);\n	B_RET = mmtr_mlt(B_TEMP_INV, B, B_RET);\n	\n	m_free(B);\n	m_free(LB);\n	m_free(B_TEMP);\n	m_free(B_TEMP_INV);\n\n	free(dindex);\n	free(cindex);\n	free(bindex);\n	free(aindex);\n\n	return B_RET;\n}\n\nvoid uniformseg(VEC * cellx_row, VEC * celly_row, MAT * x, MAT * y)\n{\n	double dx[36], dy[36], dist[36], dsum[36], perm = 0.0, uperm;\n	int i, j, index[36];\n\n	for(i = 1; i <= 36; i++)\n	{\n		dx[i%36] = v_get_val(cellx_row, i%36) - v_get_val(cellx_row, (i-1)%36);\n		dy[i%36] = v_get_val(celly_row, i%36) - v_get_val(celly_row, (i-1)%36);\n		dist[i%36] = sqrt(dx[i%36]*dx[i%36] + dy[i%36]*dy[i%36]);\n		perm+= dist[i%36];\n	}\n	uperm = perm / 36.0;\n	dsum[0] = dist[0];\n	for(i = 1; i < 36; i++)\n		dsum[i] = dsum[i-1]+dist[i];\n\n	for(i = 0; i < 36; i++)\n	{\n		double minimum=DBL_MAX, temp;\n		int min_index = 0;\n		for(j = 0; j < 36; j++)\n		{\n			temp = fabs(dsum[j]- (double)i*uperm);\n			if (temp < minimum)\n			{\n				minimum = temp;\n				min_index = j;\n			}\n		}\n		index[i] = min_index;\n	}\n\n	for(i = 0; i < 36; i++)\n	{\n		m_set_val(x, 0, i, v_get_val(cellx_row, index[i]));\n		m_set_val(y, 0, i, v_get_val(celly_row, index[i]));\n	}\n}\n\n//Get minimum element in a matrix\ndouble m_min(MAT * m)\n{\n	int i, j;\n	double minimum = DBL_MAX, temp;\n	for(i = 0; i < m->m; i++)\n	{\n		for(j = 0; j < m->n; j++)\n		{\n			temp = m_get_val(m, i, j);\n			if(temp < minimum)\n				minimum = temp;\n		}\n	}\n	return minimum;\n}\n\n//Get maximum element in a matrix\ndouble m_max(MAT * m)\n{\n	int i, j;\n	double maximum = DBL_MIN, temp;\n	for(i = 0; i < m->m; i++)\n	{\n		for(j = 0; j < m->n; j++)\n		{\n			temp = m_get_val(m, i, j);\n			if(temp > maximum)\n				maximum = temp;\n		}\n	}\n	return maximum;\n}\n\nVEC * getsampling(MAT * m, int ns)\n{\n	int N = m->n > m->m ? m-> n:m->m, M = ns;\n	int * aindex, * bindex, * cindex, * dindex;\n	int i, j;\n	VEC * retval = v_get(N*M);\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n	for(i = 0; i < N; i++)\n	{\n		for(j = 0; j < M; j++)\n		{\n			double s = (double)j / (double)M;\n			double a, b, c, d;\n\n			a = m_get_val(m, 0, aindex[i]) * (-1.0*s*s*s + 3.0*s*s - 3.0*s + 1.0);\n			b = m_get_val(m, 0, bindex[i]) * (3.0*s*s*s - 6.0*s*s + 4.0);\n			c = m_get_val(m, 0, cindex[i]) * (-3.0*s*s*s + 3.0*s*s + 3.0*s + 1.0);\n			d = m_get_val(m, 0, dindex[i]) * s*s*s;\n			v_set_val(retval, i*M+j,(a+b+c+d)/6.0);\n\n		}\n	}\n\n	free(dindex);\n	free(cindex);\n	free(bindex);\n	free(aindex);\n\n	return retval;\n}\n\nVEC * getfdriv(MAT * m, int ns)\n{\n	int N = m->n > m->m ? m-> n:m->m, M = ns;\n	int * aindex, * bindex, * cindex, * dindex;\n	int i, j;\n	VEC * retval = v_get(N*M);\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n	for(i = 0; i < N; i++)\n	{\n		for(j = 0; j < M; j++)\n		{\n			double s = (double)j / (double)M;\n			double a, b, c, d;\n\n			a = m_get_val(m, 0, aindex[i]) * (-3.0*s*s + 6.0*s - 3.0);\n			b = m_get_val(m, 0, bindex[i]) * (9.0*s*s - 12.0*s);\n			c = m_get_val(m, 0, cindex[i]) * (-9.0*s*s + 6.0*s + 3.0);\n			d = m_get_val(m, 0, dindex[i]) * (3.0 *s*s);\n			v_set_val(retval, i*M+j, (a+b+c+d)/6.0);\n\n		}\n	}\n\n	free(dindex);\n	free(cindex);\n	free(bindex);\n	free(aindex);\n\n	return retval;\n}\n\n//Performs bilinear interpolation, getting the values of m specified in the vectors X and Y\nMAT * linear_interp2(MAT * m, VEC * X, VEC * Y)\n{\n	//Kind of assumes X and Y have same len!\n\n	MAT * retval = m_get(1, X->dim);\n	double x_coord, y_coord, new_val, a, b;\n	int l, k, i;\n\n	for(i = 0; i < X->dim; i++)\n	{\n		x_coord = v_get_val(X, i);\n		y_coord = v_get_val(Y, i);\n\n		l = (int)x_coord;\n		k = (int)y_coord;\n\n		a = x_coord - (double)l;\n		b = y_coord - (double)k;\n\n		//printf("xc: %f \t yc: %f \t i: %d \t l: %d \t k: %d \t a: %f \t b: %f\n", x_coord, y_coord, i, l, k, a, b);\n\n		new_val = (1.0-a)*(1.0-b)*m_get_val(m, k, l) +\n				  a*(1.0-b)*m_get_val(m, k, l+1) +\n				  (1.0-a)*b*m_get_val(m, k+1, l) +\n				  a*b*m_get_val(m, k+1, l+1);\n\n		m_set_val(retval, 0, i, new_val);\n	}\n\n	return retval;\n}\n\nvoid splineenergyform01(MAT * Cx, MAT * Cy, MAT * Ix, MAT * Iy, int ns, double delta, double dt, int typeofcell)\n{\n	VEC * X, * Y, * Xs, * Ys, * Nx, * Ny, * X1, * Y1, * X2, * Y2, *	XY, * XX, * YY, * dCx, * dCy, * Ix1, * Ix2, *Iy1, *Iy2;\n	MAT * Ix1_mat, * Ix2_mat, * Iy1_mat, * Iy2_mat;\n	int i,j, N, * aindex, * bindex, * cindex, * dindex;\n\n	X = getsampling(Cx, ns);\n	Y = getsampling(Cy, ns);\n	Xs = getfdriv(Cx, ns);\n	Ys = getfdriv(Cy, ns);\n\n	Nx = v_get(Ys->dim);\n	for(i = 0; i < Nx->dim; i++)\n		v_set_val(Nx, i, v_get_val(Ys, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n\n	Ny = v_get(Xs->dim);\n	for(i = 0; i < Ny->dim; i++)\n		v_set_val(Ny, i, -1.0 * v_get_val(Xs, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n	\n	X1 = v_get(Nx->dim);\n	for(i = 0; i < X1->dim; i++)\n		v_set_val(X1, i, v_get_val(X, i) + delta*v_get_val(Nx, i));\n\n	Y1 = v_get(Ny->dim);\n	for(i = 0; i < Y1->dim; i++)\n		v_set_val(Y1, i, v_get_val(Y, i) + delta*v_get_val(Ny, i));\n\n	X2 = v_get(Nx->dim);\n	for(i = 0; i < X2->dim; i++)\n		v_set_val(X2, i, v_get_val(X, i) - delta*v_get_val(Nx, i));\n\n	Y2 = v_get(Ny->dim);\n	for(i = 0; i < Y2->dim; i++)\n		v_set_val(Y2, i, v_get_val(Y, i) + delta*v_get_val(Ny, i));\n\n	Ix1_mat = linear_interp2(Ix, X1, Y1);\n	Iy1_mat = linear_interp2(Iy, X1, Y1);\n	Ix2_mat = linear_interp2(Ix, X2, Y2);\n	Iy2_mat = linear_interp2(Iy, X2, Y2);\n\n	Ix1 = v_get(Ix1_mat->n);\n	Iy1 = v_get(Iy1_mat->n);\n	Ix2 = v_get(Ix2_mat->n);\n	Iy2 = v_get(Iy2_mat->n);\n\n	Ix1 = get_row(Ix1_mat, 0, Ix1);\n	Iy1 = get_row(Iy1_mat, 0, Iy1);\n	Ix2 = get_row(Ix2_mat, 0, Ix2);\n	Iy2 = get_row(Iy2_mat, 0, Iy2);\n\n	N = Cx->m;\n\n	//VEC * retval = v_get(N*ns);\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n	XY = v_get(Xs->dim);\n	for(i = 0; i < Xs->dim; i++)\n		v_set_val(XY, i, v_get_val(Xs, i) * v_get_val(Ys, i));\n\n	XX = v_get(Xs->dim);\n	for(i = 0; i < Xs->dim; i++)\n		v_set_val(XX, i, v_get_val(Xs, i) * v_get_val(Xs, i));\n\n	YY = v_get(Ys->dim);\n	for(i = 0; i < Xs->dim; i++)\n		v_set_val(YY, i, v_get_val(Ys, i) * v_get_val(Ys, i));\n\n	dCx = v_get(Cx->m);\n	dCy = v_get(Cy->m);\n\n	//get control points for splines\n	for(i = 0; i < Cx->m; i++)\n	{\n		for(j = 0; j < ns; j++)\n		{\n			double s = (double)j / (double)ns;\n			double A1, A2, A3, A4, B1, B2, B3, B4, D, D_3, Tx1, Tx2, Tx3, Tx4, Ty1, Ty2, Ty3, Ty4;\n			int k;\n\n			A1 = (-1.0*(s-1.0)*(s-1.0)*(s-1.0)) / 6.0;\n			A2 = (3.0*s*s*s - 6.0*s*s + 4.0) / 6.0;\n			A3 = (-3.0*s*s*s + 3.0*s*s + 3.0*s + 1.0) / 6.0;\n			A4 = s*s*s / 6.0;\n\n			B1 = (-3.0*s*s + 6.0*s - 3.0) / 6.0;\n			B2 = (9.0*s*s - 12.0*s) / 6.0;\n			B3 = (-9.0*s*s + 6.0*s + 3.0) / 6.0;\n			B4 = 3.0*s*s / 6.0;\n\n			k = i*ns+j;\n			D = sqrt(v_get_val(Xs, k)*v_get_val(Xs, k) + v_get_val(Ys, k)*v_get_val(Ys, k));\n			D_3 = D*D*D;\n			\n			//1st control point\n			\n			Tx1 = A1 - delta * v_get_val(XY, k) * B1 / D_3;\n			Tx2 = -1.0 * delta*(B1/D - v_get_val(XX, k)*B1/D_3);\n			Tx3 = A1 + delta * v_get_val(XY, k) * B1 / D_3;\n			Tx4 = delta*(B1/D - v_get_val(XX, k)*B1/D_3);\n\n			Ty1 = delta*(B1/D - v_get_val(YY, k)*B1/D_3);\n			Ty2 = A1 + delta * v_get_val(XY, k) * B1 / D_3;\n			Ty3 = -1.0 * delta*(B1/D - v_get_val(YY, k)*B1/D_3);\n			Ty4 = A1 - delta * v_get_val(XY, k) * B1 / D_3;\n\n			v_set_val(dCx, aindex[i], v_get_val(dCx, aindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, aindex[i], v_get_val(dCy, aindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));\n		\n			//2nd control point\n\n			Tx1 = A2 - delta * v_get_val(XY, k) * B2 / D_3;\n			Tx2 = -1.0 * delta*(B2/D - v_get_val(XX, k)*B2/D_3);\n			Tx3 = A2 + delta * v_get_val(XY, k) * B2 / D_3;\n			Tx4 = delta*(B2/D - v_get_val(XX, k)*B2/D_3);\n\n			Ty1 = delta*(B2/D - v_get_val(YY, k)*B2/D_3);\n			Ty2 = A2 + delta * v_get_val(XY, k) * B2 / D_3;\n			Ty3 = -1.0 * delta*(B2/D - v_get_val(YY, k)*B2/D_3);\n			Ty4 = A2 - delta * v_get_val(XY, k) * B2 / D_3;\n\n			v_set_val(dCx, bindex[i], v_get_val(dCx, bindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, bindex[i], v_get_val(dCy, bindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));\n\n			//3nd control point\n\n			Tx1 = A3 - delta * v_get_val(XY, k) * B3 / D_3;\n			Tx2 = -1.0 * delta*(B3/D - v_get_val(XX, k)*B3/D_3);\n			Tx3 = A3 + delta * v_get_val(XY, k) * B3 / D_3;\n			Tx4 = delta*(B3/D - v_get_val(XX, k)*B3/D_3);\n\n			Ty1 = delta*(B3/D - v_get_val(YY, k)*B3/D_3);\n			Ty2 = A3 + delta * v_get_val(XY, k) * B3 / D_3;\n			Ty3 = -1.0 * delta*(B3/D - v_get_val(YY, k)*B3/D_3);\n			Ty4 = A3 - delta * v_get_val(XY, k) * B3 / D_3;\n\n			v_set_val(dCx, cindex[i], v_get_val(dCx, cindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, cindex[i], v_get_val(dCy, cindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));\n	\n			//4nd control point\n\n			Tx1 = A4 - delta * v_get_val(XY, k) * B4 / D_3;\n			Tx2 = -1.0 * delta*(B4/D - v_get_val(XX, k)*B4/D_3);\n			Tx3 = A4 + delta * v_get_val(XY, k) * B4 / D_3;\n			Tx4 = delta*(B4/D - v_get_val(XX, k)*B4/D_3);\n\n			Ty1 = delta*(B4/D - v_get_val(YY, k)*B4/D_3);\n			Ty2 = A4 + delta * v_get_val(XY, k) * B4 / D_3;\n			Ty3 = -1.0 * delta*(B4/D - v_get_val(YY, k)*B4/D_3);\n			Ty4 = A4 - delta * v_get_val(XY, k) * B4 / D_3;\n\n			v_set_val(dCx, dindex[i], v_get_val(dCx, dindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, dindex[i], v_get_val(dCy, dindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));		\n		}\n	}\n\n	if(typeofcell==1)\n	{\n		for(i = 0; i < Cx->n; i++)\n			m_set_val(Cx, 0, i, m_get_val(Cx, 1, i) - dt*v_get_val(dCx, i));\n\n		for(i = 0; i < Cy->n; i++)\n			m_set_val(Cy, 0, i, m_get_val(Cy, 1, i) - dt*v_get_val(dCy, i));\n	}\n	else\n	{\n		for(i = 0; i < Cx->n; i++)\n			m_set_val(Cx, 0, i, m_get_val(Cx, 1, i) + dt*v_get_val(dCx, i));\n\n		for(i = 0; i < Cy->n; i++)\n			m_set_val(Cy, 0, i, m_get_val(Cy, 1, i) + dt*v_get_val(dCy, i));\n	}\n\n	v_free(dCy); v_free(dCx); v_free(YY); v_free(XX); v_free(XY);\n\n	free(dindex); free(cindex); free(bindex); free(aindex); \n\n	v_free(Iy2); v_free(Ix2); v_free(Iy1); v_free(Ix1); \n\n	m_free(Iy2_mat); m_free(Ix2_mat); m_free(Iy1_mat); m_free(Ix1_mat); \n\n	v_free(Y2); v_free(X2); v_free(Y1); v_free(X1); v_free(Ny); v_free(Nx); v_free(Ys); v_free(Xs); v_free(Y); v_free(X); \n}\n