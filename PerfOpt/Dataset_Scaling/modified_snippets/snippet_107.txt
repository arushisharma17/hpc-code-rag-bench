\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\nstatic	char	rcsid[] = "$Id: bkpfacto.c,v 1.7 1994/01/13 05:45:50 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include        "matrix2.h"\n\n#define	btos(x)	((x) ? "TRUE" : "FALSE")\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n#define alpha	0.6403882032022076 /* = (1+sqrt(17))/8 */\n\n/* sqr -- returns square of x -- utility function */\ndouble	sqr(x)\ndouble	x;\n{	return x*x;	}\n\n/* interchange -- a row/column swap routine */\nstatic void interchange(A,i,j)\nMAT	*A;	/* assumed != NULL & also SQUARE */\nint	i, j;	/* assumed in range */\n{\n	Real	**A_me, tmp;\n	int	k, n;\n\n	A_me = A->me;	n = A->n;\n	if ( i == j )\n		return;\n	if ( i > j )\n	{	k = i;	i = j;	j = k;	}\n	for ( k = 0; k < i; k++ )\n	{\n		/* tmp = A_me[k][i]; */\n		tmp = m_entry(A,k,i);\n		/* A_me[k][i] = A_me[k][j]; */\n		m_set_val(A,k,i,m_entry(A,k,j));\n		/* A_me[k][j] = tmp; */\n		m_set_val(A,k,j,tmp);\n	}\n	for ( k = j+1; k < n; k++ )\n	{\n		/* tmp = A_me[j][k]; */\n		tmp = m_entry(A,j,k);\n		/* A_me[j][k] = A_me[i][k]; */\n		m_set_val(A,j,k,m_entry(A,i,k));\n		/* A_me[i][k] = tmp; */\n		m_set_val(A,i,k,tmp);\n	}\n	for ( k = i+1; k < j; k++ )\n	{\n		/* tmp = A_me[k][j]; */\n		tmp = m_entry(A,k,j);\n		/* A_me[k][j] = A_me[i][k]; */\n		m_set_val(A,k,j,m_entry(A,i,k));\n		/* A_me[i][k] = tmp; */\n		m_set_val(A,i,k,tmp);\n	}\n	/* tmp = A_me[i][i]; */\n	tmp = m_entry(A,i,i);\n	/* A_me[i][i] = A_me[j][j]; */\n	m_set_val(A,i,i,m_entry(A,j,j));\n	/* A_me[j][j] = tmp; */\n	m_set_val(A,j,j,tmp);\n}\n\n/* BKPfactor -- Bunch-Kaufman-Parlett factorisation of A in-situ\n	-- A is factored into the form P'AP = MDM' where \n	P is a permutation matrix, M lower triangular and D is block\n	diagonal with blocks of size 1 or 2\n	-- P is stored in pivot; blocks[i]==i iff D[i][i] is a block */\n#ifndef ANSI_C\nMAT	*BKPfactor(A,pivot,blocks)\nMAT	*A;\nPERM	*pivot, *blocks;\n#else\nMAT	*BKPfactor(MAT *A, PERM *pivot, PERM *blocks)\n#endif\n{\n	int	i, j, k, n, onebyone, r;\n	Real	**A_me, aii, aip1, aip1i, lambda, sigma, tmp;\n	Real	det, s, t;\n\n	if ( ! A || ! pivot || ! blocks )\n		error(E_NULL,"BKPfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"BKPfactor");\n	if ( A->m != pivot->size || pivot->size != blocks->size )\n		error(E_SIZES,"BKPfactor");\n\n	n = A->n;\n	A_me = A->me;\n	px_ident(pivot);	px_ident(blocks);\n\n	for ( i = 0; i < n; i = onebyone ? i+1 : i+2 )\n	{\n		/* printf("# Stage: %d\n",i); */\n		aii = fabs(m_entry(A,i,i));\n		lambda = 0.0;	r = (i+1 < n) ? i+1 : i;\n		for ( k = i+1; k < n; k++ )\n		{\n		    tmp = fabs(m_entry(A,i,k));\n		    if ( tmp >= lambda )\n		    {\n			lambda = tmp;\n			r = k;\n		    }\n		}\n		/* printf("# lambda = %g, r = %d\n", lambda, r); */\n		/* printf("# |A[%d][%d]| = %g\n",r,r,fabs(m_entry(A,r,r))); */\n\n		/* determine if 1x1 or 2x2 block, and do pivoting if needed */\n		if ( aii >= alpha*lambda )\n		{\n		    onebyone = TRUE;\n		    goto dopivot;\n		}\n		/* compute sigma */\n		sigma = 0.0;\n		for ( k = i; k < n; k++ )\n		{\n		    if ( k == r )\n			continue;\n		    tmp = ( k > r ) ? fabs(m_entry(A,r,k)) :\n			fabs(m_entry(A,k,r));\n		    if ( tmp > sigma )\n			sigma = tmp;\n		}\n		if ( aii*sigma >= alpha*sqr(lambda) )\n		    onebyone = TRUE;\n		else if ( fabs(m_entry(A,r,r)) >= alpha*sigma )\n		{\n		    /* printf("# Swapping rows/cols %d and %d\n",i,r); */\n		    interchange(A,i,r);\n		    px_transp(pivot,i,r);\n		    onebyone = TRUE;\n		}\n		else\n		{\n		    /* printf("# Swapping rows/cols %d and %d\n",i+1,r); */\n		    interchange(A,i+1,r);\n		    px_transp(pivot,i+1,r);\n		    px_transp(blocks,i,i+1);\n		    onebyone = FALSE;\n		}\n		/* printf("onebyone = %s\n",btos(onebyone)); */\n		/* printf("# Matrix so far (@checkpoint A) =\n"); */\n		/* m_output(A); */\n		/* printf("# pivot =\n");	px_output(pivot); */\n		/* printf("# blocks =\n");	px_output(blocks); */\n\ndopivot:\n		if ( onebyone )\n		{   /* do one by one block */\n		    if ( m_entry(A,i,i) != 0.0 )\n		    {\n			aii = m_entry(A,i,i);\n			for ( j = i+1; j < n; j++ )\n			{\n			    tmp = m_entry(A,i,j)/aii;\n			    for ( k = j; k < n; k++ )\n				m_sub_val(A,j,k,tmp*m_entry(A,i,k));\n			    m_set_val(A,i,j,tmp);\n			}\n		    }\n		}\n		else /* onebyone == FALSE */\n		{   /* do two by two block */\n		    det = m_entry(A,i,i)*m_entry(A,i+1,i+1)-sqr(m_entry(A,i,i+1));\n		    /* Must have det < 0 */\n		    /* printf("# det = %g\n",det); */\n		    aip1i = m_entry(A,i,i+1)/det;\n		    aii = m_entry(A,i,i)/det;\n		    aip1 = m_entry(A,i+1,i+1)/det;\n		    for ( j = i+2; j < n; j++ )\n		    {\n			s = - aip1i*m_entry(A,i+1,j) + aip1*m_entry(A,i,j);\n			t = - aip1i*m_entry(A,i,j) + aii*m_entry(A,i+1,j);\n			for ( k = j; k < n; k++ )\n			    m_sub_val(A,j,k,m_entry(A,i,k)*s + m_entry(A,i+1,k)*t);\n			m_set_val(A,i,j,s);\n			m_set_val(A,i+1,j,t);\n		    }\n		}\n		/* printf("# Matrix so far (@checkpoint B) =\n"); */\n		/* m_output(A); */\n		/* printf("# pivot =\n");	px_output(pivot); */\n		/* printf("# blocks =\n");	px_output(blocks); */\n	}\n\n	/* set lower triangular half */\n	for ( i = 0; i < A->m; i++ )\n	    for ( j = 0; j < i; j++ )\n		m_set_val(A,i,j,m_entry(A,j,i));\n\n	return A;\n}\n\n/* BKPsolve -- solves A.x = b where A has been factored a la BKPfactor()\n	-- returns x, which is created if NULL */\n#ifndef ANSI_C\nVEC	*BKPsolve(A,pivot,block,b,x)\nMAT	*A;\nPERM	*pivot, *block;\nVEC	*b, *x;\n#else\nVEC	*BKPsolve(const MAT *A, PERM *pivot, const PERM *block,\n		  const VEC *b, VEC *x)\n#endif\n{\n	STATIC VEC	*tmp=VNULL;	/* dummy storage needed */\n	int	i, j, n, onebyone;\n	Real	**A_me, a11, a12, a22, b1, b2, det, sum, *tmp_ve, tmp_diag;\n\n	if ( ! A || ! pivot || ! block || ! b )\n		error(E_NULL,"BKPsolve");\n	if ( A->m != A->n )\n		error(E_SQUARE,"BKPsolve");\n	n = A->n;\n	if ( b->dim != n || pivot->size != n || block->size != n )\n		error(E_SIZES,"BKPsolve");\n	x = v_resize(x,n);\n	tmp = v_resize(tmp,n);\n	MEM_STAT_REG(tmp,TYPE_VEC);\n\n	A_me = A->me;	tmp_ve = tmp->ve;\n\n	px_vec(pivot,b,tmp);\n	/* solve for lower triangular part */\n	for ( i = 0; i < n; i++ )\n	{\n		sum = v_entry(tmp,i);\n		if ( block->pe[i] < i )\n		    for ( j = 0; j < i-1; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		else\n		    for ( j = 0; j < i; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		v_set_val(tmp,i,sum);\n	}\n	/* printf("# BKPsolve: solving L part: tmp =\n");	v_output(tmp); */\n	/* solve for diagonal part */\n	for ( i = 0; i < n; i = onebyone ? i+1 : i+2 )\n	{\n		onebyone = ( block->pe[i] == i );\n		if ( onebyone )\n		{\n		    tmp_diag = m_entry(A,i,i);\n		    if ( tmp_diag == 0.0 )\n			error(E_SING,"BKPsolve");\n		    /* tmp_ve[i] /= tmp_diag; */\n		    v_set_val(tmp,i,v_entry(tmp,i) / tmp_diag);\n		}\n		else\n		{\n		    a11 = m_entry(A,i,i);\n		    a22 = m_entry(A,i+1,i+1);\n		    a12 = m_entry(A,i+1,i);\n		    b1 = v_entry(tmp,i);	b2 = v_entry(tmp,i+1);\n		    det = a11*a22-a12*a12;	/* < 0 : see BKPfactor() */\n		    if ( det == 0.0 )\n			error(E_SING,"BKPsolve");\n		    det = 1/det;\n		    v_set_val(tmp,i,det*(a22*b1-a12*b2));\n		    v_set_val(tmp,i+1,det*(a11*b2-a12*b1));\n		}\n	}\n	/* printf("# BKPsolve: solving D part: tmp =\n");	v_output(tmp); */\n	/* solve for transpose of lower traingular part */\n	for ( i = n-1; i >= 0; i-- )\n	{	/* use symmetry of factored form to get stride 1 */\n		sum = v_entry(tmp,i);\n		if ( block->pe[i] > i )\n		    for ( j = i+2; j < n; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		else\n		    for ( j = i+1; j < n; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		v_set_val(tmp,i,sum);\n	}\n\n	/* printf("# BKPsolve: solving L^T part: tmp =\n");v_output(tmp); */\n	/* and do final permutation */\n	x = pxinv_vec(pivot,tmp,x);\n\n#ifdef THREADSAFE\n	V_FREE(tmp);\n#endif\n\n	return x;\n}\n\n		\n\n