\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File containing Lanczos type routines for finding eigenvalues\n	of large, sparse, symmetic matrices\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include	"sparse.h"\n\nstatic char rcsid[] = "$Id: lanczos.c,v 1.4 1994/01/13 05:28:24 des Exp $";\n\n#ifdef ANSI_C\nextern	VEC	*trieig(VEC *,VEC *,MAT *);\n#else\nextern	VEC	*trieig();\n#endif\n\n/* lanczos -- raw lanczos algorithm -- no re-orthogonalisation\n	-- creates T matrix of size == m,\n		but no larger than before beta_k == 0\n	-- uses passed routine to do matrix-vector multiplies */\nvoid	lanczos(A_fn,A_params,m,x0,a,b,beta2,Q)\nVEC	*(*A_fn)();	/* VEC *(*A_fn)(void *A_params,VEC *in, VEC *out) */\nvoid	*A_params;\nint	m;\nVEC	*x0, *a, *b;\nReal	*beta2;\nMAT	*Q;\n{\n	int	j;\n	VEC	*v, *w, *tmp;\n	Real	alpha, beta;\n\n	if ( ! A_fn || ! x0 || ! a || ! b )\n		error(E_NULL,"lanczos");\n	if ( m <= 0 )\n		error(E_BOUNDS,"lanczos");\n	if ( Q && ( Q->m < x0->dim || Q->n < m ) )\n		error(E_SIZES,"lanczos");\n\n	a = v_resize(a,(unsigned int)m);\n	b = v_resize(b,(unsigned int)(m-1));\n	v = v_get(x0->dim);\n	w = v_get(x0->dim);\n	tmp = v_get(x0->dim);\n\n	beta = 1.0;\n	/* normalise x0 as w */\n	sv_mlt(1.0/v_norm2(x0),x0,w);\n\n	(*A_fn)(A_params,w,v);\n\n	for ( j = 0; j < m; j++ )\n	{\n		/* store w in Q if Q not NULL */\n		if ( Q )\n		    set_col(Q,j,w);\n\n		alpha = in_prod(w,v);\n		a->ve[j] = alpha;\n		v_mltadd(v,w,-alpha,v);\n		beta = v_norm2(v);\n		if ( beta == 0.0 )\n		{\n		    v_resize(a,(unsigned int)j+1);\n		    v_resize(b,(unsigned int)j);\n		    *beta2 = 0.0;\n		    if ( Q )\n			Q = m_resize(Q,Q->m,j+1);\n		    return;\n		}\n		if ( j < m-1 )\n		    b->ve[j] = beta;\n		v_copy(w,tmp);\n		sv_mlt(1/beta,v,w);\n		sv_mlt(-beta,tmp,v);\n		(*A_fn)(A_params,w,tmp);\n		v_add(v,tmp,v);\n	}\n	*beta2 = beta;\n\n\n	V_FREE(v);	V_FREE(w);	V_FREE(tmp);\n}\n\nextern	double	frexp(), ldexp();\n\n/* product -- returns the product of a long list of numbers\n	-- answer stored in mant (mantissa) and expt (exponent) */\nstatic	double	product(a,offset,expt)\nVEC	*a;\ndouble	offset;\nint	*expt;\n{\n	Real	mant, tmp_fctr;\n	int	i, tmp_expt;\n\n	if ( ! a )\n		error(E_NULL,"product");\n\n	mant = 1.0;\n	*expt = 0;\n	if ( offset == 0.0 )\n		for ( i = 0; i < a->dim; i++ )\n		{\n			mant *= frexp(a->ve[i],&tmp_expt);\n			*expt += tmp_expt;\n			if ( ! (i % 10) )\n			{\n			    mant = frexp(mant,&tmp_expt);\n			    *expt += tmp_expt;\n			}\n		}\n	else\n		for ( i = 0; i < a->dim; i++ )\n		{\n			tmp_fctr = a->ve[i] - offset;\n			tmp_fctr += (tmp_fctr > 0.0 ) ? -MACHEPS*offset :\n							 MACHEPS*offset;\n			mant *= frexp(tmp_fctr,&tmp_expt);\n			*expt += tmp_expt;\n			if ( ! (i % 10) )\n			{\n			    mant = frexp(mant,&tmp_expt);\n			    *expt += tmp_expt;\n			}\n		}\n\n	mant = frexp(mant,&tmp_expt);\n	*expt += tmp_expt;\n\n	return mant;\n}\n\n/* product2 -- returns the product of a long list of numbers\n	-- answer stored in mant (mantissa) and expt (exponent) */\nstatic	double	product2(a,k,expt)\nVEC	*a;\nint	k;	/* entry of a to leave out */\nint	*expt;\n{\n	Real	mant, mu, tmp_fctr;\n	int	i, tmp_expt;\n\n	if ( ! a )\n		error(E_NULL,"product2");\n	if ( k < 0 || k >= a->dim )\n		error(E_BOUNDS,"product2");\n\n	mant = 1.0;\n	*expt = 0;\n	mu = a->ve[k];\n	for ( i = 0; i < a->dim; i++ )\n	{\n		if ( i == k )\n			continue;\n		tmp_fctr = a->ve[i] - mu;\n		tmp_fctr += ( tmp_fctr > 0.0 ) ? -MACHEPS*mu : MACHEPS*mu;\n		mant *= frexp(tmp_fctr,&tmp_expt);\n		*expt += tmp_expt;\n		if ( ! (i % 10) )\n		{\n		    mant = frexp(mant,&tmp_expt);\n		    *expt += tmp_expt;\n		}\n	}\n	mant = frexp(mant,&tmp_expt);\n	*expt += tmp_expt;\n\n	return mant;\n}\n\n/* dbl_cmp -- comparison function to pass to qsort() */\nstatic	int	dbl_cmp(x,y)\nReal	*x, *y;\n{\n	Real	tmp;\n\n	tmp = *x - *y;\n	return (tmp > 0 ? 1 : tmp < 0 ? -1: 0);\n}\n\n/* lanczos2 -- lanczos + error estimate for every e-val\n	-- uses Cullum & Willoughby approach, Sparse Matrix Proc. 1978\n	-- returns multiple e-vals where multiple e-vals may not exist\n	-- returns evals vector */\nVEC	*lanczos2(A_fn,A_params,m,x0,evals,err_est)\nVEC	*(*A_fn)();\nvoid	*A_params;\nint	m;\nVEC	*x0;		/* initial vector */\nVEC	*evals;		/* eigenvalue vector */\nVEC	*err_est;	/* error estimates of eigenvalues */\n{\n	VEC		*a;\n	STATIC	VEC	*b=VNULL, *a2=VNULL, *b2=VNULL;\n	Real	beta, pb_mant, det_mant, det_mant1, det_mant2;\n	int	i, pb_expt, det_expt, det_expt1, det_expt2;\n\n	if ( ! A_fn || ! x0 )\n		error(E_NULL,"lanczos2");\n	if ( m <= 0 )\n		error(E_RANGE,"lanczos2");\n\n	a = evals;\n	a = v_resize(a,(unsigned int)m);\n	b = v_resize(b,(unsigned int)(m-1));\n	MEM_STAT_REG(b,TYPE_VEC);\n\n	lanczos(A_fn,A_params,m,x0,a,b,&beta,MNULL);\n\n	/* printf("# beta =%g\n",beta); */\n	pb_mant = 0.0;\n	if ( err_est )\n	{\n		pb_mant = product(b,(double)0.0,&pb_expt);\n		/* printf("# pb_mant = %g, pb_expt = %d\n",pb_mant, pb_expt); */\n	}\n\n	/* printf("# diags =\n");	out_vec(a); */\n	/* printf("# off diags =\n");	out_vec(b); */\n	a2 = v_resize(a2,a->dim - 1);\n	b2 = v_resize(b2,b->dim - 1);\n	MEM_STAT_REG(a2,TYPE_VEC);\n	MEM_STAT_REG(b2,TYPE_VEC);\n	for ( i = 0; i < a2->dim - 1; i++ )\n	{\n		a2->ve[i] = a->ve[i+1];\n		b2->ve[i] = b->ve[i+1];\n	}\n	a2->ve[a2->dim-1] = a->ve[a2->dim];\n\n	trieig(a,b,MNULL);\n\n	/* sort evals as a courtesy */\n	qsort((void *)(a->ve),(int)(a->dim),sizeof(Real),(int (*)())dbl_cmp);\n\n	/* error estimates */\n	if ( err_est )\n	{\n		err_est = v_resize(err_est,(unsigned int)m);\n\n		trieig(a2,b2,MNULL);\n		/* printf("# a =\n");	out_vec(a); */\n		/* printf("# a2 =\n");	out_vec(a2); */\n\n		for ( i = 0; i < a->dim; i++ )\n		{\n			det_mant1 = product2(a,i,&det_expt1);\n			det_mant2 = product(a2,(double)a->ve[i],&det_expt2);\n			/* printf("# det_mant1=%g, det_expt1=%d\n",\n					det_mant1,det_expt1); */\n			/* printf("# det_mant2=%g, det_expt2=%d\n",\n					det_mant2,det_expt2); */\n			if ( det_mant1 == 0.0 )\n			{   /* multiple e-val of T */\n			    err_est->ve[i] = 0.0;\n			    continue;\n			}\n			else if ( det_mant2 == 0.0 )\n			{\n			    err_est->ve[i] = HUGE_VAL;\n			    continue;\n			}\n			if ( (det_expt1 + det_expt2) % 2 )\n			    /* if odd... */\n			    det_mant = sqrt(2.0*fabs(det_mant1*det_mant2));\n			else /* if even... */\n			    det_mant = sqrt(fabs(det_mant1*det_mant2));\n			det_expt = (det_expt1+det_expt2)/2;\n			err_est->ve[i] = fabs(beta*\n				ldexp(pb_mant/det_mant,pb_expt-det_expt));\n		}\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(b);	V_FREE(a2);	V_FREE(b2);\n#endif\n\n	return a;\n}\n\n/* sp_lanczos -- version that uses sparse matrix data structure */\nvoid    sp_lanczos(A,m,x0,a,b,beta2,Q)\nSPMAT	*A;\nint     m;\nVEC     *x0, *a, *b;\nReal  *beta2;\nMAT     *Q;\n{	lanczos(sp_mv_mlt,A,m,x0,a,b,beta2,Q);	}\n\n/* sp_lanczos2 -- version of lanczos2() that uses sparse matrix data\n					structure */\nVEC	*sp_lanczos2(A,m,x0,evals,err_est)\nSPMAT	*A;\nint	m;\nVEC	*x0;		/* initial vector */\nVEC	*evals;		/* eigenvalue vector */\nVEC	*err_est;	/* error estimates of eigenvalues */\n{	return lanczos2(sp_mv_mlt,A,m,x0,evals,err_est);	}\n\n