\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n#include	<stdio.h>\n#include	"zmatrix.h"\n\nstatic	char	rcsid[] = "$Id: zmatop.c,v 1.2 1995/03/27 15:49:03 des Exp $";\n\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n/* zm_add -- matrix addition -- may be in-situ */\nZMAT	*zm_add(mat1,mat2,out)\nZMAT	*mat1,*mat2,*out;\n{\n    unsigned int	m,n,i;\n    \n    if ( mat1==ZMNULL || mat2==ZMNULL )\n	error(E_NULL,"zm_add");\n    if ( mat1->m != mat2->m || mat1->n != mat2->n )\n	error(E_SIZES,"zm_add");\n    if ( out==ZMNULL || out->m != mat1->m || out->n != mat1->n )\n	out = zm_resize(out,mat1->m,mat1->n);\n    m = mat1->m;	n = mat1->n;\n    for ( i=0; i<m; i++ )\n    {\n	__zadd__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n	/**************************************************\n	  for ( j=0; j<n; j++ )\n	  out->me[i][j] = mat1->me[i][j]+mat2->me[i][j];\n	  **************************************************/\n    }\n    \n    return (out);\n}\n\n/* zm_sub -- matrix subtraction -- may be in-situ */\nZMAT	*zm_sub(mat1,mat2,out)\nZMAT	*mat1,*mat2,*out;\n{\n    unsigned int	m,n,i;\n    \n    if ( mat1==ZMNULL || mat2==ZMNULL )\n	error(E_NULL,"zm_sub");\n    if ( mat1->m != mat2->m || mat1->n != mat2->n )\n	error(E_SIZES,"zm_sub");\n    if ( out==ZMNULL || out->m != mat1->m || out->n != mat1->n )\n	out = zm_resize(out,mat1->m,mat1->n);\n    m = mat1->m;	n = mat1->n;\n    for ( i=0; i<m; i++ )\n    {\n	__zsub__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n	/**************************************************\n	  for ( j=0; j<n; j++ )\n	  out->me[i][j] = mat1->me[i][j]-mat2->me[i][j];\n	**************************************************/\n    }\n    \n    return (out);\n}\n\n/*\n  Note: In the following routines, "adjoint" means complex conjugate\n  transpose:\n  A* = conjugate(A^T)\n  */\n\n/* zm_mlt -- matrix-matrix multiplication */\nZMAT	*zm_mlt(A,B,OUT)\nZMAT	*A,*B,*OUT;\n{\n    unsigned int	i, /* j, */ k, m, n, p;\n    complex	**A_v, **B_v /*, *B_row, *OUT_row, sum, tmp */;\n    \n    if ( A==ZMNULL || B==ZMNULL )\n	error(E_NULL,"zm_mlt");\n    if ( A->n != B->m )\n	error(E_SIZES,"zm_mlt");\n    if ( A == OUT || B == OUT )\n	error(E_INSITU,"zm_mlt");\n    m = A->m;	n = A->n;	p = B->n;\n    A_v = A->me;		B_v = B->me;\n    \n    if ( OUT==ZMNULL || OUT->m != A->m || OUT->n != B->n )\n	OUT = zm_resize(OUT,A->m,B->n);\n    \n    /****************************************************************\n      for ( i=0; i<m; i++ )\n      for  ( j=0; j<p; j++ )\n      {\n      sum = 0.0;\n      for ( k=0; k<n; k++ )\n      sum += A_v[i][k]*B_v[k][j];\n      OUT->me[i][j] = sum;\n      }\n    ****************************************************************/\n    zm_zero(OUT);\n    for ( i=0; i<m; i++ )\n	for ( k=0; k<n; k++ )\n	{\n	    if ( ! is_zero(A_v[i][k]) )\n		__zmltadd__(OUT->me[i],B_v[k],A_v[i][k],(int)p,Z_NOCONJ);\n	    /**************************************************\n	      B_row = B_v[k];	OUT_row = OUT->me[i];\n	      for ( j=0; j<p; j++ )\n	      (*OUT_row++) += tmp*(*B_row++);\n	    **************************************************/\n	}\n    \n    return OUT;\n}\n\n/* zmma_mlt -- matrix-matrix adjoint multiplication\n   -- A.B* is returned, and stored in OUT */\nZMAT	*zmma_mlt(A,B,OUT)\nZMAT	*A, *B, *OUT;\n{\n    int	i, j, limit;\n    /* complex	*A_row, *B_row, sum; */\n    \n    if ( ! A || ! B )\n	error(E_NULL,"zmma_mlt");\n    if ( A == OUT || B == OUT )\n	error(E_INSITU,"zmma_mlt");\n    if ( A->n != B->n )\n	error(E_SIZES,"zmma_mlt");\n    if ( ! OUT || OUT->m != A->m || OUT->n != B->m )\n	OUT = zm_resize(OUT,A->m,B->m);\n    \n    limit = A->n;\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < B->m; j++ )\n	{\n	    OUT->me[i][j] = __zip__(B->me[j],A->me[i],(int)limit,Z_CONJ);\n	    /**************************************************\n	      sum = 0.0;\n	      A_row = A->me[i];\n	      B_row = B->me[j];\n	      for ( k = 0; k < limit; k++ )\n	      sum += (*A_row++)*(*B_row++);\n	      OUT->me[i][j] = sum;\n	      **************************************************/\n	}\n    \n    return OUT;\n}\n\n/* zmam_mlt -- matrix adjoint-matrix multiplication\n   -- A*.B is returned, result stored in OUT */\nZMAT	*zmam_mlt(A,B,OUT)\nZMAT	*A, *B, *OUT;\n{\n    int	i, k, limit;\n    /* complex	*B_row, *OUT_row, multiplier; */\n    complex	tmp;\n    \n    if ( ! A || ! B )\n	error(E_NULL,"zmam_mlt");\n    if ( A == OUT || B == OUT )\n	error(E_INSITU,"zmam_mlt");\n    if ( A->m != B->m )\n	error(E_SIZES,"zmam_mlt");\n    if ( ! OUT || OUT->m != A->n || OUT->n != B->n )\n	OUT = zm_resize(OUT,A->n,B->n);\n    \n    limit = B->n;\n    zm_zero(OUT);\n    for ( k = 0; k < A->m; k++ )\n	for ( i = 0; i < A->n; i++ )\n	{\n	    tmp.re =   A->me[k][i].re;\n	    tmp.im = - A->me[k][i].im;\n	    if ( ! is_zero(tmp) )\n		__zmltadd__(OUT->me[i],B->me[k],tmp,(int)limit,Z_NOCONJ);\n	}\n    \n    return OUT;\n}\n\n/* zmv_mlt -- matrix-vector multiplication \n   -- Note: b is treated as a column vector */\nZVEC	*zmv_mlt(A,b,out)\nZMAT	*A;\nZVEC	*b,*out;\n{\n    unsigned int	i, m, n;\n    complex	**A_v, *b_v /*, *A_row */;\n    /* register complex	sum; */\n    \n    if ( A==ZMNULL || b==ZVNULL )\n	error(E_NULL,"zmv_mlt");\n    if ( A->n != b->dim )\n	error(E_SIZES,"zmv_mlt");\n    if ( b == out )\n	error(E_INSITU,"zmv_mlt");\n    if ( out == ZVNULL || out->dim != A->m )\n	out = zv_resize(out,A->m);\n    \n    m = A->m;		n = A->n;\n    A_v = A->me;		b_v = b->ve;\n    for ( i=0; i<m; i++ )\n    {\n	/* for ( j=0; j<n; j++ )\n	   sum += A_v[i][j]*b_v[j]; */\n	out->ve[i] = __zip__(A_v[i],b_v,(int)n,Z_NOCONJ);\n	/**************************************************\n	  A_row = A_v[i];		b_v = b->ve;\n	  for ( j=0; j<n; j++ )\n	  sum += (*A_row++)*(*b_v++);\n	  out->ve[i] = sum;\n	**************************************************/\n    }\n    \n    return out;\n}\n\n/* zsm_mlt -- scalar-matrix multiply -- may be in-situ */\nZMAT	*zsm_mlt(scalar,matrix,out)\ncomplex	scalar;\nZMAT	*matrix,*out;\n{\n    unsigned int	m,n,i;\n    \n    if ( matrix==ZMNULL )\n	error(E_NULL,"zsm_mlt");\n    if ( out==ZMNULL || out->m != matrix->m || out->n != matrix->n )\n	out = zm_resize(out,matrix->m,matrix->n);\n    m = matrix->m;	n = matrix->n;\n    for ( i=0; i<m; i++ )\n	__zmlt__(matrix->me[i],scalar,out->me[i],(int)n);\n    /**************************************************\n      for ( j=0; j<n; j++ )\n      out->me[i][j] = scalar*matrix->me[i][j];\n      **************************************************/\n    return (out);\n}\n\n/* zvm_mlt -- vector adjoint-matrix multiplication */\nZVEC	*zvm_mlt(A,b,out)\nZMAT	*A;\nZVEC	*b,*out;\n{\n    unsigned int	j,m,n;\n    /* complex	sum,**A_v,*b_v; */\n    \n    if ( A==ZMNULL || b==ZVNULL )\n	error(E_NULL,"zvm_mlt");\n    if ( A->m != b->dim )\n	error(E_SIZES,"zvm_mlt");\n    if ( b == out )\n	error(E_INSITU,"zvm_mlt");\n    if ( out == ZVNULL || out->dim != A->n )\n	out = zv_resize(out,A->n);\n    \n    m = A->m;		n = A->n;\n    \n    zv_zero(out);\n    for ( j = 0; j < m; j++ )\n	if ( b->ve[j].re != 0.0 || b->ve[j].im != 0.0  )\n	    __zmltadd__(out->ve,A->me[j],b->ve[j],(int)n,Z_CONJ);\n    /**************************************************\n      A_v = A->me;		b_v = b->ve;\n      for ( j=0; j<n; j++ )\n      {\n      sum = 0.0;\n      for ( i=0; i<m; i++ )\n      sum += b_v[i]*A_v[i][j];\n      out->ve[j] = sum;\n      }\n      **************************************************/\n    \n    return out;\n}\n\n/* zm_adjoint -- adjoint matrix */\nZMAT	*zm_adjoint(in,out)\nZMAT	*in, *out;\n{\n    int	i, j;\n    int	in_situ;\n    complex	tmp;\n    \n    if ( in == ZMNULL )\n	error(E_NULL,"zm_adjoint");\n    if ( in == out && in->n != in->m )\n	error(E_INSITU2,"zm_adjoint");\n    in_situ = ( in == out );\n    if ( out == ZMNULL || out->m != in->n || out->n != in->m )\n	out = zm_resize(out,in->n,in->m);\n    \n    if ( ! in_situ )\n    {\n	for ( i = 0; i < in->m; i++ )\n	    for ( j = 0; j < in->n; j++ )\n	    {\n		out->me[j][i].re =   in->me[i][j].re;\n		out->me[j][i].im = - in->me[i][j].im;\n	    }\n    }\n    else\n    {\n	for ( i = 0 ; i < in->m; i++ )\n	{\n	    for ( j = 0; j < i; j++ )\n	    {\n		tmp.re = in->me[i][j].re;\n		tmp.im = in->me[i][j].im;\n		in->me[i][j].re =   in->me[j][i].re;\n		in->me[i][j].im = - in->me[j][i].im;\n		in->me[j][i].re =   tmp.re;\n		in->me[j][i].im = - tmp.im;\n	    }\n	    in->me[i][i].im = - in->me[i][i].im;\n	}\n    }\n    \n    return out;\n}\n\n/* zswap_rows -- swaps rows i and j of matrix A upto column lim */\nZMAT	*zswap_rows(A,i,j,lo,hi)\nZMAT	*A;\nint	i, j, lo, hi;\n{\n    int	k;\n    complex	**A_me, tmp;\n    \n    if ( ! A )\n	error(E_NULL,"swap_rows");\n    if ( i < 0 || j < 0 || i >= A->m || j >= A->m )\n	error(E_SIZES,"swap_rows");\n    lo = max(0,lo);\n    hi = min(hi,A->n-1);\n    A_me = A->me;\n    \n    for ( k = lo; k <= hi; k++ )\n    {\n	tmp = A_me[k][i];\n	A_me[k][i] = A_me[k][j];\n	A_me[k][j] = tmp;\n    }\n    return A;\n}\n\n/* zswap_cols -- swap columns i and j of matrix A upto row lim */\nZMAT	*zswap_cols(A,i,j,lo,hi)\nZMAT	*A;\nint	i, j, lo, hi;\n{\n    int	k;\n    complex	**A_me, tmp;\n    \n    if ( ! A )\n	error(E_NULL,"swap_cols");\n    if ( i < 0 || j < 0 || i >= A->n || j >= A->n )\n	error(E_SIZES,"swap_cols");\n    lo = max(0,lo);\n    hi = min(hi,A->m-1);\n    A_me = A->me;\n    \n    for ( k = lo; k <= hi; k++ )\n    {\n	tmp = A_me[i][k];\n	A_me[i][k] = A_me[j][k];\n	A_me[j][k] = tmp;\n    }\n    return A;\n}\n\n/* mz_mltadd -- matrix-scalar multiply and add\n   -- may be in situ\n   -- returns out == A1 + s*A2 */\nZMAT	*mz_mltadd(A1,A2,s,out)\nZMAT	*A1, *A2, *out;\ncomplex	s;\n{\n    /* register complex	*A1_e, *A2_e, *out_e; */\n    /* register int	j; */\n    int	i, m, n;\n    \n    if ( ! A1 || ! A2 )\n	error(E_NULL,"mz_mltadd");\n    if ( A1->m != A2->m || A1->n != A2->n )\n	error(E_SIZES,"mz_mltadd");\n\n    if ( out != A1 && out != A2 )\n        out = zm_resize(out,A1->m,A1->n);\n    \n    if ( s.re == 0.0 && s.im == 0.0 )\n	return zm_copy(A1,out);\n    if ( s.re == 1.0 && s.im == 0.0 )\n	return zm_add(A1,A2,out);\n    \n    out = zm_copy(A1,out);\n    \n    m = A1->m;	n = A1->n;\n    for ( i = 0; i < m; i++ )\n    {\n	__zmltadd__(out->me[i],A2->me[i],s,(int)n,Z_NOCONJ);\n	/**************************************************\n	  A1_e = A1->me[i];\n	  A2_e = A2->me[i];\n	  out_e = out->me[i];\n	  for ( j = 0; j < n; j++ )\n	  out_e[j] = A1_e[j] + s*A2_e[j];\n	  **************************************************/\n    }\n    \n    return out;\n}\n\n/* zmv_mltadd -- matrix-vector multiply and add\n   -- may not be in situ\n   -- returns out == v1 + alpha*A*v2 */\nZVEC	*zmv_mltadd(v1,v2,A,alpha,out)\nZVEC	*v1, *v2, *out;\nZMAT	*A;\ncomplex	alpha;\n{\n    /* register	int	j; */\n    int	i, m, n;\n    complex	tmp, *v2_ve, *out_ve;\n    \n    if ( ! v1 || ! v2 || ! A )\n	error(E_NULL,"zmv_mltadd");\n    if ( out == v2 )\n	error(E_INSITU,"zmv_mltadd");\n    if ( v1->dim != A->m || v2->dim != A-> n )\n	error(E_SIZES,"zmv_mltadd");\n    \n    tracecatch(out = zv_copy(v1,out),"zmv_mltadd");\n    \n    v2_ve = v2->ve;	out_ve = out->ve;\n    m = A->m;	n = A->n;\n    \n    if ( alpha.re == 0.0 && alpha.im == 0.0 )\n	return out;\n    \n    for ( i = 0; i < m; i++ )\n    {\n	tmp = __zip__(A->me[i],v2_ve,(int)n,Z_NOCONJ);\n	out_ve[i].re += alpha.re*tmp.re - alpha.im*tmp.im;\n	out_ve[i].im += alpha.re*tmp.im + alpha.im*tmp.re;\n	/**************************************************\n	  A_e = A->me[i];\n	  sum = 0.0;\n	  for ( j = 0; j < n; j++ )\n	  sum += A_e[j]*v2_ve[j];\n	  out_ve[i] = v1->ve[i] + alpha*sum;\n	  **************************************************/\n    }\n    \n    return out;\n}\n\n/* zvm_mltadd -- vector-matrix multiply and add a la zvm_mlt()\n   -- may not be in situ\n   -- returns out == v1 + v2*.A */\nZVEC	*zvm_mltadd(v1,v2,A,alpha,out)\nZVEC	*v1, *v2, *out;\nZMAT	*A;\ncomplex	alpha;\n{\n    int	/* i, */ j, m, n;\n    complex	tmp, /* *A_e, */ *out_ve;\n    \n    if ( ! v1 || ! v2 || ! A )\n	error(E_NULL,"zvm_mltadd");\n    if ( v2 == out )\n	error(E_INSITU,"zvm_mltadd");\n    if ( v1->dim != A->n || A->m != v2->dim )\n	error(E_SIZES,"zvm_mltadd");\n    \n    tracecatch(out = zv_copy(v1,out),"zvm_mltadd");\n    \n    out_ve = out->ve;	m = A->m;	n = A->n;\n    for ( j = 0; j < m; j++ )\n    {\n	/* tmp = zmlt(v2->ve[j],alpha); */\n	tmp.re =   v2->ve[j].re*alpha.re - v2->ve[j].im*alpha.im;\n	tmp.im =   v2->ve[j].re*alpha.im + v2->ve[j].im*alpha.re;\n	if ( tmp.re != 0.0 || tmp.im != 0.0 )\n	    __zmltadd__(out_ve,A->me[j],tmp,(int)n,Z_CONJ);\n	/**************************************************\n	  A_e = A->me[j];\n	  for ( i = 0; i < n; i++ )\n	  out_ve[i] += A_e[i]*tmp;\n	**************************************************/\n    }\n    \n    return out;\n}\n\n/* zget_col -- gets a specified column of a matrix; returned as a vector */\nZVEC	*zget_col(mat,col,vec)\nint	col;\nZMAT	*mat;\nZVEC	*vec;\n{\n	unsigned int	i;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,"zget_col");\n	if ( col < 0 || col >= mat->n )\n		error(E_RANGE,"zget_col");\n	if ( vec==ZVNULL || vec->dim<mat->m )\n		vec = zv_resize(vec,mat->m);\n\n	for ( i=0; i<mat->m; i++ )\n	    vec->ve[i] = mat->me[i][col];\n\n	return (vec);\n}\n\n/* zget_row -- gets a specified row of a matrix and retruns it as a vector */\nZVEC	*zget_row(mat,row,vec)\nint	row;\nZMAT	*mat;\nZVEC	*vec;\n{\n	int	/* i, */ lim;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,"zget_row");\n	if ( row < 0 || row >= mat->m )\n		error(E_RANGE,"zget_row");\n	if ( vec==ZVNULL || vec->dim<mat->n )\n		vec = zv_resize(vec,mat->n);\n\n	lim = min(mat->n,vec->dim);\n\n	/* for ( i=0; i<mat->n; i++ ) */\n	/*     vec->ve[i] = mat->me[row][i]; */\n	MEMCOPY(mat->me[row],vec->ve,lim,complex);\n\n	return (vec);\n}\n\n/* zset_col -- sets column of matrix to values given in vec (in situ) */\nZMAT	*zset_col(mat,col,vec)\nZMAT	*mat;\nZVEC	*vec;\nint	col;\n{\n	unsigned int	i,lim;\n\n	if ( mat==ZMNULL || vec==ZVNULL )\n		error(E_NULL,"zset_col");\n	if ( col < 0 || col >= mat->n )\n		error(E_RANGE,"zset_col");\n	lim = min(mat->m,vec->dim);\n	for ( i=0; i<lim; i++ )\n	    mat->me[i][col] = vec->ve[i];\n\n	return (mat);\n}\n\n/* zset_row -- sets row of matrix to values given in vec (in situ) */\nZMAT	*zset_row(mat,row,vec)\nZMAT	*mat;\nZVEC	*vec;\nint	row;\n{\n	unsigned int	/* j, */ lim;\n\n	if ( mat==ZMNULL || vec==ZVNULL )\n		error(E_NULL,"zset_row");\n	if ( row < 0 || row >= mat->m )\n		error(E_RANGE,"zset_row");\n	lim = min(mat->n,vec->dim);\n	/* for ( j=j0; j<lim; j++ ) */\n	/*     mat->me[row][j] = vec->ve[j]; */\n	MEMCOPY(vec->ve,mat->me[row],lim,complex);\n\n	return (mat);\n}\n\n/* zm_rand -- randomise a complex matrix; uniform in [0,1)+[0,1)*i */\nZMAT	*zm_rand(A)\nZMAT	*A;\n{\n    int		i;\n\n    if ( ! A )\n	error(E_NULL,"zm_rand");\n\n    for ( i = 0; i < A->m; i++ )\n	mrandlist((Real *)(A->me[i]),2*A->n);\n\n    return A;\n}\n