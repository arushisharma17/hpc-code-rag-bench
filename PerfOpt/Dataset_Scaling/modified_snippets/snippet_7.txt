#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\n// Returns the current system time in microseconds \nlong long get_time()\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * 1000000) + tv.tv_usec;\n\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE	256\n\n/* maximum power density possible (say 300W for a 10mm x 10mm chip)	*/\n#define MAX_PD	(3.0e6)\n/* required precision in degrees	*/\n#define PRECISION	0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n/* capacitance fitting factor	*/\n#define FACTOR_CHIP	0.5\n#define OPEN\n//#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\n/* chip parameters	*/\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\n/* ambient temperature, assuming no package at all	*/\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\n/* Single iteration of the transient solver in the grid model.\n * advances the solution of the discretized difference equations \n * by one time step\n */\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\n					  FLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1, \n					  FLOAT step)\n{\n    FLOAT delta;\n    int r, c;\n    int chunk;\n    int num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\n    int chunks_in_row = col/BLOCK_SIZE_C;\n    int chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n    #ifndef __MIC__\n	omp_set_num_threads(num_omp_threads);\n    #endif\n    #pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\n    for ( chunk = 0; chunk < num_chunk; ++chunk )\n    {\n        int r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\n        int c_start = BLOCK_SIZE_C*(chunk%chunks_in_row); \n        int r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\n        int c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n       \n        if ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n        {\n            for ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\n                for ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\n                    /* Corner 1 */\n                    if ( (r == 0) && (c == 0) ) {\n                        delta = (Cap_1) * (power[0] +\n                            (temp[1] - temp[0]) * Rx_1 +\n                            (temp[col] - temp[0]) * Ry_1 +\n                            (amb_temp - temp[0]) * Rz_1);\n                    }	/* Corner 2 */\n                    else if ((r == 0) && (c == col-1)) {\n                        delta = (Cap_1) * (power[c] +\n                            (temp[c-1] - temp[c]) * Rx_1 +\n                            (temp[c+col] - temp[c]) * Ry_1 +\n                        (   amb_temp - temp[c]) * Rz_1);\n                    }	/* Corner 3 */\n                    else if ((r == row-1) && (c == col-1)) {\n                        delta = (Cap_1) * (power[r*col+c] + \n                            (temp[r*col+c-1] - temp[r*col+c]) * Rx_1 + \n                            (temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 + \n                        (   amb_temp - temp[r*col+c]) * Rz_1);					\n                    }	/* Corner 4	*/\n                    else if ((r == row-1) && (c == 0)) {\n                        delta = (Cap_1) * (power[r*col] + \n                            (temp[r*col+1] - temp[r*col]) * Rx_1 + \n                            (temp[(r-1)*col] - temp[r*col]) * Ry_1 + \n                            (amb_temp - temp[r*col]) * Rz_1);\n                    }	/* Edge 1 */\n                    else if (r == 0) {\n                        delta = (Cap_1) * (power[c] + \n                            (temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 + \n                            (temp[col+c] - temp[c]) * Ry_1 + \n                            (amb_temp - temp[c]) * Rz_1);\n                    }	/* Edge 2 */\n                    else if (c == col-1) {\n                        delta = (Cap_1) * (power[r*col+c] + \n                            (temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) * Ry_1 + \n                            (temp[r*col+c-1] - temp[r*col+c]) * Rx_1 + \n                            (amb_temp - temp[r*col+c]) * Rz_1);\n                    }	/* Edge 3 */\n                    else if (r == row-1) {\n                        delta = (Cap_1) * (power[r*col+c] + \n                            (temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) * Rx_1 + \n                            (temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 + \n                            (amb_temp - temp[r*col+c]) * Rz_1);\n                    }	/* Edge 4 */\n                    else if (c == 0) {\n                        delta = (Cap_1) * (power[r*col] + \n                            (temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) * Ry_1 + \n                            (temp[r*col+1] - temp[r*col]) * Rx_1 + \n                            (amb_temp - temp[r*col]) * Rz_1);\n                    }\n                    result[r*col+c] =temp[r*col+c]+ delta;\n                }\n            }\n            continue;\n        }\n\n        for ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\n#pragma omp simd        \n            for ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\n            /* Update Temperatures */\n                result[r*col+c] =temp[r*col+c]+ \n                     ( Cap_1 * (power[r*col+c] + \n                    (temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.f*temp[r*col+c]) * Ry_1 + \n                    (temp[r*col+c+1] + temp[r*col+c-1] - 2.f*temp[r*col+c]) * Rx_1 + \n                    (amb_temp - temp[r*col+c]) * Rz_1));\n            }\n        }\n    }\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n/* Transient solver driver routine: simply converts the heat \n * transfer differential equations to difference equations \n * and solves the difference equations by iterating\n */\nvoid compute_tran_temp(FLOAT *result, int num_iterations, FLOAT *temp, FLOAT *power, int row, int col) \n{\n	#ifdef VERBOSE\n	int i = 0;\n	#endif\n\n	FLOAT grid_height = chip_height / row;\n	FLOAT grid_width = chip_width / col;\n\n	FLOAT Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;\n	FLOAT Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);\n	FLOAT Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);\n	FLOAT Rz = t_chip / (K_SI * grid_height * grid_width);\n\n	FLOAT max_slope = MAX_PD / (FACTOR_CHIP * t_chip * SPEC_HEAT_SI);\n    FLOAT step = PRECISION / max_slope / 1000.0;\n\n    FLOAT Rx_1=1.f/Rx;\n    FLOAT Ry_1=1.f/Ry;\n    FLOAT Rz_1=1.f/Rz;\n    FLOAT Cap_1 = step/Cap;\n	#ifdef VERBOSE\n	fprintf(stdout, "total iterations: %d s\tstep size: %g s\n", num_iterations, step);\n	fprintf(stdout, "Rx: %g\tRy: %g\tRz: %g\tCap: %g\n", Rx, Ry, Rz, Cap);\n	#endif\n\n#ifdef OMP_OFFLOAD\n        int array_size = row*col;\n#pragma omp target \\n        map(temp[0:array_size]) \\n        map(to: power[0:array_size], row, col, Cap_1, Rx_1, Ry_1, Rz_1, step, num_iterations) \\n        map( result[0:array_size])\n#endif\n        {\n            FLOAT* r = result;\n            FLOAT* t = temp;\n            for (int i = 0; i < num_iterations ; i++)\n            {\n                #ifdef VERBOSE\n                fprintf(stdout, "iteration %d\n", i++);\n                #endif\n                single_iteration(r, t, power, row, col, Cap_1, Rx_1, Ry_1, Rz_1, step);\n                FLOAT* tmp = t;\n                t = r;\n                r = tmp;\n            }	\n        }\n	#ifdef VERBOSE\n	fprintf(stdout, "iteration %d\n", i++);\n	#endif\n}\n\nvoid fatal(char *s)\n{\n	fprintf(stderr, "error: %s\n", s);\n	exit(1);\n}\n\nvoid writeoutput(FLOAT *vect, int grid_rows, int grid_cols, char *file) {\n\n    int i,j, index=0;\n    FILE *fp;\n    char str[STR_SIZE];\n\n    if( (fp = fopen(file, "w" )) == 0 )\n        printf( "The file was not opened\n" );\n\n\n    for (i=0; i < grid_rows; i++) \n        for (j=0; j < grid_cols; j++)\n        {\n\n            sprintf(str, "%d\t%g\n", index, vect[i*grid_cols+j]);\n            fputs(str,fp);\n            index++;\n        }\n\n    fclose(fp);	\n}\n\nvoid read_input(FLOAT *vect, int grid_rows, int grid_cols, char *file)\n{\n  	int i, index;\n	FILE *fp;\n	char str[STR_SIZE];\n	FLOAT val;\n\n	fp = fopen (file, "r");\n	if (!fp)\n		fatal ("file could not be opened for reading");\n\n	for (i=0; i < grid_rows * grid_cols; i++) {\n		fgets(str, STR_SIZE, fp);\n		if (feof(fp))\n			fatal("not enough lines in file");\n		if ((sscanf(str, "%f", &val) != 1) )\n			fatal("invalid file format");\n		vect[i] = val;\n	}\n\n	fclose(fp);	\n}\n\nvoid usage(int argc, char **argv)\n{\n	fprintf(stderr, "Usage: %s <grid_rows> <grid_cols> <sim_time> <no. of threads><temp_file> <power_file>\n", argv[0]);\n	fprintf(stderr, "\t<grid_rows>  - number of rows in the grid (positive integer)\n");\n	fprintf(stderr, "\t<grid_cols>  - number of columns in the grid (positive integer)\n");\n	fprintf(stderr, "\t<sim_time>   - number of iterations\n");\n	fprintf(stderr, "\t<no. of threads>   - number of threads\n");\n	fprintf(stderr, "\t<temp_file>  - name of the file containing the initial temperature values of each cell\n");\n	fprintf(stderr, "\t<power_file> - name of the file containing the dissipated power values of each cell\n");\n        fprintf(stderr, "\t<output_file> - name of the output file\n");\n	exit(1);\n}\n\nint main(int argc, char **argv)\n{\n	int grid_rows, grid_cols, sim_time, i;\n	FLOAT *temp, *power, *result;\n	char *tfile, *pfile, *ofile;\n	\n	/* check validity of inputs	*/\n	if (argc != 8)\n		usage(argc, argv);\n	if ((grid_rows = atoi(argv[1])) <= 0 ||\n		(grid_cols = atoi(argv[2])) <= 0 ||\n		(sim_time = atoi(argv[3])) <= 0 || \n		(num_omp_threads = atoi(argv[4])) <= 0\n		)\n		usage(argc, argv);\n\n	/* allocate memory for the temperature and power arrays	*/\n	temp = (FLOAT *) calloc (grid_rows * grid_cols, sizeof(FLOAT));\n	power = (FLOAT *) calloc (grid_rows * grid_cols, sizeof(FLOAT));\n	result = (FLOAT *) calloc (grid_rows * grid_cols, sizeof(FLOAT));\n	if(!temp || !power)\n		fatal("unable to allocate memory");\n\n	/* read initial temperatures and input power	*/\n	tfile = argv[5];\n	pfile = argv[6];\n    ofile = argv[7];\n\n	read_input(temp, grid_rows, grid_cols, tfile);\n	read_input(power, grid_rows, grid_cols, pfile);\n\n	printf("Start computing the transient temperature\n");\n	\n    long long start_time = get_time();\n\n    compute_tran_temp(result,sim_time, temp, power, grid_rows, grid_cols);\n\n    long long end_time = get_time();\n\n    printf("Ending simulation\n");\n    printf("Total time: %.3f seconds\n", ((float) (end_time - start_time)) / (1000*1000));\n\n    writeoutput((1&sim_time) ? result : temp, grid_rows, grid_cols, ofile);\n\n	/* output results	*/\n#ifdef VERBOSE\n	fprintf(stdout, "Final Temperatures:\n");\n#endif\n\n#ifdef OUTPUT\n	for(i=0; i < grid_rows * grid_cols; i++)\n	fprintf(stdout, "%d\t%g\n", i, temp[i]);\n#endif\n	/* cleanup	*/\n	free(temp);\n	free(power);\n\n	return 0;\n}\n/* vim: set ts=4 sw=4  sts=4 et si ai: */\n