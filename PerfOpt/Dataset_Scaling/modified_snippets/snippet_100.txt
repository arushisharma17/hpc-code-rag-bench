\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	Elementary functions for complex numbers\n	-- if not already defined\n*/\n\n#include	<math.h>\n#include	"zmatrix.h"\n\nstatic char rcsid[] = "$Id: zfunc.c,v 1.3 1995/04/07 16:27:25 des Exp $";\n\n#ifndef COMPLEX_H\n\n#ifndef zmake\n/* zmake -- create complex number real + i*imag */\ncomplex	zmake(real,imag)\ndouble	real, imag;\n{\n    complex	w;	/* == real + i*imag */\n\n    w.re = real;	w.im = imag;\n    return w;\n}\n#endif\n\n#ifndef zneg\n/* zneg -- returns negative of z */\ncomplex	zneg(z)\ncomplex	z;\n{\n    z.re = - z.re;\n    z.im = - z.im;\n\n    return z;\n}\n#endif\n\n#ifndef zabs\n/* zabs -- returns |z| */\ndouble	zabs(z)\ncomplex	z;\n{\n    Real	x, y, tmp;\n    int		x_expt, y_expt;\n\n    /* Note: we must ensure that overflow does not occur! */\n    x = ( z.re >= 0.0 ) ? z.re : -z.re;\n    y = ( z.im >= 0.0 ) ? z.im : -z.im;\n    if ( x < y )\n    {\n	tmp = x;\n	x = y;\n	y = tmp;\n    }\n    if ( x == 0.0 ) /* then y == 0.0 as well */\n	return 0.0;\n    x = frexp(x,&x_expt);\n    y = frexp(y,&y_expt);\n    y = ldexp(y,y_expt-x_expt);\n    tmp = sqrt(x*x+y*y);\n\n    return ldexp(tmp,x_expt);\n}\n#endif\n\n#ifndef zadd\n/* zadd -- returns z1+z2 */\ncomplex zadd(z1,z2)\ncomplex	z1, z2;\n{\n    complex z;\n\n    z.re = z1.re + z2.re;\n    z.im = z1.im + z2.im;\n\n    return z;\n}\n#endif\n\n#ifndef zsub\n/* zsub -- returns z1-z2 */\ncomplex zsub(z1,z2)\ncomplex	z1, z2;\n{\n    complex z;\n\n    z.re = z1.re - z2.re;\n    z.im = z1.im - z2.im;\n\n    return z;\n}\n#endif\n\n#ifndef zmlt\n/* zmlt -- returns z1*z2 */\ncomplex	zmlt(z1,z2)\ncomplex	z1, z2;\n{\n    complex z;\n\n    z.re = z1.re * z2.re - z1.im * z2.im;\n    z.im = z1.re * z2.im + z1.im * z2.re;\n\n    return z;\n}\n#endif\n\n#ifndef zinv\n/* zmlt -- returns 1/z */\ncomplex	zinv(z)\ncomplex	z;\n{\n    Real	x, y, tmp;\n    int		x_expt, y_expt;\n\n    if ( z.re == 0.0 && z.im == 0.0 )\n	error(E_SING,"zinv");\n    /* Note: we must ensure that overflow does not occur! */\n    x = ( z.re >= 0.0 ) ? z.re : -z.re;\n    y = ( z.im >= 0.0 ) ? z.im : -z.im;\n    if ( x < y )\n    {\n	tmp = x;\n	x = y;\n	y = tmp;\n    }\n    x = frexp(x,&x_expt);\n    y = frexp(y,&y_expt);\n    y = ldexp(y,y_expt-x_expt);\n\n    tmp = 1.0/(x*x + y*y);\n    z.re =  z.re*tmp*ldexp(1.0,-2*x_expt);\n    z.im = -z.im*tmp*ldexp(1.0,-2*x_expt);\n\n    return z;\n}\n#endif\n\n#ifndef zdiv\n/* zdiv -- returns z1/z2 */\ncomplex	zdiv(z1,z2)\ncomplex	z1, z2;\n{\n    return zmlt(z1,zinv(z2));\n}\n#endif\n\n#ifndef zsqrt\n/* zsqrt -- returns sqrt(z); uses branch with Re sqrt(z) >= 0 */\ncomplex	zsqrt(z)\ncomplex	z;\n{\n    complex	w;	/* == sqrt(z) at end */\n    Real	alpha;\n    \n    alpha = sqrt(0.5*(fabs(z.re) + zabs(z)));\n    if (alpha!=0) \n      {\n    	if (z.re>=0.0)\n	  {\n	    w.re = alpha;\n	    w.im = z.im / (2.0*alpha);\n	  }\n    	else\n	  {\n	    w.re = fabs(z.im)/(2.0*alpha);\n	    w.im = ( z.im >= 0 ) ? alpha : - alpha;\n	  }\n      }\n    else\n      w.re = w.im = 0.0;\n\n    return w;\n}\n#endif\n\n#ifndef	zexp\n/* zexp -- returns exp(z) */\ncomplex	zexp(z)\ncomplex	z;\n{\n    complex	w;	/* == exp(z) at end */\n    Real	r;\n\n    r = exp(z.re);\n    w.re = r*cos(z.im);\n    w.im = r*sin(z.im);\n\n    return w;\n}\n#endif\n\n#ifndef	zlog\n/* zlog -- returns log(z); uses principal branch with -pi <= Im log(z) <= pi */\ncomplex	zlog(z)\ncomplex	z;\n{\n    complex	w;	/* == log(z) at end */\n\n    w.re = log(zabs(z));\n    w.im = atan2(z.im,z.re);\n\n    return w;\n}\n#endif\n\n#ifndef zconj\ncomplex	zconj(z)\ncomplex	z;\n{\n    complex	w;	/* == conj(z) */\n\n    w.re =   z.re;\n    w.im = - z.im;\n    return w;\n}\n#endif\n\n#endif\n\n