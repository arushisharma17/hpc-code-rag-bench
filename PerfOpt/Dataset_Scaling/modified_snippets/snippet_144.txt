#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <cmath>\n#include <sys/time.h>\n#include <list>\n#include <map>\n#include <vector>\n#include <queue>\n#include <cstring>\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <assert.h>\n\n#define ulong4 uint32_t\n#define uint4 uint32_t\n#define int2 int32_t\n#include "mummergpu.h"\n\n#define MPOOL 0\n\n#include "PoolMalloc.hh"\n\nusing namespace std;\n\n// Enable verification/debug options\n#define VERIFY  0\n#define VERBOSE 0\nconst bool DEBUG = 0;\n\n// Setting for linear time alg\nbool FORCEROOT = false;\nbool DOJUMP = true;\nbool DOINTERNALSKIP = true;\nbool DOPHASETRICK = true;\n\n// Statistics\nint skippedbases = 0;\nint skippedextensions = 0;\n\nchar substrbuffer[1024];\nconst char * substr(const char * str, int start, int len)\n{\n  if (len > 1024) { len = 1024; }\n  strncpy(substrbuffer, str+start, len);\n  substrbuffer[len] = '\0';\n\n  return substrbuffer;\n}\n\n\n// Helper to convert from ascii to single byte\nunsigned char b2i(char base)\n{\n  switch (base)\n  {\n    case 'A' : return 0;\n    case 'C' : return 1;\n    case 'G' : return 2;\n    case 'T' : return 3;\n    case '$' : return 4;\n\n    default: \n      cerr << "Unknown base: " << base << endl;\n      return b2i('A');\n  };\n}\n\n#include <sys/time.h>\n#include <string>\n\nclass EventTime_t\n{\npublic:\n  /// Constructor, starts the stopwatch\n  EventTime_t()\n  {\n    start();\n    memset(&m_end, 0, sizeof(struct timeval));\n  }\n\n\n  /// Explicitly restart the stopwatch\n  void start()\n  {\n    gettimeofday(&m_start, NULL);\n  }\n\n\n  /// Explicitly stop the stopwatch\n  void stop()\n  {\n    gettimeofday(&m_end, NULL);\n  }\n\n\n  /// Return the duration in seconds\n  double duration()\n  {\n    if ((m_end.tv_sec == 0) && (m_end.tv_usec == 0)) { stop(); }\n    return ((m_end.tv_sec - m_start.tv_sec)*1000000.0 + (m_end.tv_usec - m_start.tv_usec)) / 1e6;\n  }\n\n\n  /** \brief Pretty-print the duration in seconds.\n   ** If stop() has not already been called, uses the current time as the end\n   ** time.\n   ** \param format Controls if time should be enclosed in [ ] \n   ** \param precision Controls number of digits past decimal pt\n   **/\n  std::string str(bool format = true, \n                  int precision=2)\n  {\n    double r = duration();\n\n    char buffer[1024];\n    sprintf(buffer, "%0.*f", precision, r);\n\n    if (format)\n    {\n      string s("[");\n      s += buffer;\n      s += "s]";\n      return s;\n    }\n\n    return buffer;\n  }\n\n\nprivate:\n  /// Start time\n  struct timeval m_start;\n\n  /// End time\n  struct timeval m_end;\n};\n\n\n// A node in the suffix tree\nclass SuffixNode\n{\npublic:\n  static int s_nodecount;\n\n#ifdef MPOOL\n  void *operator new( size_t num_bytes, PoolMalloc_t *mem)\n  {\n    return mem->pmalloc(num_bytes);\n  }\n#endif\n\n  SuffixNode(int s, int e, int leafid,\n             SuffixNode * p, SuffixNode * x)\n    : m_start(s), m_end(e), \n      m_nodeid(++s_nodecount),\n      m_leafid(leafid),\n      m_numleaves(0),\n      m_parent(p), \n	  m_suffix(x),\n      m_printParent(NULL)\n  {\n    for (int i = 0; i < basecount; i++)\n    { m_children[i] = NULL; }\n	\n	m_depth = len();\n	if (p)\n	   m_depth += p->m_depth;\n  }\n\n  ~SuffixNode()\n  {\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i]) { delete m_children[i]; }\n    }\n  }\n\n  int id()\n  {\n    if (this) { return m_nodeid; }\n    return 0;\n  }\n\n  void setPrintParent(int min_match_len)\n  {\n    if (!m_parent)\n    {\n      // at root\n      m_printParent = this;\n    }\n    else if (m_parent->m_depth <= min_match_len)\n    {\n      m_printParent = this;\n    }\n    else\n    {\n      m_printParent = m_parent->m_printParent;\n    }\n\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i])\n      {\n        m_children[i]->setPrintParent(min_match_len);\n      }\n    }\n  }\n\n  bool isLeaf()\n  {\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i]) { return false; }\n    }\n\n    return true;\n  }\n\n  const char * str(const char * refstr)\n  {\n    return substr(refstr, m_start, m_end-m_start+1);\n  }\n\n  int len(int i=-1)\n  {\n    if (i != -1)\n    {\n      if (i < m_end)\n      {\n        return i - m_start + 1;\n      }\n    }\n\n    return m_end - m_start + 1;\n  }\n\n  int depth()\n  { \n	 return m_depth;\n  }\n\n  ostream & printLabel(ostream & os, const char * refstr)\n  {\n    if (m_start == m_end && m_start == 0)\n    {\n      os << "\"ROOT\"";\n    }\n    else\n    {\n      os << "\"" << str(refstr) << "\"";\n\n       //  << " [" << m_start \n       //  << ","  << m_end \n       //  << "(" << m_nodeid << ")\"";\n    }\n\n    return os;\n  }\n\n\n  ostream & printNodeLabel(ostream & os)\n  {\n    os << m_nodeid;\n    return os;\n  }\n\n  ostream & printEdgeLabel(ostream & os, const char * refstr)\n  {\n    string seq = substr(refstr, m_start, m_end-m_start+1);\n    os << "\"" << seq << "\"";\n    //os << "\"" << seq << " [" << m_start << "," << m_end << "]\"";\n    return os;\n  }\n\n  int setNumLeaves()\n  {\n    if (isLeaf())\n    {\n      m_numleaves = 1;\n      return 1;\n    }\n\n    int sum = 0;\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i])\n      {\n        sum += m_children[i]->setNumLeaves();\n      }\n    }\n\n    m_numleaves = sum;\n    return sum;\n  }\n\n\n  int  m_start;                         // start pos in string\n  int  m_end;                           // end pos in string\n  int  m_nodeid;                        // the id for this node\n  int  m_leafid;                        // For leafs, the start position of the suffix in the string\n  int  m_depth;                         // string depth to me\n  int  m_numleaves;                     // number of leaves below me\n  SuffixNode * m_children [basecount];  // children nodes\n  SuffixNode * m_parent;                // parent node\n  SuffixNode * m_suffix;                // suffixlink\n  SuffixNode * m_printParent;           // where to start printing\n\n#if VERIFY\n  string m_pathstring;                  // string of path to node\n#endif\n};\n\nint SuffixNode::s_nodecount(0);\n\nostream & operator<< (ostream & os, SuffixNode * n)\n{\n  return n->printNodeLabel(os);\n}\n\n\n// Encapsulate the tree with some helper functions\nclass SuffixTree\n{\npublic:\n  SuffixTree(const char * s) : m_string(s)\n  { \n    m_strlen = strlen(s);\n#ifdef MPOOL\n    m_root = new (&m_pool) SuffixNode(0,0,0,NULL,NULL); // whole tree\n#else\n    m_root = new SuffixNode(0,0,0,NULL,NULL); // whole tree\n#endif\n    m_root->m_suffix = m_root;\n  }\n\n  ~SuffixTree()\n  {\n#ifdef MPOOL\n#else\n	 delete m_root;\n#endif\n  }\n\n  SuffixNode * m_root;\n  const char * m_string;\n  int m_strlen;\n\n#ifdef MPOOL\n  PoolMalloc_t m_pool;\n#endif\n\n  // Print a node for dot\n  void printNodeDot(SuffixNode * node, ostream & dfile)\n  {\n    int children = 0;\n    for (int i = 0; i < basecount; i++)\n    {\n      SuffixNode * child = node->m_children[i];\n      if (child)\n      {\n        children++;\n\n        dfile << " " << node << "->" << child;\n\n        //node->printNodeLabel(dfile, m_string) << " -> ";\n        //child->printNodeLabel(dfile, m_string);\n\n        //dfile << " [minlen=" << child->len() << ", label=";\n        dfile << " [minlen=1, label=";\n        child->printEdgeLabel(dfile, m_string) << "]" << endl;\n\n        printNodeDot(child, dfile);\n      }\n    }\n\n    if (node->m_suffix)\n    {\n      dfile << " " << node << " -> " << node->m_suffix\n           << " [style=dotted, constraint=false]" << endl;\n\n      //node->printLabel(dfile, m_string) << " -> ";\n      //node->m_suffix->printLabel(dfile, m_string) << " [style=dotted, constraint=false]" << endl;\n    }\n\n    if (children == 0)\n    {\n      //dfile << " " << node << " [shape=box, label=";\n      //node->printLabel(dfile, m_string) << "]" << endl;\n\n      dfile << " " << node << " [shape=box,width=.2,height=.2,label=\"" << node->id() << ":" << node->m_leafid << "\"]" << endl;\n    }\n    else\n    {\n      //dfile << " " << node << " [label=";\n      //node->printLabel(dfile, m_string) << "]" << endl;\n      dfile << " " << node << " [width=.2,height=.2,label=\"" << node->id() << "\"]" << endl;\n    }\n  }\n\n  // Print the whole tree for dot\n  void printDot(const char * dotfilename)\n  {\n    ofstream dfile;\n    dfile.open(dotfilename, ofstream::out | ofstream::trunc);\n\n    cerr << "Printing dot tree to " << dotfilename << endl;\n\n    dfile << "digraph G {" << endl;\n    dfile << " size=\"7.5,10\"" << endl;\n    dfile << " center=true" << endl;\n    dfile << " label=\"Suffix tree of \'" << m_string << "\' len:" \n          << m_strlen-1 << " nc:"\n          << SuffixNode::s_nodecount << "\"" << endl;\n\n    printNodeDot(m_root, dfile);\n    dfile << "}" << endl;\n  }\n\n  // Print a node in text format\n  void printNodeText(ostream & out, SuffixNode * n, int depth)\n  {\n    for (int b = 0; b < basecount; b++)\n    {\n      if (n->m_children[b])\n      {\n        for (int i = 0; i < depth; i++)\n        {\n          out << " ";\n        }\n        out << " ";\n        out << n->m_children[b]->str(m_string) << endl;\n        printNodeText(out, n->m_children[b], depth+1);\n      }\n    }\n  }\n\n  // Print the tree in Text\n  void printText(ostream & out)\n  {\n    out << "Suffix Tree len=" << m_strlen-1 << endl; \n    out << "String: \"" << m_string << "\"" << endl;\n    out << "+" << endl;\n    printNodeText(out, m_root, 0);\n  }\n\n  // Print the tree as list of sorted suffixes\n  void printTreeSorted(ostream & out, SuffixNode * node, const string & pathstring)\n  {\n    bool isLeaf = true;\n\n    string ps(pathstring);\n    if (node != m_root) { ps.append(node->str(m_string)); }\n\n    for (int i = 0; i < basecount; i++)\n    {\n      if (node->m_children[i])\n      {\n        isLeaf = false;\n        printTreeSorted(out, node->m_children[i], ps);\n      }\n    }\n\n    if (isLeaf) { out << ps << endl; }\n  }\n\n  void printTreeFlat(ostream & out)\n  {\n    out << "nodeid\tparent\tSL\tstart\tend\t$\tA\tC\tG\tT\tnodestring" << endl;\n    out << "0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0" << endl;\n    printNodeFlat(out, m_root);\n  }\n\n  void printNodeFlat(ostream & out, SuffixNode * node)\n  {\n    out << node->id()           << "\t"\n        << node->m_parent->id() << "\t"\n        << node->m_suffix->id() << "\t"\n        << node->m_start        << "\t"\n        << node->m_end          << "\t";\n\n    for (int i = 0; i < basecount; i++)\n    {\n      out << node->m_children[i]->id() << "\t";\n    }\n\n	out << node->m_start << "\t" << node->m_end << "\t"; \n\n    if (node == m_root) { out << "ROOT" << endl; } \n    else                { out << node->str(m_string) << endl; }\n\n    for (int i = 0; i < basecount; i++)\n    {\n      if (node->m_children[i]) { printNodeFlat(out, node->m_children[i]); }\n    }\n  }\n\n#if VERIFY\n  void setNodePath(SuffixNode * node, const string & parentString)\n  {\n    node->m_pathstring = parentString;\n\n    if (node != m_root)\n    {\n      node->m_pathstring.append(m_string, node->m_start, node->m_end - node->m_start + 1);\n    }\n\n    for (int b = 0; b < basecount; b++)\n    {\n      if (node->m_children[b])\n      {\n        setNodePath(node->m_children[b], node->m_pathstring);\n      }\n    }\n  }\n\n  int verifyNodeSuffixLinks(SuffixNode * node, int & linkcount)\n  {\n    int errs = 0;\n    if (node != m_root && node->m_suffix)\n    {\n      const string & np = node->m_pathstring;\n      const string & sp = node->m_suffix->m_pathstring;\n      if (np.substr(1, np.length() -1) != sp)\n      {\n        cerr << "Suffix Link Mismatch!!" << endl;\n        node->printLabel(cerr, m_string) << ": " << np << endl;\n        node->m_suffix->printLabel(cerr, m_string) << ": " << sp << endl;\n        errs++;\n      }\n\n      linkcount++;\n    }\n\n    if (node == m_root && node->m_suffix != m_root)\n    {\n      cerr << "Error m_root suffix != m_root !!!" << endl;\n      errs++;\n    }\n\n    int childcount = 0;\n    for (int b = 0; b < basecount; b++)\n    {\n      if (node->m_children[b])\n      {\n        childcount++;\n        errs += verifyNodeSuffixLinks(node->m_children[b], linkcount);\n      }\n    }\n\n    if (childcount && !node->m_suffix)\n    {\n      errs++;\n      node->printLabel(cerr, m_string) << " has no suffix link!!!" << endl;\n    }\n\n    return errs;\n  }\n\n  void verifySuffixLinks()\n  {\n    cerr << endl;\n    cerr << "Verifing links" << endl;\n    setNodePath(m_root, "");\n    int linkcount = 0;\n    int err = verifyNodeSuffixLinks(m_root, linkcount);\n    cerr << err << " suffix link errors detected" << endl;\n    cerr << linkcount << " suffix links checked" << endl;\n\n    if (err) { exit(1); }\n  }\n#endif\n  \n\n  void buildUkkonen()\n  {\n    int len = m_strlen - 1; // length of the string, not of the buffer (remove s)\n    char base = m_string[1];\n\n    if (DEBUG)\n    {\n      cerr << "Building Ukkonen Tree for " << m_string << endl\n           << "Len: " << len << endl;\n    }\n\n    // Construct T1\n#ifdef MPOOL\n    SuffixNode * node = new (&m_pool) SuffixNode(1, len, 1, m_root, NULL); // leaf: 1\n#else\n    SuffixNode * node = new SuffixNode(1, len, 1, m_root, NULL); // leaf: 1\n#endif\n    m_root->m_children[b2i(base)] = node;\n    SuffixNode * firstleaf = node;\n    SuffixNode * lastleaf = node;\n\n    if (DEBUG)\n    { cerr << "Phase 1 Child: "; node->printLabel(cerr, m_string) << endl; }\n\n    int startj = 2;\n\n    // phase i+1\n    for (int i = 2; i <= len; i++)\n    {\n      // Start at the last leaf created which will allow easy\n      // access to the node for startj\n      node = lastleaf;\n      int nodewalk = 0;\n\n      // Keep track of last internal nodes created in split so we can add suffix links\n      SuffixNode * splitnode = NULL;\n\n      if (!DOPHASETRICK)\n      {\n        startj = 2;\n        node = firstleaf;\n      }\n\n      if (DEBUG) \n      { \n        char next = m_string[i];\n        cerr << endl;\n        cerr << i << ".0 " << "Phase " << i << " adding " << next << " starting with " << startj << endl; \n\n        string beta = substr(m_string, 1, i);\n        cerr << i << ".1" << " Extension 1: \"" << beta << "\" [implicit]" << endl;\n      }\n\n      for (int j = startj; j <= i; j++)\n      {\n        // Goal: Ensure S[j .. i] (beta) is in the suffix tree \n        // Precondition: S[j-1 .. i] (alpha) is in the suffix tree "near" node\n        //               All Internal nodes have a suffix link\n\n        // Idea: 1) Remember where alpha is in the tree relative to node\n        //       2) Walk up the tree w bases until we get to a node with a suffix link.\n        //       3) Follow suffix link which shifts the path from S[j-1..i] to S[j..i]\n        //       4) Walk down tree in new location ensuring S[i-w .. i] is in tree\n\n        // Notes: 1) All internal nodes have a suffix link by next extension\n        //        2) Any time we walk up to root, have to check S[j..i]\n        //        3) Suffix [1..i] is always present so start extension j with 2\n\n        int betapos = i; // The first position in string we need to check in tree\n\n        if (DEBUG)\n        {\n          cerr << endl;\n          string beta = substr(m_string, j, i-j+1);\n          cerr << i << "." << j << " Phase " << i << " Extension " << j << ": \"" << beta << "\" bp:" << betapos << endl;\n\n          cerr << i << "." << j << "  Walking up from n:"; \n          node->printLabel(cerr, m_string) << " nw: " << nodewalk << endl;\n        }\n\n        if (node == m_root)\n        {\n          // If we are at root, we have to check the full string s[j..i] anyways\n        }\n        else\n        {\n          if (nodewalk)\n          {\n            // partially walked down node->child, but didn't switch to child\n            // Match at i=6 on left... nodewalk=2, at 5 after suffix link\n            // 5 = i-2+1\n            //                 o ----- o\n            //               5 A       A 5  <-\n            //            -> 6 T       T 6 \n\n            betapos -= nodewalk-1;\n\n            if (DEBUG)\n            {\n              cerr << i << "." << j << "   Adjusted nw: " << nodewalk << endl;\n            }\n          }\n          else\n          {\n            // Exactly at a node or leaf. \n            // Walk up to parent, subtracting length of that edge\n            int len = node->len(i);\n            betapos -= len-1;\n            node = node->m_parent;\n\n            if (DEBUG)\n            {\n              cerr << i << "." << j << "   Adjusted len: " << len << endl;\n            }\n          }\n          \n          if (DEBUG)\n          {\n            cerr << i << "." << j << "   parent bp: " << betapos <<  " n:";\n            node->printLabel(cerr, m_string) << endl;\n          }\n\n          if (node->m_suffix == NULL)\n          {\n            // Subtract entire edge length\n            betapos -= node->len(i);\n            node = node->m_parent;\n\n            if (DEBUG)\n            {\n              cerr << i << "." << j << "   grandparent bp: " << betapos << " n:";\n              node->printLabel(cerr, m_string) << endl;\n            }\n\n            #if VERIFY\n            if (node->m_suffix == NULL)\n            {\n              cerr << "Missing suffix link!!! ";\n              exit(1);\n            }\n            #endif\n          }\n        }\n\n        // jump across suffix link\n        node = node->m_suffix;\n        if (node == m_root) { betapos = j; } // have to check full string\n\n        if (DEBUG)\n        {\n          cerr << i << "." << j << "  Starting to walk down from bp: " << betapos << " to " << i << " n:";\n          node->printLabel(cerr, m_string) << endl;\n        }\n\n        if (FORCEROOT && node != m_root)\n        {\n          node = m_root;\n          betapos = j;\n\n          if (DEBUG)\n          {\n            cerr << i << "." << j << " AtRoot bp: " << betapos << endl;\n          }\n        }\n\n        bool done = false;\n        startj = j+1; // assume this extension should be skipped in the next phase\n\n        while ((betapos <= i) && !done)\n        {\n          char base = m_string[betapos];\n          unsigned char b = b2i(base);\n          SuffixNode * child = node->m_children[b];\n\n          if (DEBUG)\n          {\n            cerr << i << "." << j << "  node betapos: " << betapos << "[" << base << "] n:";\n            node->printLabel(cerr, m_string) << " ";\n            if (child) { cerr << "c: "; child->printLabel(cerr, m_string); } \n            cerr << endl;\n          }\n\n          if (!child)\n          {\n            if (splitnode && betapos == splitnode->m_start)\n            {\n              if (DEBUG)\n              {\n                cerr << i << "." << j << "   Add SL1: ";\n                splitnode->m_parent->printLabel(cerr, m_string) << " sl-> ";\n                node->printLabel(cerr, m_string) << endl;\n              }\n\n              splitnode->m_parent->m_suffix = node;\n              splitnode = NULL;\n            }\n\n#ifdef MPOOL\n            SuffixNode * newnode = new (&m_pool) SuffixNode(betapos, len, j, node, NULL); // leaf: j\n#else\n            SuffixNode * newnode = new SuffixNode(betapos, len, j, node, NULL); // leaf: j\n#endif\n            node->m_children[b] = newnode; \n            lastleaf = newnode;\n\n            if (DEBUG)\n            {\n              cerr << i << "." << j << "   New Node: ";\n              newnode->printLabel(cerr, m_string) << endl;\n            }\n\n            node = newnode;\n\n            // This is the first base that differs, but the edgelength to \n            // i may be longer. Therefore set nodewalk to 0, so the entire\n            // edge is subtracted.\n            nodewalk = 0;\n            done = true;\n            break;\n          }\n          else\n          {\n            int nodepos = child->m_start;\n            nodewalk = 0;\n\n            char nodebase = m_string[nodepos];\n\n            #if VERIFY\n            if (nodebase != base)\n            {\n              char nb = m_string[nodepos];\n              cerr << "ERROR: first base on edge doesn't match edge label" << endl;\n              cerr << "       nb: " << nb << " base: " << base << endl;\n              exit(1);\n            }\n            #endif\n\n            // By construction, the string from j-1 to betapos to i-1\n            // must already by present in the suffix tree\n            // Therefore, we can skip checking every character, and zoom\n            // to exactly the right character, possibly skipping the entire edge\n\n            if (DOJUMP)\n            {\n              int mustmatch = i-1 - betapos + 1;\n              int childlen = child->len(i);\n\n              if (mustmatch >= childlen)\n              {\n                betapos += childlen;\n                nodepos += childlen;\n\n                skippedbases += childlen;\n\n                if (DEBUG)\n                {\n                  cerr << i << "." << j << "   Edge Jump by: " << childlen << " new bp: " << betapos << " np: " << nodepos << endl;\n                }\n\n                #if VERIFY\n                if (nodepos != child->m_end+1)\n                {\n                  cerr << "ERROR: jump should have skipped entire edge, but didn't!" << endl;\n                  exit(1);\n                }\n                #endif\n              }\n              else if (mustmatch)\n              {\n                betapos += mustmatch;\n                nodepos += mustmatch;\n                nodewalk += mustmatch;\n\n                skippedbases += mustmatch;\n\n                if (DEBUG)\n                {\n                  cerr << i << "." << j << "   Partial Jump by: " << mustmatch << " new bp: " << betapos << " np: " << nodepos << endl;\n                }\n\n                #if VERIFY\n                if (VERIFY)\n                {\n                  if (m_string[betapos-1] != m_string[nodepos-1])\n                  {\n                    cerr << "ERROR: jump should have matched at least the mustmatch-1 characters" << endl;\n                    cerr << "s[bp-1]: " << m_string[betapos-1] << " s[np-1]: " << m_string[nodepos-1] << endl;\n                    exit(1);\n                  }\n                }\n                #endif\n              }\n            }\n\n            while (nodepos <= child->m_end && betapos <= i)\n            {\n              nodebase = m_string[nodepos];\n\n              #if VERBOSE\n                cerr << i << "." << j << "   child bp: " << betapos << "[" << m_string[betapos] \n                     << "] nb [" << nodebase << "]" << endl;\n              #endif\n\n              if (m_string[betapos] == nodebase)\n              {\n                if (splitnode && betapos == splitnode->m_start)\n                {\n                  if (DEBUG)\n                  {\n                    cerr << i << "." << j << "   Add SL2: ";\n                    splitnode->m_parent->printLabel(cerr, m_string) << " sl-> ";\n                    node->printLabel(cerr, m_string) << endl;\n                  }\n\n                  splitnode->m_parent->m_suffix = node;\n                  splitnode = NULL;\n                }\n\n                nodepos++; betapos++; nodewalk++;\n\n                if (betapos == i+1)\n                {\n                  if (DEBUG)\n                  {\n                    cerr << i << "." << j << "    Internal edge match nw: " << nodewalk << endl;\n                  }\n\n                  if ((nodewalk == child->len(i)) && (child->m_end == len))\n                  {\n                    // we walked the whole edge to leaf, implicit rule I extension\n                    if (DEBUG)\n                    {\n                      cerr << i << "." << j << "    Leaf Node, Implicit Rule I Extension" << endl;\n                    }\n                  }\n                  else\n                  {\n                    // "Real" rule III implicit extension\n\n                    // The j-1 extension was the last explicit extension in this round\n                    // Start the next round at the last explicit extension\n                    if (DOPHASETRICK)\n                    {\n                      startj = j;\n\n                      int skip = startj - 2;\n\n                      if (DEBUG)\n                      {\n                        cerr << i << "." << j << "    Implicit Extension... start next phase at " << startj << ", saved " << skip << endl;\n                      }\n\n                      skippedextensions += skip;\n                    }\n\n                    if (DOINTERNALSKIP)\n                    {\n                      // Since we hit an internal match on a non-leaf, we know every other \n                      // extension in this phase will also hit an internal match. \n\n                      // Have to be careful since leafs get the full string immediately, but\n                      // they really have a Rule 1 extension\n\n                      int skip = i-j;\n\n                      if (DEBUG)\n                      { \n                        cerr << i << "." << j << "    Implicit Extension... skipping rest of phase, saved " << skip << endl;\n                      }\n\n                      skippedextensions += skip;\n                      j = i+1;\n                    }\n                  }\n\n                  done = true;\n                }\n              }\n              else\n              {\n                if (DEBUG) { cerr << i << "." << j << "   Spliting "; child->printLabel(cerr, m_string); }\n\n                // Split is a copy of the child with the end shifted\n                // Then adjust start of child\n#ifdef MPOOL\n                SuffixNode * split = new (&m_pool) SuffixNode(child->m_start, nodepos-1, 0, node, NULL); // internal\n#else\n                SuffixNode * split = new SuffixNode(child->m_start, nodepos-1, 0, node, NULL); // internal\n#endif\n\n                split->m_children[b2i(nodebase)] = child;\n                child->m_start = nodepos;\n                child->m_parent = split;\n\n                if (DEBUG)\n                {\n                  cerr << " => ";\n                  split->printLabel(cerr, m_string) << " + ";\n                  child->printLabel(cerr, m_string) << endl;\n                }\n\n                node->m_children[b] = split;\n                node = split;\n\n                if (splitnode && betapos == splitnode->m_start)\n                {\n                  if (DEBUG)\n                  {\n                    cerr << i << "." << j << "   Add SL3: ";\n                    splitnode->m_parent->printLabel(cerr, m_string) << " sl-> ";\n                    node->printLabel(cerr, m_string) << endl;\n                  }\n\n                  splitnode->m_parent->m_suffix = split;\n                  splitnode = NULL;\n                }\n\n                // Now create the new node\n#ifdef MPOOL\n                SuffixNode * newnode = new (&m_pool) SuffixNode(betapos, len, j, split, NULL); // leaf j\n#else\n                SuffixNode * newnode = new SuffixNode(betapos, len, j, split, NULL); // leaf j\n#endif\n                lastleaf = newnode;\n\n                split->m_children[b2i(m_string[betapos])] = newnode; \n                splitnode = newnode;\n\n                node = newnode;\n\n                if (DEBUG)\n                {\n                  cerr << i << "." << j << "   Split New Node: ";\n                  newnode->printLabel(cerr, m_string) << endl;\n                }\n\n                // This is the first base that differs, but the edgelength to \n                // i may be longer. Therefore set nodewalk to 0, so the entire\n                // edge is subtracted.\n                nodewalk = 0;\n                done = true;\n                break;\n              }\n            }\n          }\n\n          if (!done) { node = child; }\n        }\n      }\n\n      #if VERIFY\n      if (VERIFY) { verifySuffixLinks(); }\n      #endif\n    }\n  }\n};\n\n\nSuffixTree * gtree = NULL;\n\nvoid buildUkkonenSuffixTree(const char * str)\n{\n   gtree = new SuffixTree(str);\n   gtree->buildUkkonen();\n}\n\nstatic const int TEXBLOCKSIZE = 32;\n\n#define LOW3(x) (x & 0xFF)\n#define MID3(x) (x & 0xFF00) >> 8\n#define HI3(x)  (x & 0xFF0000) >> 16\n\n#define HALF_TEXTURE_DIMENSION 2048\n\ninline TextureAddress id2addr(int id)\n{\n  TextureAddress retval;\n\n#if MERGETEX && REORDER_TREE\n  // Half width is 2048 => 11 bits\n  // TEXBLOCKSIZE is 32 => 5 bits\n  int bigx = id & 0xFFFF; // 11 + 5 bits\n  int bigy = id >> 16;\n\n  retval.y = (bigy << 5) + (bigx & 0x1F);\n  retval.x = bigx >> 5;\n\n  // now stuff y's 13th bit into x's 12th bit\n  \n  retval.x |= (retval.y & 0x1000) >> 1;\n  retval.y &= 0xFFF;\n\n#elif REORDER_TREE\n  // MAX_TEXTURE_DIMENSION is 4096 => 12 bits\n  // TEXBLOCKSIZE is 32 => 5 bits\n  int bigx = id & 0x1FFFF; // 12 + 5 bits\n  int bigy = id >> 17;\n  retval.y = (bigy << 5) + (bigx & 0x1F);\n  retval.x = bigx >> 5;\n\n#elif MERGETEX\n  retval.x = id;\n\n#else\n  retval.x = id;\n\n#endif\n  return retval;\n}\n\ninline int addr2id(TextureAddress addr)\n{\n#if MERGETEX && REORDER_TREE\n  // shift x'a 12th bit as y's 13th\n  addr.y |= (addr.x & 0x800) << 1;\n  addr.x &= 0x7FF;\n\n  int blocky = addr.y & 0x1F;\n  int bigy = addr.y >> 5;\n  int bigx = (addr.x << 5) + blocky;\n  return bigx + (bigy << 16);\n\n#elif REORDER_TREE\n  int blocky = addr.y & 0x1F;\n  int bigy = addr.y >> 5;\n  int bigx = (addr.x << 5) + blocky;\n  return bigx + (bigy << 17);\n\n#elif MERGETEX\n    return addr.x;\n\n#else\n    return addr.x;\n\n#endif\n}\n\nvoid writeAddress(unsigned char arr[3], TextureAddress addr)\n{\n#if REORDER_TREE\n  arr[0] = addr.x & 0xFF;\n  arr[1] = addr.y & 0xFF;\n  arr[2] = (((addr.x) >> 8) & 0xF) | (((addr.y) >> 4) & 0xF0);\n#else\n  arr[0] = LOW3(addr.x);\n  arr[1] = MID3(addr.x);\n  arr[2] = HI3(addr.x);\n#endif\n}\n\nTextureAddress arrayToAddress(unsigned char arr[3])\n{\n  TextureAddress retval;\n\n#if REORDER_TREE\n  retval.x = arr[0] | ((arr[2] & 0xF) << 8);\n  retval.y = arr[1] | ((arr[2] & 0xF0) << 4);\n#else\n  retval.x = MK3(arr);\n#endif\n\n  return retval;\n}\n\n\n\nvoid buildNodeTexture(SuffixNode * node,\n                      PixelOfNode * nodeTexture,\n                      PixelOfChildren * childrenTexture,\n                      AuxiliaryNodeData aux_data[],\n                      const char * refstr)\n{	\n  int origid = node->id();\n    \n  aux_data[origid].length = node->len();\n  aux_data[origid].numleaves = node->m_numleaves;\n  aux_data[origid].printParent = id2addr(node->m_printParent->id());\n\n  TextureAddress myaddress(id2addr(origid));\n\n  PixelOfNode * nd;\n  PixelOfChildren * cd;\n\n#if MERGETEX && REORDER_TREE\n  int tex = myaddress.x & 0x800;\n  myaddress.x &= 0x7FF;\n  myaddress.x *= 2;\n\n  int loc = myaddress.x + myaddress.y*MAX_TEXTURE_DIMENSION;\n\n  if (tex)\n  {\n    nd = (PixelOfNode*)    &childrenTexture[loc];\n    cd = (PixelOfChildren*)&childrenTexture[loc+1];\n  }\n  else\n  {\n    nd = (PixelOfNode*)    &nodeTexture[loc];\n    cd = (PixelOfChildren*)&nodeTexture[loc+1];\n  }\n\n#elif REORDER_TREE\n  int loc = myaddress.x + myaddress.y*MAX_TEXTURE_DIMENSION;\n\n  nd = &(nodeTexture[loc]);\n  cd = &(childrenTexture[loc]);\n\n#elif MERGETEX\n  int loc = myaddress.x * 2;\n\n  if (loc >= (MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION))\n  {\n    loc -= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION;\n    nd = (PixelOfNode*)    &(childrenTexture[loc]);\n    cd = (PixelOfChildren*)&(childrenTexture[loc+1]);\n  }\n  else\n  {\n    nd = (PixelOfNode*)    &(nodeTexture[loc]);\n    cd = (PixelOfChildren*)&(nodeTexture[loc+1]);\n  }\n\n#else\n  int loc = myaddress.x;\n  nd = &(nodeTexture[loc]);\n  cd = &(childrenTexture[loc]);\n#endif\n\n  unsigned char arr[3];\n  writeAddress(arr, myaddress);\n  TextureAddress newaddr = arrayToAddress(arr);\n\n  TextureAddress parent(id2addr(node->m_parent->id()));\n  writeAddress(nd->parent, parent);\n  assert(arrayToAddress(nd->parent).data == parent.data);\n\n  TextureAddress suffix(id2addr(node->m_suffix->id()));\n  writeAddress(nd->suffix, suffix);\n  assert(arrayToAddress(nd->suffix).data == suffix.data);\n\n  nd->start[0]  = LOW3(node->m_start);\n  nd->start[1]  = MID3(node->m_start);\n  nd->start[2]  = HI3(node->m_start);\n\n  assert(MK3(nd->start) == node->m_start);\n\n  nd->end[0]    = LOW3(node->m_end);\n  nd->end[1]    = MID3(node->m_end);\n  nd->end[2]    = HI3(node->m_end);\n\n  assert(MK3(nd->end) == node->m_end);\n\n  int depth = node->depth();\n  nd->depth[0]  = LOW3(depth);\n  nd->depth[1]  = MID3(depth);\n  nd->depth[2]  = HI3(depth);\n    \n  assert(MK3(nd->depth) == depth);\n    \n  cd->leafchar = 0;\n\n  if (node->m_leafid != 0)\n  {\n    cd->leafchar  = refstr[node->m_leafid-1];\n\n    cd->leafid[0] = LOW3(node->m_leafid);\n    cd->leafid[1] = MID3(node->m_leafid);\n    cd->leafid[2] = HI3(node->m_leafid);\n  }\n  else\n  {\n    if (node->m_children[0]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[0]->id());\n      writeAddress(cd->a, childaddr);\n      assert(arrayToAddress(cd->a).data == childaddr.data);\n      buildNodeTexture(node->m_children[0], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n            \n    if (node->m_children[1]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[1]->id());\n      writeAddress(cd->c, childaddr);\n      assert(arrayToAddress(cd->c).data == childaddr.data);\n      buildNodeTexture(node->m_children[1], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n\n    if (node->m_children[2]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[2]->id());\n      writeAddress(cd->g, childaddr);\n      assert(arrayToAddress(cd->g).data == childaddr.data);\n      buildNodeTexture(node->m_children[2], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n\n    if (node->m_children[3]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[3]->id());\n      writeAddress(cd->t, childaddr);\n      assert(arrayToAddress(cd->t).data == childaddr.data);\n      buildNodeTexture(node->m_children[3], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n\n    if (node->m_children[4]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[4]->id());\n      writeAddress(cd->d, childaddr);\n      assert(arrayToAddress(cd->d).data == childaddr.data);\n      buildNodeTexture(node->m_children[4], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n  }\n}\n\nvoid buildSuffixTreeTexture(PixelOfNode** nodeTexture,\n                            PixelOfChildren **childrenTexture,\n                            unsigned int* width, \n                            unsigned int* node_height,\n                            unsigned int* children_height,\n                            AuxiliaryNodeData **aux_data,\n                            const char * refstr,\n                            int min_match_len) \n{\n    // Leave space for NULL node\n    int allnodes = SuffixNode::s_nodecount + 1;\n\n    assert(allnodes < MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION);\n    \n    assert(sizeof(PixelOfNode) == 16);\n    assert(sizeof(PixelOfChildren) == 16);\n    \n\n#if MERGETEX && REORDER_TREE\n    *width = MAX_TEXTURE_DIMENSION;\n    \n	int numrows = ((int)ceil((allnodes+0.0) / ((MAX_TEXTURE_DIMENSION/2) * TEXBLOCKSIZE))) * TEXBLOCKSIZE;\n    if (numrows <= MAX_TEXTURE_DIMENSION)\n    {\n      *node_height = numrows;\n      *children_height = 0;\n    }\n    else\n    {\n      *node_height = MAX_TEXTURE_DIMENSION;\n      *children_height = (numrows - MAX_TEXTURE_DIMENSION);\n    }\n\n#elif REORDER_TREE\n    *width = MAX_TEXTURE_DIMENSION;\n	int numrows = ((int)ceil((allnodes+0.0) / ((MAX_TEXTURE_DIMENSION) * TEXBLOCKSIZE))) * TEXBLOCKSIZE;\n    *node_height = numrows;\n    *children_height = numrows;\n\n#elif MERGETEX\n    *width = 1;\n    int numcells = allnodes*2;\n\n    if (numcells <= (MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION))\n    {\n      *node_height = numcells;\n      *children_height = 0;\n    }\n    else\n    {\n      *node_height = MAX_TEXTURE_DIMENSION * MAX_TEXTURE_DIMENSION;\n      *children_height = numcells - *node_height;\n    }\n\n#else\n    *width = 1;\n    *node_height = allnodes;\n    *children_height = allnodes;\n#endif\n\n    int alloc = 0;\n\n    // allocate space for the node and children textures\n    *nodeTexture     = (PixelOfNode*) calloc((*width) * (*node_height), sizeof(PixelOfNode));\n    alloc += (*width) * (*node_height) * sizeof(PixelOfNode);\n\n    *childrenTexture = NULL;\n\n    if (*children_height)\n    {\n      *childrenTexture = (PixelOfChildren*) calloc((*width) * (*children_height), sizeof(PixelOfChildren));\n      alloc += (*width) * (*children_height) * sizeof(PixelOfChildren);\n    }\n    \n    fprintf(stderr, " node: %dx%d",     *width, *node_height);\n    fprintf(stderr, " children: %dx%d ", *width, *children_height);\n\n    *aux_data = (AuxiliaryNodeData*)calloc(allnodes, sizeof(AuxiliaryNodeData));\n\n    if (!*nodeTexture || (*children_height && !*childrenTexture) || !*aux_data) \n    {\n        fprintf(stderr, "arg.  texture allocation failed.\n");\n        exit(-1);\n    }\n    \n    gtree->m_root->setNumLeaves();\n    gtree->m_root->setPrintParent(min_match_len);\n    \n    buildNodeTexture(gtree->m_root,\n                     *nodeTexture,\n                     *childrenTexture,\n                     *aux_data,\n                     refstr);\n};\n\n\nvoid printTreeTexture(const char * texfilename,\n                      PixelOfNode * nodeTexture,\n                      PixelOfChildren * childrenTexture,\n                      int nodecount)\n{\n  cerr << "Printing tree texture to " << texfilename << endl;\n\n  ofstream texfile;\n  texfile.open(texfilename, ofstream::out | ofstream::trunc);\n\n  texfile << "id\tx\ty\tstart\tend\tdepth\ta.x\ta.y\tc.x\tc.y\tg.x\tg.y\tt.x\tt.y\t$.x\t$.y\tp.x\tp.y" << endl;\n  for (int i = 0; i < nodecount; i++)\n  {\n    TextureAddress myaddress(id2addr(i)); \n\n    texfile << i << "\t"\n            << myaddress.x << "\t"\n#if REORDER_TREE\n            << myaddress.y << "\t"\n#endif\n            << MK3(nodeTexture[i].start) << "\t"\n            << MK3(nodeTexture[i].end)   << "\t"\n            << MK3(nodeTexture[i].depth) << "\t";\n\n    TextureAddress a = arrayToAddress(childrenTexture[i].a);\n    texfile << a.x << "\t";\n#if REORDER_TREE\n    texfile << a.y << "\t";\n#endif\n\n    TextureAddress c = arrayToAddress(childrenTexture[i].c);\n    texfile << c.x << "\t";\n#if REORDER_TREE\n    texfile << c.y << "\t";\n#endif\n\n    TextureAddress g = arrayToAddress(childrenTexture[i].g);\n    texfile << g.x << "\t";\n#if REORDER_TREE\n    texfile << g.y << "\t";\n#endif\n\n    TextureAddress t = arrayToAddress(childrenTexture[i].t);\n    texfile << t.x << "\t";\n#if REORDER_TREE\n    texfile << t.y << "\t";\n#endif\n\n    TextureAddress d = arrayToAddress(childrenTexture[i].d);\n    texfile << d.x << "\t";\n#if REORDER_TREE\n    texfile << d.y << "\t";\n#endif\n\n    TextureAddress p = arrayToAddress(nodeTexture[i].parent);\n    texfile << p.x << "\t";\n#if REORDER_TREE\n    texfile << p.y;\n#endif\n\n    texfile << endl;\n  }\n\n  texfile.close();\n}\n\nvoid renumberTree()\n{\n  queue<pair<SuffixNode *, int> > nodequeue;\n\n  nodequeue.push(make_pair(gtree->m_root,0));\n  int nodecount = 0;\n\n  while(!nodequeue.empty())\n  {\n    pair<SuffixNode *,int> npair = nodequeue.front(); nodequeue.pop();\n\n    SuffixNode * node = npair.first;\n    int depth = npair.second;\n    \n    node->m_nodeid = ++nodecount;\n\n    if (depth < 16)\n    {\n      for (int i = 0; i < basecount; i++)\n      {\n        SuffixNode * child = node->m_children[i];\n        if (child) { nodequeue.push(make_pair(child,depth+1)); }\n      }\n    }\n    else\n    {\n      for (int i = 0; i < basecount; i++)\n      {\n        SuffixNode * child = node->m_children[i];\n        if (child)\n        {\n          child->m_nodeid = ++nodecount;\n          \n          for(int j = 0; j < basecount; j++)\n          {\n            SuffixNode * gchild = child->m_children[j];\n\n            if (gchild)\n            {\n              gchild->m_nodeid = ++nodecount;\n              for (int k = 0; k < basecount; k++)\n              {\n                SuffixNode * ggchild = gchild->m_children[k];\n\n                if (ggchild)\n                { \n                  ggchild->m_nodeid = ++nodecount;\n\n                  for (int l = 0; l < basecount; l++)\n                  {\n                    SuffixNode * gggchild = ggchild->m_children[l];\n\n                    if (gggchild)\n                    {\n                      gggchild->m_nodeid = ++nodecount;\n\n                      for (int m = 0; m < basecount; m++)\n                      {\n                        SuffixNode * ggggchild = gggchild->m_children[m];\n                        if (ggggchild){ nodequeue.push(make_pair(ggggchild, depth+5)); }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nextern "C"\nvoid createTreeTexture(const char * refstr,\n                       PixelOfNode** nodeTexture,\n                       PixelOfChildren** childrenTexture,\n                       unsigned int* width,\n                       unsigned int* node_height,\n                       unsigned int* children_height,\n                       AuxiliaryNodeData** aux_data,\n                       int* num_nodes,\n                       int min_match_len,\n                       Statistics* statistics,\n                       const char * dotfilename,\n                       const char * texfilename)\n\n{\n    cerr << "  Creating Suffix Tree... ";\n    EventTime_t btimer;\n    char* ctimer = createTimer();\n    startTimer(ctimer);\n\n    SuffixNode::s_nodecount = 0;\n    buildUkkonenSuffixTree(refstr);\n\n	stopTimer(ctimer);\n	if (statistics)\n		statistics->t_tree_construction += getTimerValue(ctimer);\n	deleteTimer(ctimer);\n	\n    cerr << SuffixNode::s_nodecount << " nodes "\n    << btimer.str(true, 5) << endl;\n\n#if RENUMBER_TREE    \n    cerr << "  Renumbering tree... ";\n    EventTime_t rtimer;\n    char* reordertimer = createTimer();\n    startTimer(reordertimer);\n    renumberTree();\n    stopTimer(reordertimer);\n    if (statistics)\n        statistics->t_tree_reorder += getTimerValue(reordertimer);\n    deleteTimer(reordertimer);\n    cerr << rtimer.str(true, 5) << endl;\n#endif\n    \n    EventTime_t ftimer;\n    cerr << "  Flattening Tree... ";\n    char* flattentimer = createTimer();\n    startTimer(flattentimer);\n    buildSuffixTreeTexture(nodeTexture,\n                           childrenTexture,\n                           width, node_height, children_height,\n                           aux_data,\n                           gtree->m_string,\n                           min_match_len);\n    stopTimer(flattentimer);\n    if (statistics)\n        statistics->t_tree_flatten += getTimerValue(flattentimer);\n    deleteTimer(flattentimer);  \n\n    *num_nodes = SuffixNode::s_nodecount + 1;\n    cerr << ftimer.str(true, 5) << endl;\n    \n    if (dotfilename)\n    {\n        gtree->printDot(dotfilename);\n    }\n    \n    if (texfilename)\n    {\n        printTreeTexture(texfilename,\n                         *nodeTexture,\n                         *childrenTexture,\n                         SuffixNode::s_nodecount + 1);\n    }\n    \n    delete gtree;\n    gtree = NULL;\n}\n\n\n\nextern "C"\nvoid getReferenceString(const char * filename, char** refstr, size_t* reflen)\n{\n  EventTime_t timer;\n  cerr << "Loading ref: " << filename << "... ";\n\n  string S="s";\n\n  ifstream file;\n  file.open(filename);\n\n  if (!file)\n  {\n    cerr << "Can't open " << filename << endl;\n    exit (1);\n  }\n\n  // Skip over the reference header line\n  char refline[2048];\n  file.getline(refline, sizeof(refline));\n\n  if (refline[0] != '>')\n  {\n    cerr << endl\n         << "ERROR: Reference file is not in FASTA format"\n         << endl;\n  }\n\n  // Now read the reference string\n  string buffer;\n  while (file >> buffer)\n  {\n    if (buffer[0] == '>')\n    {\n      cerr << endl\n           << "ERROR: Only a single reference sequence is supported!" \n           << endl;\n\n      exit (1);\n    }\n    else\n    {\n      for (unsigned int i = 0; i < buffer.length(); i++)\n      {\n        char b = toupper(buffer[i]);\n		if (b == ' ')\n			continue;\n        if (b == 'A' || b == 'C' || b == 'G' || b=='T')\n        {\n          S += b;\n        }\n		else\n		{\n		   S += 'A';\n		}\n      }\n    }\n  }\n\n  S += "$";\n *refstr = strdup(S.c_str());\n  *reflen = strlen(*refstr) + 1;\n\n  cerr << *reflen-3 << " bp. " << timer.str(true, 5) << endl;\n}\n\ninline void addChar(char **buf, int * size, int * pos, char c)\n{\n  if (*pos == *size)\n  {\n    (*size) *= 2; // double the size of the buffer\n    *buf = (char *) realloc(*buf, *size);\n    if (!*buf)\n    {\n      cerr << "ERROR: Realloc failed, requested: " << *size << endl;\n      exit(1);\n    }\n  }\n\n  (*buf)[*pos] = c;\n  (*pos)++;\n}\n\ninline size_t bytesNeededOnGPU(unsigned int querylen, int min_match_len)\n{\n   if (min_match_len == -1)\n	  return sizeof(MatchCoord) + (querylen + 10);\n   else\n	  return sizeof(MatchCoord) * (querylen - min_match_len + 1) + \n		(querylen + 10);\n} \n\n#define WARP_SIZE 16\n\n//Gets up to set_size queries.\nextern "C"\n    void getQueriesTexture(int qfile,\n                           char** queryTexture,\n                           size_t* queryTextureSize,\n                           int** queryAddrs,\n                           char*** queryNames,\n                           int** queryLengths,\n                           unsigned int* numQueries,\n                           unsigned int* num_match_coords,\n                           unsigned int memory_avail,\n                           int min_match_length,\n                           bool rc)\n{\n    EventTime_t timer;\n    \n    int qstringpos = 0;\n    int qstringsize = 1024 * 1024;\n    char * qstring = (char *) malloc(qstringsize);\n    \n    bool resetAmbiguity  = true;\n    \n    // offset of query i in qstring\n    int offsetspos = 0;\n    int offsetssize = 1024;\n    int * offsets = (int *) malloc(offsetssize * sizeof(int));\n    int * lengths = (int *) malloc(offsetssize * sizeof(int));\n    \n    int qrylen = 0;\n    int this_qrylen = 0;\n    \n    int bytes_read;\n    unsigned char buf[32*1024];\n    \n    vector<char*> names;\n    string header;\n    bool inheader = false;\n    int total_read = 0;\n    \n    unsigned char dnachar [256];\n    \n    bool set_full = false;\n    \n#if COALESCED_QUERIES\n    unsigned int curr_warp_padding = 0;\n    unsigned int warp_max_qry_len = 2;\n#endif\n    \n    // tracks the GPU memory needed by the queries read so far.\n    unsigned int  curr_mem_usage = 0;\n    \n    for (int i = 0; i < 256; i++)\n    {\n        dnachar[i] = 0;\n    }\n    \n    dnachar[(unsigned char) 'A'] = 1;\n    dnachar[(unsigned char) 'C'] = 1;\n    dnachar[(unsigned char) 'G'] = 1;\n    dnachar[(unsigned char) 'T'] = 1;\n    \n    while ((bytes_read = read(qfile, buf, sizeof(buf))) != 0)\n    {\n        // cerr << "bytes_read: " << bytes_read << endl;\n        \n        if (bytes_read == -1)\n        {\n            cerr << "ERROR: Error reading file: " << errno << endl;\n            exit(1);\n        }\n        \n        int i = 0;\n        \n        if (inheader)\n        {\n            // Handle case where last read was inside a header\n            for (; i < bytes_read; i++)\n            {\n                if (buf[i] == '\n')\n                {\n                    inheader = false;\n                    i++;\n                    char* name = strdup(header.c_str());\n                    names.push_back(name);\n                    header.clear();\n                    break;\n                }\n                else\n                {\n                    header.insert(header.end(), buf[i]);\n                }\n            }\n        }\n        \n        for (; i < bytes_read; i++)\n        {\n            unsigned char b = toupper(buf[i]);\n            \n            if (b == '>')\n            {\n            \n                if (curr_mem_usage + bytesNeededOnGPU(MAX_QUERY_LEN, min_match_length) >= memory_avail)\n                {\n                    set_full = true;\n                    off_t seek = lseek(qfile, -(bytes_read - i), SEEK_CUR);\n                    if (seek == (off_t) - 1)\n                    {\n                        cerr << "lseek failed: " << errno << endl;\n                        exit(-1);\n                    }\n                    break;\n                }\n                \n                \n                // in a header line\n                if (offsetspos != 0)\n                {\n                    if (this_qrylen < min_match_length)\n                    {\n                        //printf("> %s\n", names.back());\n                        //if (rc)\n                        //    printf("> %s Reverse\n", names.back());\n                        names.pop_back();\n                        --offsetspos;\n                        qstringpos -= this_qrylen  + 1;\n                    }\n                    else\n                    {\n                        addChar(&qstring, &qstringsize, &qstringpos, '\0');\n                        lengths[offsetspos - 1] = this_qrylen;\n#if COALESCED_QUERIES\n                        if (warp_max_qry_len < this_qrylen + 2)\n                        {\n                            int num_warp_queries = (offsetspos - 1) % WARP_SIZE;\n                            \n                            curr_warp_padding -= num_warp_queries * warp_max_qry_len;\n                            curr_mem_usage -= num_warp_queries * warp_max_qry_len;\n                            \n                            warp_max_qry_len = this_qrylen  + 2;\n                            if (warp_max_qry_len % 4)\n                                warp_max_qry_len += 4 - (warp_max_qry_len % 4);\n                                \n                            curr_warp_padding += num_warp_queries * warp_max_qry_len;\n                            curr_mem_usage += num_warp_queries * warp_max_qry_len;\n                        }\n                        //TODO: We shouldn't simply pass in warp_max_qry_len,\n                        // we really ought to pass the real length in, and then add the padding\n                        // For now, we are overestimating.\n                        curr_mem_usage += bytesNeededOnGPU(warp_max_qry_len, min_match_length);\n                        curr_warp_padding += warp_max_qry_len;\n#else\n                        curr_mem_usage += bytesNeededOnGPU(this_qrylen, min_match_length);\n#endif\n                    }\n                }\n                \n                if (offsetspos == offsetssize)\n                {\n                    offsetssize *= 2;\n                    offsets = (int *) realloc(offsets, sizeof(int) * offsetssize);\n                    lengths = (int *) realloc(lengths, sizeof(int) * offsetssize);\n                    if (!offsets || !lengths)\n                    {\n                        cerr << endl\n                        << "ERROR: Realloc failed: requested "\n                        << sizeof(int) * offsetssize << endl;\n                        exit(1);\n                    }\n                }\n                \n                offsets[offsetspos++] = qstringpos;\n#if COALESCED_QUERIES\n                if ((offsetspos % WARP_SIZE) == 0)\n                {\n                    warp_max_qry_len = 2;\n                }\n#endif\n                inheader = true;\n                \n                // Try to walk out of header\n                for (i++; i < bytes_read; i++)\n                {\n                    if (buf[i] == '\n')\n                    {\n                        inheader = false;\n                        char* name = strdup(header.c_str());\n                        names.push_back(name);\n                        header.clear();\n                        break;\n                    }\n                    else\n                    {\n                        header.insert(header.end(), buf[i]);\n                    }\n                }\n                \n                addChar(&qstring, &qstringsize, &qstringpos, 'q');\n                this_qrylen = 0;\n            }\n            else if (dnachar[b])\n            {\n                addChar(&qstring, &qstringsize, &qstringpos, b);\n                qrylen++;\n                this_qrylen++;\n            }\n            else if (isspace(b))\n            {\n            \n            }\n            else if (resetAmbiguity)\n            {\n                addChar(&qstring, &qstringsize, &qstringpos, 'x');\n                this_qrylen++;\n            }\n            else\n            {\n                cerr << endl\n                << "ERROR: Unexpected character: " << buf[i]\n                << " in query file at byte: " << total_read + i << endl;\n                exit(1);\n            }\n        }\n        \n        if (set_full)\n            break;\n            \n        total_read += bytes_read;\n    }\n    \n    if (qstringpos)\n    {\n        if (this_qrylen < min_match_length)\n        {\n            //printf("> %s\n", names.back());\n            //if (rc)\n            //    printf("> %s Reverse\n", names.back());\n            names.pop_back();\n            --offsetspos;\n            qstringpos -= this_qrylen + 1;\n        }\n        else\n        {\n            addChar(&qstring, &qstringsize, &qstringpos, '\0');\n            lengths[offsetspos - 1] = this_qrylen;\n#if COALESCED_QUERIES\n            int num_warp_queries = (offsetspos - 1) % WARP_SIZE;\n            if (warp_max_qry_len < this_qrylen + 2)\n            {\n            \n            \n                curr_warp_padding -= num_warp_queries * warp_max_qry_len;\n                curr_mem_usage -= num_warp_queries * warp_max_qry_len;\n                \n                warp_max_qry_len = this_qrylen  + 2;\n                if (warp_max_qry_len % 4)\n                    warp_max_qry_len += 4 - (warp_max_qry_len % 4);\n                    \n                curr_warp_padding += num_warp_queries * warp_max_qry_len;\n                curr_mem_usage += num_warp_queries * warp_max_qry_len;\n            }\n            curr_mem_usage += bytesNeededOnGPU(warp_max_qry_len, min_match_length);\n            curr_warp_padding += warp_max_qry_len;\n            \n            if ((++num_warp_queries) % WARP_SIZE)\n            {\n                curr_warp_padding += warp_max_qry_len * (WARP_SIZE - (num_warp_queries % WARP_SIZE));\n            }\n#else\n            curr_mem_usage += bytesNeededOnGPU(this_qrylen, min_match_length);\n#endif\n            \n        }\n    }\n    \n    *numQueries = offsetspos;\n    \n    if (offsetspos == 0)\n    {\n        free(offsets);\n        free(lengths);\n        free(qstring);\n        *queryAddrs = NULL;\n        *queryTexture = NULL;\n        *queryTextureSize = 0;\n        *queryNames = NULL;\n        \n        return;\n    }\n    \n    \n    *queryAddrs = offsets;\n    \n    *queryTexture = qstring;\n    *queryTextureSize = qstringpos;\n    *queryNames = (char**)malloc(names.size() * sizeof(char*));\n    *queryLengths = lengths;\n    \n    for (unsigned int i = 0; i < *numQueries; ++i)\n    {\n        *(*queryNames + i) = names[i];\n    }\n    \n    \n#if COALESCED_QUERIES\n    EventTime_t reorder_timer;\n    unsigned int total_reordered_qry_size = 0;\n    vector<pair<int*, int> > reordered_query_chunks;\n    \n    \n    for (unsigned int i = 0; i < *numQueries; i += WARP_SIZE)\n    {\n        int max_qry_len = 0;\n        for (unsigned int j = 0; j < WARP_SIZE && (i + j) < *numQueries; ++j)\n        {\n            if ( max_qry_len < lengths[i + j] )\n                max_qry_len = lengths[i + j];\n        }\n        if (max_qry_len == 0)\n        {\n            int a = 0;\n        }\n        max_qry_len += 2;\n        unsigned int block_size = WARP_SIZE * (max_qry_len + ((max_qry_len % 4) ? 4 - (max_qry_len % 4) : 0));\n        int* reordered_query_chars = (int*)calloc(block_size / sizeof(int), sizeof(int));\n        //fprintf (stderr, "reordering block for warp %d\n", i / WARP_SIZE);\n        \n        for (int curr_char = 0; curr_char < max_qry_len; ++curr_char)\n        {\n            for (unsigned int curr_qry = 0; curr_qry < WARP_SIZE && (i + curr_qry) < *numQueries; ++curr_qry)\n            {\n                int qlen = lengths[i + curr_qry] + 2;\n                if (curr_qry == 16 && curr_char == 0)\n                {\n                    int a = 0;\n                }\n                if (curr_char < qlen)\n                {\n                    int* qry_word = reordered_query_chars + ((curr_char / 4) * WARP_SIZE + curr_qry);\n                    int c = *(qstring + offsets[i + curr_qry] + curr_char);\n                    //*((char*) ((void*)qry_word + (curr_char & 0x0000000f) = c;\n                    //*qry_word |= c << ((curr_char & 0x0000000f) << (3 - (curr_char & 0x0000000f)));\n                    *qry_word |= (c << (8 * ( (curr_char % 4))));\n                    //fprintf(stderr, "writing (%d, %d, %d)\n",i, curr_qry, curr_char);\n                }\n            }\n        }\n        total_reordered_qry_size += block_size;\n        \n        reordered_query_chunks.push_back(make_pair<int*, int>(reordered_query_chars, block_size));\n    }\n    \n    free(*queryTexture);\n    *queryTexture = (char*)malloc( total_reordered_qry_size );\n    *queryTextureSize = total_reordered_qry_size;\n    unsigned int p = 0;\n    *num_match_coords = 0;\n    for (unsigned int i = 0; i < reordered_query_chunks.size(); ++i)\n    {\n        for (unsigned int j = 0; j < WARP_SIZE && (i*WARP_SIZE + j) < *numQueries; ++j)\n        {\n            int qryid = i * WARP_SIZE + j;\n            offsets[qryid] = (p / 4) + j;\n        }\n        //*num_match_coords += reordered_query_chunks[i].second - WARP_SIZE * (min_match_length + 1);\n        memcpy(*queryTexture + p, reordered_query_chunks[i].first, reordered_query_chunks[i].second);\n        p += reordered_query_chunks[i].second;\n        \n    }\n    cerr <<  "Reordering complete. " << reorder_timer.str(true, 5) << endl;\n    fprintf(stderr, " curr_warp_padding = %d, total_reordered = %d\n", curr_warp_padding, total_reordered_qry_size);\n    //assert (curr_warp_padding == total_reordered_qry_size);\n    curr_mem_usage = total_reordered_qry_size;\n#else\n    \n    *num_match_coords = *queryTextureSize - *numQueries * (min_match_length + 1);\n#endif\n	assert (curr_mem_usage < memory_avail);\n    cerr << offsetspos << " queries ("\n    << qrylen << " bp), need "\n    << curr_mem_usage << " bytes on the GPU ("\n    << memory_avail << " avail) "\n    << timer.str(true, 5) << endl;\n}\n\n\n\nstruct pathblock\n{\n    TextureAddress node_addr;\n    int string_depth;\n};\n\n\n#define __USE_BUFFERED_IO__ \n\nstatic const size_t output_buf_limit = 32*1024;\nchar output_buf[output_buf_limit];\n\n//FIXME: needs to be reinitialized to zero at the beginning of each round of printing.\nsize_t bytes_written = 0;\n\nint addToBuffer(char* string)\n{\n	 size_t buf_length = strlen(string);\n	 \n	 if (buf_length + bytes_written>= output_buf_limit)\n	 {\n		size_t chunk = (output_buf_limit - bytes_written - 1);\n		strncpy(output_buf + bytes_written, string, chunk);\n		output_buf[bytes_written + chunk] = 0;\n		printf("%s", output_buf);\n		//memset(output_buf, 0, sizeof(output_buf));\n		strncpy(output_buf, string + chunk, buf_length - chunk);\n		bytes_written = buf_length - chunk;\n	 }\n	 else\n	 {\n		strncpy(output_buf + bytes_written, string, buf_length);\n		bytes_written += buf_length;\n	 }\n   return 0;\n}\n\nvoid flushOutput()\n{\n   if (bytes_written)\n   {\n	  output_buf[bytes_written] = 0;\n	  printf("%s", output_buf);\n	  bytes_written  = 0;\n   }\n	//memset(output_buf, 0, sizeof(output_buf));\n   //cerr << "expectedvisit: " << expectedvisit << endl;\n   //cerr << "leavesvisited: " << leavesvisited << endl;\n   //cerr << "leavesprinted: " << leavesprinted << endl;\n}\n\ninline char *itoa(int i, char *a)\n{\n	char b[24];\n	char* c = b;\n	while (i / 10 > 0)\n	{\n		*c = "0123456789"[i % 10];\n		++c;\n		i /= 10;\n	}\n	\n	*c = "0123456789"[i % 10];\n	++c;\n	\n	while (c > b) {--c; *a = *c; ++a;}\n	return a;\n}\n\nint addMatchToBuffer(int left_in_ref, int qrypos, int matchlen)\n{\n	// The ridiculous second term here comes from the maximum number of \n	// characters one might need to express a match to a reference that is \n	// no more than 10 billion bases long, using a MAX_QUERY_LENGTH of 8192,\n	// plus whitespace\n	if (bytes_written >= output_buf_limit - (12 + 4 + 4 + 4))\n	{\n		flushOutput();\n	}\n	\n	char* p_buf = output_buf + bytes_written;	\n	p_buf = itoa(left_in_ref, p_buf);\n	*p_buf = '\t';\n	++p_buf;\n	p_buf = itoa(qrypos,p_buf);\n	*p_buf = '\t';\n	++p_buf;\n	p_buf = itoa(matchlen,p_buf);\n	*p_buf = '\n';\n	++p_buf;\n	bytes_written +=  p_buf - (output_buf + bytes_written);\n}\n\n#define NODE_LENGTH(x)      (page->ref.aux_data[x].length)\n#define NODE_PRINTPARENT(x) (page->ref.aux_data[x].printParent)\n#define NODE_NUMLEAVES(x)   (page->ref.aux_data[x].numleaves)\n\n#if REORDER_TREE\n#define GETNODE(node_addr)     (((PixelOfNode*)    (page->ref.h_node_tex_array))     + (node_addr.x) + (node_addr.y * MAX_TEXTURE_DIMENSION))\n#define GETCHILDREN(node_addr) (((PixelOfChildren*)(page->ref.h_children_tex_array)) + (node_addr.x) + (node_addr.y * MAX_TEXTURE_DIMENSION))\n#define PADDR(node_addr)        node_addr.x << "," << node_addr.y\n#else\n#define GETCHILDREN(node_addr) (((PixelOfChildren*)(page->ref.h_children_tex_array)) + (node_addr.x))\n#define GETNODE(node_addr)     (((PixelOfNode*)    (page->ref.h_node_tex_array))     + (node_addr.x))\n#define PADDR(node_addr)       node_addr.x\n#endif\n\n#if MERGETEX\n\nchar * getMerged(const ReferencePage * page, TextureAddress cur, int getChildrenData)\n{\n#if !REORDER_TREE\n  bool useChildrenForData = false;\n\n  cur.x *= 2;\n  if (cur.x >= (MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION))\n  {\n    useChildrenForData = true;\n    cur.x -= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION;\n  }\n#else\n  bool useChildrenForData = cur.x & 0x800;\n  cur.x &= 0x7FF;\n  cur.x *= 2;\n#endif\n\n  cur.x += getChildrenData;\n\n  if (useChildrenForData)\n  {\n    return (char *) GETCHILDREN(cur);\n  }\n  else\n  {\n    return (char *) GETNODE(cur);\n  }\n}\n\n#define SDEPTH(node_addr)   (((PixelOfNode*)    getMerged(page, node_addr, 0))->depth)\n#define PARENT(node_addr)   (((PixelOfNode*)    getMerged(page, node_addr, 0))->parent)\n\n#define LEAFCHAR(node_addr) (((PixelOfChildren*)getMerged(page, node_addr, 1))->leafchar)\n#define LEAFID(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->leafid)\n#define CHILDA(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->a)\n#define CHILDC(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->c)\n#define CHILDG(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->g)\n#define CHILDT(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->t)\n#define CHILDD(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->d)\n\n#else // !MERGETEX\n\n#define SDEPTH(node_addr)   (GETNODE(node_addr)->depth)\n#define PARENT(node_addr)   (GETNODE(node_addr)->parent)\n\n#define LEAFCHAR(node_addr) (GETCHILDREN(node_addr)->leafchar)\n#define LEAFID(node_addr)   (GETCHILDREN(node_addr)->leafid)\n#define CHILDA(node_addr)   (GETCHILDREN(node_addr)->a)\n#define CHILDC(node_addr)   (GETCHILDREN(node_addr)->c)\n#define CHILDG(node_addr)   (GETCHILDREN(node_addr)->g)\n#define CHILDT(node_addr)   (GETCHILDREN(node_addr)->t)\n#define CHILDD(node_addr)   (GETCHILDREN(node_addr)->d)\n\n#endif // MERGETEX\n\n\n\nchar buf[256];\n\nvoid printNodeAlignments(const ReferencePage* page,\n						 const char queryflankingbase, \n						 const TextureAddress node,\n						 const int qrypos, \n						 int qrylen,\n						 const pathblock path[],\n						 int path_idx,\n                         bool rc)\n{\n  char isLeaf = LEAFCHAR(node); \n\n  if (path[path_idx].node_addr.data == node.data)\n  {\n	 qrylen = path[path_idx].string_depth;\n	 path_idx--;  \n  }\n  \n  if (isLeaf)\n  {\n     if (isLeaf != queryflankingbase)\n     {\n       int leafid = MK3(LEAFID(node));\n       int left_in_ref = (leafid - 1) + page->begin; \n       int right_in_ref = left_in_ref + qrylen;\n\n       if ((left_in_ref != page->begin || page->shadow_left == -1) && \n           (right_in_ref != page->end || page->shadow_right == -1))\n       {\n		 if (!(left_in_ref > page->begin && right_in_ref < page->shadow_left))\n		 {\n		   sprintf(buf, "\t%d\t%d\t%d\n", left_in_ref, qrypos, qrylen);\n		   //sprintf(buf, "%8d%10d%10d\n", left_in_ref, qrypos, qrylen);\n		   addToBuffer(buf);\n		 }\n	   }\n	 }\n  }\n  else\n  {\n    TextureAddress child;\n\n    child = arrayToAddress(CHILDA(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDC(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDG(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDT(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDD(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n  }\n}\n\nint expectedvisit = 0;\nint leavesvisited = 0;\nint leavesprinted = 0;\n\n\n//FIXME: hardcoded path buffer, needs to be as long as the longest query in the query set.\npathblock path[8192];\n\nchar RC(char c)\n{\n  switch(c)\n  {\n    case 'A': return 'T';\n    case 'C': return 'G';\n    case 'G': return 'C';\n    case 'T': return 'A';\n    case 'q': return '\0';\n    default:  return c;\n  };\n}\n\n\n\nvoid printAlignmentsOld( ReferencePage* page,\n					 char* query, \n                     int qrylen,\n					 int nodeid, \n					 int qrypos, \n					 int edge_match, \n					 int min_match,\n                     bool rc,\n                     bool forwardcoordinates)\n{\n   TextureAddress node_addr = id2addr(nodeid);\n   TextureAddress prev;\n   prev.data = 0; \n  \n   int path_idx = 0;\n   int string_depth = MK3(SDEPTH(node_addr)) - 1;\n\n   if (edge_match > 0)\n   {\n     string_depth = MK3(SDEPTH(node_addr)) - (NODE_LENGTH(nodeid) - edge_match) - 1;\n   }\n   else\n   {\n     edge_match = NODE_LENGTH(nodeid);\n   }\n\n   path[path_idx].node_addr = node_addr;\n   path[path_idx].string_depth = string_depth;\n   path_idx++;\n   string_depth -= edge_match;\n   prev = node_addr;\n\n   node_addr = arrayToAddress(PARENT(node_addr));\n   \n   while ((node_addr.data) && string_depth >= min_match)\n   {\n	  nodeid = addr2id(node_addr);\n	  path[path_idx].node_addr = node_addr;\n	  path[path_idx].string_depth = string_depth;\n	  path_idx++;	\n	  string_depth -= NODE_LENGTH(nodeid);	  \n	  \n	  prev = node_addr;\n	  node_addr = arrayToAddress(PARENT(node_addr));\n   }\n   \n   char flankingbase = query[qrypos];\n\n   if (rc)\n   {\n     flankingbase = RC(query[strlen(query)-qrypos]);\n     if (forwardcoordinates) { qrypos = qrylen - 1 - qrypos; }\n   }\n\n   printNodeAlignments(page, flankingbase, prev, qrypos + 1, \n   				       MK3(SDEPTH(prev)), path, path_idx - 1, rc);\n}\n\ninline char getQueryChar(char* query, int position)\n{\n#if COALESCED_QUERIES\n	int shift = 8 * (position % 4);\n    int mask = (0xFF) << shift;\n    int c_word = ((int*)query)[(position >> 2) * WARP_SIZE];\n//	XPRINTF("c_word = %x, mask = %x\n", c_word, mask);\n	return (c_word & mask) >> shift;\n#else\n	return *(query + position);\n#endif	\n}\n\n// Stackless printing\nvoid printAlignments(ReferencePage* page,\n					 Alignment* h_alignments,\n                     char* query,\n                     int qrylen,\n                     TextureAddress matchNodeAddr,\n                     int qrystartpos,\n                     int edge_match,\n                     int min_match,\n                     bool rc,\n                     bool forwardcoordinates) \n{\n  char queryflankingbase = getQueryChar(query, qrystartpos);\n	Alignment* alignments = h_alignments;  \n  if (rc) \n  {\n    queryflankingbase = RC(query[strlen(query)-qrystartpos]);\n    if (forwardcoordinates) { qrystartpos = qrylen - 1 - qrystartpos; }\n  }\n    \n  // Find the top node to start printing from\n  TextureAddress cur = matchNodeAddr;\n  TextureAddress printParent = cur;\n	unsigned int matchNodeId = addr2id(matchNodeAddr);\n  int verbose = 0;\n    \n  if (verbose)\n  {\n    cout << "query: " << query << endl;\n    cout << "starting node: " << PADDR(cur)\n         << " depth: " << MK3(SDEPTH(cur)) << endl;\n  }\n\n  while (MK3(SDEPTH(cur)) > min_match)\n  {\n    printParent = cur;\n    cur = arrayToAddress(PARENT(cur));\n\n    if (verbose)\n    {\n      cout << "par: " << PADDR(cur)\n           << " depth: " << MK3(SDEPTH(cur)) << endl;\n    }\n  }\n\n  if (printParent.data != NODE_PRINTPARENT(matchNodeId).data)\n  {\n    TextureAddress other;\n    other.data = NODE_PRINTPARENT(matchNodeId).data;\n    \n    cout << "printParent ("          << PADDR(printParent) << "):" << MK3(SDEPTH(printParent)) \n         << " != NODE_PRINTPARENT (" << PADDR(other)       << "):" << MK3(SDEPTH(other)) \n         << endl;\n        exit(1);\n  }\n    \n  if (verbose)\n  {\n    cout << "printParent: " << PADDR(printParent) << endl;\n  }\n    \n  expectedvisit += NODE_NUMLEAVES(addr2id(printParent));\n    \n  // traverse the tree starting at printParent\n  TextureAddress badParent = cur;\n  cur = printParent;\n    \n  char curchild = 'A';\n  bool forceToParent = false;\n    \n  int printParentId = addr2id(printParent);\n  int matchlen = MK3(SDEPTH(printParent))-1;\n  int depthToGoldenPath = 0;\n    \n    \n  // If the printparent is the matchnode, then we are already off the golden path\n  if (printParentId == matchNodeId)\n  {\n    if (edge_match > 0)\n    {\n      matchlen = MK3(SDEPTH(badParent)) - 1 + edge_match;\n    }\n        \n    depthToGoldenPath = 1;\n  }\n    \n  // keep going until I hit the printParent's parent\n  while (cur.data != badParent.data)\n  {\n    if (verbose)\n    {\n      cout << " cur: " << PADDR(cur)\n           << " curchild: " << curchild << endl;\n    }\n\n    char isLeaf = LEAFCHAR(cur);\n        \n    if (isLeaf || forceToParent)\n    {\n      // See if I am left maximal and print\n      if (isLeaf)\n      {\n        leavesvisited++;\n                \n        if (isLeaf != queryflankingbase)\n        {\n          int leafid = MK3(LEAFID(cur));\n          int left_in_ref = (leafid - 1) + page->begin;\n          int right_in_ref = left_in_ref + matchlen;\n                    \n          if ((left_in_ref != page->begin || page->shadow_left == -1) &&\n              (right_in_ref != page->end || page->shadow_right == -1))\n          {\n            if (!(left_in_ref > page->begin && right_in_ref < page->shadow_left))\n            {\n              leavesprinted++;\n	            alignments->left_in_ref = left_in_ref;\n	            alignments->matchlen = matchlen;\n	            ++alignments;\n\n              if (verbose)\n              {\n                fprintf(stderr, "%8d%10d%10d\n", left_in_ref, qrystartpos+1, matchlen);\n              }\n            }\n          }\n        }\n      }\n            \n      forceToParent = false;\n            \n      // now return to my parent and advance curchild\n      TextureAddress myParent = arrayToAddress(PARENT(cur));\n\n      if      (cur.data == arrayToAddress(CHILDA(myParent)).data) { curchild = 'C'; }\n      else if (cur.data == arrayToAddress(CHILDC(myParent)).data) { curchild = 'G'; }\n      else if (cur.data == arrayToAddress(CHILDG(myParent)).data) { curchild = 'T'; }\n      else if (cur.data == arrayToAddress(CHILDT(myParent)).data) { curchild = '$'; }\n      else  // I must be the $ child, go up a level\n      {\n                forceToParent = true;\n      }\n            \n      cur = myParent;\n            \n      if (depthToGoldenPath) { depthToGoldenPath--; }\n            \n      if (depthToGoldenPath == 0)\n      {\n        matchlen = MK3(SDEPTH(cur)) - 1;\n      }\n    }\n    else\n    {\n      // try to walk down the tree\n            \n      char goldenChild = 0;\n            \n      if (depthToGoldenPath == 0)\n      {\n        // we are currently on the golden path\n        // one of the children is also on the golden path\n        goldenChild = query[qrystartpos+matchlen+1];\n      }\n            \n      do\n      {\n        TextureAddress a;\n        if (curchild == 'A')\n        {\n          a = arrayToAddress(CHILDA(cur));\n          if (a.data) { cur = a; break; }\n          curchild = 'C';\n        }\n                \n        if (curchild == 'C')\n        {\n          a = arrayToAddress(CHILDC(cur));\n          if (a.data) { cur = a; break; }\n          curchild = 'G';\n        }\n                \n        if (curchild == 'G')\n        {\n          a = arrayToAddress(CHILDG(cur));\n          if (a.data) { cur = a; break; }\n          curchild = 'T';\n        }\n                \n        if (curchild == 'T')\n        {\n          a = arrayToAddress(CHILDT(cur));\n          if (a.data) { cur = a; break; }\n          curchild = '$';\n        }\n                \n        if (curchild == '$')\n        {\n          a = arrayToAddress(CHILDD(cur));\n          if (a.data) { cur = a; break; }\n        }\n                \n        // checked all of the children, go back to parent\n        forceToParent = true;\n      }\n      while (0);\n            \n      if (!forceToParent)\n      {\n        if (depthToGoldenPath == 0)\n        {\n          if (curchild == goldenChild)\n          {\n            int cid = addr2id(cur);\n            matchlen = MK3(SDEPTH(cur))-1;\n                        \n            if (cid == matchNodeId)\n            {\n              // we overextended the golden path\n              depthToGoldenPath = 1;\n                            \n              if (edge_match > 0)\n              {\n                matchlen = MK3(SDEPTH(cur)) - (NODE_LENGTH(cid) - edge_match) - 1;\n              }\n            }\n          }\n          else\n          {\n            depthToGoldenPath = 1;\n          }\n        }\n        else\n        {\n          depthToGoldenPath++;\n        }\n                \n        curchild = 'A';\n      }\n    }\n  }\n}\n\nextern "C"\nint lookupNumLeaves(ReferencePage * page, TextureAddress addr)\n{\n	unsigned int nodeid = addr2id(addr);\n  	TextureAddress printParent = NODE_PRINTPARENT(nodeid);\n	nodeid = addr2id(printParent);\n  	return NODE_NUMLEAVES(nodeid);\n}\n\n#if 0\nstruct ExactMatch\n{\n	ExactMatch(unsigned int lr, unsigned short qs, unsigned short ml) \n		: left_in_ref(lr), qrystartpos(qs), matchlen(ml) {}\n		\n	unsigned int left_in_ref;\n	unsigned short qrystartpos;\n	unsigned short matchlen;\n};\n\nstruct EMSortByRefPos\n{\n	bool operator()(const ExactMatch& lhs, const ExactMatch& rhs)\n	{\n		return lhs.left_in_ref < rhs.left_in_ref;\n	}\n};\n\nvoid align(const string & S, \n           const string & T,\n           int match_score,\n           int mismatch_score,\n           int gap_open,\n		int gap_extension);\n\nstatic const int MAX_MISMATCH = 4;\nvoid mapQueryEndToEnd(MatchContext* ctx, vector<ExactMatch>& ems, unsigned int qry)\n{\n	sort(ems.begin(), ems.end(), EMSortByRefPos());\n	vector<unsigned int> candidate_alignments;\n\n	unsigned int length = ctx->queries->h_lengths_array[qry];\n	unsigned int min_bases_covered = 2 * ctx->min_match_length;\n	if (string(*(ctx->queries->h_names + qry)) == "rid754")\n	{\n		int a = 5;\n	}\n	\n	for (int i = 0; i < (int)(ems.size() - 1); ++i)\n	{\n		if (candidate_alignments.size() && \n			(ems[i].left_in_ref - length > ems[candidate_alignments.back()].left_in_ref))\n			continue;\n		\n		unsigned int j = i;\n		unsigned int left_ref = ems[j].left_in_ref;\n		unsigned int right_ref = left_ref + ems[j].matchlen;\n\n		unsigned int leftmost_qrypos = ems[i].qrystartpos;\n		unsigned int rightmost_qrypos = leftmost_qrypos + ems[i].matchlen;\n		do {\n			if (rightmost_qrypos - leftmost_qrypos >= min_bases_covered)\n			{\n				candidate_alignments.push_back(i);\n				break;\n			}\n			++j;\n			right_ref = ems[j].left_in_ref + ems[j].matchlen;\n			unsigned int right_qpos = ems[j].qrystartpos + ems[j].matchlen;\n			if (right_qpos > rightmost_qrypos)\n				rightmost_qrypos = right_qpos;\n		} while(right_ref - left_ref < length && j < ems.size());\n	}\n	for(unsigned int i = 0; i < candidate_alignments.size(); ++i)\n	{\n		char refstr[2 * (MAX_QUERY_LEN + MAX_MISMATCH)];\n		memset(refstr, 0, sizeof(refstr));\n		ExactMatch& m = ems[candidate_alignments[i]];\n		strncpy(refstr, \n				ctx->ref->str + m.left_in_ref - m.qrystartpos - MAX_MISMATCH, \n				2 * (length + MAX_MISMATCH));\n		char* qrystr = ctx->queries->h_tex_array + ctx->queries->h_addrs_tex_array[qry];\n		align(string(refstr), string(qrystr), 10, -2, -2, -2);\n	}\n	// addToBuffer("> ");\n	// addToBuffer(*(ctx->queries->h_names + qry));\n	// addToBuffer("\n");\n	// char buf[256];\n	// sprintf(buf, "%d candidate matches\n", candidate_alignments.size());\n	// addToBuffer(buf);\n	// for (int i = 0; i < (int)(ems.size() - 1); ++i)\n	// {	if (find(candidate_alignments.begin(), candidate_alignments.end(), i) != candidate_alignments.end())\n	// 	{\n	// 		sprintf(buf, "%8d%10d%10d\t****\n",\n	// 		       ems[i].left_in_ref,\n	// 		       ems[i].qrystartpos + 1,\n	// 		       ems[i].matchlen);\n	// \n	// 	}\n	// 	else\n	// 	{\n	// 		sprintf(buf, "%8d%10d%10d\n",\n	// 		       ems[i].left_in_ref,\n	// 		       ems[i].qrystartpos + 1,\n	// 		       ems[i].matchlen);\n	// 	}\n	// 	addToBuffer(buf);\n	//}\n	\n	//flushOutput();\n}\n\nextern "C"\nvoid mapQueriesEndToEnd(MatchContext* ctx,\n                        ReferencePage* page,\n                        MatchInfo* h_matches,\n                        unsigned int numMatches,\n                        Alignment* h_alignments,\n                        unsigned int numAligments)\n{\n    int lastqry = -1;\n	vector<ExactMatch> ems;\n    for (int m = 0; m < numMatches; m++)\n    {\n        if (h_matches[m].queryid != lastqry)\n        {\n			if (lastqry != -1)\n				mapQueryEndToEnd(ctx, ems, lastqry);\n			ems.clear();\n			\n            lastqry = h_matches[m].queryid;\n            // addToBuffer("> ");\n            // addToBuffer(*(ctx->queries->h_names + lastqry));\n            // addToBuffer("\n");\n			if (string(*(ctx->queries->h_names + lastqry)) == "rid754")\n			{\n				int a = 5;\n			}\n        }\n        \n        int base = h_matches[m].resultsoffset;\n\n        for (int i = 0; i < h_matches[m].numLeaves; i++)\n        {\n            // See if there are any more left maximal alignments for this match\n            if (h_alignments[base+i].left_in_ref == 0)\n            {\n                break;\n            }\n            ems.push_back(ExactMatch(h_alignments[base+i].left_in_ref,\n            					     h_matches[m].qrystartpos + 1,\n									 h_alignments[base+i].matchlen));\n			\n        }\n    }\n}\n#endif\n