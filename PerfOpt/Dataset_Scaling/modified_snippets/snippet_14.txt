// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu\n// This code is from the AIAA-2009-4001 paper\n\n\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <omp.h>\n\nstruct double3 { double x, y, z; };\n\n#ifndef block_length\n#error "you need to define block_length"\n#endif\n\n/*\n * Options\n *\n */\n#define GAMMA 1.4\n#define iterations 2000\n\n#define NDIM 3\n#define NNB 4\n\n#define RK 3	// 3rd order RK\n#define ff_mach 1.2\n#define deg_angle_of_attack 0.0\n\n/*\n * not options\n */\n#define VAR_DENSITY 0\n#define VAR_MOMENTUM  1\n#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)\n#define NVAR (VAR_DENSITY_ENERGY+1)\n\n\n/*\n * Generic functions\n */\ntemplate <typename T>\nT* alloc(int N)\n{\n	return new T[N];\n}\n\ntemplate <typename T>\nvoid dealloc(T* array)\n{\n	delete[] array;\n}\n\ntemplate <typename T>\nvoid copy(T* dst, T* src, int N)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < N; i++)\n	{\n		dst[i] = src[i];\n	}\n}\n\n\nvoid dump(double* variables, int nel, int nelr)\n{\n\n\n	{\n		std::ofstream file("density");\n		file << nel << " " << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;\n	}\n\n\n	{\n		std::ofstream file("momentum");\n		file << nel << " " << nelr << std::endl;\n		for(int i = 0; i < nel; i++)\n		{\n			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << " ";\n			file << std::endl;\n		}\n	}\n\n	{\n		std::ofstream file("density_energy");\n		file << nel << " " << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;\n	}\n\n}\n\n/*\n * Element-based Cell-centered FVM solver functions\n */\ndouble ff_variable[NVAR];\ndouble3 ff_fc_momentum_x;\ndouble3 ff_fc_momentum_y;\ndouble3 ff_fc_momentum_z;\ndouble3 ff_fc_density_energy;\n\n\nvoid initialize_variables(int nelr, double* variables)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];\n	}\n}\n\ninline void compute_flux_contribution(double& density, double3& momentum, double& density_energy, double& pressure, double3& velocity, double3& fc_momentum_x, double3& fc_momentum_y, double3& fc_momentum_z, double3& fc_density_energy)\n{\n	fc_momentum_x.x = velocity.x*momentum.x + pressure;\n	fc_momentum_x.y = velocity.x*momentum.y;\n	fc_momentum_x.z = velocity.x*momentum.z;\n\n	fc_momentum_y.x = fc_momentum_x.y;\n	fc_momentum_y.y = velocity.y*momentum.y + pressure;\n	fc_momentum_y.z = velocity.y*momentum.z;\n\n	fc_momentum_z.x = fc_momentum_x.z;\n	fc_momentum_z.y = fc_momentum_y.z;\n	fc_momentum_z.z = velocity.z*momentum.z + pressure;\n\n	double de_p = density_energy+pressure;\n	fc_density_energy.x = velocity.x*de_p;\n	fc_density_energy.y = velocity.y*de_p;\n	fc_density_energy.z = velocity.z*de_p;\n}\n\ninline void compute_velocity(double& density, double3& momentum, double3& velocity)\n{\n	velocity.x = momentum.x / density;\n	velocity.y = momentum.y / density;\n	velocity.z = momentum.z / density;\n}\n\ninline double compute_speed_sqd(double3& velocity)\n{\n	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;\n}\n\ninline double compute_pressure(double& density, double& density_energy, double& speed_sqd)\n{\n	return (double(GAMMA)-double(1.0))*(density_energy - double(0.5)*density*speed_sqd);\n}\n\ninline double compute_speed_of_sound(double& density, double& pressure)\n{\n	return std::sqrt(double(GAMMA)*pressure/density);\n}\n\n\n\nvoid compute_step_factor(int nelr, double* variables, double* areas, double* step_factors)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double density = variables[NVAR*i + VAR_DENSITY];\n\n		double3 momentum;\n		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		double density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];\n		double3 velocity;	   compute_velocity(density, momentum, velocity);\n		double speed_sqd      = compute_speed_sqd(velocity);\n		double pressure       = compute_pressure(density, density_energy, speed_sqd);\n		double speed_of_sound = compute_speed_of_sound(density, pressure);\n\n		// dt = double(0.5) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once\n		step_factors[i] = double(0.5) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));\n	}\n}\n\n\nvoid compute_flux_contributions(int nelr, double* variables, double* fc_momentum_x, double* fc_momentum_y, double* fc_momentum_z, double* fc_density_energy)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double density_i = variables[NVAR*i + VAR_DENSITY];\n		double3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		double3 velocity_i;             				compute_velocity(density_i, momentum_i, velocity_i);\n		double speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		double speed_i                              = sqrtf(speed_sqd_i);\n		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		double3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;\n		double3 fc_i_density_energy;	\n		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z, fc_i_density_energy);\n\n		fc_momentum_x[i*NDIM + 0] = fc_i_momentum_x.x;\n		fc_momentum_x[i*NDIM + 1] = fc_i_momentum_x.y;\n		fc_momentum_x[i*NDIM+  2] = fc_i_momentum_x.z;\n\n		fc_momentum_y[i*NDIM+ 0] = fc_i_momentum_y.x;\n		fc_momentum_y[i*NDIM+ 1] = fc_i_momentum_y.y;\n		fc_momentum_y[i*NDIM+ 2] = fc_i_momentum_y.z;\n\n\n		fc_momentum_z[i*NDIM+ 0] = fc_i_momentum_z.x;\n		fc_momentum_z[i*NDIM+ 1] = fc_i_momentum_z.y;\n		fc_momentum_z[i*NDIM+ 2] = fc_i_momentum_z.z;\n\n		fc_density_energy[i*NDIM+ 0] = fc_i_density_energy.x;\n		fc_density_energy[i*NDIM+ 1] = fc_i_density_energy.y;\n		fc_density_energy[i*NDIM+ 2] = fc_i_density_energy.z;\n	}\n\n}\n\n/*\n *\n *\n*/\n\nvoid compute_flux(int nelr, int* elements_surrounding_elements, double* normals, double* variables, double* fc_momentum_x, double* fc_momentum_y, double* fc_momentum_z, double* fc_density_energy, double* fluxes)\n{\n	const double smoothing_coefficient = double(0.2);\n\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		int j, nb;\n		double3 normal; double normal_len;\n		double factor;\n\n		double density_i = variables[NVAR*i + VAR_DENSITY];\n		double3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		double3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);\n		double speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		double speed_i                              = std::sqrt(speed_sqd_i);\n		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		double3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;\n		double3 fc_i_density_energy;\n\n		fc_i_momentum_x.x = fc_momentum_x[i*NDIM + 0];\n		fc_i_momentum_x.y = fc_momentum_x[i*NDIM + 1];\n		fc_i_momentum_x.z = fc_momentum_x[i*NDIM + 2];\n\n		fc_i_momentum_y.x = fc_momentum_y[i*NDIM + 0];\n		fc_i_momentum_y.y = fc_momentum_y[i*NDIM + 1];\n		fc_i_momentum_y.z = fc_momentum_y[i*NDIM + 2];\n\n		fc_i_momentum_z.x = fc_momentum_z[i*NDIM + 0];\n		fc_i_momentum_z.y = fc_momentum_z[i*NDIM + 1];\n		fc_i_momentum_z.z = fc_momentum_z[i*NDIM + 2];\n\n		fc_i_density_energy.x = fc_density_energy[i*NDIM + 0];\n		fc_i_density_energy.y = fc_density_energy[i*NDIM + 1];\n		fc_i_density_energy.z = fc_density_energy[i*NDIM + 2];\n\n		double flux_i_density = double(0.0);\n		double3 flux_i_momentum;\n		flux_i_momentum.x = double(0.0);\n		flux_i_momentum.y = double(0.0);\n		flux_i_momentum.z = double(0.0);\n		double flux_i_density_energy = double(0.0);\n\n		double3 velocity_nb;\n		double density_nb, density_energy_nb;\n		double3 momentum_nb;\n		double3 fc_nb_momentum_x, fc_nb_momentum_y, fc_nb_momentum_z;\n		double3 fc_nb_density_energy;\n		double speed_sqd_nb, speed_of_sound_nb, pressure_nb;\n\n		for(j = 0; j < NNB; j++)\n		{\n			nb = elements_surrounding_elements[i*NNB + j];\n			normal.x = normals[(i*NNB + j)*NDIM + 0];\n			normal.y = normals[(i*NNB + j)*NDIM + 1];\n			normal.z = normals[(i*NNB + j)*NDIM + 2];\n			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);\n\n			if(nb >= 0) 	// a legitimate neighbor\n			{\n				density_nb =        variables[nb*NVAR + VAR_DENSITY];\n				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];\n				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];\n				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];\n				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];\n													compute_velocity(density_nb, momentum_nb, velocity_nb);\n				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);\n				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);\n				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);\n\n				fc_nb_momentum_x.x = fc_momentum_x[nb*NDIM + 0];\n				fc_nb_momentum_x.y = fc_momentum_x[nb*NDIM + 1];\n				fc_nb_momentum_x.z = fc_momentum_x[nb*NDIM + 2];\n\n				fc_nb_momentum_y.x = fc_momentum_y[nb*NDIM + 0];\n				fc_nb_momentum_y.y = fc_momentum_y[nb*NDIM + 1];\n				fc_nb_momentum_y.z = fc_momentum_y[nb*NDIM + 2];\n\n				fc_nb_momentum_z.x = fc_momentum_z[nb*NDIM + 0];\n				fc_nb_momentum_z.y = fc_momentum_z[nb*NDIM + 1];\n				fc_nb_momentum_z.z = fc_momentum_z[nb*NDIM + 2];\n\n				fc_nb_density_energy.x = fc_density_energy[nb*NDIM + 0];\n				fc_nb_density_energy.y = fc_density_energy[nb*NDIM + 1];\n\n				// artificial viscosity\n				factor = -normal_len*smoothing_coefficient*double(0.5)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);\n				flux_i_density += factor*(density_i-density_nb);\n				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);\n				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);\n				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);\n				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);\n\n				// accumulate cell-centered fluxes\n				factor = double(0.5)*normal.x;\n				flux_i_density += factor*(momentum_nb.x+momentum_i.x);\n				flux_i_density_energy += factor*(fc_nb_density_energy.x+fc_i_density_energy.x);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.x+fc_i_momentum_x.x);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.x+fc_i_momentum_y.x);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.x+fc_i_momentum_z.x);\n\n				factor = double(0.5)*normal.y;\n				flux_i_density += factor*(momentum_nb.y+momentum_i.y);\n				flux_i_density_energy += factor*(fc_nb_density_energy.y+fc_i_density_energy.y);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.y+fc_i_momentum_x.y);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.y+fc_i_momentum_y.y);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.y+fc_i_momentum_z.y);\n\n				factor = double(0.5)*normal.z;\n				flux_i_density += factor*(momentum_nb.z+momentum_i.z);\n				flux_i_density_energy += factor*(fc_nb_density_energy.z+fc_i_density_energy.z);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.z+fc_i_momentum_x.z);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.z+fc_i_momentum_y.z);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.z+fc_i_momentum_z.z);\n			}\n			else if(nb == -1)	// a wing boundary\n			{\n				flux_i_momentum.x += normal.x*pressure_i;\n				flux_i_momentum.y += normal.y*pressure_i;\n				flux_i_momentum.z += normal.z*pressure_i;\n			}\n			else if(nb == -2) // a far field boundary\n			{\n				factor = double(0.5)*normal.x;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);\n				flux_i_density_energy += factor*(ff_fc_density_energy.x+fc_i_density_energy.x);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.x + fc_i_momentum_x.x);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.x + fc_i_momentum_y.x);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.x + fc_i_momentum_z.x);\n\n				factor = double(0.5)*normal.y;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);\n				flux_i_density_energy += factor*(ff_fc_density_energy.y+fc_i_density_energy.y);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.y + fc_i_momentum_x.y);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.y + fc_i_momentum_y.y);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.y + fc_i_momentum_z.y);\n\n				factor = double(0.5)*normal.z;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);\n				flux_i_density_energy += factor*(ff_fc_density_energy.z+fc_i_density_energy.z);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.z + fc_i_momentum_x.z);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.z + fc_i_momentum_y.z);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.z + fc_i_momentum_z.z);\n\n			}\n		}\n\n		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;\n		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;\n		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;\n		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;\n		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;\n	}\n}\n\nvoid time_step(int j, int nelr, double* old_variables, double* variables, double* step_factors, double* fluxes)\n{\n	#pragma omp parallel for  default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double factor = step_factors[i]/double(RK+1-j);\n\n		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];\n		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];\n		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];\n		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];\n		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];\n	}\n}\n/*\n * Main function\n */\nint main(int argc, char** argv)\n{\n	if (argc < 2)\n	{\n		std::cout << "specify data file name" << std::endl;\n		return 0;\n	}\n	const char* data_file_name = argv[1];\n\n	// set far field conditions\n	{\n		const double angle_of_attack = double(3.1415926535897931 / 180.0) * double(deg_angle_of_attack);\n\n		ff_variable[VAR_DENSITY] = double(1.4);\n\n		double ff_pressure = double(1.0);\n		double ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);\n		double ff_speed = double(ff_mach)*ff_speed_of_sound;\n\n		double3 ff_velocity;\n		ff_velocity.x = ff_speed*double(cos((double)angle_of_attack));\n		ff_velocity.y = ff_speed*double(sin((double)angle_of_attack));\n		ff_velocity.z = 0.0;\n\n		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;\n		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;\n		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;\n\n		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(double(0.5)*(ff_speed*ff_speed)) + (ff_pressure / double(GAMMA-1.0));\n\n		double3 ff_momentum;\n		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);\n		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);\n		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);\n		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_fc_momentum_x, ff_fc_momentum_y, ff_fc_momentum_z, ff_fc_density_energy);\n	}\n	int nel;\n	int nelr;\n\n	// read in domain geometry\n	double* areas;\n	int* elements_surrounding_elements;\n	double* normals;\n	{\n		std::ifstream file(data_file_name);\n\n		file >> nel;\n		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));\n\n		areas = new double[nelr];\n		elements_surrounding_elements = new int[nelr*NNB];\n		normals = new double[NDIM*NNB*nelr];\n\n		// read in data\n		for(int i = 0; i < nel; i++)\n		{\n			file >> areas[i];\n			for(int j = 0; j < NNB; j++)\n			{\n				file >> elements_surrounding_elements[i*NNB + j];\n				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;\n				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering\n\n				for(int k = 0; k < NDIM; k++)\n				{\n					file >>  normals[(i*NNB + j)*NDIM + k];\n					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];\n				}\n			}\n		}\n\n		// fill in remaining data\n		int last = nel-1;\n		for(int i = nel; i < nelr; i++)\n		{\n			areas[i] = areas[last];\n			for(int j = 0; j < NNB; j++)\n			{\n				// duplicate the last element\n				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];\n				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];\n			}\n		}\n	}\n\n	// Create arrays and set initial conditions\n	double* variables = alloc<double>(nelr*NVAR);\n	initialize_variables(nelr, variables);\n\n	double* old_variables = alloc<double>(nelr*NVAR);\n	double* fluxes = alloc<double>(nelr*NVAR);\n	double* step_factors = alloc<double>(nelr);\n	double* fc_momentum_x = alloc<double>(nelr*NDIM); \n	double* fc_momentum_y = alloc<double>(nelr*NDIM);\n	double* fc_momentum_z = alloc<double>(nelr*NDIM);\n	double* fc_density_energy = alloc<double>(nelr*NDIM);\n\n	// these need to be computed the first time in order to compute time step\n	std::cout << "Starting..." << std::endl;\n	double start = omp_get_wtime();\n\n	// Begin iterations\n	for(int i = 0; i < iterations; i++)\n	{\n		copy<double>(old_variables, variables, nelr*NVAR);\n\n		// for the first iteration we compute the time step\n		compute_step_factor(nelr, variables, areas, step_factors);\n\n		for(int j = 0; j < RK; j++)\n		{\n			compute_flux_contributions(nelr, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy);\n			compute_flux(nelr, elements_surrounding_elements, normals, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy, fluxes);\n			time_step(j, nelr, old_variables, variables, step_factors, fluxes);\n		}\n	}\n\n	double end = omp_get_wtime();\n	std::cout  << (end-start)  / iterations << " seconds per iteration" << std::endl;\n\n	std::cout << "Saving solution..." << std::endl;\n	dump(variables, nel, nelr);\n	std::cout << "Saved solution..." << std::endl;\n\n\n	std::cout << "Cleaning up..." << std::endl;\n	dealloc<double>(areas);\n	dealloc<int>(elements_surrounding_elements);\n	dealloc<double>(normals);\n\n	dealloc<double>(variables);\n	dealloc<double>(old_variables);\n	dealloc<double>(fluxes);\n	dealloc<double>(step_factors);\n	dealloc<double>(fc_momentum_x); \n	dealloc<double>(fc_momentum_y);\n	dealloc<double>(fc_momentum_z);\n	dealloc<double>(fc_density_energy);\n	std::cout << "Done..." << std::endl;\n\n	return 0;\n}\n