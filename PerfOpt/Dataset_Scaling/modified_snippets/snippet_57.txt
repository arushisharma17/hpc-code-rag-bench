\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	Arnoldi method for finding eigenvalues of large non-symmetric\n		matrices\n*/\n#include	<stdio.h>\n#include	<math.h>\n#include	"matrix.h"\n#include	"matrix2.h"\n#include	"sparse.h"\n\nstatic char rcsid[] = "$Id: arnoldi.c,v 1.3 1994/01/13 05:45:40 des Exp $";\n\n\n/* arnoldi -- an implementation of the Arnoldi method */\nMAT	*arnoldi(A,A_param,x0,m,h_rem,Q,H)\nVEC	*(*A)();\nvoid	*A_param;\nVEC	*x0;\nint	m;\nReal	*h_rem;\nMAT	*Q, *H;\n{\n	STATIC VEC	*v=VNULL, *u=VNULL, *r=VNULL, *s=VNULL, *tmp=VNULL;\n	int	i;\n	Real	h_val;\n\n	if ( ! A || ! Q || ! x0 )\n	    error(E_NULL,"arnoldi");\n	if ( m <= 0 )\n	    error(E_BOUNDS,"arnoldi");\n	if ( Q->n != x0->dim ||	Q->m != m )\n	    error(E_SIZES,"arnoldi");\n\n	m_zero(Q);\n	H = m_resize(H,m,m);\n	m_zero(H);\n	u = v_resize(u,x0->dim);\n	v = v_resize(v,x0->dim);\n	r = v_resize(r,m);\n	s = v_resize(s,m);\n	tmp = v_resize(tmp,x0->dim);\n	MEM_STAT_REG(u,TYPE_VEC);\n	MEM_STAT_REG(v,TYPE_VEC);\n	MEM_STAT_REG(r,TYPE_VEC);\n	MEM_STAT_REG(s,TYPE_VEC);\n	MEM_STAT_REG(tmp,TYPE_VEC);\n	sv_mlt(1.0/v_norm2(x0),x0,v);\n	for ( i = 0; i < m; i++ )\n	{\n	    set_row(Q,i,v);\n	    u = (*A)(A_param,v,u);\n	    r = mv_mlt(Q,u,r);\n	    tmp = vm_mlt(Q,r,tmp);\n	    v_sub(u,tmp,u);\n	    h_val = v_norm2(u);\n	    /* if u == 0 then we have an exact subspace */\n	    if ( h_val == 0.0 )\n	    {\n		*h_rem = h_val;\n		return H;\n	    }\n	    /* iterative refinement -- ensures near orthogonality */\n	    do {\n		s = mv_mlt(Q,u,s);\n		tmp = vm_mlt(Q,s,tmp);\n		v_sub(u,tmp,u);\n		v_add(r,s,r);\n	    } while ( v_norm2(s) > 0.1*(h_val = v_norm2(u)) );\n	    /* now that u is nearly orthogonal to Q, update H */\n	    set_col(H,i,r);\n	    if ( i == m-1 )\n	    {\n		*h_rem = h_val;\n		continue;\n	    }\n	    /* H->me[i+1][i] = h_val; */\n	    m_set_val(H,i+1,i,h_val);\n	    sv_mlt(1.0/h_val,u,v);\n	}\n\n#ifdef THREADSAFE\n	V_FREE(v);	V_FREE(u);	V_FREE(r);\n	V_FREE(r);	V_FREE(s);	V_FREE(tmp);\n#endif\n	return H;\n}\n\n/* sp_arnoldi -- uses arnoldi() with an explicit representation of A */\nMAT	*sp_arnoldi(A,x0,m,h_rem,Q,H)\nSPMAT	*A;\nVEC	*x0;\nint	m;\nReal	*h_rem;\nMAT	*Q, *H;\n{	return arnoldi(sp_mv_mlt,A,x0,m,h_rem,Q,H);	}\n\n/* gmres -- generalised minimum residual algorithm of Saad & Schultz\n		SIAM J. Sci. Stat. Comp. v.7, pp.856--869 (1986)\n	-- y is overwritten with the solution */\nVEC	*gmres(A,A_param,m,Q,R,b,tol,x)\nVEC	*(*A)();\nvoid	*A_param;\nVEC	*b, *x;\nint	m;\nMAT	*Q, *R;\ndouble	tol;\n{\n    STATIC VEC	*v=VNULL, *u=VNULL, *r=VNULL, *tmp=VNULL, *rhs=VNULL;\n    STATIC VEC	*diag=VNULL, *beta=VNULL;\n    int	i;\n    Real	h_val, norm_b;\n    \n    if ( ! A || ! Q || ! b || ! R )\n	error(E_NULL,"gmres");\n    if ( m <= 0 )\n	error(E_BOUNDS,"gmres");\n    if ( Q->n != b->dim || Q->m != m )\n	error(E_SIZES,"gmres");\n    \n    x = v_copy(b,x);\n    m_zero(Q);\n    R = m_resize(R,m+1,m);\n    m_zero(R);\n    u = v_resize(u,x->dim);\n    v = v_resize(v,x->dim);\n    tmp = v_resize(tmp,x->dim);\n    rhs = v_resize(rhs,m+1);\n    MEM_STAT_REG(u,TYPE_VEC);\n    MEM_STAT_REG(v,TYPE_VEC);\n    MEM_STAT_REG(r,TYPE_VEC);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n    MEM_STAT_REG(rhs,TYPE_VEC);\n    norm_b = v_norm2(x);\n    if ( norm_b == 0.0 )\n	error(E_RANGE,"gmres");\n    sv_mlt(1.0/norm_b,x,v);\n    \n    for ( i = 0; i < m; i++ )\n    {\n	set_row(Q,i,v);\n	tracecatch(u = (*A)(A_param,v,u),"gmres");\n	r = mv_mlt(Q,u,r);\n	tmp = vm_mlt(Q,r,tmp);\n	v_sub(u,tmp,u);\n	h_val = v_norm2(u);\n	set_col(R,i,r);\n	R->me[i+1][i] = h_val;\n	sv_mlt(1.0/h_val,u,v);\n    }\n    \n    /* use i x i submatrix of R */\n    R = m_resize(R,i+1,i);\n    rhs = v_resize(rhs,i+1);\n    v_zero(rhs);\n    rhs->ve[0] = norm_b;\n    tmp = v_resize(tmp,i);\n    diag = v_resize(diag,i+1);\n    beta = v_resize(beta,i+1);\n    MEM_STAT_REG(beta,TYPE_VEC);\n    MEM_STAT_REG(diag,TYPE_VEC);\n    QRfactor(R,diag /* ,beta */);\n    tmp = QRsolve(R,diag, /* beta, */ rhs,tmp);\n    v_resize(tmp,m);\n    vm_mlt(Q,tmp,x);\n\n#ifdef THREADSAFE\n    V_FREE(v);		V_FREE(u);	V_FREE(r);\n    V_FREE(tmp);	V_FREE(rhs);\n    V_FREE(diag);	V_FREE(beta);\n#endif\n\n    return x;\n}\n