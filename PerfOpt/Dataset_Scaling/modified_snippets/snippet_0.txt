#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#ifdef FP_NUMBER\ntypedef double FP_NUMBER;\n#else\ntypedef float FP_NUMBER;\n#endif\n\n\n#define GET_RAND_FP ((FP_NUMBER)rand()/((FP_NUMBER)(RAND_MAX)+(FP_NUMBER)(1)))\nchar L_FNAME[32], U_FNAME[32], A_FNAME[32];\n\nint main (int argc, char **argv){\n    int i,j,k,MatrixDim;\n    FP_NUMBER sum, **L, **U, **A;\n    FILE *fl,*fu,*fa;\n\n    if ( argc < 2) {\n        printf("./gen_input [Matrix_Dimension_size]\n");\n        return 1;\n    }\n\n    MatrixDim = atoi(argv[1]);\n    L = (FP_NUMBER **) malloc(sizeof(FP_NUMBER*)*MatrixDim);\n    U = (FP_NUMBER **) malloc(sizeof(FP_NUMBER*)*MatrixDim);\n    A = (FP_NUMBER **) malloc(sizeof(FP_NUMBER*)*MatrixDim);\n\n    if ( !L || !U || !A){\n        printf("Can not allocate memory\n");\n        if (L) free(L);\n        if (U) free(U);\n        if (A) free(A);\n        return 1;\n    }\n\n    srand(time(NULL));\n\n    sprintf(L_FNAME, "l-%d.dat", MatrixDim);\n    fl = fopen(L_FNAME, "wb");\n    if (fl == NULL) {\n        printf("Cannot open file %s\n", L_FNAME);\n        return 1;\n    }\n\n    sprintf(U_FNAME, "u-%d.dat", MatrixDim);\n    fu = fopen(U_FNAME, "wb");\n    if (fu == NULL) {\n        printf("Cannot open file %s\n", U_FNAME);\n        return 1;\n    }\n\n    sprintf(A_FNAME, "%d.dat", MatrixDim);\n    fa = fopen(A_FNAME, "wb");\n    if (!fa) {\n        printf("Cannot open file %s\n", A_FNAME);\n        return 1;\n    }\n\n    for (i=0; i < MatrixDim; i ++){\n        L[i]=(FP_NUMBER*)malloc(sizeof(FP_NUMBER)*MatrixDim);\n        U[i]=(FP_NUMBER*)malloc(sizeof(FP_NUMBER)*MatrixDim);\n        A[i]=(FP_NUMBER*)malloc(sizeof(FP_NUMBER)*MatrixDim);\n    }\n#if 1\n#pragma omp parallel for default(none)\\n    private(i,j) shared(L,U,MatrixDim)\n#endif\n    for (i=0; i < MatrixDim; i ++){\n        for (j=0; j < MatrixDim; j++){\n            if ( i == j) {\n                L[i][j] = 1.0;\n                U[i][j] = GET_RAND_FP;\n            } else if (i < j){\n                L[i][j] = 0;\n                U[i][j] = GET_RAND_FP;\n            } else { // i > j\n                L[i][j] = GET_RAND_FP;\n                U[i][j] = 0;\n            }\n        }\n    }\n\n#if 1\n#pragma omp parallel for default(none) \\n    private(i,j,k,sum) shared(L,U,A,MatrixDim)\n#endif\n    for (i=0; i < MatrixDim; i++ ) {\n        for (j=0; j < MatrixDim; j++){\n            sum = 0;\n            for(k=0; k < MatrixDim; k++)\n                sum += L[i][k]*U[k][j];\n            A[i][j] = sum;\n        }\n    }\n\n    for (i=0; i < MatrixDim; i ++) {\n        for (j=0; j < MatrixDim; j++)\n            fprintf(fl, "%f ", L[i][j]);\n        fprintf(fl, "\n");\n    }\n    fclose(fl);\n\n    for (i=0; i < MatrixDim; i ++) {\n        for (j=0; j < MatrixDim; j++)\n            fprintf(fu, "%f ", U[i][j]);\n        fprintf(fu, "\n");\n    }\n    fclose(fu);\n\n    fprintf(fa, "%d\n", MatrixDim);\n    for (i=0; i < MatrixDim; i ++) {\n        for (j=0; j < MatrixDim; j++)\n            fprintf(fa, "%f ", A[i][j]);\n        fprintf(fa, "\n");\n    }\n    fclose(fa);\n\n    for (i = 0; i < MatrixDim; i ++ ){\n        free(L[i]);\n        free(U[i]);\n        free(A[i]);\n    }\n    free(L);\n    free(U);\n    free(A);\n\n    return 0;\n}\n