\n/* routines from the section 8 of tutorial.txt */\n\n#include "matrix.h"\n\n#define M3D_LIST    3      /* list number */\n#define TYPE_MAT3D  0      /* the number of a type */\n\n/* type for 3 dimensional matrices */\ntypedef struct {\n	int l,m,n;    /* actual dimensions */\n	int max_l, max_m, max_n;    /* maximal dimensions */\n	Real ***me;    /* pointer to matrix elements */\n	               /* we do not consider segmented memory */\n        Real *base, **me2d;  /* me and me2d are additional pointers \n				to base */\n} MAT3D;\n\n\n/* function for creating a variable of MAT3D type */\n\nMAT3D *m3d_get(l,m,n)\nint l,m,n;\n{\n  MAT3D *mat;\n  int i,j,k;\n\n  /* check if arguments are positive */\n  if (l <= 0 || m <= 0 || n <= 0)\n    error(E_NEG,"m3d_get");\n\n	/* new structure */\n  if ((mat = NEW(MAT3D)) == (MAT3D *)NULL)\n    error(E_MEM,"m3d_get");\n  else if (mem_info_is_on()) {\n	/* record how many bytes is allocated */\n    mem_bytes_list(TYPE_MAT3D,0,sizeof(MAT3D),M3D_LIST);\n	/* record a new allocated variable */\n    mem_numvar_list(TYPE_MAT3D,1,M3D_LIST);\n  }\n\n  mat->l = mat->max_l = l;\n  mat->m = mat->max_m = m;\n  mat->n = mat->max_n = n;\n\n	/* allocate memory for 3D array */\n  if ((mat->base = NEW_A(l*m*n,Real)) == (Real *)NULL) \n    error(E_MEM,"m3d_get");\n  else if (mem_info_is_on())\n    mem_bytes_list(TYPE_MAT3D,0,l*m*n*sizeof(Real),M3D_LIST);\n\n	/* allocate memory for 2D pointers */\n  if ((mat->me2d = NEW_A(l*m,Real *)) == (Real **)NULL)\n    error(E_MEM,"m3d_get");\n  else if (mem_info_is_on())\n    mem_bytes_list(TYPE_MAT3D,0,l*m*sizeof(Real *),M3D_LIST);  	\n\n	/* allocate  memory for 1D pointers */\n  if ((mat->me = NEW_A(l,Real **)) == (Real ***)NULL)\n    error(E_MEM,"m3d_get");\n  else if (mem_info_is_on())\n    mem_bytes_list(TYPE_MAT3D,0,l*sizeof(Real **),M3D_LIST);\n\n  	/* pointers to 2D matrices */\n  for (i=0,k=0; i < l; i++)\n    for (j=0; j < m; j++)\n      mat->me2d[k++] = &mat->base[(i*m+j)*n];\n\n       /* pointers to rows */\n  for (i=0; i < l; i++)\n    mat->me[i] = &mat->me2d[i*m];\n\n  return mat;\n}\n\n\n/* deallocate a variable of type MAT3D */\n\nint m3d_free(mat)\nMAT3D *mat;\n{\n 	  /* do not try to deallocate the NULL pointer */\n  if (mat == (MAT3D *)NULL)\n    return -1;\n	\n	  /* first deallocate base */\n  if (mat->base != (Real *)NULL) {\n    if (mem_info_is_on())\n	/* record how many bytes is deallocated */\n      mem_bytes_list(TYPE_MAT3D,mat->max_l*mat->max_m*mat->max_n*sizeof(Real),\n		     0,M3D_LIST);\n    free((char *)mat->base);\n  }\n\n 	/* deallocate array of 2D pointers */\n  if (mat->me2d != (Real **)NULL) {\n    if (mem_info_is_on())\n	/* record how many bytes is deallocated */\n      mem_bytes_list(TYPE_MAT3D,mat->max_l*mat->max_m*sizeof(Real *),\n		     0,M3D_LIST);\n    free((char *)mat->me2d);\n  }\n\n 	/* deallocate array of 1D pointers */\n  if (mat->me != (Real ***)NULL) {\n    if (mem_info_is_on())\n	/* record how many bytes is deallocated */\n      mem_bytes_list(TYPE_MAT3D,mat->max_l*sizeof(Real **),0,M3D_LIST);\n    free((char *)mat->me);\n  }\n\n	/* deallocate  MAT3D structure */\n  if (mem_info_is_on()) {\n    mem_bytes_list(TYPE_MAT3D,sizeof(MAT3D),0,M3D_LIST);\n    mem_numvar_list(TYPE_MAT3D,-1,M3D_LIST);\n  }\n  free((char *)mat);\n\n  return 0;\n}\n\n/*=============================================*/\n\nchar *m3d_names[] = {\n  "MAT3D"\n};\n\n\n#define M3D_NUM  (sizeof(m3d_names)/sizeof(*m3d_names))\n\nint (*m3d_free_funcs[M3D_NUM])() = {\n  m3d_free\n};\n\nstatic MEM_ARRAY m3d_sum[M3D_NUM];\n\n\n/* test routing for allocating/deallocating static variables */\nvoid test_stat(k)\nint k;\n{\n   static MAT3D *work;\n\n   if (!work) {\n      work = m3d_get(10,10,10);\n      mem_stat_reg_list((void **)&work,TYPE_MAT3D,M3D_LIST);\n      work->me[9][9][9] = -3.14;\n   }\n   \n   if (k == 9) \n     printf(" work[9][9][9] = %g\n",work->me[9][9][9]);\n}\n\n\nvoid main()\n{\n  MAT3D *M;\n  int i,j,k;\n\n  mem_info_on(TRUE);\n  /* can be the first command */\n  mem_attach_list(M3D_LIST,M3D_NUM,m3d_names,m3d_free_funcs,m3d_sum);\n\n  M = m3d_get(3,4,5);\n  mem_info_file(stdout,M3D_LIST);\n\n  /* make use of M->me[i][j][k], where i,j,k are non-negative and \n	i < 3, j < 4, k < 5 */\n\n  mem_stat_mark(1);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 4; j++)\n      for (k=0; k < 5; k++) {\n	 test_stat(i+j+k);\n	 M->me[i][j][k] = i+j+k;\n      }\n  mem_stat_free_list(1,M3D_LIST);\n  mem_info_file(stdout,M3D_LIST);\n\n  printf(" M[%d][%d][%d] = %g\n",2,3,4,M->me[2][3][4]);\n\n  mem_stat_mark(2);\n  test_stat(9);\n  mem_stat_free_list(2,M3D_LIST);\n\n  m3d_free(M);  /* if M is not necessary */\n  mem_info_file(stdout,M3D_LIST);\n\n}\n\n\n\n