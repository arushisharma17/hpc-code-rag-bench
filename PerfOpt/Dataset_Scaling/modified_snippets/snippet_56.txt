\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* iter0.c  14/09/93 */\n\n/* ITERATIVE METHODS - service functions */\n\n/* functions for creating and releasing ITER structures;\n   for memory information;\n   for getting some values from an ITER variable;\n   for changing values in an ITER variable;\n   see also iter.c\n*/\n\n#include        <stdio.h>\n#include	<math.h>\n#include        "iter.h"\n\n\nstatic char rcsid[] = "$Id: iter0.c,v 1.3 1995/01/30 14:50:56 des Exp $";\n\n\n/* standard functions */\n\n/* standard information */\n#ifndef ANSI_C\nvoid iter_std_info(ip,nres,res,Bres)\nITER *ip;\ndouble nres;\nVEC *res, *Bres;\n#else\nvoid iter_std_info(const ITER *ip, double nres, VEC *res, VEC *Bres)\n#endif\n{\n   if (nres >= 0.0)\n#ifndef MEX\n     printf(" %d. residual = %g\n",ip->steps,nres);\n#else\n     mexPrintf(" %d. residual = %g\n",ip->steps,nres);\n#endif\n   else \n#ifndef MEX\n     printf(" %d. residual = %g (WARNING !!! should be >= 0) \n",\n	    ip->steps,nres);\n#else\n     mexPrintf(" %d. residual = %g (WARNING !!! should be >= 0) \n",\n	       ip->steps,nres);\n#endif\n}\n\n/* standard stopping criterion */\n#ifndef ANSI_C\nint iter_std_stop_crit(ip, nres, res, Bres)\nITER *ip;\ndouble nres;\nVEC *res, *Bres;\n#else\nint iter_std_stop_crit(const ITER *ip, double nres, VEC *res, VEC *Bres)\n#endif\n{\n   /* standard stopping criterium */\n   if (nres <= ip->init_res*ip->eps) return TRUE; \n   return FALSE;\n}\n\n\n/* iter_get - create a new structure pointing to ITER */\n#ifndef ANSI_C\nITER *iter_get(lenb, lenx)\nint lenb, lenx;\n#else\nITER *iter_get(int lenb, int lenx)\n#endif\n{\n   ITER *ip;\n\n   if ((ip = NEW(ITER)) == (ITER *) NULL)\n     error(E_MEM,"iter_get");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ITER,0,sizeof(ITER));\n      mem_numvar(TYPE_ITER,1);\n   }\n\n   /* default values */\n   \n   ip->shared_x = FALSE;\n   ip->shared_b = FALSE;\n   ip->k = 0;\n   ip->limit = ITER_LIMIT_DEF;\n   ip->eps = ITER_EPS_DEF;\n   ip->steps = 0;\n\n   if (lenb > 0) ip->b = v_get(lenb);\n   else ip->b = (VEC *)NULL;\n\n   if (lenx > 0) ip->x = v_get(lenx);\n   else ip->x = (VEC *)NULL;\n\n   ip->Ax = (Fun_Ax) NULL;\n   ip->A_par = NULL;	\n   ip->ATx = (Fun_Ax) NULL;\n   ip->AT_par = NULL;\n   ip->Bx = (Fun_Ax) NULL;\n   ip->B_par = NULL;\n   ip->info = iter_std_info;\n   ip->stop_crit = iter_std_stop_crit;\n   ip->init_res = 0.0;\n   \n   return ip;\n}\n\n\n/* iter_free - release memory */\n#ifndef ANSI_C\nint iter_free(ip)\nITER *ip;\n#else\nint iter_free(ITER *ip)\n#endif\n{\n   if (ip == (ITER *)NULL) return -1;\n   \n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_ITER,sizeof(ITER),0);\n      mem_numvar(TYPE_ITER,-1);\n   }\n\n   if ( !ip->shared_x && ip->x != NULL ) v_free(ip->x);\n   if ( !ip->shared_b && ip->b != NULL ) v_free(ip->b);\n\n   free((char *)ip);\n\n   return 0;\n}\n\n#ifndef ANSI_C\nITER *iter_resize(ip,new_lenb,new_lenx)\nITER *ip;\nint new_lenb, new_lenx;\n#else\nITER *iter_resize(ITER *ip, int new_lenb, int new_lenx)\n#endif\n{\n   VEC *old;\n\n   if ( ip == (ITER *) NULL)\n     error(E_NULL,"iter_resize");\n\n   old = ip->x;\n   ip->x = v_resize(ip->x,new_lenx);\n   if ( ip->shared_x && old != ip->x )\n     warning(WARN_SHARED_VEC,"iter_resize");\n   old = ip->b;\n   ip->b = v_resize(ip->b,new_lenb);\n   if ( ip->shared_b && old != ip->b )\n     warning(WARN_SHARED_VEC,"iter_resize");\n\n   return ip;\n}\n\n#ifndef MEX\n/* print out ip structure - for diagnostic purposes mainly */\n#ifndef ANSI_C\nvoid iter_dump(fp,ip)\nITER *ip;\nFILE *fp;\n#else\nvoid iter_dump(FILE *fp, ITER *ip)\n#endif\n{\n   if (ip == NULL) {\n      fprintf(fp," ITER structure: NULL\n");\n      return;\n   }\n\n   fprintf(fp,"\n ITER structure:\n");\n   fprintf(fp," ip->shared_x = %s, ip->shared_b = %s\n",\n	   (ip->shared_x ? "TRUE" : "FALSE"),\n	   (ip->shared_b ? "TRUE" : "FALSE") );\n   fprintf(fp," ip->k = %d, ip->limit = %d, ip->steps = %d, ip->eps = %g\n",\n	   ip->k,ip->limit,ip->steps,ip->eps);\n   fprintf(fp," ip->x = 0x%p, ip->b = 0x%p\n",ip->x,ip->b);\n   fprintf(fp," ip->Ax = 0x%p, ip->A_par = 0x%p\n",ip->Ax,ip->A_par);\n   fprintf(fp," ip->ATx = 0x%p, ip->AT_par = 0x%p\n",ip->ATx,ip->AT_par);\n   fprintf(fp," ip->Bx = 0x%p, ip->B_par = 0x%p\n",ip->Bx,ip->B_par);\n   fprintf(fp," ip->info = 0x%p, ip->stop_crit = 0x%p, ip->init_res = %g\n",\n	   ip->info,ip->stop_crit,ip->init_res);\n   fprintf(fp,"\n");\n   \n}\n#endif\n\n/* copy the structure ip1 to ip2 preserving vectors x and b of ip2\n   (vectors x and b in ip2 are the same before and after iter_copy2)\n   if ip2 == NULL then a new structure is created with x and b being NULL\n   and other members are taken from ip1\n*/\n#ifndef ANSI_C\nITER *iter_copy2(ip1,ip2)\nITER *ip1, *ip2;\n#else\nITER *iter_copy2(ITER *ip1, ITER *ip2)\n#endif\n{\n   VEC *x, *b;\n   int shx, shb;\n\n   if (ip1 == (ITER *)NULL) \n     error(E_NULL,"iter_copy2");\n\n   if (ip2 == (ITER *)NULL) {\n      if ((ip2 = NEW(ITER)) == (ITER *) NULL)\n	error(E_MEM,"iter_copy2");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ITER,0,sizeof(ITER));\n	 mem_numvar(TYPE_ITER,1);\n      }\n      ip2->x = ip2->b = NULL;\n      ip2->shared_x = ip2->shared_x = FALSE;\n   }\n\n   x = ip2->x;\n   b = ip2->b;\n   shb = ip2->shared_b;\n   shx = ip2->shared_x;\n   MEM_COPY(ip1,ip2,sizeof(ITER));\n   ip2->x = x;\n   ip2->b = b;\n   ip2->shared_x = shx;\n   ip2->shared_b = shb;\n\n   return ip2;\n}\n\n\n/* copy the structure ip1 to ip2 copying also the vectors x and b */\n#ifndef ANSI_C\nITER *iter_copy(ip1,ip2)\nITER *ip1, *ip2;\n#else\nITER *iter_copy(const ITER *ip1, ITER *ip2)\n#endif\n{\n   VEC *x, *b;\n\n   if (ip1 == (ITER *)NULL) \n     error(E_NULL,"iter_copy");\n\n   if (ip2 == (ITER *)NULL) {\n      if ((ip2 = NEW(ITER)) == (ITER *) NULL)\n	error(E_MEM,"iter_copy2");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ITER,0,sizeof(ITER));\n	 mem_numvar(TYPE_ITER,1);\n      }\n   }\n\n   x = ip2->x;\n   b = ip2->b;\n\n   MEM_COPY(ip1,ip2,sizeof(ITER));\n   if (ip1->x)\n     ip2->x = v_copy(ip1->x,x);\n   if (ip1->b)\n     ip2->b = v_copy(ip1->b,b);\n\n   ip2->shared_x = ip2->shared_b = FALSE;\n\n   return ip2;\n}\n\n\n/*** functions to generate sparse matrices with random entries ***/\n\n\n/* iter_gen_sym -- generate symmetric positive definite\n   n x n matrix, \n   nrow - number of nonzero entries in a row\n   */\n#ifndef ANSI_C\nSPMAT	*iter_gen_sym(n,nrow)\nint	n, nrow;\n#else\nSPMAT	*iter_gen_sym(int n, int nrow)\n#endif\n{\n   SPMAT	*A;\n   VEC	        *u;\n   Real       s1;\n   int		i, j, k, k_max;\n   \n   if (nrow <= 1) nrow = 2;\n   /* nrow should be even */\n   if ((nrow & 1)) nrow -= 1;\n   A = sp_get(n,n,nrow);\n   u = v_get(A->m);\n   v_zero(u);\n   for ( i = 0; i < A->m; i++ )\n   {\n      k_max = ((rand() >> 8) % (nrow/2));\n      for ( k = 0; k <= k_max; k++ )\n      {\n	 j = (rand() >> 8) % A->n;\n	 s1 = mrand();\n	 sp_set_val(A,i,j,s1);\n	 sp_set_val(A,j,i,s1);\n	 u->ve[i] += fabs(s1);\n	 u->ve[j] += fabs(s1);\n      }\n   }\n   /* ensure that A is positive definite */\n   for ( i = 0; i < A->m; i++ )\n     sp_set_val(A,i,i,u->ve[i] + 1.0);\n   \n   V_FREE(u);\n   return A;\n}\n\n\n/* iter_gen_nonsym -- generate non-symmetric m x n sparse matrix, m >= n \n   nrow - number of entries in a row;\n   diag - number which is put in diagonal entries and then permuted\n   (if diag is zero then 1.0 is there)\n*/\n#ifndef ANSI_C\nSPMAT	*iter_gen_nonsym(m,n,nrow,diag)\nint	m, n, nrow;\ndouble diag;\n#else\nSPMAT	*iter_gen_nonsym(int m, int n, int nrow, double diag)\n#endif\n{\n   SPMAT	*A;\n   PERM		*px;\n   int		i, j, k, k_max;\n   Real		s1;\n   \n   if (nrow <= 1) nrow = 2;\n   if (diag == 0.0) diag = 1.0;\n   A = sp_get(m,n,nrow);\n   px = px_get(n);\n   for ( i = 0; i < A->m; i++ )\n   {\n      k_max = (rand() >> 8) % (nrow-1);\n      for ( k = 0; k <= k_max; k++ )\n      {\n	 j = (rand() >> 8) % A->n;\n	 s1 = mrand();\n	 sp_set_val(A,i,j,-s1);\n      }\n   }\n   /* to make it likely that A is nonsingular, use pivot... */\n   for ( i = 0; i < 2*A->n; i++ )\n   {\n      j = (rand() >> 8) % A->n;\n      k = (rand() >> 8) % A->n;\n      px_transp(px,j,k);\n   }\n   for ( i = 0; i < A->n; i++ )\n     sp_set_val(A,i,px->pe[i],diag);  \n   \n   PX_FREE(px);\n   return A;\n}\n\n#if ( 0 )\n/* iter_gen_nonsym -- generate non-symmetric positive definite \n   n x n sparse matrix;\n   nrow - number of entries in a row\n*/\n#ifndef ANSI_C\nSPMAT	*iter_gen_nonsym_posdef(n,nrow)\nint	n, nrow;\n#else\nSPMAT	*iter_gen_nonsym(int m, int n, int nrow, double diag)\n#endif\n{\n   SPMAT	*A;\n   PERM		*px;\n   VEC          *u;\n   int		i, j, k, k_max;\n   Real		s1;\n   \n   if (nrow <= 1) nrow = 2;\n   A = sp_get(n,n,nrow);\n   px = px_get(n);\n   u = v_get(A->m);\n   v_zero(u);\n   for ( i = 0; i < A->m; i++ )\n   {\n      k_max = (rand() >> 8) % (nrow-1);\n      for ( k = 0; k <= k_max; k++ )\n      {\n	 j = (rand() >> 8) % A->n;\n	 s1 = mrand();\n	 sp_set_val(A,i,j,-s1);\n	 u->ve[i] += fabs(s1);\n      }\n   }\n   /* ensure that A is positive definite */\n   for ( i = 0; i < A->m; i++ )\n     sp_set_val(A,i,i,u->ve[i] + 1.0);\n   \n   PX_FREE(px);\n   V_FREE(u);\n   return A;\n}\n#endif\n\n\n\n\n