\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*  iter_tort.c  16/09/93 */\n\n/*\n  This file contains tests for the iterative part of Meschach\n*/\n\n#include	<stdio.h>\n#include	"matrix2.h"\n#include	"sparse2.h"\n#include	"iter.h"\n#include	<math.h>\n\n#define	errmesg(mesg)	printf("Error: %s error: line %d\n",mesg,__LINE__)\n#define notice(mesg)	printf("# Testing %s...\n",mesg);\n  \n  /* for iterative methods */\n  \n#if REAL == DOUBLE\n#define	EPS	1e-7\n#define KK	20\n#elif REAL == FLOAT\n#define EPS   1e-5\n#define KK	8\n#endif\n\n#define ANON  513\n#define ASYM  ANON   \n\n  \nstatic VEC *ex_sol = VNULL;\n\n/* new iter information */\nvoid iter_mod_info(ip,nres,res,Bres)\nITER *ip;\ndouble nres;\nVEC *res, *Bres;\n{\n   static VEC *tmp;\n\n   if (ip->b == VNULL) return;\n   tmp = v_resize(tmp,ip->b->dim);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n\n   if (nres >= 0.0) {\n      printf(" %d. residual = %g\n",ip->steps,nres);\n   }\n   else \n     printf(" %d. residual = %g (WARNING !!! should be >= 0) \n",\n	    ip->steps,nres);\n   if (ex_sol != VNULL)\n     printf("    ||u_ex - u_approx||_2 = %g\n",\n	    v_norm2(v_sub(ip->x,ex_sol,tmp)));\n}\n\n\n/* out = A^T*A*x */\nVEC *norm_equ(A,x,out)\nSPMAT *A;\nVEC *x, *out;\n{\n   static VEC * tmp;\n\n   tmp = v_resize(tmp,x->dim);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n   sp_mv_mlt(A,x,tmp);\n   sp_vm_mlt(A,tmp,out);\n   return out;\n\n}\n\n\n/* \n  make symmetric preconditioner for nonsymmetric matrix A;\n   B = 0.5*(A+A^T) and then B is factorized using \n   incomplete Choleski factorization\n*/\n\nSPMAT *gen_sym_precond(A)\nSPMAT *A;\n{\n   SPMAT *B;\n   SPROW *row;\n   int i,j,k;\n   Real val;\n   \n   B = sp_get(A->m,A->n,A->row[0].maxlen);\n   for (i=0; i < A->m; i++) {\n      row = &(A->row[i]);\n      for (j = 0; j < row->len; j++) {\n	k = row->elt[j].col;\n	if (i != k) {\n	   val = 0.5*(sp_get_val(A,i,k) + sp_get_val(A,k,i));\n	   sp_set_val(B,i,k,val);\n	   sp_set_val(B,k,i,val);\n	}\n	else { /* i == k */\n	  val = sp_get_val(A,i,i);\n	  sp_set_val(B,i,i,val);\n       }\n     }\n   }\n\n   spICHfactor(B);\n   return B;\n}\n\n/* Dv_mlt -- diagonal by vector multiply; the diagonal matrix is represented\n		by a vector d */\nVEC	*Dv_mlt(d, x, out)\nVEC	*d, *x, *out;\n{\n    int		i;\n\n    if ( ! d || ! x )\n	error(E_NULL,"Dv_mlt");\n    if ( d->dim != x->dim )\n	error(E_SIZES,"Dv_mlt");\n    out = v_resize(out,x->dim);\n\n    for ( i = 0; i < x->dim; i++ )\n	out->ve[i] = d->ve[i]*x->ve[i];\n\n    return out;\n}\n\n\n\n/************************************************/\nvoid	main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n   VEC		*x, *y, *z, *u, *v, *xn, *yn;\n   SPMAT	*A = NULL, *B = NULL;\n   SPMAT	*An = NULL, *Bn = NULL;\n   int		i, k, kk, j;\n   ITER        *ips, *ips1, *ipns, *ipns1;\n   MAT         *Q, *H, *Q1, *H1;\n   VEC         vt, vt1;\n   Real        hh;\n\n\n   mem_info_on(TRUE);\n   notice("allocating sparse matrices");\n   \n   printf(" dim of A = %dx%d\n",ASYM,ASYM);\n   \n   A = iter_gen_sym(ASYM,8);   \n   B = sp_copy(A);\n   spICHfactor(B);\n   \n   u = v_get(A->n);\n   x = v_get(A->n);\n   y = v_get(A->n);\n   v = v_get(A->n);\n\n   v_rand(x);\n   sp_mv_mlt(A,x,y);\n   ex_sol = x;\n   \n   notice(" initialize ITER variables");\n   /* ips for symmetric matrices with precondition */\n   ips = iter_get(A->m,A->n);\n\n   /*  printf(" ips:\n");\n   iter_dump(stdout,ips);   */\n\n   ips->limit = 500;\n   ips->eps = EPS;\n   \n   iter_Ax(ips,sp_mv_mlt,A);\n   iter_Bx(ips,spCHsolve,B);\n\n   ips->b = v_copy(y,ips->b);\n   v_rand(ips->x);\n   /* test of iter_resize */\n   ips = iter_resize(ips,2*A->m,2*A->n);\n   ips = iter_resize(ips,A->m,A->n);\n\n   /*  printf(" ips:\n");\n   iter_dump(stdout,ips); */\n   \n   /* ips1 for symmetric matrices without precondition */\n   ips1 = iter_get(0,0);\n   /*   printf(" ips1:\n");\n   iter_dump(stdout,ips1);   */\n   ITER_FREE(ips1);\n\n   ips1 = iter_copy2(ips,ips1);\n   iter_Bx(ips1,NULL,NULL);\n   ips1->b = ips->b;\n   ips1->shared_b = TRUE;\n   /*    printf(" ips1:\n");\n   iter_dump(stdout,ips1);   */\n\n   /* ipns for nonsymetric matrices with precondition */\n   ipns = iter_copy(ips,INULL);\n   ipns->k = KK;\n   ipns->limit = 500;\n   ipns->info = NULL;\n\n   An = iter_gen_nonsym_posdef(ANON,8);   \n   Bn = gen_sym_precond(An);\n   xn = v_get(An->n);\n   yn = v_get(An->n);\n   v_rand(xn);\n   sp_mv_mlt(An,xn,yn);\n   ipns->b = v_copy(yn,ipns->b);\n\n   iter_Ax(ipns, sp_mv_mlt,An);\n   iter_ATx(ipns, sp_vm_mlt,An);\n   iter_Bx(ipns, spCHsolve,Bn);\n\n   /*  printf(" ipns:\n");\n   iter_dump(stdout,ipns); */\n   \n   /* ipns1 for nonsymmetric matrices without precondition */\n   ipns1 = iter_copy2(ipns,INULL);\n   ipns1->b = ipns->b;\n   ipns1->shared_b = TRUE;\n   iter_Bx(ipns1,NULL,NULL);\n\n   /*   printf(" ipns1:\n");\n   iter_dump(stdout,ipns1);  */\n\n\n   /*******  CG  ********/\n\n   notice(" CG method without preconditioning");\n   ips1->info = NULL;\n   mem_stat_mark(1);\n   iter_cg(ips1);\n\n   k = ips1->steps;\n   z = ips1->x;\n   printf(" cg: no. of iter.steps = %d\n",k);\n   v_sub(z,x,u);\n   printf(" (cg:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n",\n	  v_norm2(u),EPS);\n   \n   notice(" CG method with ICH preconditioning");\n\n   ips->info = NULL;\n   v_zero(ips->x);  \n   iter_cg(ips);  \n\n   k = ips->steps;\n   printf(" cg: no. of iter.steps = %d\n",k);\n   v_sub(ips->x,x,u);\n   printf(" (cg:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n",\n	  v_norm2(u),EPS);\n   \n   V_FREE(v);\n   if ((v = iter_spcg(A,B,y,EPS,VNULL,1000,&k)) == VNULL)\n     errmesg("CG method with precond.: NULL solution"); \n   \n   v_sub(ips->x,v,u);\n   if (v_norm2(u) >= EPS) {\n      errmesg("CG method with precond.: different solutions");\n      printf(" diff. = %g\n",v_norm2(u));\n   }   \n   \n\n   mem_stat_free(1);\n   printf(" spcg: # of iter. steps = %d\n",k);\n   v_sub(v,x,u);\n   printf(" (spcg:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(u),EPS);  \n\n\n   /***  CG FOR NORMAL EQUATION *****/\n\n   notice("CGNE method with ICH preconditioning (nonsymmetric case)");\n\n   /* ipns->info = iter_std_info;  */\n   ipns->info = NULL;\n   v_zero(ipns->x);\n \n   mem_stat_mark(1);\n   iter_cgne(ipns);\n\n   k = ipns->steps;\n   z = ipns->x;\n   printf(" cgne: no. of iter.steps = %d\n",k);\n   v_sub(z,xn,u);\n   printf(" (cgne:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(u),EPS);\n\n   notice("CGNE method without preconditioning (nonsymmetric case)");\n\n   v_rand(u);\n   u = iter_spcgne(An,NULL,yn,EPS,u,1000,&k);\n\n   mem_stat_free(1);\n   printf(" spcgne: no. of iter.steps = %d\n",k);\n   v_sub(u,xn,u);\n   printf(" (spcgne:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(u),EPS);\n\n   /***  CGS  *****/\n\n   notice("CGS method with ICH preconditioning (nonsymmetric case)");\n\n   v_zero(ipns->x);   /* new init guess == 0 */\n \n   mem_stat_mark(1);\n   ipns->info = NULL;\n   v_rand(u);\n   iter_cgs(ipns,u);\n\n   k = ipns->steps;\n   z = ipns->x;\n   printf(" cgs: no. of iter.steps = %d\n",k);\n   v_sub(z,xn,u);\n   printf(" (cgs:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(u),EPS);\n\n   notice("CGS method without preconditioning (nonsymmetric case)");\n\n   v_rand(u);\n   v_rand(v);\n   v = iter_spcgs(An,NULL,yn,u,EPS,v,1000,&k);\n\n   mem_stat_free(1);\n   printf(" cgs: no. of iter.steps = %d\n",k);\n   v_sub(v,xn,u);\n   printf(" (cgs:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(u),EPS);\n   \n\n\n   /*** LSQR ***/\n\n   notice("LSQR method (without preconditioning)");\n\n   v_rand(u);\n   v_free(ipns1->x);\n   ipns1->x = u;\n   ipns1->shared_x = TRUE;\n   ipns1->info = NULL;\n   mem_stat_mark(2);\n   z = iter_lsqr(ipns1);\n   \n   v_sub(xn,z,v);\n   k = ipns1->steps;\n   printf(" lsqr: # of iter. steps = %d\n",k);\n   printf(" (lsqr:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(v),EPS);\n\n   v_rand(u);\n   u = iter_splsqr(An,yn,EPS,u,1000,&k);\n   mem_stat_free(2);\n   \n   v_sub(xn,u,v);\n   printf(" splsqr: # of iter. steps = %d\n",k);\n   printf(" (splsqr:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n",	\n	  v_norm2(v),EPS);\n\n\n\n   /***** GMRES ********/\n\n   notice("GMRES method with ICH preconditioning (nonsymmetric case)");\n\n   v_zero(ipns->x);\n/*   ipns->info = iter_std_info;  */\n   ipns->info = NULL;  \n\n   mem_stat_mark(2);\n   z = iter_gmres(ipns);\n   v_sub(xn,z,v);\n   k = ipns->steps;\n   printf(" gmres: # of iter. steps = %d\n",k);\n   printf(" (gmres:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(v),EPS);\n\n   notice("GMRES method without preconditioning (nonsymmetric case)");\n   V_FREE(v);\n   v = iter_spgmres(An,NULL,yn,EPS,VNULL,10,1004,&k);\n   mem_stat_free(2);\n   \n   v_sub(xn,v,v);\n   printf(" spgmres: # of iter. steps = %d\n",k);\n   printf(" (spgmres:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(v),EPS);\n\n\n\n   /**** MGCR *****/\n\n   notice("MGCR method with ICH preconditioning (nonsymmetric case)");\n\n   v_zero(ipns->x);\n   mem_stat_mark(2);\n   z = iter_mgcr(ipns);\n   v_sub(xn,z,v);\n   k = ipns->steps;\n   printf(" mgcr: # of iter. steps = %d\n",k);\n   printf(" (mgcr:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n",\n	  v_norm2(v),EPS);\n\n   notice("MGCR method without  preconditioning (nonsymmetric case)");\n   V_FREE(v);\n   v = iter_spmgcr(An,NULL,yn,EPS,VNULL,10,1004,&k);\n   mem_stat_free(2);\n   \n   v_sub(xn,v,v);\n   printf(" spmgcr: # of iter. steps = %d\n",k);\n   printf(" (spmgcr:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n",\n	  v_norm2(v),EPS);\n\n\n   /***** ARNOLDI METHOD ********/\n\n\n   notice("arnoldi method");\n\n   kk = ipns1->k = KK;\n   Q = m_get(kk,x->dim);\n   Q1 = m_get(kk,x->dim);\n   H = m_get(kk,kk);\n   v_rand(u);\n   ipns1->x = u;\n   ipns1->shared_x = TRUE;\n   mem_stat_mark(3);\n   iter_arnoldi_iref(ipns1,&hh,Q,H);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt.max_dim = x->dim;\n   vt1.dim = vt1.max_dim = x->dim;\n   for (j=0; j < kk; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(An,&vt,&vt1);\n   }\n   H1 = m_get(kk,kk);\n   mmtr_mlt(Q,Q1,H1);\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (arnoldi_iref) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n   /* check Q*Q^T = I  */\n\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < kk; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (arnoldi_iref) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n   ipns1->x = u;\n   ipns1->shared_x = TRUE;\n   mem_stat_mark(3);\n   iter_arnoldi(ipns1,&hh,Q,H);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt.max_dim = x->dim;\n   vt1.dim = vt1.max_dim = x->dim;\n   for (j=0; j < kk; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(An,&vt,&vt1);\n   }\n\n   mmtr_mlt(Q,Q1,H1);\n   m_sub(H,H1,H1);\n  if (m_norm_inf(H1) > MACHEPS*x->dim)  \n     printf(" (arnoldi) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n   /* check Q*Q^T = I  */\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < kk; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (arnoldi) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n   v_rand(u);\n   mem_stat_mark(3);\n   iter_sparnoldi(An,u,kk,&hh,Q,H);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt.max_dim = x->dim;\n   vt1.dim = vt1.max_dim = x->dim;\n   for (j=0; j < kk; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(An,&vt,&vt1);\n   }\n\n   mmtr_mlt(Q,Q1,H1);\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (sparnoldi) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n   /* check Q*Q^T = I  */\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < kk; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (sparnoldi) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n\n\n   /****** LANCZOS METHOD ******/\n\n   notice("lanczos method");\n   kk = ipns1->k; \n   Q = m_resize(Q,kk,x->dim);\n   Q1 = m_resize(Q1,kk,x->dim);\n   H = m_resize(H,kk,kk);\n   ips1->k = kk;\n   v_rand(u);\n   v_free(ips1->x);\n   ips1->x = u;\n   ips1->shared_x = TRUE;\n\n   mem_stat_mark(3);\n   iter_lanczos(ips1,x,y,&hh,Q);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt1.dim = Q->n;\n   vt.max_dim = vt1.max_dim = Q->max_n;\n   Q1 = m_resize(Q1,Q->m,Q->n);\n   for (j=0; j < Q->m; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(A,&vt,&vt1);\n   }\n   H1 = m_resize(H1,Q->m,Q->m);\n   H = m_resize(H,Q->m,Q->m);\n   mmtr_mlt(Q,Q1,H1);\n\n   m_zero(H);\n   for (j=0; j < Q->m-1; j++) {\n      H->me[j][j] = x->ve[j];\n      H->me[j][j+1] = H->me[j+1][j] = y->ve[j];\n   }\n   H->me[Q->m-1][Q->m-1] = x->ve[Q->m-1];\n\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (lanczos) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n   /* check Q*Q^T = I  */\n\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < Q->m; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (lanczos) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n   mem_stat_mark(3);\n   v_rand(u);\n   iter_splanczos(A,kk,u,x,y,&hh,Q);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt1.dim = Q->n;\n   vt.max_dim = vt1.max_dim = Q->max_n;\n   Q1 = m_resize(Q1,Q->m,Q->n);\n   for (j=0; j < Q->m; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(A,&vt,&vt1);\n   }\n   H1 = m_resize(H1,Q->m,Q->m);\n   H = m_resize(H,Q->m,Q->m);\n   mmtr_mlt(Q,Q1,H1);\n   for (j=0; j < Q->m-1; j++) {\n      H->me[j][j] = x->ve[j];\n      H->me[j][j+1] = H->me[j+1][j] = y->ve[j];\n   }\n   H->me[Q->m-1][Q->m-1] = x->ve[Q->m-1];\n\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (splanczos) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n   /* check Q*Q^T = I  */\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < Q->m; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf(" (splanczos) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n",\n	    m_norm_inf(H1),MACHEPS);\n\n\n\n   /***** LANCZOS2 ****/\n\n   notice("lanczos2 method");\n   kk = 50;  		/* # of dir. vectors */\n   ips1->k = kk;\n   v_rand(u);\n   ips1->x = u;\n   ips1->shared_x = TRUE;\n\n   for ( i = 0; i < xn->dim; i++ )\n	xn->ve[i] = i;\n   iter_Ax(ips1,Dv_mlt,xn);\n   mem_stat_mark(3);\n   iter_lanczos2(ips1,y,v);\n   mem_stat_free(3);\n\n   printf("# Number of steps of Lanczos algorithm = %d\n", kk);\n   printf("# Exact eigenvalues are 0, 1, 2, ..., %d\n",ANON-1);\n   printf("# Extreme eigenvalues should be accurate; \n");\n   printf("# interior values usually are not.\n");\n   printf("# approx e-vals =\n");	v_output(y);\n   printf("# Error in estimate of bottom e-vec (Lanczos) = %g\n",\n	  fabs(v->ve[0]));\n\n   mem_stat_mark(3);\n   v_rand(u);\n   iter_splanczos2(A,kk,u,y,v);\n   mem_stat_free(3);\n\n\n   /***** FINISHING *******/\n\n   notice("release ITER variables");\n   \n   M_FREE(Q);\n   M_FREE(Q1);\n   M_FREE(H);\n   M_FREE(H1);\n\n   ITER_FREE(ipns);\n   ITER_FREE(ips);\n   ITER_FREE(ipns1);\n   ITER_FREE(ips1);\n   SP_FREE(A);\n   SP_FREE(B);\n   SP_FREE(An);\n   SP_FREE(Bn);\n   \n   V_FREE(x);\n   V_FREE(y);\n   V_FREE(u);\n   V_FREE(v); \n   V_FREE(xn);\n   V_FREE(yn);\n\n   printf("# Done testing (%s)\n",argv[0]);\n   mem_info();\n}\n