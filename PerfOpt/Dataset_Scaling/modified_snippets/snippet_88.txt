\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  Sparse matrix Bunch--Kaufman--Parlett factorisation and solve\n  Radical revision started Thu 05th Nov 1992, 09:36:12 AM\n  to use Karen George's suggestion of leaving the the row elements unordered\n  Radical revision completed Mon 07th Dec 1992, 10:59:57 AM\n*/\n\nstatic	char	rcsid[] = "$Id: spbkp.c,v 1.6 1996/08/20 19:53:10 stewart Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "sparse2.h"\n\n\n#ifdef MALLOCDECL\n#include <malloc.h>\n#endif\n\n#define alpha	0.6403882032022076 /* = (1+sqrt(17))/8 */\n\n\n#define	btos(x)	((x) ? "TRUE" : "FALSE")\n\n/* assume no use of sqr() uses side-effects */\n#define	sqr(x)	((x)*(x))\n\n/* unord_get_idx -- returns index (encoded if entry not allocated)\n	of the element of row r with column j\n	-- uses linear search */\n#ifndef ANSI_C\nint	unord_get_idx(r,j)\nSPROW	*r;\nint	j;\n#else\nint	unord_get_idx(SPROW *r, int j)\n#endif\n{\n    int		idx;\n    row_elt	*e;\n\n    if ( ! r || ! r->elt )\n	error(E_NULL,"unord_get_idx");\n    for ( idx = 0, e = r->elt; idx < r->len; idx++, e++ )\n	if ( e->col == j )\n	    break;\n    if ( idx >= r->len )\n	return -(r->len+2);\n    else\n	return idx;\n}\n\n/* unord_get_val -- returns value of the (i,j) entry of A\n	-- same assumptions as unord_get_idx() */\n#ifndef ANSI_C\ndouble	unord_get_val(A,i,j)\nSPMAT	*A;\nint	i, j;\n#else\ndouble	unord_get_val(SPMAT *A, int i, int j)\n#endif\n{\n    SPROW	*r;\n    int		idx;\n\n    if ( ! A )\n	error(E_NULL,"unord_get_val");\n    if ( i < 0 || i >= A->m || j < 0 || j >= A->n )\n	error(E_BOUNDS,"unord_get_val");\n\n    r = &(A->row[i]);\n    idx = unord_get_idx(r,j);\n    if ( idx < 0 )\n	return 0.0;\n    else\n	return r->elt[idx].val;\n}\n\n	    \n/* bkp_swap_elt -- swaps the (i,j) with the (k,l) entry of sparse matrix\n	-- either or both of the entries may be unallocated */\n#ifndef ANSI_C\nstatic SPMAT	*bkp_swap_elt(A,i1,j1,idx1,i2,j2,idx2)\nSPMAT	*A;\nint	i1, j1, idx1, i2, j2, idx2;\n#else\nstatic SPMAT	*bkp_swap_elt(SPMAT *A, int i1, int j1, \n			      int idx1, int i2, int j2, int idx2)\n#endif\n{\n    int		tmp_row, tmp_idx;\n    SPROW	*r1, *r2;\n    row_elt	*e1, *e2;\n    Real	tmp;\n\n    if ( ! A )\n	error(E_NULL,"bkp_swap_elt");\n\n    if ( i1 < 0 || j1 < 0 || i2 < 0 || j2 < 0 ||\n	 i1 >= A->m || j1 >= A->n || i2 >= A->m || j2 >= A->n )\n    {\n	error(E_BOUNDS,"bkp_swap_elt");\n    }\n\n    if ( i1 == i2 && j1 == j2 )\n	return A;\n    if ( idx1 < 0 && idx2 < 0 )	/* neither allocated */\n	return A;\n\n    r1 = &(A->row[i1]);		r2 = &(A->row[i2]);\n    /* if ( idx1 >= r1->len || idx2 >= r2->len )\n	error(E_BOUNDS,"bkp_swap_elt"); */\n    if ( idx1 < 0 )	/* assume not allocated */\n    {\n	idx1 = r1->len;\n	if ( idx1 >= r1->maxlen )\n	{    tracecatch(sprow_xpd(r1,2*r1->maxlen+1,TYPE_SPMAT),\n			"bkp_swap_elt");	}\n	r1->len = idx1+1;\n	r1->elt[idx1].col = j1;\n	r1->elt[idx1].val = 0.0;\n	/* now patch up column access path */\n	tmp_row = -1;	tmp_idx = j1;\n	chase_col(A,j1,&tmp_row,&tmp_idx,i1-1);\n\n	if ( tmp_row < 0 )\n	{\n	    r1->elt[idx1].nxt_row = A->start_row[j1];\n	    r1->elt[idx1].nxt_idx = A->start_idx[j1];\n	    A->start_row[j1] = i1;\n	    A->start_idx[j1] = idx1;\n	}\n	else\n	{\n	    row_elt	*tmp_e;\n\n	    tmp_e = &(A->row[tmp_row].elt[tmp_idx]);\n	    r1->elt[idx1].nxt_row = tmp_e->nxt_row;\n	    r1->elt[idx1].nxt_idx = tmp_e->nxt_idx;\n	    tmp_e->nxt_row = i1;\n	    tmp_e->nxt_idx = idx1;\n	}\n    }\n    else if ( r1->elt[idx1].col != j1 )\n	error(E_INTERN,"bkp_swap_elt");\n    if ( idx2 < 0 )\n    {\n	idx2 = r2->len;\n	if ( idx2 >= r2->maxlen )\n	{    tracecatch(sprow_xpd(r2,2*r2->maxlen+1,TYPE_SPMAT),\n			"bkp_swap_elt");	}\n\n	r2->len = idx2+1;\n	r2->elt[idx2].col = j2;\n	r2->elt[idx2].val = 0.0;\n	/* now patch up column access path */\n	tmp_row = -1;	tmp_idx = j2;\n	chase_col(A,j2,&tmp_row,&tmp_idx,i2-1);\n	if ( tmp_row < 0 )\n	{\n	    r2->elt[idx2].nxt_row = A->start_row[j2];\n	    r2->elt[idx2].nxt_idx = A->start_idx[j2];\n	    A->start_row[j2] = i2;\n	    A->start_idx[j2] = idx2;\n	}\n	else\n	{\n	    row_elt	*tmp_e;\n\n	    tmp_e = &(A->row[tmp_row].elt[tmp_idx]);\n	    r2->elt[idx2].nxt_row = tmp_e->nxt_row;\n	    r2->elt[idx2].nxt_idx = tmp_e->nxt_idx;\n	    tmp_e->nxt_row = i2;\n	    tmp_e->nxt_idx = idx2;\n	}\n    }\n    else if ( r2->elt[idx2].col != j2 )\n	error(E_INTERN,"bkp_swap_elt");\n\n    e1 = &(r1->elt[idx1]);	e2 = &(r2->elt[idx2]);\n\n    tmp = e1->val;\n    e1->val = e2->val;\n    e2->val = tmp;\n\n    return A;\n}\n\n/* bkp_bump_col -- bumps row and idx to next entry in column j */\n#ifndef ANSI_C\nrow_elt	*bkp_bump_col(A, j, row, idx)\nSPMAT	*A;\nint	j, *row, *idx;\n#else\nrow_elt	*bkp_bump_col(SPMAT *A, int j, int *row, int *idx)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( *row < 0 )\n    {\n	*row = A->start_row[j];\n	*idx = A->start_idx[j];\n    }\n    else\n    {\n	r = &(A->row[*row]);\n	e = &(r->elt[*idx]);\n	if ( e->col != j )\n	    error(E_INTERN,"bkp_bump_col");\n	*row = e->nxt_row;\n	*idx = e->nxt_idx;\n    }\n    if ( *row < 0 )\n	return (row_elt *)NULL;\n    else\n	return &(A->row[*row].elt[*idx]);\n}\n\n/* bkp_interchange -- swap rows/cols i and j (symmetric pivot)\n	-- uses just the upper triangular part */\n#ifndef ANSI_C\nSPMAT	*bkp_interchange(A, i1, i2)\nSPMAT	*A;\nint	i1, i2;\n#else\nSPMAT	*bkp_interchange(SPMAT *A, int i1, int i2)\n#endif\n{\n    int		tmp_row, tmp_idx;\n    int		row1, row2, idx1, idx2, tmp_row1, tmp_idx1, tmp_row2, tmp_idx2;\n    SPROW	*r1, *r2;\n    row_elt	*e1, *e2;\n    IVEC	*done_list = IVNULL;\n\n    if ( ! A )\n	error(E_NULL,"bkp_interchange");\n    if ( i1 < 0 || i1 >= A->n || i2 < 0 || i2 >= A->n )\n	error(E_BOUNDS,"bkp_interchange");\n    if ( A->m != A->n )\n	error(E_SQUARE,"bkp_interchange");\n\n    if ( i1 == i2 )\n	return A;\n    if ( i1 > i2 )\n    {	tmp_idx = i1;	i1 = i2;	i2 = tmp_idx;	}\n\n    done_list = iv_resize(done_list,A->n);\n    for ( tmp_idx = 0; tmp_idx < A->n; tmp_idx++ )\n	done_list->ive[tmp_idx] = FALSE;\n    row1 = -1;		idx1 = i1;\n    row2 = -1;		idx2 = i2;\n    e1 = bkp_bump_col(A,i1,&row1,&idx1);\n    e2 = bkp_bump_col(A,i2,&row2,&idx2);\n\n    while ( (row1 >= 0 && row1 < i1) || (row2 >= 0 && row2 < i1) )\n	/* Note: "row2 < i1" not "row2 < i2" as we must stop before the\n	   "knee bend" */\n    {\n	if ( row1 >= 0 && row1 < i1 && ( row1 < row2 || row2 < 0 ) )\n	{\n	    tmp_row1 = row1;	tmp_idx1 = idx1;\n	    e1 = bkp_bump_col(A,i1,&tmp_row1,&tmp_idx1);\n	    if ( ! done_list->ive[row1] )\n	    {\n		if ( row1 == row2 )\n		    bkp_swap_elt(A,row1,i1,idx1,row1,i2,idx2);\n		else\n		    bkp_swap_elt(A,row1,i1,idx1,row1,i2,-1);\n		done_list->ive[row1] = TRUE;\n	    }\n	    row1 = tmp_row1;	idx1 = tmp_idx1;\n	}\n	else if ( row2 >= 0 && row2 < i1 && ( row2 < row1 || row1 < 0 ) )\n	{\n	    tmp_row2 = row2;	tmp_idx2 = idx2;\n	    e2 = bkp_bump_col(A,i2,&tmp_row2,&tmp_idx2);\n	    if ( ! done_list->ive[row2] )\n	    {\n		if ( row1 == row2 )\n		    bkp_swap_elt(A,row2,i1,idx1,row2,i2,idx2);\n		else\n		    bkp_swap_elt(A,row2,i1,-1,row2,i2,idx2);\n		done_list->ive[row2] = TRUE;\n	    }\n	    row2 = tmp_row2;	idx2 = tmp_idx2;\n	}\n	else if ( row1 == row2 )\n	{\n	    tmp_row1 = row1;	tmp_idx1 = idx1;\n	    e1 = bkp_bump_col(A,i1,&tmp_row1,&tmp_idx1);\n	    tmp_row2 = row2;	tmp_idx2 = idx2;\n	    e2 = bkp_bump_col(A,i2,&tmp_row2,&tmp_idx2);\n	    if ( ! done_list->ive[row1] )\n	    {\n		bkp_swap_elt(A,row1,i1,idx1,row2,i2,idx2);\n		done_list->ive[row1] = TRUE;\n	    }\n	    row1 = tmp_row1;	idx1 = tmp_idx1;\n	    row2 = tmp_row2;	idx2 = tmp_idx2;\n	}\n    }\n\n    /* ensure we are **past** the first knee */\n    while ( row2 >= 0 && row2 <= i1 )\n	e2 = bkp_bump_col(A,i2,&row2,&idx2);\n\n    /* at/after 1st "knee bend" */\n    r1 = &(A->row[i1]);\n    idx1 = 0;\n    e1 = &(r1->elt[idx1]);\n    while ( row2 >= 0 && row2 < i2 )\n    {\n	/* used for update of e2 at end of loop */\n	tmp_row = row2;	tmp_idx = idx2;\n	if ( ! done_list->ive[row2] )\n	{\n	    r2 = &(A->row[row2]);\n	    bkp_bump_col(A,i2,&tmp_row,&tmp_idx);\n	    done_list->ive[row2] = TRUE;\n	    tmp_idx1 = unord_get_idx(r1,row2);\n	    tracecatch(bkp_swap_elt(A,row2,i2,idx2,i1,row2,tmp_idx1),\n		       "bkp_interchange");\n	}\n\n	/* update e1 and e2 */\n	row2 = tmp_row;	idx2 = tmp_idx;\n	e2 = ( row2 >= 0 ) ? &(A->row[row2].elt[idx2]) : (row_elt *)NULL;\n    }\n\n    idx1 = 0;\n    e1 = r1->elt;\n    while ( idx1 < r1->len )\n    {\n	if ( e1->col >= i2 || e1->col <= i1 )\n	{\n	    idx1++;\n	    e1++;\n	    continue;\n	}\n	if ( ! done_list->ive[e1->col] )\n	{\n	    tmp_idx2 = unord_get_idx(&(A->row[e1->col]),i2);\n	    tracecatch(bkp_swap_elt(A,i1,e1->col,idx1,e1->col,i2,tmp_idx2),\n		       "bkp_interchange");\n	    done_list->ive[e1->col] = TRUE;\n	}\n	idx1++;\n	e1++;\n    }\n\n    /* at/after 2nd "knee bend" */\n    idx1 = 0;\n    e1 = &(r1->elt[idx1]);\n    r2 = &(A->row[i2]);\n    idx2 = 0;\n    e2 = &(r2->elt[idx2]);\n    while ( idx1 < r1->len )\n    {\n	if ( e1->col <= i2 )\n	{\n	    idx1++;	e1++;\n	    continue;\n	}\n	if ( ! done_list->ive[e1->col] )\n	{\n	    tmp_idx2 = unord_get_idx(r2,e1->col);\n	    tracecatch(bkp_swap_elt(A,i1,e1->col,idx1,i2,e1->col,tmp_idx2),\n		       "bkp_interchange");\n	    done_list->ive[e1->col] = TRUE;\n	}\n	idx1++;	e1++;\n    }\n\n    idx2 = 0;	e2 = r2->elt;\n    while ( idx2 < r2->len )\n    {\n	if ( e2->col <= i2 )\n	{\n	    idx2++;	e2++;\n	    continue;\n	}\n	if ( ! done_list->ive[e2->col] )\n	{\n	    tmp_idx1 = unord_get_idx(r1,e2->col);\n	    tracecatch(bkp_swap_elt(A,i2,e2->col,idx2,i1,e2->col,tmp_idx1),\n		       "bkp_interchange");\n	    done_list->ive[e2->col] = TRUE;\n	}\n	idx2++;	e2++;\n    }\n\n    /* now interchange the digonal entries! */\n    idx1 = unord_get_idx(&(A->row[i1]),i1);\n    idx2 = unord_get_idx(&(A->row[i2]),i2);\n    if ( idx1 >= 0 || idx2 >= 0 )\n    {\n	tracecatch(bkp_swap_elt(A,i1,i1,idx1,i2,i2,idx2),\n		   "bkp_interchange");\n    }\n\n    return A;\n}\n\n\n/* iv_min -- returns minimum of an integer vector\n   -- sets index to the position in iv if index != NULL */\n#ifndef ANSI_C\nint	iv_min(iv,index)\nIVEC	*iv;\nint	*index;\n#else\nint	iv_min(IVEC *iv, int *index)\n#endif\n{\n    int		i, i_min, min_val, tmp;\n    \n    if ( ! iv ) \n	error(E_NULL,"iv_min");\n    if ( iv->dim <= 0 )\n	error(E_SIZES,"iv_min");\n    i_min = 0;\n    min_val = iv->ive[0];\n    for ( i = 1; i < iv->dim; i++ )\n    {\n	tmp = iv->ive[i];\n	if ( tmp < min_val )\n	{\n	    min_val = tmp;\n	    i_min = i;\n	}\n    }\n    \n    if ( index != (int *)NULL )\n	*index = i_min;\n    \n    return min_val;\n}\n\n/* max_row_col -- returns max { |A[j][k]| : k >= i, k != j, k != l } given j\n	using symmetry and only the upper triangular part of A */\n#ifndef ANSI_C\nstatic double max_row_col(A,i,j,l)\nSPMAT	*A;\nint	i, j, l;\n#else\nstatic double max_row_col(SPMAT *A, int i,int j, int l)\n#endif\n{\n    int		row_num, idx;\n    SPROW	*r;\n    row_elt	*e;\n    Real	max_val, tmp;\n\n    if ( ! A )\n	error(E_NULL,"max_row_col");\n    if ( i < 0 || i > A->n || j < 0 || j >= A->n )\n	error(E_BOUNDS,"max_row_col");\n\n    max_val = 0.0;\n\n    idx = unord_get_idx(&(A->row[i]),j);\n    if ( idx < 0 )\n    {\n	row_num = -1;	idx = j;\n	e = chase_past(A,j,&row_num,&idx,i);\n    }\n    else\n    {\n	row_num = i;\n	e = &(A->row[i].elt[idx]);\n    }\n    while ( row_num >= 0 && row_num < j )\n    {\n	if ( row_num != l )\n	{\n	    tmp = fabs(e->val);\n	    if ( tmp > max_val )\n		max_val = tmp;\n	}\n	e = bump_col(A,j,&row_num,&idx);\n    }\n    r = &(A->row[j]);\n    for ( idx = 0, e = r->elt; idx < r->len; idx++, e++ )\n    {\n	if ( e->col > j && e->col != l )\n	{\n	    tmp = fabs(e->val);\n	    if ( tmp > max_val )\n		max_val = tmp;\n	}\n    }\n\n    return max_val;\n}\n\n/* nonzeros -- counts non-zeros in A */\n#ifndef ANSI_C\nstatic int	nonzeros(A)\nSPMAT	*A;\n#else\nstatic int	nonzeros(const SPMAT *A)\n#endif\n{\n    int		cnt, i;\n\n    if ( ! A )\n	return 0;\n    cnt = 0;\n    for ( i = 0; i < A->m; i++ )\n	cnt += A->row[i].len;\n\n    return cnt;\n}\n\n/* chk_col_access -- for spBKPfactor()\n	-- checks that column access path is OK */\n#ifndef ANSI_C\nint	chk_col_access(A)\nSPMAT	*A;\n#else\nint	chk_col_access(const SPMAT *A)\n#endif\n{\n    int		cnt_nz, j, row, idx;\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( ! A )\n	error(E_NULL,"chk_col_access");\n\n    /* count nonzeros as we go down columns */\n    cnt_nz = 0;\n    for ( j = 0; j < A->n; j++ )\n    {\n	row = A->start_row[j];\n	idx = A->start_idx[j];\n	while ( row >= 0 )\n	{\n	    if ( row >= A->m || idx < 0 )\n		return FALSE;\n	    r = &(A->row[row]);\n	    if ( idx >= r->len )\n		return FALSE;\n	    e = &(r->elt[idx]);\n	    if ( e->nxt_row >= 0 && e->nxt_row <= row )\n		return FALSE;\n	    row = e->nxt_row;\n	    idx = e->nxt_idx;\n	    cnt_nz++;\n	}\n    }\n\n    if ( cnt_nz != nonzeros(A) )\n	return FALSE;\n    else\n	return TRUE;\n}\n\n/* col_cmp -- compare two columns -- for sorting rows using qsort() */\n#ifndef ANSI_C\nstatic int	col_cmp(e1,e2)\nrow_elt	*e1, *e2;\n#else\nstatic int	col_cmp(const row_elt *e1, const row_elt *e2)\n#endif\n{\n    return e1->col - e2->col;\n}\n\n/* spBKPfactor -- sparse Bunch-Kaufman-Parlett factorisation of A in-situ\n   -- A is factored into the form P'AP = MDM' where \n   P is a permutation matrix, M lower triangular and D is block\n   diagonal with blocks of size 1 or 2\n   -- P is stored in pivot; blocks[i]==i iff D[i][i] is a block */\n#ifndef ANSI_C\nSPMAT	*spBKPfactor(A,pivot,blocks,tol)\nSPMAT	*A;\nPERM	*pivot, *blocks;\ndouble	tol;\n#else\nSPMAT	*spBKPfactor(SPMAT *A, PERM *pivot, PERM *blocks, double tol)\n#endif\n{\n    int		i, j, k, l, n, onebyone, r;\n    int		idx, idx1, idx_piv;\n    int		row_num;\n    int		best_deg, best_j, best_l, best_cost, mark_cost, deg, deg_j,\n			deg_l, ignore_deg;\n    int		list_idx, list_idx2, old_list_idx;\n    SPROW	*row, *r_piv, *r1_piv;\n    row_elt	*e, *e1;\n    Real	aii, aip1, aip1i;\n    Real	det, max_j, max_l, s, t;\n    STATIC IVEC	*scan_row = IVNULL, *scan_idx = IVNULL, *col_list = IVNULL,\n		*tmp_iv = IVNULL;\n    STATIC IVEC *deg_list = IVNULL;\n    STATIC IVEC	*orig_idx = IVNULL, *orig1_idx = IVNULL;\n    STATIC PERM	*order = PNULL;\n\n    if ( ! A || ! pivot || ! blocks )\n	error(E_NULL,"spBKPfactor");\n    if ( A->m != A->n )\n	error(E_SQUARE,"spBKPfactor");\n    if ( A->m != pivot->size || pivot->size != blocks->size )\n	error(E_SIZES,"spBKPfactor");\n    if ( tol <= 0.0 || tol > 1.0 )\n	error(E_RANGE,"spBKPfactor");\n    \n    n = A->n;\n    \n    px_ident(pivot);	px_ident(blocks);\n    sp_col_access(A);	sp_diag_access(A);\n    ignore_deg = FALSE;\n\n    deg_list = iv_resize(deg_list,n);\n    if ( order != NULL )\n      px_ident(order);\n    order = px_resize(order,n);\n    MEM_STAT_REG(deg_list,TYPE_IVEC);\n    MEM_STAT_REG(order,TYPE_PERM);\n\n    scan_row = iv_resize(scan_row,5);\n    scan_idx = iv_resize(scan_idx,5);\n    col_list = iv_resize(col_list,5);\n    orig_idx = iv_resize(orig_idx,5);\n    orig_idx = iv_resize(orig1_idx,5);\n    orig_idx = iv_resize(tmp_iv,5);\n    MEM_STAT_REG(scan_row,TYPE_IVEC);\n    MEM_STAT_REG(scan_idx,TYPE_IVEC);\n    MEM_STAT_REG(col_list,TYPE_IVEC);\n    MEM_STAT_REG(orig_idx,TYPE_IVEC);\n    MEM_STAT_REG(orig1_idx,TYPE_IVEC);\n    MEM_STAT_REG(tmp_iv,TYPE_IVEC);\n\n    for ( i = 0; i < n-1; i = onebyone ? i+1 : i+2 )\n    {\n	/* now we want to use a Markowitz-style selection rule for\n	   determining which rows to swap and whether to use\n	   1x1 or 2x2 pivoting */\n\n	/* get list of degrees of nodes */\n	deg_list = iv_resize(deg_list,n-i);\n	if ( ! ignore_deg )\n	    for ( j = i; j < n; j++ )\n		deg_list->ive[j-i] = 0;\n	else\n	{\n	    for ( j = i; j < n; j++ )\n		deg_list->ive[j-i] = 1;\n	    if ( i < n )\n		deg_list->ive[0] = 0;\n	}\n	order = px_resize(order,n-i);\n	px_ident(order);\n\n	if ( ! ignore_deg )\n	{\n	    for ( j = i; j < n; j++ )\n	    {\n		/* idx = sprow_idx(&(A->row[j]),j+1); */\n		/* idx = fixindex(idx); */\n		idx = 0;\n		row = &(A->row[j]);\n		e = &(row->elt[idx]);\n		/* deg_list->ive[j-i] += row->len - idx; */\n		for ( ; idx < row->len; idx++, e++ )\n		    if ( e->col >= i )\n			deg_list->ive[e->col - i]++;\n	    }\n	    /* now deg_list[k] == degree of node k+i */\n	    \n	    /* now sort them into increasing order */\n	    iv_sort(deg_list,order);\n	    /* now deg_list[idx] == degree of node i+order[idx] */\n	}\n\n	/* now we can chase through the nodes in order of increasing\n	   degree, picking out the ones that satisfy our stability\n	   criterion */\n	list_idx = 0;	r = -1;\n	best_j = best_l = -1;\n	for ( deg = 0; deg <= n; deg++ )\n	{\n	    Real	ajj, all, ajl;\n\n	    if ( list_idx >= deg_list->dim )\n		break;	/* That's all folks! */\n	    old_list_idx = list_idx;\n	    while ( list_idx < deg_list->dim &&\n		    deg_list->ive[list_idx] <= deg )\n	    {\n		j = i+order->pe[list_idx];\n		if ( j < i )\n		    continue;\n		/* can we use row/col j for a 1 x 1 pivot? */\n		/* find max_j = max_{k>=i} {|A[k][j]|,|A[j][k]|} */\n		ajj = fabs(unord_get_val(A,j,j));\n		if ( ajj == 0.0 )\n		{\n		    list_idx++;\n		    continue;	/* can't use this for 1 x 1 pivot */\n		}\n\n		max_j = max_row_col(A,i,j,-1);\n		if ( ajj >= tol/* *alpha */ *max_j )\n		{\n		    onebyone = TRUE;\n		    best_j = j;\n		    best_deg = deg_list->ive[list_idx];\n		    break;\n		}\n		list_idx++;\n	    }\n	    if ( best_j >= 0 )\n		break;\n	    best_cost = 2*n;	/* > any possible Markowitz cost (bound) */\n	    best_j = best_l = -1;\n	    list_idx = old_list_idx;\n	    while ( list_idx < deg_list->dim &&\n		    deg_list->ive[list_idx] <= deg )\n	    {\n		j = i+order->pe[list_idx];\n		ajj = fabs(unord_get_val(A,j,j));\n		for ( list_idx2 = 0; list_idx2 < list_idx; list_idx2++ )\n		{\n		    deg_j = deg;\n		    deg_l = deg_list->ive[list_idx2];\n		    l = i+order->pe[list_idx2];\n		    if ( l < i )\n			continue;\n		    /* try using rows/cols (j,l) for a 2 x 2 pivot block */\n		    all = fabs(unord_get_val(A,l,l));\n		    ajl = ( j > l ) ? fabs(unord_get_val(A,l,j)) :\n					   fabs(unord_get_val(A,j,l));\n		    det = fabs(ajj*all - ajl*ajl);\n		    if ( det == 0.0 )\n			continue;\n		    max_j = max_row_col(A,i,j,l);\n		    max_l = max_row_col(A,i,l,j);\n		    if ( tol*(all*max_j+ajl*max_l) < det &&\n			 tol*(ajl*max_j+ajj*max_l) < det )\n		    {\n			/* acceptably stable 2 x 2 pivot */\n			/* this is actually an overestimate of the\n			   Markowitz cost for choosing (j,l) */\n			mark_cost = (ajj == 0.0) ?\n			    ((all == 0.0) ? deg_j+deg_l : deg_j+2*deg_l) :\n				((all == 0.0) ? 2*deg_j+deg_l :\n				 2*(deg_j+deg_l));\n			if ( mark_cost < best_cost )\n			{\n			    onebyone = FALSE;\n			    best_cost = mark_cost;\n			    best_j = j;\n			    best_l = l;\n			    best_deg = deg_j;\n			}\n		    }\n		}\n		list_idx++;\n	    }\n	    if ( best_j >= 0 )\n		break;\n	}\n\n	if ( best_deg > (int)floor(0.8*(n-i)) )\n	    ignore_deg = TRUE;\n\n	/* now do actual interchanges */\n	if ( best_j >= 0 && onebyone )\n	{\n	    bkp_interchange(A,i,best_j);\n	    px_transp(pivot,i,best_j);\n	}\n	else if ( best_j >= 0 && best_l >= 0 && ! onebyone )\n	{\n	    if ( best_j == i || best_j == i+1 )\n	    {\n		if ( best_l == i || best_l == i+1 )\n		{\n		    /* no pivoting, but must update blocks permutation */\n		    px_transp(blocks,i,i+1);\n		    goto dopivot;\n		}\n		bkp_interchange(A,(best_j == i) ? i+1 : i,best_l);\n		px_transp(pivot,(best_j == i) ? i+1 : i,best_l);\n	    }\n	    else if ( best_l == i || best_l == i+1 )\n	    {\n		bkp_interchange(A,(best_l == i) ? i+1 : i,best_j);\n		px_transp(pivot,(best_l == i) ? i+1 : i,best_j);\n	    }\n	    else /* best_j & best_l outside i, i+1 */\n	    {\n		if ( i != best_j )\n		{\n		    bkp_interchange(A,i,best_j);\n		    px_transp(pivot,i,best_j);\n		}\n		if ( i+1 != best_l )\n		{\n		    bkp_interchange(A,i+1,best_l);\n		    px_transp(pivot,i+1,best_l);\n		}\n	    }\n	}\n	else	/* can't pivot &/or nothing to pivot */\n	    continue;\n\n	/* update blocks permutation */\n	if ( ! onebyone )\n	    px_transp(blocks,i,i+1);\n\n	dopivot:\n	if ( onebyone )\n	{\n	    int		idx_j, idx_k, s_idx, s_idx2;\n	    row_elt	*e_ij, *e_ik;\n\n	    r_piv = &(A->row[i]);\n	    idx_piv = unord_get_idx(r_piv,i);\n	    /* if idx_piv < 0 then aii == 0 and no pivoting can be done;\n	       -- this means that we should continue to the next iteration */\n	    if ( idx_piv < 0 )\n		continue;\n	    aii = r_piv->elt[idx_piv].val;\n	    if ( aii == 0.0 )\n		continue;\n\n	    /* for ( j = i+1; j < n; j++ )  { ... pivot step ... } */\n	    /* initialise scan_... etc for the 1 x 1 pivot */\n	    scan_row = iv_resize(scan_row,r_piv->len);\n	    scan_idx = iv_resize(scan_idx,r_piv->len);\n	    col_list = iv_resize(col_list,r_piv->len);\n	    orig_idx = iv_resize(orig_idx,r_piv->len);\n	    row_num = i;	s_idx = idx = 0;\n	    e = &(r_piv->elt[idx]);\n	    for ( idx = 0; idx < r_piv->len; idx++, e++ )\n	    {\n		if ( e->col < i )\n		    continue;\n		scan_row->ive[s_idx] = i;\n		scan_idx->ive[s_idx] = idx;\n		orig_idx->ive[s_idx] = idx;\n		col_list->ive[s_idx] = e->col;\n		s_idx++;\n	    }\n	    scan_row = iv_resize(scan_row,s_idx);\n	    scan_idx = iv_resize(scan_idx,s_idx);\n	    col_list = iv_resize(col_list,s_idx);\n	    orig_idx = iv_resize(orig_idx,s_idx);\n\n	    order = px_resize(order,scan_row->dim);\n	    px_ident(order);\n	    iv_sort(col_list,order);\n\n	    tmp_iv = iv_resize(tmp_iv,scan_row->dim);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_idx);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_row->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_row);\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n		tmp_iv->ive[idx] = orig_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,orig_idx);\n\n	    /* now do actual pivot */\n	    /* for ( j = i+1; j < n-1; j++ ) .... */\n\n	    for ( s_idx = 0; s_idx < scan_row->dim; s_idx++ )\n	    {\n		idx_j = orig_idx->ive[s_idx];\n		if ( idx_j < 0 )\n		    error(E_INTERN,"spBKPfactor");\n		e_ij = &(r_piv->elt[idx_j]);\n		j = e_ij->col;\n		if ( j < i+1 )\n		    continue;\n		scan_to(A,scan_row,scan_idx,col_list,j);\n\n		/* compute multiplier */\n		t = e_ij->val / aii;\n\n		/* for ( k = j; k < n; k++ ) { .... update A[j][k] .... } */\n		/* this is the row in which pivoting is done */\n		row = &(A->row[j]);\n		for ( s_idx2 = s_idx; s_idx2 < scan_row->dim; s_idx2++ )\n		{\n		    idx_k = orig_idx->ive[s_idx2];\n		    e_ik = &(r_piv->elt[idx_k]);\n		    k = e_ik->col;\n		    /* k >= j since col_list has been sorted */\n\n		    if ( scan_row->ive[s_idx2] == j )\n		    {	/* no fill-in -- can be done directly */\n			idx = scan_idx->ive[s_idx2];\n			/* idx = sprow_idx2(row,k,idx); */\n			row->elt[idx].val -= t*e_ik->val;\n		    }\n		    else\n		    {	/* fill-in -- insert entry & patch column */\n			int	old_row, old_idx;\n			row_elt	*old_e, *new_e;\n\n			old_row = scan_row->ive[s_idx2];\n			old_idx = scan_idx->ive[s_idx2];\n			/* old_idx = sprow_idx2(&(A->row[old_row]),k,old_idx); */\n\n			if ( old_idx < 0 )\n			    error(E_INTERN,"spBKPfactor");\n			/* idx = sprow_idx(row,k); */\n			/* idx = fixindex(idx); */\n			idx = row->len;\n\n			/* sprow_set_val(row,k,-t*e_ik->val); */\n			if ( row->len >= row->maxlen )\n			{ tracecatch(sprow_xpd(row,2*row->maxlen+1,TYPE_SPMAT),\n				     "spBKPfactor");		}\n\n			row->len = idx+1;\n\n			new_e = &(row->elt[idx]);\n			new_e->val = -t*e_ik->val;\n			new_e->col = k;\n\n			old_e = &(A->row[old_row].elt[old_idx]);\n			new_e->nxt_row = old_e->nxt_row;\n			new_e->nxt_idx = old_e->nxt_idx;\n			old_e->nxt_row = j;\n			old_e->nxt_idx = idx;\n		    }\n		}\n		e_ij->val = t;\n	    }\n	}\n	else /* onebyone == FALSE */\n	{	/* do 2 x 2 pivot */\n	    int	idx_k, idx1_k, s_idx, s_idx2;\n	    int	old_col;\n	    row_elt	*e_tmp;\n\n	    r_piv = &(A->row[i]);\n	    idx_piv = unord_get_idx(r_piv,i);\n	    aii = aip1i = 0.0;\n	    e_tmp = r_piv->elt;\n	    for ( idx_piv = 0; idx_piv < r_piv->len; idx_piv++, e_tmp++ )\n		if ( e_tmp->col == i )\n		    aii = e_tmp->val;\n	        else if ( e_tmp->col == i+1 )\n		    aip1i = e_tmp->val;\n\n	    r1_piv = &(A->row[i+1]);\n	    e_tmp = r1_piv->elt;\n	    aip1 = unord_get_val(A,i+1,i+1);\n	    det = aii*aip1 - aip1i*aip1i;	/* Must have det < 0 */\n	    if ( aii == 0.0 && aip1i == 0.0 )\n	    {\n		/* error(E_RANGE,"spBKPfactor"); */\n		onebyone = TRUE;\n		continue;	/* cannot pivot */\n	    }\n\n	    if ( det == 0.0 )\n	    {\n		if ( aii != 0.0 )\n		    error(E_RANGE,"spBKPfactor");\n		onebyone = TRUE;\n		continue;	/* cannot pivot */\n	    }\n	    aip1i = aip1i/det;\n	    aii = aii/det;\n	    aip1 = aip1/det;\n	    \n	    /* initialise scan_... etc for the 2 x 2 pivot */\n	    s_idx = r_piv->len + r1_piv->len;\n	    scan_row = iv_resize(scan_row,s_idx);\n	    scan_idx = iv_resize(scan_idx,s_idx);\n	    col_list = iv_resize(col_list,s_idx);\n	    orig_idx = iv_resize(orig_idx,s_idx);\n	    orig1_idx = iv_resize(orig1_idx,s_idx);\n\n	    e = r_piv->elt;\n	    for ( idx = 0; idx < r_piv->len; idx++, e++ )\n	    {\n		scan_row->ive[idx] = i;\n		scan_idx->ive[idx] = idx;\n		col_list->ive[idx] = e->col;\n		orig_idx->ive[idx] = idx;\n		orig1_idx->ive[idx] = -1;\n	    }\n	    e = r_piv->elt;\n	    e1 = r1_piv->elt;\n	    for ( idx = 0; idx < r1_piv->len; idx++, e1++ )\n	    {\n		scan_row->ive[idx+r_piv->len] = i+1;\n		scan_idx->ive[idx+r_piv->len] = idx;\n		col_list->ive[idx+r_piv->len] = e1->col;\n		orig_idx->ive[idx+r_piv->len] = -1;\n		orig1_idx->ive[idx+r_piv->len] = idx;\n	    }\n\n	    e1 = r1_piv->elt;\n	    order = px_resize(order,scan_row->dim);\n	    px_ident(order);\n	    iv_sort(col_list,order);\n	    tmp_iv = iv_resize(tmp_iv,scan_row->dim);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_idx);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_row->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_row);\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n		tmp_iv->ive[idx] = orig_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,orig_idx);\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n		tmp_iv->ive[idx] = orig1_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,orig1_idx);\n\n	    s_idx = 0;\n	    old_col = -1;\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n	    {\n		if ( col_list->ive[idx] == old_col )\n		{\n		    if ( scan_row->ive[idx] == i )\n		    {\n			scan_row->ive[s_idx-1] = scan_row->ive[idx];\n			scan_idx->ive[s_idx-1] = scan_idx->ive[idx];\n			col_list->ive[s_idx-1] = col_list->ive[idx];\n			orig_idx->ive[s_idx-1] = orig_idx->ive[idx];\n			orig1_idx->ive[s_idx-1] = orig1_idx->ive[idx-1];\n		    }\n		    else if ( idx > 0 )\n		    {\n			scan_row->ive[s_idx-1] = scan_row->ive[idx-1];\n			scan_idx->ive[s_idx-1] = scan_idx->ive[idx-1];\n			col_list->ive[s_idx-1] = col_list->ive[idx-1];\n			orig_idx->ive[s_idx-1] = orig_idx->ive[idx-1];\n			orig1_idx->ive[s_idx-1] = orig1_idx->ive[idx];\n		    }\n		}\n		else\n		{\n		    scan_row->ive[s_idx] = scan_row->ive[idx];\n		    scan_idx->ive[s_idx] = scan_idx->ive[idx];\n		    col_list->ive[s_idx] = col_list->ive[idx];\n		    orig_idx->ive[s_idx] = orig_idx->ive[idx];\n		    orig1_idx->ive[s_idx] = orig1_idx->ive[idx];\n		    s_idx++;\n		}\n		old_col = col_list->ive[idx];\n	    }\n	    scan_row = iv_resize(scan_row,s_idx);\n	    scan_idx = iv_resize(scan_idx,s_idx);\n	    col_list = iv_resize(col_list,s_idx);\n	    orig_idx = iv_resize(orig_idx,s_idx);\n	    orig1_idx = iv_resize(orig1_idx,s_idx);\n\n	    /* for ( j = i+2; j < n; j++ )  { .... row operation .... } */\n	    for ( s_idx = 0; s_idx < scan_row->dim; s_idx++ )\n	    {\n		int	idx_piv, idx1_piv;\n		Real	aip1j, aij, aik, aip1k;\n		row_elt	*e_ik, *e_ip1k;\n\n		j = col_list->ive[s_idx];\n		if ( j < i+2 )\n		    continue;\n		tracecatch(scan_to(A,scan_row,scan_idx,col_list,j),\n			   "spBKPfactor");\n\n		idx_piv = orig_idx->ive[s_idx];\n		aij = ( idx_piv < 0 ) ? 0.0 : r_piv->elt[idx_piv].val;\n		/* aij = ( s_idx < r_piv->len ) ? r_piv->elt[s_idx].val :\n		    0.0; */\n		/* aij   = sp_get_val(A,i,j); */\n		idx1_piv = orig1_idx->ive[s_idx];\n		aip1j = ( idx1_piv < 0 ) ? 0.0 : r1_piv->elt[idx1_piv].val;\n		/* aip1j = ( s_idx < r_piv->len ) ? 0.0 :\n		    r1_piv->elt[s_idx-r_piv->len].val; */\n		/* aip1j = sp_get_val(A,i+1,j); */\n		s = - aip1i*aip1j + aip1*aij;\n		t = - aip1i*aij + aii*aip1j;\n\n		/* for ( k = j; k < n; k++ )  { .... update entry .... } */\n		row = &(A->row[j]);\n		/* set idx_k and idx1_k indices */\n		s_idx2 = s_idx;\n		k = col_list->ive[s_idx2];\n		idx_k = orig_idx->ive[s_idx2];\n		idx1_k = orig1_idx->ive[s_idx2];\n\n		while ( s_idx2 < scan_row->dim )\n		{\n		    k = col_list->ive[s_idx2];\n		    idx_k = orig_idx->ive[s_idx2];\n		    idx1_k = orig1_idx->ive[s_idx2];\n		    e_ik = ( idx_k < 0 ) ? (row_elt *)NULL :\n			&(r_piv->elt[idx_k]);\n		    e_ip1k = ( idx1_k < 0 ) ? (row_elt *)NULL :\n			&(r1_piv->elt[idx1_k]);\n		    aik = ( idx_k >= 0 ) ? e_ik->val : 0.0;\n		    aip1k = ( idx1_k >= 0 ) ? e_ip1k->val : 0.0;\n		    if ( scan_row->ive[s_idx2] == j )\n		    {	/* no fill-in */\n			row = &(A->row[j]);\n			/* idx = sprow_idx(row,k); */\n			idx = scan_idx->ive[s_idx2];\n			if ( idx < 0 )\n			    error(E_INTERN,"spBKPfactor");\n			row->elt[idx].val -= s*aik + t*aip1k;\n		    }\n		    else\n		    {	/* fill-in -- insert entry & patch column */\n			Real	tmp;\n			int	old_row, old_idx;\n			row_elt	*old_e, *new_e;\n\n			tmp = - s*aik - t*aip1k;\n			if ( tmp != 0.0 )\n			{\n			    row = &(A->row[j]);\n			    old_row = scan_row->ive[s_idx2];\n			    old_idx = scan_idx->ive[s_idx2];\n\n			    idx = row->len;\n			    if ( row->len >= row->maxlen )\n			    {  tracecatch(sprow_xpd(row,2*row->maxlen+1,\n						    TYPE_SPMAT),\n					   "spBKPfactor");	    }\n\n			    row->len = idx + 1;\n			    /* idx = sprow_idx(row,k); */\n			    new_e = &(row->elt[idx]);\n			    new_e->val = tmp;\n			    new_e->col = k;\n\n			    if ( old_row < 0 )\n				error(E_INTERN,"spBKPfactor");\n			    /* old_idx = sprow_idx2(&(A->row[old_row]),\n						  k,old_idx); */\n			    old_e = &(A->row[old_row].elt[old_idx]);\n			    new_e->nxt_row = old_e->nxt_row;\n			    new_e->nxt_idx = old_e->nxt_idx;\n			    old_e->nxt_row = j;\n			    old_e->nxt_idx = idx;\n			}\n		    }\n\n		    /* update idx_k, idx1_k, s_idx2 etc */\n		    s_idx2++;\n		}\n\n		/* store multipliers -- may involve fill-in (!) */\n		/* idx = sprow_idx(r_piv,j); */\n		idx = orig_idx->ive[s_idx];\n		if ( idx >= 0 )\n		{\n		    r_piv->elt[idx].val = s;\n		}\n		else if ( s != 0.0 )\n		{\n		    int		old_row, old_idx;\n		    row_elt	*new_e, *old_e;\n\n		    old_row = -1;	old_idx = j;\n\n		    if ( i > 0 )\n		    {\n			tracecatch(chase_col(A,j,&old_row,&old_idx,i-1),\n				   "spBKPfactor");\n		    }\n		    /* sprow_set_val(r_piv,j,s); */\n		    idx = r_piv->len;\n		    if ( r_piv->len >= r_piv->maxlen )\n		    {	tracecatch(sprow_xpd(r_piv,2*r_piv->maxlen+1,\n					     TYPE_SPMAT),\n				   "spBKPfactor");		    }\n\n		    r_piv->len = idx + 1;\n		    /* idx = sprow_idx(r_piv,j); */\n		    /* if ( idx < 0 )\n			error(E_INTERN,"spBKPfactor"); */\n		    new_e = &(r_piv->elt[idx]);\n		    new_e->val = s;\n		    new_e->col = j;\n		    if ( old_row < 0 )\n		    {\n			new_e->nxt_row = A->start_row[j];\n			new_e->nxt_idx = A->start_idx[j];\n			A->start_row[j] = i;\n			A->start_idx[j] = idx;\n		    }\n		    else\n		    {\n			/* old_idx = sprow_idx2(&(A->row[old_row]),j,old_idx);*/\n			if ( old_idx < 0 )\n			    error(E_INTERN,"spBKPfactor");\n			old_e = &(A->row[old_row].elt[old_idx]);\n			new_e->nxt_row = old_e->nxt_row;\n			new_e->nxt_idx = old_e->nxt_idx;\n			old_e->nxt_row = i;\n			old_e->nxt_idx = idx;\n		    }\n		}\n		/* idx1 = sprow_idx(r1_piv,j); */\n		idx1 = orig1_idx->ive[s_idx];\n		if ( idx1 >= 0 )\n		{\n		    r1_piv->elt[idx1].val = t;\n		}\n		else if ( t != 0.0 )\n		{\n		    int		old_row, old_idx;\n		    row_elt	*new_e, *old_e;\n\n		    old_row = -1;	old_idx = j;\n		    tracecatch(chase_col(A,j,&old_row,&old_idx,i),\n			       "spBKPfactor");\n		    /* sprow_set_val(r1_piv,j,t); */\n		    idx1 = r1_piv->len;\n		    if ( r1_piv->len >= r1_piv->maxlen )\n		    {	tracecatch(sprow_xpd(r1_piv,2*r1_piv->maxlen+1,\n					     TYPE_SPMAT),\n				   "spBKPfactor");		    }\n\n		    r1_piv->len = idx1 + 1;\n		    /* idx1 = sprow_idx(r1_piv,j); */\n		    /* if ( idx < 0 )\n			error(E_INTERN,"spBKPfactor"); */\n		    new_e = &(r1_piv->elt[idx1]);\n		    new_e->val = t;\n		    new_e->col = j;\n		    if ( idx1 < 0 )\n			error(E_INTERN,"spBKPfactor");\n		    new_e = &(r1_piv->elt[idx1]);\n		    if ( old_row < 0 )\n		    {\n			new_e->nxt_row = A->start_row[j];\n			new_e->nxt_idx = A->start_idx[j];\n			A->start_row[j] = i+1;\n			A->start_idx[j] = idx1;\n		    }\n		    else\n		    {\n			old_idx = sprow_idx2(&(A->row[old_row]),j,old_idx);\n			if ( old_idx < 0 )\n			    error(E_INTERN,"spBKPfactor");\n			old_e = &(A->row[old_row].elt[old_idx]);\n			new_e->nxt_row = old_e->nxt_row;\n			new_e->nxt_idx = old_e->nxt_idx;\n			old_e->nxt_row = i+1;\n			old_e->nxt_idx = idx1;\n		    }\n		}\n	    }\n	}\n    }\n\n    /* now sort the rows arrays */\n    for ( i = 0; i < A->m; i++ )\n	qsort(A->row[i].elt,A->row[i].len,sizeof(row_elt),(int(*)())col_cmp);\n    A->flag_col = A->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n    IV_FREE(scan_row);	IV_FREE(scan_idx);	IV_FREE(col_list);\n    IV_FREE(tmp_iv);	IV_FREE(deg_list);	IV_FREE(orig_idx);\n    IV_FREE(orig1_idx);	PX_FREE(order);\n#endif\n    return A;\n}\n\n/* spBKPsolve -- solves A.x = b where A has been factored a la BKPfactor()\n   -- returns x, which is created if NULL */\n#ifndef ANSI_C\nVEC	*spBKPsolve(A,pivot,block,b,x)\nSPMAT	*A;\nPERM	*pivot, *block;\nVEC	*b, *x;\n#else\nVEC	*spBKPsolve(SPMAT *A, PERM *pivot, PERM *block,\n		    const VEC *b, VEC *x)\n#endif\n{\n    STATIC VEC	*tmp=VNULL;	/* dummy storage needed */\n    int		i /* , j */, n, onebyone;\n    int		row_num, idx;\n    Real	a11, a12, a22, b1, b2, det, sum, *tmp_ve, tmp_diag;\n    SPROW	*r;\n    row_elt	*e;\n    \n    if ( ! A || ! pivot || ! block || ! b )\n	error(E_NULL,"spBKPsolve");\n    if ( A->m != A->n )\n	error(E_SQUARE,"spBKPsolve");\n    n = A->n;\n    if ( b->dim != n || pivot->size != n || block->size != n )\n	error(E_SIZES,"spBKPsolve");\n    x = v_resize(x,n);\n    tmp = v_resize(tmp,n);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n    \n    tmp_ve = tmp->ve;\n\n    if ( ! A->flag_col )\n	sp_col_access(A);\n\n    px_vec(pivot,b,tmp);\n    /* printf("# BKPsolve: effect of pivot: tmp =\n");	v_output(tmp); */\n\n    /* solve for lower triangular part */\n    for ( i = 0; i < n; i++ )\n    {\n	sum = tmp_ve[i];\n	if ( block->pe[i] < i )\n	{\n	    /* for ( j = 0; j < i-1; j++ )\n		  sum -= A_me[j][i]*tmp_ve[j]; */\n	    row_num = -1;	idx = i;\n	    e = bump_col(A,i,&row_num,&idx);\n	    while ( row_num >= 0 && row_num < i-1 )\n	    {\n		sum -= e->val*tmp_ve[row_num];\n		e = bump_col(A,i,&row_num,&idx);\n	    }\n	}\n	else\n	{\n	    /* for ( j = 0; j < i; j++ )\n	          sum -= A_me[j][i]*tmp_ve[j]; */\n	    row_num = -1; idx = i;\n	    e = bump_col(A,i,&row_num,&idx);\n	    while ( row_num >= 0 && row_num < i )\n	    {\n		sum -= e->val*tmp_ve[row_num];\n		e = bump_col(A,i,&row_num,&idx);\n	    }\n	}\n	tmp_ve[i] = sum;\n    }\n\n    /* printf("# BKPsolve: solving L part: tmp =\n");	v_output(tmp); */\n    /* solve for diagonal part */\n    for ( i = 0; i < n; i = onebyone ? i+1 : i+2 )\n    {\n	onebyone = ( block->pe[i] == i );\n	if ( onebyone )\n	{\n	    /* tmp_ve[i] /= A_me[i][i]; */\n	    tmp_diag = sp_get_val(A,i,i);\n	    if ( tmp_diag == 0.0 )\n		error(E_SING,"spBKPsolve");\n	    tmp_ve[i] /= tmp_diag;\n	}\n	else\n	{\n	    a11 = sp_get_val(A,i,i);\n	    a22 = sp_get_val(A,i+1,i+1);\n	    a12 = sp_get_val(A,i,i+1);\n	    b1 = tmp_ve[i];\n	    b2 = tmp_ve[i+1];\n	    det = a11*a22-a12*a12;	/* < 0 : see BKPfactor() */\n	    if ( det == 0.0 )\n		error(E_SING,"BKPsolve");\n	    det = 1/det;\n	    tmp_ve[i]   = det*(a22*b1-a12*b2);\n	    tmp_ve[i+1] = det*(a11*b2-a12*b1);\n	}\n    }\n\n    /* printf("# BKPsolve: solving D part: tmp =\n");	v_output(tmp); */\n    /* solve for transpose of lower triangular part */\n    for ( i = n-2; i >= 0; i-- )\n    {\n	sum = tmp_ve[i];\n	if ( block->pe[i] > i )\n	{\n	    /* onebyone is false */\n	    /* for ( j = i+2; j < n; j++ )\n		  sum -= A_me[i][j]*tmp_ve[j]; */\n	    if ( i+2 >= n )\n		continue;\n	    r = &(A->row[i]);\n	    idx = sprow_idx(r,i+2);\n	    idx = fixindex(idx);\n	    e = &(r->elt[idx]);\n	    for ( ; idx < r->len; idx++, e++ )\n		sum -= e->val*tmp_ve[e->col];\n	}\n	else /* onebyone */\n	{\n	    /* for ( j = i+1; j < n; j++ )\n		  sum -= A_me[i][j]*tmp_ve[j]; */\n	    r = &(A->row[i]);\n	    idx = sprow_idx(r,i+1);\n	    idx = fixindex(idx);\n	    e = &(r->elt[idx]);\n	    for ( ; idx < r->len; idx++, e++ )\n		sum -= e->val*tmp_ve[e->col];\n	}\n	tmp_ve[i] = sum;\n    }\n\n    /* printf("# BKPsolve: solving L^T part: tmp =\n");v_output(tmp); */\n    /* and do final permutation */\n    x = pxinv_vec(pivot,tmp,x);\n\n#ifdef	THREADSAFE\n    V_FREE(tmp);\n#endif\n\n    return x;\n}\n\n\n\n