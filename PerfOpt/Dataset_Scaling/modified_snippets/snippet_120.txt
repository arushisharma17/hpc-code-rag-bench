\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  This file contains routines for computing functions of matrices\n  especially polynomials and exponential functions\n  Copyright (C) Teresa Leyk and David Stewart, 1993\n  */\n\n#include <stdio.h>\n#include <math.h>\n#include "matrix.h"\n#include "matrix2.h"\n\nstatic char	rcsid[] = "$Id: mfunc.c,v 1.2 1994/11/01 05:57:56 des Exp $";\n\n\n\n/* _m_pow -- computes integer powers of a square matrix A, A^p\n   -- uses tmp as temporary workspace */\n#ifndef ANSI_C\nMAT	*_m_pow(A, p, tmp, out)\nMAT	*A, *tmp, *out;\nint	p;\n#else\nMAT	*_m_pow(const MAT *A, int p, MAT *tmp, MAT *out)\n#endif\n{\n   int		it_cnt, k, max_bit;\n   \n   /*\n     File containing routines for evaluating matrix functions\n     esp. the exponential function\n     */\n\n#define	Z(k)	(((k) & 1) ? tmp : out)\n   \n   if ( ! A )\n     error(E_NULL,"_m_pow");\n   if ( A->m != A->n )\n     error(E_SQUARE,"_m_pow");\n   if ( p < 0 )\n     error(E_NEG,"_m_pow");\n   out = m_resize(out,A->m,A->n);\n   tmp = m_resize(tmp,A->m,A->n);\n   \n   if ( p == 0 )\n     m_ident(out);\n   else if ( p > 0 )\n   {\n      it_cnt = 1;\n      for ( max_bit = 0; ; max_bit++ )\n	if ( (p >> (max_bit+1)) == 0 )\n	  break;\n      tmp = m_copy(A,tmp);\n      \n      for ( k = 0; k < max_bit; k++ )\n      {\n	 m_mlt(Z(it_cnt),Z(it_cnt),Z(it_cnt+1));\n	 it_cnt++;\n	 if ( p & (1 << (max_bit-1)) )\n	 {\n	    m_mlt(A,Z(it_cnt),Z(it_cnt+1));\n	    /* m_copy(Z(it_cnt),out); */\n	    it_cnt++;\n	 }\n	 p <<= 1;\n      }\n      if (it_cnt & 1)\n	out = m_copy(Z(it_cnt),out);\n   }\n\n   return out;\n\n#undef Z   \n}\n\n/* m_pow -- computes integer powers of a square matrix A, A^p */\n#ifndef ANSI_C\nMAT	*m_pow(A, p, out)\nMAT	*A, *out;\nint	p;\n#else\nMAT	*m_pow(const MAT *A, int p, MAT *out)\n#endif\n{\n   STATIC MAT	*wkspace=MNULL, *tmp=MNULL;\n   \n   if ( ! A )\n     error(E_NULL,"m_pow");\n   if ( A->m != A->n )\n     error(E_SQUARE,"m_pow");\n   \n   wkspace = m_resize(wkspace,A->m,A->n);\n   MEM_STAT_REG(wkspace,TYPE_MAT);\n   if ( p < 0 )\n   {\n       tmp = m_resize(tmp,A->m,A->n);\n       MEM_STAT_REG(tmp,TYPE_MAT);\n       tracecatch(m_inverse(A,tmp),"m_pow");\n       out = _m_pow(tmp, -p, wkspace, out);\n   }\n   else\n       out = _m_pow(A, p, wkspace, out);\n\n#ifdef	THREADSAFE\n   M_FREE(wkspace);	M_FREE(tmp);\n#endif\n\n   return out;\n}\n\n/**************************************************/\n\n/* _m_exp -- compute matrix exponential of A and save it in out\n   -- uses Pade approximation followed by repeated squaring\n   -- eps is the tolerance used for the Pade approximation \n   -- A is not changed\n   -- q_out - degree of the Pade approximation (q_out,q_out)\n   -- j_out - the power of 2 for scaling the matrix A\n              such that ||A/2^j_out|| <= 0.5\n*/\n#ifndef ANSI_C\nMAT *_m_exp(A,eps,out,q_out,j_out)\nMAT *A,*out;\ndouble eps;\nint *q_out, *j_out;\n#else\nMAT *_m_exp(MAT *A, double eps, MAT *out, int *q_out, int *j_out)\n#endif\n{\n   STATIC MAT *D = MNULL, *Apow = MNULL, *N = MNULL, *Y = MNULL;\n   STATIC VEC *c1 = VNULL, *tmp = VNULL;\n   VEC y0, y1;  /* additional structures */\n   STATIC PERM *pivot = PNULL;\n   int j, k, l, q, r, s, j2max, t;\n   double inf_norm, eqq, power2, c, sign;\n   \n   if ( ! A )\n     error(E_SIZES,"_m_exp");\n   if ( A->m != A->n )\n     error(E_SIZES,"_m_exp");\n   if ( A == out )\n     error(E_INSITU,"_m_exp");\n   if ( eps < 0.0 )\n     error(E_RANGE,"_m_exp");\n   else if (eps == 0.0)\n     eps = MACHEPS;\n      \n   N = m_resize(N,A->m,A->n);\n   D = m_resize(D,A->m,A->n);\n   Apow = m_resize(Apow,A->m,A->n);\n   out = m_resize(out,A->m,A->n);\n\n   MEM_STAT_REG(N,TYPE_MAT);\n   MEM_STAT_REG(D,TYPE_MAT);\n   MEM_STAT_REG(Apow,TYPE_MAT);\n   \n   /* normalise A to have ||A||_inf <= 1 */\n   inf_norm = m_norm_inf(A);\n   if (inf_norm <= 0.0) {\n      m_ident(out);\n      *q_out = -1;\n      *j_out = 0;\n      return out;\n   }\n   else {\n      j2max = floor(1+log(inf_norm)/log(2.0));\n      j2max = max(0, j2max);\n   }\n   \n   power2 = 1.0;\n   for ( k = 1; k <= j2max; k++ )\n     power2 *= 2;\n   power2 = 1.0/power2;\n   if ( j2max > 0 )\n     sm_mlt(power2,A,A);\n   \n   /* compute order for polynomial approximation */\n   eqq = 1.0/6.0;\n   for ( q = 1; eqq > eps; q++ )\n     eqq /= 16.0*(2.0*q+1.0)*(2.0*q+3.0);\n   \n   /* construct vector of coefficients */\n   c1 = v_resize(c1,q+1);\n   MEM_STAT_REG(c1,TYPE_VEC);\n   c1->ve[0] = 1.0;\n   for ( k = 1; k <= q; k++ ) \n     c1->ve[k] = c1->ve[k-1]*(q-k+1)/((2*q-k+1)*(double)k);\n   \n   tmp = v_resize(tmp,A->n);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n   \n   s = (int)floor(sqrt((double)q/2.0));\n   if ( s <= 0 )  s = 1;\n   _m_pow(A,s,out,Apow);\n   r = q/s;\n   \n   Y = m_resize(Y,s,A->n);\n   MEM_STAT_REG(Y,TYPE_MAT);\n   /* y0 and y1 are pointers to rows of Y, N and D */\n   y0.dim = y0.max_dim = A->n;   \n   y1.dim = y1.max_dim = A->n;\n   \n   m_zero(Y);\n   m_zero(N);\n   m_zero(D);\n   \n   for( j = 0; j < A->n; j++ )\n   {\n      if (j > 0)\n	Y->me[0][j-1] = 0.0;\n      y0.ve = Y->me[0];\n      y0.ve[j] = 1.0;\n      for ( k = 0; k < s-1; k++ )\n      {\n	 y1.ve = Y->me[k+1];\n	 mv_mlt(A,&y0,&y1);\n	 y0.ve = y1.ve;\n      }\n\n      y0.ve = N->me[j];\n      y1.ve = D->me[j];\n      t = s*r;\n      for ( l = 0; l <= q-t; l++ )\n      {\n	 c = c1->ve[t+l];\n	 sign = ((t+l) & 1) ? -1.0 : 1.0;\n	 __mltadd__(y0.ve,Y->me[l],c,     Y->n);\n	 __mltadd__(y1.ve,Y->me[l],c*sign,Y->n);\n      }\n      \n      for (k=1; k <= r; k++)\n      {\n	 v_copy(mv_mlt(Apow,&y0,tmp),&y0);\n	 v_copy(mv_mlt(Apow,&y1,tmp),&y1);\n	 t = s*(r-k);\n	 for (l=0; l < s; l++)\n	 {\n	    c = c1->ve[t+l];\n	    sign = ((t+l) & 1) ? -1.0 : 1.0;\n	    __mltadd__(y0.ve,Y->me[l],c,     Y->n);\n	    __mltadd__(y1.ve,Y->me[l],c*sign,Y->n);\n	 }\n      }\n   }\n\n   pivot = px_resize(pivot,A->m);\n   MEM_STAT_REG(pivot,TYPE_PERM);\n   \n   /* note that N and D are transposed,\n      therefore we use LUTsolve;\n      out is saved row-wise, and must be transposed \n      after this */\n\n   LUfactor(D,pivot);\n   for (k=0; k < A->n; k++)\n   {\n      y0.ve = N->me[k];\n      y1.ve = out->me[k];\n      LUTsolve(D,pivot,&y0,&y1);\n   }\n   m_transp(out,out); \n\n\n   /* Use recursive squaring to turn the normalised exponential to the\n      true exponential */\n\n#define Z(k)    ((k) & 1 ? Apow : out)\n\n   for( k = 1; k <= j2max; k++)\n      m_mlt(Z(k-1),Z(k-1),Z(k));\n\n   if (Z(k) == out)\n     m_copy(Apow,out);\n   \n   /* output parameters */\n   *j_out = j2max;\n   *q_out = q;\n\n   /* restore the matrix A */\n   sm_mlt(1.0/power2,A,A);\n\n#ifdef	THREADSAFE\n   M_FREE(D);	M_FREE(Apow);	M_FREE(N);	M_FREE(Y);\n   V_FREE(c1); 	V_FREE(tmp);\n   PX_FREE(pivot);\n#endif\n\n   return out;\n\n#undef Z\n}\n\n\n/* simple interface for _m_exp */\n#ifndef ANSI_C\nMAT *m_exp(A,eps,out)\nMAT *A,*out;\ndouble eps;\n#else\nMAT *m_exp(MAT *A, double eps, MAT *out)\n#endif\n{\n   int q_out, j_out;\n\n   return _m_exp(A,eps,out,&q_out,&j_out);\n}\n\n\n/*--------------------------------*/\n\n/* m_poly -- computes sum_i a[i].A^i, where i=0,1,...dim(a);\n   -- uses C. Van Loan's fast and memory efficient method  */\n#ifndef ANSI_C\nMAT *m_poly(A,a,out)\nMAT *A,*out;\nVEC *a;\n#else\nMAT *m_poly(const MAT *A, const VEC *a, MAT *out)\n#endif\n{\n   STATIC MAT	*Apow = MNULL, *Y = MNULL;\n   STATIC VEC   *tmp = VNULL;\n   VEC y0, y1;  /* additional vectors */\n   int j, k, l, q, r, s, t;\n   \n   if ( ! A || ! a )\n     error(E_NULL,"m_poly");\n   if ( A->m != A->n )\n     error(E_SIZES,"m_poly");\n   if ( A == out )\n     error(E_INSITU,"m_poly");\n   \n   out = m_resize(out,A->m,A->n);\n   Apow = m_resize(Apow,A->m,A->n);\n   MEM_STAT_REG(Apow,TYPE_MAT);\n   tmp = v_resize(tmp,A->n);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n\n   q = a->dim - 1;\n   if ( q == 0 ) {\n      m_zero(out);\n      for (j=0; j < out->n; j++)\n	out->me[j][j] = a->ve[0];\n      return out;\n   }\n   else if ( q == 1) {\n      sm_mlt(a->ve[1],A,out);\n      for (j=0; j < out->n; j++)\n	out->me[j][j] += a->ve[0];\n      return out;\n   }\n   \n   s = (int)floor(sqrt((double)q/2.0));\n   if ( s <= 0 ) s = 1;\n   _m_pow(A,s,out,Apow);\n   r = q/s;\n   \n   Y = m_resize(Y,s,A->n);\n   MEM_STAT_REG(Y,TYPE_MAT);\n   /* pointers to rows of Y */\n   y0.dim = y0.max_dim = A->n;\n   y1.dim = y1.max_dim = A->n;\n\n   m_zero(Y);\n   m_zero(out);\n   \n#define Z(k)     ((k) & 1 ? tmp : &y0)\n#define ZZ(k)    ((k) & 1 ? tmp->ve : y0.ve)\n\n   for( j = 0; j < A->n; j++)\n   {\n      if( j > 0 )\n	Y->me[0][j-1] = 0.0;\n      Y->me[0][j] = 1.0;\n\n      y0.ve = Y->me[0];\n      for (k = 0; k < s-1; k++)\n      {\n	 y1.ve = Y->me[k+1];\n	 mv_mlt(A,&y0,&y1);\n	 y0.ve = y1.ve;\n      }\n      \n      y0.ve = out->me[j];\n\n      t = s*r;\n      for ( l = 0; l <= q-t; l++ )\n	__mltadd__(y0.ve,Y->me[l],a->ve[t+l],Y->n);\n      \n      for (k=1; k <= r; k++)\n      {\n	 mv_mlt(Apow,Z(k-1),Z(k)); \n	 t = s*(r-k);\n	 for (l=0; l < s; l++)\n	   __mltadd__(ZZ(k),Y->me[l],a->ve[t+l],Y->n);\n      }\n      if (Z(k) == &y0) v_copy(tmp,&y0);\n   }\n\n   m_transp(out,out);\n\n#ifdef	THREADSAFE\n   M_FREE(Apow);	M_FREE(Y);	V_FREE(tmp);	\n#endif\n   \n   return out;\n}\n\n\n