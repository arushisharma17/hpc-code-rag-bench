//====================================================================================================100\n//		UPDATE\n//====================================================================================================100\n\n//    2006.03   Rob Janiczek\n//        --creation of prototype version\n//    2006.03   Drew Gilliam\n//        --rewriting of prototype version into current version\n//        --got rid of multiple function calls, all code in a  \n//         single function (for speed)\n//        --code cleanup & commenting\n//        --code optimization efforts   \n//    2006.04   Drew Gilliam\n//        --added diffusion coefficent saturation on [0,1]\n//		2009.12 Lukasz G. Szafaryn\n//		-- reading from image, command line inputs\n//		2010.01 Lukasz G. Szafaryn\n//		--comments\n\n//====================================================================================================100\n//	DEFINE / INCLUDE\n//====================================================================================================100\n\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <omp.h>\n\n#include "define.c"\n#include "graphics.c"\n#include "resize.c"\n#include "timer.c"\n\n//====================================================================================================100\n//====================================================================================================100\n//	MAIN FUNCTION\n//====================================================================================================100\n//====================================================================================================100\n\nint main(int argc, char *argv []){\n\n	//================================================================================80\n	// 	VARIABLES\n	//================================================================================80\n\n	// time\n	long long time0;\n	long long time1;\n	long long time2;\n	long long time3;\n	long long time4;\n	long long time5;\n	long long time6;\n	long long time7;\n	long long time8;\n	long long time9;\n	long long time10;\n\n	time0 = get_time();\n\n    // inputs image, input paramenters\n    fp* image_ori;																// originalinput image\n	int image_ori_rows;\n	int image_ori_cols;\n	long image_ori_elem;\n\n    // inputs image, input paramenters\n    fp* image;															// input image\n    long Nr,Nc;													// IMAGE nbr of rows/cols/elements\n	long Ne;\n\n	// algorithm parameters\n    int niter;																// nbr of iterations\n    fp lambda;															// update step size\n\n    // size of IMAGE\n	int r1,r2,c1,c2;												// row/col coordinates of uniform ROI\n	long NeROI;														// ROI nbr of elements\n    \n    // ROI statistics\n    fp meanROI, varROI, q0sqr;											//local region statistics\n    \n    // surrounding pixel indicies\n    int *iN,*iS,*jE,*jW;    \n\n    // center pixel value\n    fp Jc;\n\n	// directional derivatives\n	fp *dN,*dS,*dW,*dE;\n    \n    // calculation variables\n    fp tmp,sum,sum2;\n    fp G2,L,num,den,qsqr,D;\n       \n    // diffusion coefficient\n    fp *c; \n	fp cN,cS,cW,cE;\n    \n    // counters\n    int iter;   // primary loop\n    long i,j;    // image row/col\n    long k;      // image single index    \n\n	// number of threads\n	int threads;\n\n	time1 = get_time();\n\n	//================================================================================80\n	// 	GET INPUT PARAMETERS\n	//================================================================================80\n\n	if(argc != 6){\n		printf("ERROR: wrong number of arguments\n");\n		return 0;\n	}\n	else{\n		niter = atoi(argv[1]);\n		lambda = atof(argv[2]);\n		Nr = atoi(argv[3]);						// it is 502 in the original image\n		Nc = atoi(argv[4]);						// it is 458 in the original image\n		threads = atoi(argv[5]);\n	}\n\n	omp_set_num_threads(threads);\n	// printf("THREAD %d\n", omp_get_thread_num());\n	// printf("NUMBER OF THREADS: %d\n", omp_get_num_threads());\n\n	time2 = get_time();\n\n	//================================================================================80\n	// 	READ IMAGE (SIZE OF IMAGE HAS TO BE KNOWN)\n	//================================================================================80\n\n    // read image\n	image_ori_rows = 502;\n	image_ori_cols = 458;\n	image_ori_elem = image_ori_rows * image_ori_cols;\n\n	image_ori = (fp*)malloc(sizeof(fp) * image_ori_elem);\n\n	read_graphics(	"../../../data/srad/image.pgm",\n								image_ori,\n								image_ori_rows,\n								image_ori_cols,\n								1);\n\n	time3 = get_time();\n\n	//================================================================================80\n	// 	RESIZE IMAGE (ASSUMING COLUMN MAJOR STORAGE OF image_orig)\n	//================================================================================80\n\n	Ne = Nr*Nc;\n\n	image = (fp*)malloc(sizeof(fp) * Ne);\n\n	resize(	image_ori,\n				image_ori_rows,\n				image_ori_cols,\n				image,\n				Nr,\n				Nc,\n				1);\n\n	time4 = get_time();\n\n	//================================================================================80\n	// 	SETUP\n	//================================================================================80\n\n    r1     = 0;											// top row index of ROI\n    r2     = Nr - 1;									// bottom row index of ROI\n    c1     = 0;											// left column index of ROI\n    c2     = Nc - 1;									// right column index of ROI\n\n    // ROI image size    \n    NeROI = (r2-r1+1)*(c2-c1+1);											// number of elements in ROI, ROI size\n    \n    // allocate variables for surrounding pixels\n    iN = malloc(sizeof(int*)*Nr) ;									// north surrounding element\n    iS = malloc(sizeof(int*)*Nr) ;									// south surrounding element\n    jW = malloc(sizeof(int*)*Nc) ;									// west surrounding element\n    jE = malloc(sizeof(int*)*Nc) ;									// east surrounding element\n    \n	// allocate variables for directional derivatives\n	dN = malloc(sizeof(fp)*Ne) ;											// north direction derivative\n    dS = malloc(sizeof(fp)*Ne) ;											// south direction derivative\n    dW = malloc(sizeof(fp)*Ne) ;											// west direction derivative\n    dE = malloc(sizeof(fp)*Ne) ;											// east direction derivative\n\n	// allocate variable for diffusion coefficient\n    c  = malloc(sizeof(fp)*Ne) ;											// diffusion coefficient\n        \n    // N/S/W/E indices of surrounding pixels (every element of IMAGE)\n	// #pragma omp parallel\n    for (i=0; i<Nr; i++) {\n        iN[i] = i-1;														// holds index of IMAGE row above\n        iS[i] = i+1;														// holds index of IMAGE row below\n    }\n	// #pragma omp parallel\n    for (j=0; j<Nc; j++) {\n        jW[j] = j-1;														// holds index of IMAGE column on the left\n        jE[j] = j+1;														// holds index of IMAGE column on the right\n    }\n	// N/S/W/E boundary conditions, fix surrounding indices outside boundary of IMAGE\n    iN[0]    = 0;															// changes IMAGE top row index from -1 to 0\n    iS[Nr-1] = Nr-1;														// changes IMAGE bottom row index from Nr to Nr-1 \n    jW[0]    = 0;															// changes IMAGE leftmost column index from -1 to 0\n    jE[Nc-1] = Nc-1;														// changes IMAGE rightmost column index from Nc to Nc-1\n\n	time5 = get_time();\n\n	//================================================================================80\n	// 	SCALE IMAGE DOWN FROM 0-255 TO 0-1 AND EXTRACT\n	//================================================================================80\n\n	// #pragma omp parallel\n	for (i=0; i<Ne; i++) {													// do for the number of elements in input IMAGE\n		image[i] = exp(image[i]/255);											// exponentiate input IMAGE and copy to output image\n    }\n\n	time6 = get_time();\n\n	//================================================================================80\n	// 	COMPUTATION\n	//================================================================================80\n\n	// printf("iterations: ");\n\n    // primary loop\n    for (iter=0; iter<niter; iter++){										// do for the number of iterations input parameter\n\n		// printf("%d ", iter);\n		// fflush(NULL);\n\n        // ROI statistics for entire ROI (single number for ROI)\n        sum=0; \n		sum2=0;\n        for (i=r1; i<=r2; i++) {											// do for the range of rows in ROI\n            for (j=c1; j<=c2; j++) {										// do for the range of columns in ROI\n                tmp   = image[i + Nr*j];										// get coresponding value in IMAGE\n                sum  += tmp ;												// take corresponding value and add to sum\n                sum2 += tmp*tmp;											// take square of corresponding value and add to sum2\n            }\n        }\n        meanROI = sum / NeROI;												// gets mean (average) value of element in ROI\n        varROI  = (sum2 / NeROI) - meanROI*meanROI;							// gets variance of ROI\n        q0sqr   = varROI / (meanROI*meanROI);								// gets standard deviation of ROI\n\n        // directional derivatives, ICOV, diffusion coefficent\n		#pragma omp parallel for shared(image, dN, dS, dW, dE, c, Nr, Nc, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n		for (j=0; j<Nc; j++) {												// do for the range of columns in IMAGE\n\n            for (i=0; i<Nr; i++) {											// do for the range of rows in IMAGE \n\n                // current index/pixel\n                k = i + Nr*j;												// get position of current element\n                Jc = image[k];													// get value of the current element\n\n                // directional derivates (every element of IMAGE)\n                dN[k] = image[iN[i] + Nr*j] - Jc;								// north direction derivative\n                dS[k] = image[iS[i] + Nr*j] - Jc;								// south direction derivative\n                dW[k] = image[i + Nr*jW[j]] - Jc;								// west direction derivative\n                dE[k] = image[i + Nr*jE[j]] - Jc;								// east direction derivative\n\n                // normalized discrete gradient mag squared (equ 52,53)\n                G2 = (dN[k]*dN[k] + dS[k]*dS[k]								// gradient (based on derivatives)\n                    + dW[k]*dW[k] + dE[k]*dE[k]) / (Jc*Jc);\n\n                // normalized discrete laplacian (equ 54)\n                L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;					// laplacian (based on derivatives)\n\n                // ICOV (equ 31/35)\n                num  = (0.5*G2) - ((1.0/16.0)*(L*L)) ;						// num (based on gradient and laplacian)\n                den  = 1 + (.25*L);											// den (based on laplacian)\n                qsqr = num/(den*den);										// qsqr (based on num and den)\n \n                // diffusion coefficent (equ 33) (every element of IMAGE)\n                den = (qsqr-q0sqr) / (q0sqr * (1+q0sqr)) ;					// den (based on qsqr and q0sqr)\n                c[k] = 1.0 / (1.0+den) ;									// diffusion coefficient (based on den)\n\n                // saturate diffusion coefficent to 0-1 range\n                if (c[k] < 0)												// if diffusion coefficient < 0\n					{c[k] = 0;}												// ... set to 0\n                else if (c[k] > 1)											// if diffusion coefficient > 1\n					{c[k] = 1;}												// ... set to 1\n\n            }\n\n        }\n\n        // divergence & image update\n		#pragma omp parallel for shared(image, c, Nr, Nc, lambda) private(i, j, k, D, cS, cN, cW, cE)\n        for (j=0; j<Nc; j++) {												// do for the range of columns in IMAGE\n\n			// printf("NUMBER OF THREADS: %d\n", omp_get_num_threads());\n\n            for (i=0; i<Nr; i++) {											// do for the range of rows in IMAGE\n\n                // current index\n                k = i + Nr*j;												// get position of current element\n\n                // diffusion coefficent\n                cN = c[k];													// north diffusion coefficient\n                cS = c[iS[i] + Nr*j];										// south diffusion coefficient\n                cW = c[k];													// west diffusion coefficient\n                cE = c[i + Nr*jE[j]];										// east diffusion coefficient\n\n                // divergence (equ 58)\n                D = cN*dN[k] + cS*dS[k] + cW*dW[k] + cE*dE[k];				// divergence\n\n                // image update (equ 61) (every element of IMAGE)\n                image[k] = image[k] + 0.25*lambda*D;								// updates image (based on input time step and divergence)\n\n            }\n\n        }\n\n	}\n\n	// printf("\n");\n\n	time7 = get_time();\n\n	//================================================================================80\n	// 	SCALE IMAGE UP FROM 0-1 TO 0-255 AND COMPRESS\n	//================================================================================80\n\n	// #pragma omp parallel\n	for (i=0; i<Ne; i++) {													// do for the number of elements in IMAGE\n		image[i] = log(image[i])*255;													// take logarithm of image, log compress\n	}\n\n	time8 = get_time();\n\n	//================================================================================80\n	// 	WRITE IMAGE AFTER PROCESSING\n	//================================================================================80\n\n	write_graphics(	"image_out.pgm",\n								image,\n								Nr,\n								Nc,\n								1,\n								255);\n\n	time9 = get_time();\n\n	//================================================================================80\n	// 	DEALLOCATE\n	//================================================================================80\n\n	free(image_ori);\n	free(image);\n\n    free(iN); free(iS); free(jW); free(jE);									// deallocate surrounding pixel memory\n    free(dN); free(dS); free(dW); free(dE);									// deallocate directional derivative memory\n    free(c);																// deallocate diffusion coefficient memory\n\n	time10 = get_time();\n\n	//================================================================================80\n	//		DISPLAY TIMING\n	//================================================================================80\n\n	printf("Time spent in different stages of the application:\n");\n	printf("%.12f s, %.12f % : SETUP VARIABLES\n", 									(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : READ COMMAND LINE PARAMETERS\n", 	(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : READ IMAGE FROM FILE\n", 						(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : RESIZE IMAGE\n", 										(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : SETUP, MEMORY ALLOCATION\n", 				(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : EXTRACT IMAGE\n", 									(float) (time6-time5) / 1000000, (float) (time6-time5) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : COMPUTE\n", 												(float) (time7-time6) / 1000000, (float) (time7-time6) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : COMPRESS IMAGE\n", 									(float) (time8-time7) / 1000000, (float) (time8-time7) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : SAVE IMAGE INTO FILE\n", 							(float) (time9-time8) / 1000000, (float) (time9-time8) / (float) (time10-time0) * 100);\n	printf("%.12f s, %.12f % : FREE MEMORY\n", 										(float) (time10-time9) / 1000000, (float) (time10-time9) / (float) (time10-time0) * 100);\n	printf("Total time:\n");\n	printf("%.12f s\n", 																					(float) (time10-time0) / 1000000);\n\n//====================================================================================================100\n//	END OF FILE\n//====================================================================================================100\n\n}\n\n\n