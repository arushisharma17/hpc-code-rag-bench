\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* pxop.c 1.5 12/03/87 */\n\n\n#include	<stdio.h>\n#include	"matrix.h"\n\nstatic	char	rcsid[] = "$Id: pxop.c,v 1.6 1995/06/08 14:57:11 des Exp $";\n\n/**********************************************************************\nNote: A permutation is often interpreted as a matrix\n		(i.e. a permutation matrix).\n	A permutation px represents a permutation matrix P where\n		P[i][j] == 1 if and only if px->pe[i] == j\n**********************************************************************/\n\n\n/* px_inv -- invert permutation -- in situ\n	-- taken from ACM Collected Algorithms #250 */\n#ifndef ANSI_C\nPERM	*px_inv(px,out)\nPERM	*px, *out;\n#else\nPERM	*px_inv(const PERM *px, PERM *out)\n#endif\n{\n    int	i, j, k, n, *p;\n    \n    out = px_copy(px, out);\n    n = out->size;\n    p = (int *)(out->pe);\n    for ( n--; n>=0; n-- )\n    {\n	i = p[n];\n	if ( i < 0 )	p[n] = -1 - i;\n	else if ( i != n )\n	{\n	    k = n;\n	    while (TRUE)\n	    {\n		if ( i < 0 || i >= out->size )\n		    error(E_BOUNDS,"px_inv");\n		j = p[i];	p[i] = -1 - k;\n		if ( j == n )\n		{	p[n] = i;	break;		}\n		k = i;		i = j;\n	    }\n	}\n    }\n    return out;\n}\n\n/* px_mlt -- permutation multiplication (composition) */\n#ifndef ANSI_C\nPERM	*px_mlt(px1,px2,out)\nPERM	*px1,*px2,*out;\n#else\nPERM	*px_mlt(const PERM *px1, const PERM *px2, PERM *out)\n#endif\n{\n    unsigned int	i,size;\n    \n    if ( px1==(PERM *)NULL || px2==(PERM *)NULL )\n	error(E_NULL,"px_mlt");\n    if ( px1->size != px2->size )\n	error(E_SIZES,"px_mlt");\n    if ( px1 == out || px2 == out )\n	error(E_INSITU,"px_mlt");\n    if ( out==(PERM *)NULL || out->size < px1->size )\n	out = px_resize(out,px1->size);\n    \n    size = px1->size;\n    for ( i=0; i<size; i++ )\n	if ( px2->pe[i] >= size )\n	    error(E_BOUNDS,"px_mlt");\n	else\n	    out->pe[i] = px1->pe[px2->pe[i]];\n    \n    return out;\n}\n\n/* px_vec -- permute vector */\n#ifndef ANSI_C\nVEC	*px_vec(px,vector,out)\nPERM	*px;\nVEC	*vector,*out;\n#else\nVEC	*px_vec(PERM *px, const VEC *vector, VEC *out)\n#endif\n{\n    unsigned int	old_i, i, size, start;\n    Real	tmp;\n    \n    if ( px==PNULL || vector==VNULL )\n	error(E_NULL,"px_vec");\n    if ( px->size > vector->dim )\n	error(E_SIZES,"px_vec");\n    if ( out==VNULL || out->dim < vector->dim )\n	out = v_resize(out,vector->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return v_copy(vector,out);\n    if ( out != vector )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,"px_vec");\n	    else\n		out->ve[i] = vector->ve[px->pe[i]];\n    }\n    else\n    {	/* in situ algorithm */\n	start = 0;\n	while ( start < size )\n	{\n	    old_i = start;\n	    i = px->pe[old_i];\n	    if ( i >= size )\n	    {\n		start++;\n		continue;\n	    }\n	    tmp = vector->ve[start];\n	    while ( TRUE )\n	    {\n		vector->ve[old_i] = vector->ve[i];\n		px->pe[old_i] = i+size;\n		old_i = i;\n		i = px->pe[old_i];\n		if ( i >= size )\n		    break;\n		if ( i == start )\n		{\n		    vector->ve[old_i] = tmp;\n		    px->pe[old_i] = i+size;\n		    break;\n		}\n	    }\n	    start++;\n	}\n\n	for ( i = 0; i < size; i++ )\n	    if ( px->pe[i] < size )\n		error(E_BOUNDS,"px_vec");\n	    else\n		px->pe[i] = px->pe[i]-size;\n    }\n    \n    return out;\n}\n\n/* pxinv_vec -- apply the inverse of px to x, returning the result in out */\n#ifndef ANSI_C\nVEC	*pxinv_vec(px,x,out)\nPERM	*px;\nVEC	*x, *out;\n#else\nVEC	*pxinv_vec(PERM *px, const VEC *x, VEC *out)\n#endif\n{\n    unsigned int	i, size;\n    \n    if ( ! px || ! x )\n	error(E_NULL,"pxinv_vec");\n    if ( px->size > x->dim )\n	error(E_SIZES,"pxinv_vec");\n    /* if ( x == out )\n	error(E_INSITU,"pxinv_vec"); */\n    if ( ! out || out->dim < x->dim )\n	out = v_resize(out,x->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return v_copy(x,out);\n    if ( out != x )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,"pxinv_vec");\n	    else\n		out->ve[px->pe[i]] = x->ve[i];\n    }\n    else\n    {	/* in situ algorithm --- cheat's way out */\n	px_inv(px,px);\n	px_vec(px,x,out);\n	px_inv(px,px);\n    }\n\n    return out;\n}\n\n\n\n/* px_transp -- transpose elements of permutation\n		-- Really multiplying a permutation by a transposition */\n#ifndef ANSI_C\nPERM	*px_transp(px,i1,i2)\nPERM	*px;		/* permutation to transpose */\nunsigned int	i1,i2;		/* elements to transpose */\n#else\nPERM	*px_transp(PERM *px, unsigned int i1, unsigned int i2)\n#endif\n{\n	unsigned int	temp;\n\n	if ( px==(PERM *)NULL )\n		error(E_NULL,"px_transp");\n\n	if ( i1 < px->size && i2 < px->size )\n	{\n		temp = px->pe[i1];\n		px->pe[i1] = px->pe[i2];\n		px->pe[i2] = temp;\n	}\n\n	return px;\n}\n\n/* myqsort -- a cheap implementation of Quicksort on integers\n		-- returns number of swaps */\n#ifndef ANSI_C\nstatic int myqsort(a,num)\nint	*a, num;\n#else\nstatic int myqsort(int *a, int num)\n#endif\n{\n	int	i, j, tmp, v;\n	int	numswaps;\n\n	numswaps = 0;\n	if ( num <= 1 )\n		return 0;\n\n	i = 0;	j = num;	v = a[0];\n	for ( ; ; )\n	{\n		while ( a[++i] < v )\n			;\n		while ( a[--j] > v )\n			;\n		if ( i >= j )	break;\n\n		tmp = a[i];\n		a[i] = a[j];\n		a[j] = tmp;\n		numswaps++;\n	}\n\n	tmp = a[0];\n	a[0] = a[j];\n	a[j] = tmp;\n	if ( j != 0 )\n		numswaps++;\n\n	numswaps += myqsort(&a[0],j);\n	numswaps += myqsort(&a[j+1],num-(j+1));\n\n	return numswaps;\n}\n\n\n/* px_sign -- compute the ``sign'' of a permutation = +/-1 where\n		px is the product of an even/odd # transpositions */\n#ifndef ANSI_C\nint	px_sign(px)\nPERM	*px;\n#else\nint	px_sign(const PERM *px)\n#endif\n{\n	int	numtransp;\n	PERM	*px2;\n\n	if ( px==(PERM *)NULL )\n		error(E_NULL,"px_sign");\n	px2 = px_copy(px,PNULL);\n	numtransp = myqsort((int *)px2->pe,px2->size);\n	px_free(px2);\n\n	return ( numtransp % 2 ) ? -1 : 1;\n}\n\n\n/* px_cols -- permute columns of matrix A; out = A.px'\n	-- May NOT be in situ */\n#ifndef ANSI_C\nMAT	*px_cols(px,A,out)\nPERM	*px;\nMAT	*A, *out;\n#else\nMAT	*px_cols(const PERM *px, const MAT *A, MAT *out)\n#endif\n{\n	int	i, j, m, n, px_j;\n	Real	**A_me, **out_me;\n#ifdef ANSI_C\n	MAT	*m_get(int, int);\n#else\n	extern MAT	*m_get();\n#endif\n\n	if ( ! A || ! px )\n		error(E_NULL,"px_cols");\n	if ( px->size != A->n )\n		error(E_SIZES,"px_cols");\n	if ( A == out )\n		error(E_INSITU,"px_cols");\n	m = A->m;	n = A->n;\n	if ( ! out || out->m != m || out->n != n )\n		out = m_get(m,n);\n	A_me = A->me;	out_me = out->me;\n\n	for ( j = 0; j < n; j++ )\n	{\n		px_j = px->pe[j];\n		if ( px_j >= n )\n		    error(E_BOUNDS,"px_cols");\n		for ( i = 0; i < m; i++ )\n		    out_me[i][px_j] = A_me[i][j];\n	}\n\n	return out;\n}\n\n/* px_rows -- permute columns of matrix A; out = px.A\n	-- May NOT be in situ */\n#ifndef ANSI_C\nMAT	*px_rows(px,A,out)\nPERM	*px;\nMAT	*A, *out;\n#else\nMAT	*px_rows(const PERM *px, const MAT *A, MAT *out)\n#endif\n{\n	int	i, j, m, n, px_i;\n	Real	**A_me, **out_me;\n#ifdef ANSI_C\n	MAT	*m_get(int, int);\n#else\n	extern MAT	*m_get();\n#endif\n\n	if ( ! A || ! px )\n		error(E_NULL,"px_rows");\n	if ( px->size != A->m )\n		error(E_SIZES,"px_rows");\n	if ( A == out )\n		error(E_INSITU,"px_rows");\n	m = A->m;	n = A->n;\n	if ( ! out || out->m != m || out->n != n )\n		out = m_get(m,n);\n	A_me = A->me;	out_me = out->me;\n\n	for ( i = 0; i < m; i++ )\n	{\n		px_i = px->pe[i];\n		if ( px_i >= m )\n		    error(E_BOUNDS,"px_rows");\n		for ( j = 0; j < n; j++ )\n		    out_me[i][j] = A_me[px_i][j];\n	}\n\n	return out;\n}\n\n