\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n		Files for matrix computations\n\n	Householder transformation file. Contains routines for calculating\n	householder transformations, applying them to vectors and matrices\n	by both row & column.\n\n	Complex version\n*/\n\nstatic	char	rcsid[] = "$Id: zhsehldr.c,v 1.2 1994/04/07 01:43:47 des Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"zmatrix.h"\n#include        "zmatrix2.h"\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n/* zhhvec -- calulates Householder vector to eliminate all entries after the\n	i0 entry of the vector vec. It is returned as out. May be in-situ */\nZVEC	*zhhvec(vec,i0,beta,out,newval)\nZVEC	*vec,*out;\nint	i0;\nReal	*beta;\ncomplex	*newval;\n{\n	complex	tmp;\n	Real	norm, abs_val;\n\n	if ( i0 < 0 || i0 >= vec->dim )\n	    error(E_BOUNDS,"zhhvec");\n	out = _zv_copy(vec,out,i0);\n	tmp = _zin_prod(out,out,i0,Z_CONJ);\n	if ( tmp.re <= 0.0 )\n	{\n		*beta = 0.0;\n		*newval = out->ve[i0];\n		return (out);\n	}\n	norm = sqrt(tmp.re);\n	abs_val = zabs(out->ve[i0]);\n	*beta = 1.0/(norm * (norm+abs_val));\n	if ( abs_val == 0.0 )\n	{\n	  newval->re = norm;\n	  newval->im = 0.0;\n	}\n	else\n	{ \n	  abs_val = -norm / abs_val;\n	  newval->re = abs_val*out->ve[i0].re;\n	  newval->im = abs_val*out->ve[i0].im;\n	}	abs_val = -norm / abs_val;\n	out->ve[i0].re -= newval->re;\n	out->ve[i0].im -= newval->im;\n\n	return (out);\n}\n\n/* zhhtrvec -- apply Householder transformation to vector -- may be in-situ */\nZVEC	*zhhtrvec(hh,beta,i0,in,out)\nZVEC	*hh,*in,*out;	/* hh = Householder vector */\nint	i0;\ndouble	beta;\n{\n	complex	scale, tmp;\n	/* unsigned int	i; */\n\n	if ( hh==ZVNULL || in==ZVNULL )\n		error(E_NULL,"zhhtrvec");\n	if ( in->dim != hh->dim )\n		error(E_SIZES,"zhhtrvec");\n	if ( i0 < 0 || i0 > in->dim )\n	    error(E_BOUNDS,"zhhvec");\n\n	tmp = _zin_prod(hh,in,i0,Z_CONJ);\n	scale.re = -beta*tmp.re;\n	scale.im = -beta*tmp.im;\n	out = zv_copy(in,out);\n	__zmltadd__(&(out->ve[i0]),&(hh->ve[i0]),scale,\n		    (int)(in->dim-i0),Z_NOCONJ);\n	/************************************************************\n	for ( i=i0; i<in->dim; i++ )\n		out->ve[i] = in->ve[i] - scale*hh->ve[i];\n	************************************************************/\n\n	return (out);\n}\n\n/* zhhtrrows -- transform a matrix by a Householder vector by rows\n	starting at row i0 from column j0 \n	-- in-situ\n	-- that is, M(i0:m,j0:n) <- M(i0:m,j0:n)(I-beta.hh(j0:n).hh(j0:n)^T) */\nZMAT	*zhhtrrows(M,i0,j0,hh,beta)\nZMAT	*M;\nint	i0, j0;\nZVEC	*hh;\ndouble	beta;\n{\n	complex	ip, scale;\n	int	i /*, j */;\n\n	if ( M==ZMNULL || hh==ZVNULL )\n		error(E_NULL,"zhhtrrows");\n	if ( M->n != hh->dim )\n		error(E_RANGE,"zhhtrrows");\n	if ( i0 < 0 || i0 > M->m || j0 < 0 || j0 > M->n )\n		error(E_BOUNDS,"zhhtrrows");\n\n	if ( beta == 0.0 )	return (M);\n\n	/* for each row ... */\n	for ( i = i0; i < M->m; i++ )\n	{	/* compute inner product */\n		ip = __zip__(&(M->me[i][j0]),&(hh->ve[j0]),\n			     (int)(M->n-j0),Z_NOCONJ);\n		/**************************************************\n		ip = 0.0;\n		for ( j = j0; j < M->n; j++ )\n			ip += M->me[i][j]*hh->ve[j];\n		**************************************************/\n		scale.re = -beta*ip.re;\n		scale.im = -beta*ip.im;\n		/* if ( scale == 0.0 ) */\n		if ( is_zero(scale) )\n		    continue;\n\n		/* do operation */\n		__zmltadd__(&(M->me[i][j0]),&(hh->ve[j0]),scale,\n			    (int)(M->n-j0),Z_CONJ);\n		/**************************************************\n		for ( j = j0; j < M->n; j++ )\n			M->me[i][j] -= scale*hh->ve[j];\n		**************************************************/\n	}\n\n	return (M);\n}\n\n/* zhhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- calls _zhhtrcols() with the scratch vector w\n	-- Meschach internal routines should call _zhhtrcols() to\n	avoid excessive memory allocation/de-allocation\n*/\nZMAT	*zhhtrcols(M,i0,j0,hh,beta)\nZMAT	*M;\nint	i0, j0;\nZVEC	*hh;\ndouble	beta;\n{\n	/* Real	ip, scale; */\n	complex	scale;\n	int	i /*, k */;\n	STATIC	ZVEC	*w = ZVNULL;\n\n	if ( M==ZMNULL || hh==ZVNULL )\n		error(E_NULL,"zhhtrcols");\n	if ( M->m != hh->dim )\n		error(E_SIZES,"zhhtrcols");\n	if ( i0 < 0 || i0 > M->m || j0 < 0 || j0 > M->n )\n		error(E_BOUNDS,"zhhtrcols");\n\n	if ( beta == 0.0 )	return (M);\n\n	if ( ! w || w->dim < M->n )\n	  w = zv_resize(w,M->n);\n	MEM_STAT_REG(w,TYPE_ZVEC);\n\n	M = _zhhtrcols(M,i0,j0,hh,beta,w);\n\n#ifdef THREADSAFE\n	ZV_FREE(w);\n#endif\n\n	return M;\n}\n\n/* _zhhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- scratch vector w passed as argument\n	-- raises error if w == NULL */\nZMAT	*_zhhtrcols(M,i0,j0,hh,beta,w)\nZMAT	*M;\nint	i0, j0;\nZVEC	*hh;\ndouble	beta;\nZVEC	*w;\n{\n	/* Real	ip, scale; */\n	complex	scale;\n	int	i /*, k */;\n\n	if ( M==ZMNULL || hh==ZVNULL )\n		error(E_NULL,"zhhtrcols");\n	if ( M->m != hh->dim )\n		error(E_SIZES,"zhhtrcols");\n	if ( i0 < 0 || i0 > M->m || j0 < 0 || j0 > M->n )\n		error(E_BOUNDS,"zhhtrcols");\n\n	if ( beta == 0.0 )	return (M);\n\n	if ( w->dim < M->n )\n	  w = zv_resize(w,M->n);\n	zv_zero(w);\n\n	for ( i = i0; i < M->m; i++ )\n	    /* if ( hh->ve[i] != 0.0 ) */\n	    if ( ! is_zero(hh->ve[i]) )\n		__zmltadd__(&(w->ve[j0]),&(M->me[i][j0]),hh->ve[i],\n			    (int)(M->n-j0),Z_CONJ);\n	for ( i = i0; i < M->m; i++ )\n	    /* if ( hh->ve[i] != 0.0 ) */\n	    if ( ! is_zero(hh->ve[i]) )\n	    {\n		scale.re = -beta*hh->ve[i].re;\n		scale.im = -beta*hh->ve[i].im;\n		__zmltadd__(&(M->me[i][j0]),&(w->ve[j0]),scale,\n			    (int)(M->n-j0),Z_CONJ);\n	    }\n\n	return (M);\n}\n\n