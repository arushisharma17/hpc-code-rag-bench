//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	KERNEL FUNCTION\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\nvoid kernel(public_struct public,\n				private_struct private){\n\n	//======================================================================================================================================================\n	//	COMMON VARIABLES\n	//======================================================================================================================================================\n\n	int ei_new;\n	fp* d_in;\n	int rot_row;\n	int rot_col;\n	int in2_rowlow;\n	int in2_collow;\n	int ic;\n	int jc;\n	int jp1;\n	int ja1, ja2;\n	int ip1;\n	int ia1, ia2;\n	int ja, jb;\n	int ia, ib;\n	fp s;\n	int i;\n	int j;\n	int row;\n	int col;\n	int ori_row;\n	int ori_col;\n	int position;\n	fp sum;\n	int pos_ori;\n	fp temp;\n	fp temp2;\n	int location;\n	int cent;\n	int tMask_row; \n	int tMask_col;\n	fp largest_value_current = 0;\n	fp largest_value = 0;\n	int largest_coordinate_current = 0;\n	int largest_coordinate = 0;\n	fp fin_max_val = 0;\n	int fin_max_coo = 0;\n	int largest_row;\n	int largest_col;\n	int offset_row;\n	int offset_col;\n	fp in_final_sum;\n	fp in_sqr_final_sum;\n	fp mean;\n	fp mean_sqr;\n	fp variance;\n	fp deviation;\n	fp denomT;\n	int pointer;\n	int ori_pointer;\n	int loc_pointer;\n	int ei_mod;\n\n	//======================================================================================================================================================\n	//	GENERATE TEMPLATE\n	//======================================================================================================================================================\n\n	// generate templates based on the first frame only\n	if(public.frame_no == 0){\n\n		// update temporary row/col coordinates\n		pointer = private.point_no*public.frames+public.frame_no;\n		private.d_tRowLoc[pointer] = private.d_Row[private.point_no];\n		private.d_tColLoc[pointer] = private.d_Col[private.point_no];\n\n		// pointers to: current frame, template for current point\n		d_in = &private.d_T[private.in_pointer];\n\n		// update template, limit the number of working threads to the size of template\n		for(col=0; col<public.in_mod_cols; col++){\n			for(row=0; row<public.in_mod_rows; row++){\n\n				// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)\n				ori_row = private.d_Row[private.point_no] - 25 + row - 1;\n				ori_col = private.d_Col[private.point_no] - 25 + col - 1;\n				ori_pointer = ori_col*public.frame_rows+ori_row;\n\n				// update template\n				d_in[col*public.in_mod_rows+row] = public.d_frame[ori_pointer];\n\n			}\n		}\n\n	}\n\n	//======================================================================================================================================================\n	//	PROCESS POINTS\n	//======================================================================================================================================================\n\n	// process points in all frames except for the first one\n	if(public.frame_no != 0){\n\n		//====================================================================================================\n		//	INPUTS\n		//====================================================================================================\n\n		//==================================================\n		//	1) SETUP POINTER TO POINT TO CURRENT FRAME FROM BATCH\n		//	2) SELECT INPUT 2 (SAMPLE AROUND POINT) FROM FRAME			SAVE IN d_in2			(NOT LINEAR IN MEMORY, SO NEED TO SAVE OUTPUT FOR LATER EASY USE)\n		//	3) SQUARE INPUT 2									SAVE IN d_in2_sqr\n		//==================================================\n\n		// pointers and variables\n		in2_rowlow = private.d_Row[private.point_no] - public.sSize;							// (1 to n+1)\n		in2_collow = private.d_Col[private.point_no] - public.sSize;\n\n		// work\n		for(col=0; col<public.in2_cols; col++){\n			for(row=0; row<public.in2_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + in2_rowlow - 1;\n			ori_col = col + in2_collow - 1;\n			temp = public.d_frame[ori_col*public.frame_rows+ori_row];\n			private.d_in2[col*public.in2_rows+row] = temp;\n			private.d_in2_sqr[col*public.in2_rows+row] = temp*temp;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET POINTER TO INPUT 1 (TEMPLATE FOR THIS POINT) IN TEMPLATE ARRAY				(LINEAR IN MEMORY, SO DONT NEED TO SAVE, JUST GET POINTER)\n		//	2) ROTATE INPUT 1									SAVE IN d_in_mod\n		//	3) SQUARE INPUT 1									SAVE IN d_in_sqr\n		//==================================================\n\n		// variables\n		d_in = &private.d_T[private.in_pointer];\n\n		// work\n		for(col=0; col<public.in_mod_cols; col++){\n			for(row=0; row<public.in_mod_rows; row++){\n\n			// rotated coordinates\n			rot_row = (public.in_mod_rows-1) - row;\n			rot_col = (public.in_mod_rows-1) - col;\n			pointer = rot_col*public.in_mod_rows+rot_row;\n\n			// execution\n			temp = d_in[pointer];\n			private.d_in_mod[col*public.in_mod_rows+row] = temp;\n			private.d_in_sqr[pointer] = temp * temp;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET SUM OF INPUT 1\n		//	2) GET SUM OF INPUT 1 SQUARED\n		//==================================================\n\n		in_final_sum = 0;\n		for(i = 0; i<public.in_mod_elem; i++){\n			in_final_sum = in_final_sum + d_in[i];\n		}\n\n		in_sqr_final_sum = 0;\n		for(i = 0; i<public.in_mod_elem; i++){\n			in_sqr_final_sum = in_sqr_final_sum + private.d_in_sqr[i];\n		}\n\n		//==================================================\n		//	3) DO STATISTICAL CALCULATIONS\n		//	4) GET DENOMINATOR T\n		//==================================================\n\n		mean = in_final_sum / public.in_mod_elem;													// gets mean (average) value of element in ROI\n		mean_sqr = mean * mean;\n		variance  = (in_sqr_final_sum / public.in_mod_elem) - mean_sqr;							// gets variance of ROI\n		deviation = sqrt(variance);																// gets standard deviation of ROI\n\n		denomT = sqrt((fp)(public.in_mod_elem-1))*deviation;\n\n		//====================================================================================================\n		//	1) CONVOLVE INPUT 2 WITH ROTATED INPUT 1					SAVE IN d_conv\n		//====================================================================================================\n\n		// work\n		for(col=1; col<=public.conv_cols; col++){\n\n			// column setup\n			j = col + public.joffset;\n			jp1 = j + 1;\n			if(public.in2_cols < jp1){\n				ja1 = jp1 - public.in2_cols;\n			}\n			else{\n				ja1 = 1;\n			}\n			if(public.in_mod_cols < j){\n				ja2 = public.in_mod_cols;\n			}\n			else{\n				ja2 = j;\n			}\n\n			for(row=1; row<=public.conv_rows; row++){\n\n				// row range setup\n				i = row + public.ioffset;\n				ip1 = i + 1;\n				\n				if(public.in2_rows < ip1){\n					ia1 = ip1 - public.in2_rows;\n				}\n				else{\n					ia1 = 1;\n				}\n				if(public.in_mod_rows < i){\n					ia2 = public.in_mod_rows;\n				}\n				else{\n					ia2 = i;\n				}\n\n				s = 0;\n\n				// getting data\n				for(ja=ja1; ja<=ja2; ja++){\n					jb = jp1 - ja;\n					for(ia=ia1; ia<=ia2; ia++){\n						ib = ip1 - ia;\n						s = s + private.d_in_mod[public.in_mod_rows*(ja-1)+ia-1] * private.d_in2[public.in2_rows*(jb-1)+ib-1];\n					}\n				}\n\n				private.d_conv[(col-1)*public.conv_rows+(row-1)] = s;\n\n		}\n	}\n		//====================================================================================================\n		//	LOCAL SUM 1\n		//====================================================================================================\n\n		//==================================================\n		//	1) PADD ARRAY										SAVE IN d_in2_pad\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_pad_cols; col++){\n			for(row=0; row<public.in2_pad_rows; row++){\n\n			// execution\n			if(	row > (public.in2_pad_add_rows-1) &&														// do if has numbers in original array\n				row < (public.in2_pad_add_rows+public.in2_rows) && \n				col > (public.in2_pad_add_cols-1) && \n				col < (public.in2_pad_add_cols+public.in2_cols)){\n				ori_row = row - public.in2_pad_add_rows;\n				ori_col = col - public.in2_pad_add_cols;\n				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2[ori_col*public.in2_rows+ori_row];\n			}\n			else{																			// do if otherwise\n				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;\n			}\n\n			}\n		}\n\n		//==================================================\n		//	1) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad\n		//==================================================\n\n		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){\n\n			// figure out column position\n			pos_ori = ei_new*public.in2_pad_rows;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){\n				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n				sum = private.d_in2_pad[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_sub_cols; col++){\n			for(row=0; row<public.in2_sub_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel_collow - 1;\n			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;\n			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// subtraction\n			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub\n		//==================================================\n\n		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){\n\n			// figure out row position\n			pos_ori = ei_new;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){\n				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;\n				sum = private.d_in2_sub[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 1\n		//	4) GET CUMULATIVE SUM 1 SQUARED						SAVE IN d_in2_sub2_sqr\n		//	5) GET NUMERATOR									SAVE IN d_conv\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_sub2_sqr_cols; col++){\n			for(row=0; row<public.in2_sub2_sqr_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel_collow - 1;\n			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;\n			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n			\n			// subtraction\n			temp2 = temp - temp2;\n\n			// squaring\n			private.d_in2_sub2_sqr[col*public.in2_sub2_sqr_rows+row] = temp2 * temp2; \n\n			// numerator\n			private.d_conv[col*public.in2_sub2_sqr_rows+row] = private.d_conv[col*public.in2_sub2_sqr_rows+row] - temp2 * in_final_sum / public.in_mod_elem;\n\n			}\n		}\n\n		//====================================================================================================\n		//	LOCAL SUM 2\n		//====================================================================================================\n\n		//==================================================\n		//	1) PAD ARRAY										SAVE IN d_in2_pad\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_pad_cols; col++){\n			for(row=0; row<public.in2_pad_rows; row++){\n\n			// execution\n			if(	row > (public.in2_pad_add_rows-1) &&													// do if has numbers in original array\n				row < (public.in2_pad_add_rows+public.in2_rows) && \n				col > (public.in2_pad_add_cols-1) && \n				col < (public.in2_pad_add_cols+public.in2_cols)){\n				ori_row = row - public.in2_pad_add_rows;\n				ori_col = col - public.in2_pad_add_cols;\n				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2_sqr[ori_col*public.in2_rows+ori_row];\n			}\n			else{																							// do if otherwise\n				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;\n			}\n\n			}\n		}\n\n		//==================================================\n		//	2) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad\n		//==================================================\n\n		//work\n		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){\n\n			// figure out column position\n			pos_ori = ei_new*public.in2_pad_rows;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){\n				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n				sum = private.d_in2_pad[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_sub_cols; col++){\n			for(row=0; row<public.in2_sub_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel_collow - 1;\n			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;\n			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// subtract\n			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub\n		//==================================================\n\n		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){\n\n			// figure out row position\n			pos_ori = ei_new;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){\n				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;\n				sum = private.d_in2_sub[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 2\n		//	4) GET DIFFERENTIAL LOCAL SUM\n		//	5) GET DENOMINATOR A\n		//	6) GET DENOMINATOR\n		//	7) DIVIDE NUMBERATOR BY DENOMINATOR TO GET CORRELATION	SAVE IN d_conv\n		//==================================================\n\n		// work\n		for(col=0; col<public.conv_cols; col++){\n			for(row=0; row<public.conv_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel_collow - 1;\n			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;\n			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n\n			// subtract\n			temp2 = temp - temp2;\n\n			// diff_local_sums\n			temp2 = temp2 - (private.d_in2_sub2_sqr[col*public.conv_rows+row] / public.in_mod_elem);\n\n			// denominator A\n			if(temp2 < 0){\n				temp2 = 0;\n			}\n			temp2 = sqrt(temp2);\n\n			// denominator\n			temp2 = denomT * temp2;\n			\n			// correlation\n			private.d_conv[col*public.conv_rows+row] = private.d_conv[col*public.conv_rows+row] / temp2;\n\n			}\n		}\n\n		//====================================================================================================\n		//	TEMPLATE MASK CREATE\n		//====================================================================================================\n\n		// parameters\n		cent = public.sSize + public.tSize + 1;\n		pointer = public.frame_no-1+private.point_no*public.frames;\n		tMask_row = cent + private.d_tRowLoc[pointer] - private.d_Row[private.point_no] - 1;\n		tMask_col = cent + private.d_tColLoc[pointer] - private.d_Col[private.point_no] - 1;\n\n		//work\n		for(ei_new = 0; ei_new < public.tMask_elem; ei_new++){\n			private.d_tMask[ei_new] = 0;\n		}\n		private.d_tMask[tMask_col*public.tMask_rows + tMask_row] = 1;\n\n\n		//====================================================================================================\n		//	1) MASK CONVOLUTION\n		//	2) MULTIPLICATION\n		//====================================================================================================\n\n		// work\n		// for(col=1; col<=public.conv_cols; col++){\n		for(col=1; col<=public.mask_conv_cols; col++){\n\n			// col setup\n			j = col + public.mask_conv_joffset;\n			jp1 = j + 1;\n			if(public.mask_cols < jp1){\n				ja1 = jp1 - public.mask_cols;\n			}\n			else{\n				ja1 = 1;\n			}\n			if(public.tMask_cols < j){\n				ja2 = public.tMask_cols;\n			}\n			else{\n				ja2 = j;\n			}\n\n			// for(row=1; row<=public.conv_rows; row++){\n			for(row=1; row<=public.mask_conv_rows; row++){\n\n				// row setup\n				i = row + public.mask_conv_ioffset;\n				ip1 = i + 1;\n				\n				if(public.mask_rows < ip1){\n					ia1 = ip1 - public.mask_rows;\n				}\n				else{\n					ia1 = 1;\n				}\n				if(public.tMask_rows < i){\n					ia2 = public.tMask_rows;\n				}\n				else{\n					ia2 = i;\n				}\n\n				s = 0;\n\n				// get data\n				for(ja=ja1; ja<=ja2; ja++){\n					jb = jp1 - ja;\n					for(ia=ia1; ia<=ia2; ia++){\n						ib = ip1 - ia;\n						s = s + private.d_tMask[public.tMask_rows*(ja-1)+ia-1] * 1;\n					}\n				}\n\n				private.d_mask_conv[(col-1)*public.conv_rows+(row-1)] = private.d_conv[(col-1)*public.conv_rows+(row-1)] * s;\n\n			}\n\n		}\n\n		//====================================================================================================\n		//	MAXIMUM VALUE\n		//====================================================================================================\n\n		//==================================================\n		//	SEARCH\n		//==================================================\n\n		fin_max_val = 0;\n		fin_max_coo = 0;\n		for(i=0; i<public.mask_conv_elem; i++){\n			if(private.d_mask_conv[i]>fin_max_val){\n				fin_max_val = private.d_mask_conv[i];\n				fin_max_coo = i;\n			}\n		}\n\n		//==================================================\n		//	OFFSET\n		//==================================================\n\n		// convert coordinate to row/col form\n		largest_row = (fin_max_coo+1) % public.mask_conv_rows - 1;											// (0-n) row\n		largest_col = (fin_max_coo+1) / public.mask_conv_rows;												// (0-n) column\n		if((fin_max_coo+1) % public.mask_conv_rows == 0){\n			largest_row = public.mask_conv_rows - 1;\n			largest_col = largest_col - 1;\n		}\n\n		// calculate offset\n		largest_row = largest_row + 1;																	// compensate to match MATLAB format (1-n)\n		largest_col = largest_col + 1;																	// compensate to match MATLAB format (1-n)\n		offset_row = largest_row - public.in_mod_rows - (public.sSize - public.tSize);\n		offset_col = largest_col - public.in_mod_cols - (public.sSize - public.tSize);\n		pointer = private.point_no*public.frames+public.frame_no;\n		private.d_tRowLoc[pointer] = private.d_Row[private.point_no] + offset_row;\n		private.d_tColLoc[pointer] = private.d_Col[private.point_no] + offset_col;\n\n	}\n\n	//======================================================================================================================================================\n	//	COORDINATE AND TEMPLATE UPDATE\n	//======================================================================================================================================================\n\n	// if the last frame in the bath, update template\n	if(public.frame_no != 0 && (public.frame_no)%10 == 0){\n\n		// update coordinate\n		loc_pointer = private.point_no*public.frames+public.frame_no;\n		private.d_Row[private.point_no] = private.d_tRowLoc[loc_pointer];\n		private.d_Col[private.point_no] = private.d_tColLoc[loc_pointer];\n\n		// update template, limit the number of working threads to the size of template\n		for(col=0; col<public.in_mod_cols; col++){\n			for(row=0; row<public.in_mod_rows; row++){\n\n			// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)\n			ori_row = private.d_Row[private.point_no] - 25 + row - 1;\n			ori_col = private.d_Col[private.point_no] - 25 + col - 1;\n			ori_pointer = ori_col*public.frame_rows+ori_row;\n\n			// update template\n			d_in[col*public.in_mod_rows+row] = public.alpha*d_in[col*public.in_mod_rows+row] + (1.00-public.alpha)*public.d_frame[ori_pointer];\n\n			}\n		}\n\n	}\n\n}\n\n	//===============================================================================================================================================================================================================\n	//===============================================================================================================================================================================================================\n	//	END OF FUNCTION\n	//===============================================================================================================================================================================================================\n	//===============================================================================================================================================================================================================\n