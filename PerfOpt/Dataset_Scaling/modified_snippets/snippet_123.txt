\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*	\n	File containing routines for computing the Schur decomposition\n	of a complex non-symmetric matrix\n	See also: hessen.c\n	Complex version\n*/\n\n\n#include	<stdio.h>\n#include	<math.h>\n#include	"zmatrix.h"\n#include        "zmatrix2.h"\n\nstatic char rcsid[] = "$Id: zschur.c,v 1.4 1995/04/07 16:28:58 des Exp $";\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n#define	b2s(t_or_f)	((t_or_f) ? "TRUE" : "FALSE")\n\n\n/* zschur -- computes the Schur decomposition of the matrix A in situ\n	-- optionally, gives Q matrix such that Q^*.A.Q is upper triangular\n	-- returns upper triangular Schur matrix */\nZMAT	*zschur(A,Q)\nZMAT	*A, *Q;\n{\n    int		i, j, iter, k, k_min, k_max, k_tmp, n, split;\n    Real	c;\n    complex	det, discrim, lambda, lambda0, lambda1, s, sum, ztmp;\n    complex	x, y;	/* for chasing algorithm */\n    complex	**A_me;\n    STATIC	ZVEC	*diag=ZVNULL;\n    \n    if ( ! A )\n	error(E_NULL,"zschur");\n    if ( A->m != A->n || ( Q && Q->m != Q->n ) )\n	error(E_SQUARE,"zschur");\n    if ( Q != ZMNULL && Q->m != A->m )\n	error(E_SIZES,"zschur");\n    n = A->n;\n    diag = zv_resize(diag,A->n);\n    MEM_STAT_REG(diag,TYPE_ZVEC);\n    /* compute Hessenberg form */\n    zHfactor(A,diag);\n    \n    /* save Q if necessary, and make A explicitly Hessenberg */\n    zHQunpack(A,diag,Q,A);\n\n    k_min = 0;	A_me = A->me;\n\n    while ( k_min < n )\n    {\n	/* find k_max to suit:\n	   submatrix k_min..k_max should be irreducible */\n	k_max = n-1;\n	for ( k = k_min; k < k_max; k++ )\n	    if ( is_zero(A_me[k+1][k]) )\n	    {	k_max = k;	break;	}\n\n	if ( k_max <= k_min )\n	{\n	    k_min = k_max + 1;\n	    continue;		/* outer loop */\n	}\n\n	/* now have r x r block with r >= 2:\n	   apply Francis QR step until block splits */\n	split = FALSE;		iter = 0;\n	while ( ! split )\n	{\n	    complex	a00, a01, a10, a11;\n	    iter++;\n	    \n	    /* set up Wilkinson/Francis complex shift */\n	    /* use the smallest eigenvalue of the bottom 2 x 2 submatrix */\n	    k_tmp = k_max - 1;\n\n	    a00 = A_me[k_tmp][k_tmp];\n	    a01 = A_me[k_tmp][k_max];\n	    a10 = A_me[k_max][k_tmp];\n	    a11 = A_me[k_max][k_max];\n	    ztmp.re = 0.5*(a00.re - a11.re);\n	    ztmp.im = 0.5*(a00.im - a11.im);\n	    discrim = zsqrt(zadd(zmlt(ztmp,ztmp),zmlt(a01,a10)));\n	    sum.re  = 0.5*(a00.re + a11.re);\n	    sum.im  = 0.5*(a00.im + a11.im);\n	    lambda0 = zadd(sum,discrim);\n	    lambda1 = zsub(sum,discrim);\n	    det = zsub(zmlt(a00,a11),zmlt(a01,a10)); \n	    \n	    if ( is_zero(lambda0) && is_zero(lambda1) )\n	      {                                                          \n		lambda.re = lambda.im = 0.0;\n	      } \n	    else if ( zabs(lambda0) > zabs(lambda1) )\n		lambda = zdiv(det,lambda0);\n	    else\n		lambda = zdiv(det,lambda1);\n\n	    /* perturb shift if convergence is slow */\n	    if ( (iter % 10) == 0 )\n	    {\n		lambda.re += iter*0.02;\n		lambda.im += iter*0.02;\n	    }\n\n	    /* set up Householder transformations */\n	    k_tmp = k_min + 1;\n\n	    x = zsub(A->me[k_min][k_min],lambda);\n	    y = A->me[k_min+1][k_min];\n\n	    /* use Givens' rotations to "chase" off-Hessenberg entry */\n	    for ( k = k_min; k <= k_max-1; k++ )\n	    {\n		zgivens(x,y,&c,&s);\n		zrot_cols(A,k,k+1,c,s,A);\n		zrot_rows(A,k,k+1,c,s,A);\n		if ( Q != ZMNULL )\n		    zrot_cols(Q,k,k+1,c,s,Q);\n\n		/* zero things that should be zero */\n		if ( k > k_min )\n		    A->me[k+1][k-1].re = A->me[k+1][k-1].im = 0.0;\n\n		/* get next entry to chase along sub-diagonal */\n		x = A->me[k+1][k];\n		if ( k <= k_max - 2 )\n		    y = A->me[k+2][k];\n		else\n		    y.re = y.im = 0.0;\n	    }\n\n	    for ( k = k_min; k <= k_max-2; k++ )\n	    {\n		/* zero appropriate sub-diagonals */\n		A->me[k+2][k].re = A->me[k+2][k].im = 0.0;\n	    }\n\n	    /* test to see if matrix should split */\n	    for ( k = k_min; k < k_max; k++ )\n		if ( zabs(A_me[k+1][k]) < MACHEPS*\n		    (zabs(A_me[k][k])+zabs(A_me[k+1][k+1])) )\n		{\n		    A_me[k+1][k].re = A_me[k+1][k].im = 0.0;\n		    split = TRUE;\n		}\n\n	}\n    }\n    \n    /* polish up A by zeroing strictly lower triangular elements\n       and small sub-diagonal elements */\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < i-1; j++ )\n	    A_me[i][j].re = A_me[i][j].im = 0.0;\n    for ( i = 0; i < A->m - 1; i++ )\n	if ( zabs(A_me[i+1][i]) < MACHEPS*\n	    (zabs(A_me[i][i])+zabs(A_me[i+1][i+1])) )\n	    A_me[i+1][i].re = A_me[i+1][i].im = 0.0;\n\n#ifdef	THREADSAFE\n    ZV_FREE(diag);\n#endif\n\n    return A;\n}\n\n\n#if 0\n/* schur_vecs -- returns eigenvectors computed from the real Schur\n		decomposition of a matrix\n	-- T is the block upper triangular Schur matrix\n	-- Q is the orthognal matrix where A = Q.T.Q^T\n	-- if Q is null, the eigenvectors of T are returned\n	-- X_re is the real part of the matrix of eigenvectors,\n		and X_im is the imaginary part of the matrix.\n	-- X_re is returned */\nMAT	*schur_vecs(T,Q,X_re,X_im)\nMAT	*T, *Q, *X_re, *X_im;\n{\n	int	i, j, limit;\n	Real	t11_re, t11_im, t12, t21, t22_re, t22_im;\n	Real	l_re, l_im, det_re, det_im, invdet_re, invdet_im,\n		val1_re, val1_im, val2_re, val2_im,\n		tmp_val1_re, tmp_val1_im, tmp_val2_re, tmp_val2_im, **T_me;\n	Real	sum, diff, discrim, magdet, norm, scale;\n	STATIC VEC	*tmp1_re=VNULL, *tmp1_im=VNULL,\n			*tmp2_re=VNULL, *tmp2_im=VNULL;\n\n	if ( ! T || ! X_re )\n	    error(E_NULL,"schur_vecs");\n	if ( T->m != T->n || X_re->m != X_re->n ||\n		( Q != MNULL && Q->m != Q->n ) ||\n		( X_im != MNULL && X_im->m != X_im->n ) )\n	    error(E_SQUARE,"schur_vecs");\n	if ( T->m != X_re->m ||\n		( Q != MNULL && T->m != Q->m ) ||\n		( X_im != MNULL && T->m != X_im->m ) )\n	    error(E_SIZES,"schur_vecs");\n\n	tmp1_re = v_resize(tmp1_re,T->m);\n	tmp1_im = v_resize(tmp1_im,T->m);\n	tmp2_re = v_resize(tmp2_re,T->m);\n	tmp2_im = v_resize(tmp2_im,T->m);\n	MEM_STAT_REG(tmp1_re,TYPE_VEC);\n	MEM_STAT_REG(tmp1_im,TYPE_VEC);\n	MEM_STAT_REG(tmp2_re,TYPE_VEC);\n	MEM_STAT_REG(tmp2_im,TYPE_VEC);\n\n	T_me = T->me;\n	i = 0;\n	while ( i < T->m )\n	{\n	    if ( i+1 < T->m && T->me[i+1][i] != 0.0 )\n	    {	/* complex eigenvalue */\n		sum  = 0.5*(T_me[i][i]+T_me[i+1][i+1]);\n		diff = 0.5*(T_me[i][i]-T_me[i+1][i+1]);\n		discrim = diff*diff + T_me[i][i+1]*T_me[i+1][i];\n		l_re = l_im = 0.0;\n		if ( discrim < 0.0 )\n		{	/* yes -- complex e-vals */\n		    l_re = sum;\n		    l_im = sqrt(-discrim);\n		}\n		else /* not correct Real Schur form */\n		    error(E_RANGE,"schur_vecs");\n	    }\n	    else\n	    {\n		l_re = T_me[i][i];\n		l_im = 0.0;\n	    }\n\n	    v_zero(tmp1_im);\n	    v_rand(tmp1_re);\n	    sv_mlt(MACHEPS,tmp1_re,tmp1_re);\n\n	    /* solve (T-l.I)x = tmp1 */\n	    limit = ( l_im != 0.0 ) ? i+1 : i;\n	    /* printf("limit = %d\n",limit); */\n	    for ( j = limit+1; j < T->m; j++ )\n		tmp1_re->ve[j] = 0.0;\n	    j = limit;\n	    while ( j >= 0 )\n	    {\n		if ( j > 0 && T->me[j][j-1] != 0.0 )\n		{   /* 2 x 2 diagonal block */\n		    /* printf("checkpoint A\n"); */\n		    val1_re = tmp1_re->ve[j-1] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf("checkpoint B\n"); */\n		    val1_im = tmp1_im->ve[j-1] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf("checkpoint C\n"); */\n		    val2_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint D\n"); */\n		    val2_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint E\n"); */\n		    \n		    t11_re = T_me[j-1][j-1] - l_re;\n		    t11_im = - l_im;\n		    t22_re = T_me[j][j] - l_re;\n		    t22_im = - l_im;\n		    t12 = T_me[j-1][j];\n		    t21 = T_me[j][j-1];\n\n		    scale =  fabs(T_me[j-1][j-1]) + fabs(T_me[j][j]) +\n			fabs(t12) + fabs(t21) + fabs(l_re) + fabs(l_im);\n\n		    det_re = t11_re*t22_re - t11_im*t22_im - t12*t21;\n		    det_im = t11_re*t22_im + t11_im*t22_re;\n		    magdet = det_re*det_re+det_im*det_im;\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        det_re = MACHEPS*scale;\n			magdet = det_re*det_re+det_im*det_im;\n		    }\n		    invdet_re =   det_re/magdet;\n		    invdet_im = - det_im/magdet;\n		    tmp_val1_re = t22_re*val1_re-t22_im*val1_im-t12*val2_re;\n		    tmp_val1_im = t22_im*val1_re+t22_re*val1_im-t12*val2_im;\n		    tmp_val2_re = t11_re*val2_re-t11_im*val2_im-t21*val1_re;\n		    tmp_val2_im = t11_im*val2_re+t11_re*val2_im-t21*val1_im;\n		    tmp1_re->ve[j-1] = invdet_re*tmp_val1_re -\n		    		invdet_im*tmp_val1_im;\n		    tmp1_im->ve[j-1] = invdet_im*tmp_val1_re +\n		    		invdet_re*tmp_val1_im;\n		    tmp1_re->ve[j]   = invdet_re*tmp_val2_re -\n		    		invdet_im*tmp_val2_im;\n		    tmp1_im->ve[j]   = invdet_im*tmp_val2_re +\n		    		invdet_re*tmp_val2_im;\n		    j -= 2;\n	        }\n	        else\n		{\n		    t11_re = T_me[j][j] - l_re;\n		    t11_im = - l_im;\n		    magdet = t11_re*t11_re + t11_im*t11_im;\n		    scale = fabs(T_me[j][j]) + fabs(l_re);\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        t11_re = MACHEPS*scale;\n			magdet = t11_re*t11_re + t11_im*t11_im;\n		    }\n		    invdet_re =   t11_re/magdet;\n		    invdet_im = - t11_im/magdet;\n		    /* printf("checkpoint F\n"); */\n		    val1_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint G\n"); */\n		    val1_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf("checkpoint H\n"); */\n		    tmp1_re->ve[j] = invdet_re*val1_re - invdet_im*val1_im;\n		    tmp1_im->ve[j] = invdet_im*val1_re + invdet_re*val1_im;\n		    j -= 1;\n		}\n	    }\n\n	    norm = v_norm_inf(tmp1_re) + v_norm_inf(tmp1_im);\n	    sv_mlt(1/norm,tmp1_re,tmp1_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp1_im,tmp1_im);\n	    mv_mlt(Q,tmp1_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		mv_mlt(Q,tmp1_im,tmp2_im);\n	    if ( l_im != 0.0 )\n		norm = sqrt(in_prod(tmp2_re,tmp2_re)+in_prod(tmp2_im,tmp2_im));\n	    else\n		norm = v_norm2(tmp2_re);\n	    sv_mlt(1/norm,tmp2_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp2_im,tmp2_im);\n\n	    if ( l_im != 0.0 )\n	    {\n		if ( ! X_im )\n		error(E_NULL,"schur_vecs");\n		set_col(X_re,i,tmp2_re);\n		set_col(X_im,i,tmp2_im);\n		sv_mlt(-1.0,tmp2_im,tmp2_im);\n		set_col(X_re,i+1,tmp2_re);\n		set_col(X_im,i+1,tmp2_im);\n		i += 2;\n	    }\n	    else\n	    {\n		set_col(X_re,i,tmp2_re);\n		if ( X_im != MNULL )\n		    set_col(X_im,i,tmp1_im);	/* zero vector */\n		i += 1;\n	    }\n	}\n\n	return X_re;\n}\n\n#endif\n\n