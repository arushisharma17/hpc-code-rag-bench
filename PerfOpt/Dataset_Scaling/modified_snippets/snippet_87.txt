\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Sparse Cholesky factorisation code\n	To be used with sparse.h, sparse.c etc\n\n*/\n\nstatic char	rcsid[] = "$Id: spchfctr.c,v 1.5 1996/08/20 19:45:33 stewart Exp $";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        "sparse2.h"\n\n\n#ifndef MALLOCDECL\n#ifndef ANSI_C\nextern	char	*calloc(), *realloc();\n#endif\n#endif\n\n\n\n/* sprow_ip -- finds the (partial) inner product of a pair of sparse rows\n	-- uses a "merging" approach & assumes column ordered rows\n	-- row indices for inner product are all < lim */\n#ifndef ANSI_C\nstatic double	sprow_ip(row1, row2, lim)\nSPROW	*row1, *row2;\nint	lim;\n#else\nstatic double	sprow_ip(const SPROW *row1, const SPROW *row2, int lim)\n#endif\n{\n	int			idx1, idx2, len1, len2, tmp;\n	register row_elt	*elts1, *elts2;\n	register Real		sum;\n\n	elts1 = row1->elt;	elts2 = row2->elt;\n	len1 = row1->len;	len2 = row2->len;\n\n	sum = 0.0;\n\n	if ( len1 <= 0 || len2 <= 0 )\n		return 0.0;\n	if ( elts1->col >= lim || elts2->col >= lim )\n		return 0.0;\n\n	/* use sprow_idx() to speed up inner product where one row is\n		much longer than the other */\n	idx1 = idx2 = 0;\n	if ( len1 > 2*len2 )\n	{\n		idx1 = sprow_idx(row1,elts2->col);\n		idx1 = (idx1 < 0) ? -(idx1+2) : idx1;\n		if ( idx1 < 0 )\n			error(E_UNKNOWN,"sprow_ip");\n		len1 -= idx1;\n	}\n	else if ( len2 > 2*len1 )\n	{\n		idx2 = sprow_idx(row2,elts1->col);\n		idx2 = (idx2 < 0) ? -(idx2+2) : idx2;\n		if ( idx2 < 0 )\n			error(E_UNKNOWN,"sprow_ip");\n		len2 -= idx2;\n	}\n	if ( len1 <= 0 || len2 <= 0 )\n		return 0.0;\n\n	elts1 = &(elts1[idx1]);		elts2 = &(elts2[idx2]);\n\n\n	for ( ; ; )	/* forever do... */\n	{\n		if ( (tmp=elts1->col-elts2->col) < 0 )\n		{\n		    len1--;		elts1++;\n		    if ( ! len1 || elts1->col >= lim )\n			break;\n		}\n		else if ( tmp > 0 )\n		{\n		    len2--;		elts2++;\n		    if ( ! len2 || elts2->col >= lim )\n			break;\n		}\n		else\n		{\n		    sum += elts1->val * elts2->val;\n		    len1--;		elts1++;\n		    len2--;		elts2++;\n		    if ( ! len1 || ! len2 ||\n				elts1->col >= lim || elts2->col >= lim )\n			break;\n		}\n	}\n\n	return sum;\n}\n\n/* sprow_sqr -- returns same as sprow_ip(row, row, lim) */\n#ifndef ANSI_C\nstatic double	sprow_sqr(row, lim)\nSPROW	*row;\nint	lim;\n#else\nstatic double	sprow_sqr(const SPROW *row, int lim)\n#endif\n{\n	register	row_elt	*elts;\n	int		idx, len;\n	register	Real	sum, tmp;\n\n	sum = 0.0;\n	elts = row->elt;	len = row->len;\n	for ( idx = 0; idx < len; idx++, elts++ )\n	{\n		if ( elts->col >= lim )\n			break;\n		tmp = elts->val;\n		sum += tmp*tmp;\n	}\n\n	return sum;\n}\n\nstatic	int	*scan_row = (int *)NULL, *scan_idx = (int *)NULL,\n			*col_list = (int *)NULL;\nstatic	int	scan_len = 0;\n\n/* set_scan -- expand scan_row and scan_idx arrays\n	-- return new length */\n#ifndef ANSI_C\nint	set_scan(new_len)\nint	new_len;\n#else\nint	set_scan(int new_len)\n#endif\n{\n	if ( new_len <= scan_len )\n		return scan_len;\n	if ( new_len <= scan_len+5 )\n		new_len += 5;\n\n	/* update scan_len */\n        scan_len = new_len;\n\n	if ( ! scan_row || ! scan_idx || ! col_list )\n	{\n		scan_row = (int *)calloc(new_len,sizeof(int));\n		scan_idx = (int *)calloc(new_len,sizeof(int));\n		col_list = (int *)calloc(new_len,sizeof(int));\n	}\n	else\n	{\n		scan_row = (int *)realloc((char *)scan_row,new_len*sizeof(int));\n		scan_idx = (int *)realloc((char *)scan_idx,new_len*sizeof(int));\n		col_list = (int *)realloc((char *)col_list,new_len*sizeof(int));\n	}\n\n	if ( ! scan_row || ! scan_idx || ! col_list )\n		error(E_MEM,"set_scan");\n	return new_len;\n}\n\n/* spCHfactor -- sparse Cholesky factorisation\n	-- only the lower triangular part of A (incl. diagonal) is used */\n#ifndef ANSI_C\nSPMAT	*spCHfactor(A)\nSPMAT	*A;\n#else\nSPMAT	*spCHfactor(SPMAT *A)\n#endif\n{\n	register 	int	i;\n	int	idx, k, m, minim, n, num_scan, diag_idx, tmp1;\n	Real	pivot, tmp2;\n	SPROW	*r_piv, *r_op;\n	row_elt	*elt_piv, *elt_op, *old_elt;\n\n	if ( A == SMNULL )\n		error(E_NULL,"spCHfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"spCHfactor");\n\n	/* set up access paths if not already done so */\n	sp_col_access(A);\n	sp_diag_access(A);\n\n	/* printf("spCHfactor() -- checkpoint 1\n"); */\n	m = A->m;	n = A->n;\n	for ( k = 0; k < m; k++ )\n	{\n		r_piv = &(A->row[k]);\n		if ( r_piv->len > scan_len )\n			set_scan(r_piv->len);\n		elt_piv = r_piv->elt;\n		diag_idx = sprow_idx2(r_piv,k,r_piv->diag);\n		if ( diag_idx < 0 )\n			error(E_POSDEF,"spCHfactor");\n		old_elt = &(elt_piv[diag_idx]);\n		for ( i = 0; i < r_piv->len; i++ )\n		{\n			if ( elt_piv[i].col > k )\n				break;\n			col_list[i] = elt_piv[i].col;\n			scan_row[i] = elt_piv[i].nxt_row;\n			scan_idx[i] = elt_piv[i].nxt_idx;\n		}\n		/* printf("spCHfactor() -- checkpoint 2\n"); */\n		num_scan = i;	/* number of actual entries in scan_row etc. */\n		/* printf("num_scan = %d\n",num_scan); */\n\n		/* set diagonal entry of Cholesky factor */\n		tmp2 = elt_piv[diag_idx].val - sprow_sqr(r_piv,k);\n		if ( tmp2 <= 0.0 )\n			error(E_POSDEF,"spCHfactor");\n		elt_piv[diag_idx].val = pivot = sqrt(tmp2);\n\n		/* now set the k-th column of the Cholesky factors */\n		/* printf("k = %d\n",k); */\n		for ( ; ; )	/* forever do... */\n		{\n		    /* printf("spCHfactor() -- checkpoint 3\n"); */\n		    /* find next row where something (non-trivial) happens\n			i.e. find min(scan_row) */\n		    /* printf("scan_row: "); */\n		    minim = n;\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			tmp1 = scan_row[i];\n			/* printf("%d ",tmp1); */\n			minim = ( tmp1 >= 0 && tmp1 < minim ) ? tmp1 : minim;\n		    }\n		    /* printf("minim = %d\n",minim); */\n		    /* printf("col_list: "); */\n		    /*  for ( i = 0; i < num_scan; i++ ) */\n			/*  printf("%d ",col_list[i]); */\n		    /*  printf("\n"); */\n\n		    if ( minim >= n )\n			break;	/* nothing more to do for this column */\n		    r_op = &(A->row[minim]);\n		    elt_op = r_op->elt;\n\n		    /* set next entry in column k of Cholesky factors */\n		    idx = sprow_idx2(r_op,k,scan_idx[num_scan-1]);\n		    if ( idx < 0 )\n		    {	/* fill-in */\n			sp_set_val(A,minim,k,\n					-sprow_ip(r_piv,r_op,k)/pivot);\n			/* in case a realloc() has occurred... */\n			elt_op = r_op->elt;\n			/* now set up column access path again */\n			idx = sprow_idx2(r_op,k,-(idx+2));\n			tmp1 = old_elt->nxt_row;\n			old_elt->nxt_row = minim;\n			r_op->elt[idx].nxt_row = tmp1;\n			tmp1 = old_elt->nxt_idx;\n			old_elt->nxt_idx = idx;\n			r_op->elt[idx].nxt_idx = tmp1;\n		    }\n		    else\n		        elt_op[idx].val = (elt_op[idx].val -\n				sprow_ip(r_piv,r_op,k))/pivot;\n\n		    /* printf("spCHfactor() -- checkpoint 4\n"); */\n\n		    /* remember current element in column k for column chain */\n		    idx = sprow_idx2(r_op,k,idx);\n		    old_elt = &(r_op->elt[idx]);\n\n		    /* update scan_row */\n		    /* printf("spCHfactor() -- checkpoint 5\n"); */\n		    /* printf("minim = %d\n",minim); */\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			if ( scan_row[i] != minim )\n				continue;\n			idx = sprow_idx2(r_op,col_list[i],scan_idx[i]);\n			if ( idx < 0 )\n			{	scan_row[i] = -1;	continue;	}\n			scan_row[i] = elt_op[idx].nxt_row;\n			scan_idx[i] = elt_op[idx].nxt_idx;\n			/* printf("scan_row[%d] = %d\n",i,scan_row[i]); */\n			/* printf("scan_idx[%d] = %d\n",i,scan_idx[i]); */\n		    }\n			\n		}\n	    /* printf("spCHfactor() -- checkpoint 6\n"); */\n	    /* sp_dump(stdout,A); */\n	    /* printf("\n\n\n"); */\n	}\n\n	return A;\n}\n\n/* spCHsolve -- solve L.L^T.out=b where L is a sparse matrix,\n	-- out, b dense vectors\n	-- returns out; operation may be in-situ */\n#ifndef ANSI_C\nVEC	*spCHsolve(L,b,out)\nSPMAT	*L;\nVEC	*b, *out;\n#else\nVEC	*spCHsolve(SPMAT *L, const VEC *b, VEC *out)\n#endif\n{\n	int	i, j_idx, n, scan_idx, scan_row;\n	SPROW	*row;\n	row_elt	*elt;\n	Real	diag_val, sum, *out_ve;\n\n	if ( L == SMNULL || b == VNULL )\n		error(E_NULL,"spCHsolve");\n	if ( L->m != L->n )\n		error(E_SQUARE,"spCHsolve");\n	if ( b->dim != L->m )\n		error(E_SIZES,"spCHsolve");\n\n	if ( ! L->flag_col )\n		sp_col_access(L);\n	if ( ! L->flag_diag )\n		sp_diag_access(L);\n\n	out = v_copy(b,out);\n	out_ve = out->ve;\n\n	/* forward substitution: solve L.x=b for x */\n	n = L->n;\n	for ( i = 0; i < n; i++ )\n	{\n		sum = out_ve[i];\n		row = &(L->row[i]);\n		elt = row->elt;\n		for ( j_idx = 0; j_idx < row->len; j_idx++, elt++ )\n		{\n		    if ( elt->col >= i )\n			break;\n		    sum -= elt->val*out_ve[elt->col];\n		}\n		if ( row->diag >= 0 )\n		    out_ve[i] = sum/(row->elt[row->diag].val);\n		else\n		    error(E_SING,"spCHsolve");\n	}\n\n	/* backward substitution: solve L^T.out = x for out */\n	for ( i = n-1; i >= 0; i-- )\n	{\n		sum = out_ve[i];\n		row = &(L->row[i]);\n		/* Note that row->diag >= 0 by above loop */\n		elt = &(row->elt[row->diag]);\n		diag_val = elt->val;\n\n		/* scan down column */\n		scan_idx = elt->nxt_idx;\n		scan_row = elt->nxt_row;\n		while ( scan_row >= 0 /* && scan_idx >= 0 */ )\n		{\n		    row = &(L->row[scan_row]);\n		    elt = &(row->elt[scan_idx]);\n		    sum -= elt->val*out_ve[scan_row];\n		    scan_idx = elt->nxt_idx;\n		    scan_row = elt->nxt_row;\n		}\n		out_ve[i] = sum/diag_val;\n	}\n\n	return out;\n}\n\n/* spICHfactor -- sparse Incomplete Cholesky factorisation\n	-- does a Cholesky factorisation assuming NO FILL-IN\n	-- as for spCHfactor(), only the lower triangular part of A is used */\n#ifndef ANSI_C\nSPMAT	*spICHfactor(A)\nSPMAT	*A;\n#else\nSPMAT	*spICHfactor(SPMAT *A)\n#endif\n{\n	int	k, m, n, nxt_row, nxt_idx, diag_idx;\n	Real	pivot, tmp2;\n	SPROW	*r_piv, *r_op;\n	row_elt	*elt_piv, *elt_op;\n\n	if ( A == SMNULL )\n		error(E_NULL,"spICHfactor");\n	if ( A->m != A->n )\n		error(E_SQUARE,"spICHfactor");\n\n	/* set up access paths if not already done so */\n	if ( ! A->flag_col )\n		sp_col_access(A);\n	if ( ! A->flag_diag )\n		sp_diag_access(A);\n\n	m = A->m;	n = A->n;\n	for ( k = 0; k < m; k++ )\n	{\n		r_piv = &(A->row[k]);\n\n		diag_idx = r_piv->diag;\n		if ( diag_idx < 0 )\n			error(E_POSDEF,"spICHfactor");\n\n		elt_piv = r_piv->elt;\n\n		/* set diagonal entry of Cholesky factor */\n		tmp2 = elt_piv[diag_idx].val - sprow_sqr(r_piv,k);\n		if ( tmp2 <= 0.0 )\n			error(E_POSDEF,"spICHfactor");\n		elt_piv[diag_idx].val = pivot = sqrt(tmp2);\n\n		/* find next row where something (non-trivial) happens */\n		nxt_row = elt_piv[diag_idx].nxt_row;\n		nxt_idx = elt_piv[diag_idx].nxt_idx;\n\n		/* now set the k-th column of the Cholesky factors */\n		while ( nxt_row >= 0 && nxt_idx >= 0 )\n		{\n		    /* nxt_row and nxt_idx give next next row (& index)\n			of the entry to be modified */\n		    r_op = &(A->row[nxt_row]);\n		    elt_op = r_op->elt;\n		    elt_op[nxt_idx].val = (elt_op[nxt_idx].val -\n				sprow_ip(r_piv,r_op,k))/pivot;\n\n		    nxt_row = elt_op[nxt_idx].nxt_row;\n		    nxt_idx = elt_op[nxt_idx].nxt_idx;\n		}\n	}\n\n	return A;\n}\n\n\n/* spCHsymb -- symbolic sparse Cholesky factorisation\n	-- does NOT do any floating point arithmetic; just sets up the structure\n	-- only the lower triangular part of A (incl. diagonal) is used */\n#ifndef ANSI_C\nSPMAT	*spCHsymb(A)\nSPMAT	*A;\n#else\nSPMAT	*spCHsymb(SPMAT *A)\n#endif\n{\n	register 	int	i;\n	int	idx, k, m, minim, n, num_scan, diag_idx, tmp1;\n	SPROW	*r_piv, *r_op;\n	row_elt	*elt_piv, *elt_op, *old_elt;\n\n	if ( A == SMNULL )\n		error(E_NULL,"spCHsymb");\n	if ( A->m != A->n )\n		error(E_SQUARE,"spCHsymb");\n\n	/* set up access paths if not already done so */\n	if ( ! A->flag_col )\n		sp_col_access(A);\n	if ( ! A->flag_diag )\n		sp_diag_access(A);\n\n	/* printf("spCHsymb() -- checkpoint 1\n"); */\n	m = A->m;	n = A->n;\n	for ( k = 0; k < m; k++ )\n	{\n		r_piv = &(A->row[k]);\n		if ( r_piv->len > scan_len )\n			set_scan(r_piv->len);\n		elt_piv = r_piv->elt;\n		diag_idx = sprow_idx2(r_piv,k,r_piv->diag);\n		if ( diag_idx < 0 )\n			error(E_POSDEF,"spCHsymb");\n		old_elt = &(elt_piv[diag_idx]);\n		for ( i = 0; i < r_piv->len; i++ )\n		{\n			if ( elt_piv[i].col > k )\n				break;\n			col_list[i] = elt_piv[i].col;\n			scan_row[i] = elt_piv[i].nxt_row;\n			scan_idx[i] = elt_piv[i].nxt_idx;\n		}\n		/* printf("spCHsymb() -- checkpoint 2\n"); */\n		num_scan = i;	/* number of actual entries in scan_row etc. */\n		/* printf("num_scan = %d\n",num_scan); */\n\n		/* now set the k-th column of the Cholesky factors */\n		/* printf("k = %d\n",k); */\n		for ( ; ; )	/* forever do... */\n		{\n		    /* printf("spCHsymb() -- checkpoint 3\n"); */\n		    /* find next row where something (non-trivial) happens\n			i.e. find min(scan_row) */\n		    minim = n;\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			tmp1 = scan_row[i];\n			/* printf("%d ",tmp1); */\n			minim = ( tmp1 >= 0 && tmp1 < minim ) ? tmp1 : minim;\n		    }\n\n		    if ( minim >= n )\n			break;	/* nothing more to do for this column */\n		    r_op = &(A->row[minim]);\n		    elt_op = r_op->elt;\n\n		    /* set next entry in column k of Cholesky factors */\n		    idx = sprow_idx2(r_op,k,scan_idx[num_scan-1]);\n		    if ( idx < 0 )\n		    {	/* fill-in */\n			sp_set_val(A,minim,k,0.0);\n			/* in case a realloc() has occurred... */\n			elt_op = r_op->elt;\n			/* now set up column access path again */\n			idx = sprow_idx2(r_op,k,-(idx+2));\n			tmp1 = old_elt->nxt_row;\n			old_elt->nxt_row = minim;\n			r_op->elt[idx].nxt_row = tmp1;\n			tmp1 = old_elt->nxt_idx;\n			old_elt->nxt_idx = idx;\n			r_op->elt[idx].nxt_idx = tmp1;\n		    }\n\n		    /* printf("spCHsymb() -- checkpoint 4\n"); */\n\n		    /* remember current element in column k for column chain */\n		    idx = sprow_idx2(r_op,k,idx);\n		    old_elt = &(r_op->elt[idx]);\n\n		    /* update scan_row */\n		    /* printf("spCHsymb() -- checkpoint 5\n"); */\n		    /* printf("minim = %d\n",minim); */\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			if ( scan_row[i] != minim )\n				continue;\n			idx = sprow_idx2(r_op,col_list[i],scan_idx[i]);\n			if ( idx < 0 )\n			{	scan_row[i] = -1;	continue;	}\n			scan_row[i] = elt_op[idx].nxt_row;\n			scan_idx[i] = elt_op[idx].nxt_idx;\n			/* printf("scan_row[%d] = %d\n",i,scan_row[i]); */\n			/* printf("scan_idx[%d] = %d\n",i,scan_idx[i]); */\n		    }\n			\n		}\n	    /* printf("spCHsymb() -- checkpoint 6\n"); */\n	}\n\n	return A;\n}\n\n/* comp_AAT -- compute A.A^T where A is a given sparse matrix */\n#ifndef ANSI_C\nSPMAT	*comp_AAT(A)\nSPMAT	*A;\n#else\nSPMAT	*comp_AAT(SPMAT *A)\n#endif\n{\n	SPMAT	*AAT;\n	SPROW	*r, *r2;\n	row_elt	*elts, *elts2;\n	int	i, idx, idx2, j, m, minim, n, num_scan, tmp1;\n	Real	ip;\n\n	if ( ! A )\n		error(E_NULL,"comp_AAT");\n	m = A->m;	n = A->n;\n\n	/* set up column access paths */\n	if ( ! A->flag_col )\n		sp_col_access(A);\n\n	AAT = sp_get(m,m,10);\n\n	for ( i = 0; i < m; i++ )\n	{\n		/* initialisation */\n		r = &(A->row[i]);\n		elts = r->elt;\n\n		/* set up scan lists for this row */\n		if ( r->len > scan_len )\n		    set_scan(r->len);\n		for ( j = 0; j < r->len; j++ )\n		{\n		    col_list[j] = elts[j].col;\n		    scan_row[j] = elts[j].nxt_row;\n		    scan_idx[j] = elts[j].nxt_idx;\n		}\n		num_scan = r->len;\n\n		/* scan down the rows for next non-zero not\n			associated with a diagonal entry */\n		for ( ; ; )\n		{\n		    minim = m;\n		    for ( idx = 0; idx < num_scan; idx++ )\n		    {\n			tmp1 = scan_row[idx];\n			minim = ( tmp1 >= 0 && tmp1 < minim ) ? tmp1 : minim;\n		    }\n		    if ( minim >= m )\n		 	break;\n		    r2 = &(A->row[minim]);\n		    if ( minim > i )\n		    {\n			ip = sprow_ip(r,r2,n);\n		        sp_set_val(AAT,minim,i,ip);\n		        sp_set_val(AAT,i,minim,ip);\n		    }\n		    /* update scan entries */\n		    elts2 = r2->elt;\n		    for ( idx = 0; idx < num_scan; idx++ )\n		    {\n			if ( scan_row[idx] != minim || scan_idx[idx] < 0 )\n			    continue;\n			idx2 = scan_idx[idx];\n			scan_row[idx] = elts2[idx2].nxt_row;\n			scan_idx[idx] = elts2[idx2].nxt_idx;\n		    }\n		}\n\n		/* set the diagonal entry */\n		sp_set_val(AAT,i,i,sprow_sqr(r,n));\n	}\n\n	return AAT;\n}\n\n