#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf("running OMP on host\n");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n