\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided "as is" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* 1.6 matrixio.c 11/25/87 */\n\n\n#include        <stdio.h>\n#include        <ctype.h>\n#include        "matrix.h"\n\nstatic char rcsid[] = "$Id: matrixio.c,v 1.4 1994/01/13 05:31:10 des Exp $";\n\n\n/* local variables */\nstatic char line[MAXLINE];\n\n\n/**************************************************************************\n  Input routines\n  **************************************************************************/\n/* skipjunk -- skips white spaces and strings of the form #....\n\n   Here .... is a comment string */\n#ifndef ANSI_C\nint     skipjunk(fp)\nFILE    *fp;\n#else\nint	skipjunk(FILE *fp)\n#endif\n{\n     int        c;\n     \n     for ( ; ; )        /* forever do... */\n     {\n	  /* skip blanks */\n	  do\n	       c = getc(fp);\n	  while ( isspace(c) );\n	  \n	  /* skip comments (if any) */\n	  if ( c == '#' )\n	       /* yes it is a comment (line) */\n	       while ( (c=getc(fp)) != '\n' )\n		    ;\n	  else\n	  {\n	       ungetc(c,fp);\n	       break;\n	  }\n     }\n     return 0;\n}\n\n/* m_finput -- input matrix\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by m_foutput\n	except that whitespace and comments ("#..\n") are skipped\n	-- returns a, which is created if a == NULL on entry */\n#ifndef ANSI_C\nMAT     *m_finput(fp,a)\nFILE    *fp;\nMAT     *a;\n#else\nMAT	*m_finput(FILE *fp, MAT *a)\n#endif\n{\n     MAT        *im_finput(),*bm_finput();\n     \n     if ( isatty(fileno(fp)) )\n	  return im_finput(fp,a);\n     else\n	  return bm_finput(fp,a);\n}\n\n/* im_finput -- interactive input of matrix */\n#ifndef ANSI_C\nMAT     *im_finput(fp,mat)\nFILE    *fp;\nMAT     *mat;\n#else\nMAT     *im_finput(FILE *fp,MAT *mat)\n#endif\n{\n     char       c;\n     unsigned int      i, j, m, n, dynamic;\n     /* dynamic set to TRUE if memory allocated here */\n     \n     /* get matrix size */\n     if ( mat != (MAT *)NULL && mat->m<MAXDIM && mat->n<MAXDIM )\n     {  m = mat->m;     n = mat->n;     dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,"Matrix: rows cols:");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,"im_finput");\n	  } while ( sscanf(line,"%u%u",&m,&n)<2 || m>MAXDIM || n>MAXDIM );\n	  mat = m_get(m,n);\n     }\n     \n     /* input elements */\n     for ( i=0; i<m; i++ )\n     {\n     redo:\n	  fprintf(stderr,"row %u:\n",i);\n	  for ( j=0; j<n; j++ )\n	       do\n	       {\n	       redo2:\n		    fprintf(stderr,"entry (%u,%u): ",i,j);\n		    if ( !dynamic )\n			 fprintf(stderr,"old %14.9g new: ",\n				 mat->me[i][j]);\n		    if ( fgets(line,MAXLINE,fp)==NULL )\n			 error(E_INPUT,"im_finput");\n		    if ( (*line == 'b' || *line == 'B') && j > 0 )\n		    {   j--;    dynamic = FALSE;        goto redo2;     }\n		    if ( (*line == 'f' || *line == 'F') && j < n-1 )\n		    {   j++;    dynamic = FALSE;        goto redo2;     }\n#if REAL == DOUBLE\n	       } while ( *line=='\0' || sscanf(line,"%lf",&mat->me[i][j])<1 );\n#elif REAL == FLOAT\n	       } while ( *line=='\0' || sscanf(line,"%f",&mat->me[i][j])<1 );\n#endif\n	  fprintf(stderr,"Continue: ");\n	  fscanf(fp,"%c",&c);\n	  if ( c == 'n' || c == 'N' )\n	  {    dynamic = FALSE;                 goto redo;      }\n	  if ( (c == 'b' || c == 'B') /* && i > 0 */ )\n	  {     if ( i > 0 )\n		    i--;\n		dynamic = FALSE;        goto redo;\n	  }\n     }\n     \n     return (mat);\n}\n\n/* bm_finput -- batch-file input of matrix */\n#ifndef ANSI_C\nMAT     *bm_finput(fp,mat)\nFILE    *fp;\nMAT     *mat;\n#else\nMAT     *bm_finput(FILE *fp,MAT *mat)\n#endif\n{\n     unsigned int      i,j,m,n,dummy;\n     int        io_code;\n     \n     /* get dimension */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp," Matrix: %u by %u",&m,&n)) < 2 ||\n	 m>MAXDIM || n>MAXDIM )\n	  error(io_code==EOF ? E_EOF : E_FORMAT,"bm_finput");\n     \n     /* allocate memory if necessary */\n     if ( mat==(MAT *)NULL )\n	  mat = m_resize(mat,m,n);\n     \n     /* get entries */\n     for ( i=0; i<m; i++ )\n     {\n	  skipjunk(fp);\n	  if ( fscanf(fp," row %u:",&dummy) < 1 )\n	       error(E_FORMAT,"bm_finput");\n	  for ( j=0; j<n; j++ )\n#if REAL == DOUBLE\n	       if ((io_code=fscanf(fp,"%lf",&mat->me[i][j])) < 1 )\n#elif REAL == FLOAT\n	       if ((io_code=fscanf(fp,"%f",&mat->me[i][j])) < 1 )\n#endif\n		    error(io_code==EOF ? 7 : 6,"bm_finput");\n     }\n     \n     return (mat);\n}\n\n/* px_finput -- inputs permutation from file/stream fp\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by px_foutput\n	except that whitespace and comments ("#..\n") are skipped\n	-- returns px, which is created if px == NULL on entry */\n#ifndef ANSI_C\nPERM    *px_finput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nPERM    *px_finput(FILE *fp,PERM *px)\n#endif\n{\n     PERM       *ipx_finput(),*bpx_finput();\n     \n     if ( isatty(fileno(fp)) )\n	  return ipx_finput(fp,px);\n     else\n	  return bpx_finput(fp,px);\n}\n\n\n/* ipx_finput -- interactive input of permutation */\n#ifndef ANSI_C\nPERM    *ipx_finput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nPERM    *ipx_finput(FILE *fp,PERM *px)\n#endif\n{\n     unsigned int      i,j,size,dynamic; /* dynamic set if memory allocated here */\n     unsigned int      entry,ok;\n     \n     /* get permutation size */\n     if ( px!=(PERM *)NULL && px->size<MAXDIM )\n     {  size = px->size;        dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,"Permutation: size: ");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,"ipx_finput");\n	  } while ( sscanf(line,"%u",&size)<1 || size>MAXDIM );\n	  px = px_get(size);\n     }\n     \n     /* get entries */\n     i = 0;\n     while ( i<size )\n     {\n	  /* input entry */\n	  do\n	  {\n	  redo:\n	       fprintf(stderr,"entry %u: ",i);\n	       if ( !dynamic )\n		    fprintf(stderr,"old: %u->%u new: ",\n			    i,px->pe[i]);\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,"ipx_finput");\n	       if ( (*line == 'b' || *line == 'B') && i > 0 )\n	       {        i--;    dynamic = FALSE;        goto redo;      }\n	  } while ( *line=='\0' || sscanf(line,"%u",&entry) < 1 );\n	  /* check entry */\n	  ok = (entry < size);\n	  for ( j=0; j<i; j++ )\n	       ok &= (entry != px->pe[j]);\n	  if ( ok )\n	  {\n	       px->pe[i] = entry;\n	       i++;\n	  }\n     }\n     \n     return (px);\n}\n\n/* bpx_finput -- batch-file input of permutation */\n#ifndef ANSI_C\nPERM    *bpx_finput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nPERM    *bpx_finput(FILE *fp,PERM *px)\n#endif\n{\n     unsigned int      i,j,size,entry,ok;\n     int        io_code;\n     \n     /* get size of permutation */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp," Permutation: size:%u",&size)) < 1 ||\n	 size>MAXDIM )\n	  error(io_code==EOF ? 7 : 6,"bpx_finput");\n     \n     /* allocate memory if necessary */\n     if ( px==(PERM *)NULL || px->size<size )\n	  px = px_resize(px,size);\n     \n     /* get entries */\n     skipjunk(fp);\n     i = 0;\n     while ( i<size )\n     {\n	  /* input entry */\n	  if ((io_code=fscanf(fp,"%*u -> %u",&entry)) < 1 )\n	       error(io_code==EOF ? 7 : 6,"bpx_finput");\n	  /* check entry */\n	  ok = (entry < size);\n	  for ( j=0; j<i; j++ )\n	       ok &= (entry != px->pe[j]);\n	  if ( ok )\n	  {\n	       px->pe[i] = entry;\n	       i++;\n	  }\n	  else\n	       error(E_BOUNDS,"bpx_finput");\n     }\n     \n     return (px);\n}\n\n/* v_finput -- inputs vector from file/stream fp\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by px_foutput\n	except that whitespace and comments ("#..\n") are skipped\n	-- returns x, which is created if x == NULL on entry */\n#ifndef ANSI_C\nVEC     *v_finput(fp,x)\nFILE    *fp;\nVEC     *x;\n#else\nVEC     *v_finput(FILE *fp,VEC *x)\n#endif\n{\n     VEC        *ifin_vec(),*bfin_vec();\n     \n     if ( isatty(fileno(fp)) )\n	  return ifin_vec(fp,x);\n     else\n	  return bfin_vec(fp,x);\n}\n\n/* ifin_vec -- interactive input of vector */\n#ifndef ANSI_C\nVEC     *ifin_vec(fp,vec)\nFILE    *fp;\nVEC     *vec;\n#else\nVEC     *ifin_vec(FILE *fp,VEC *vec)\n#endif\n{\n     unsigned int      i,dim,dynamic;  /* dynamic set if memory allocated here */\n     \n     /* get vector dimension */\n     if ( vec != (VEC *)NULL && vec->dim<MAXDIM )\n     {  dim = vec->dim; dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,"Vector: dim: ");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,"ifin_vec");\n	  } while ( sscanf(line,"%u",&dim)<1 || dim>MAXDIM );\n	  vec = v_get(dim);\n     }\n     \n     /* input elements */\n     for ( i=0; i<dim; i++ )\n	  do\n	  {\n	  redo:\n	       fprintf(stderr,"entry %u: ",i);\n	       if ( !dynamic )\n		    fprintf(stderr,"old %14.9g new: ",vec->ve[i]);\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,"ifin_vec");\n	       if ( (*line == 'b' || *line == 'B') && i > 0 )\n	       {        i--;    dynamic = FALSE;        goto redo;         }\n	       if ( (*line == 'f' || *line == 'F') && i < dim-1 )\n	       {        i++;    dynamic = FALSE;        goto redo;         }\n#if REAL == DOUBLE\n	  } while ( *line=='\0' || sscanf(line,"%lf",&vec->ve[i]) < 1 );\n#elif REAL == FLOAT\n          } while ( *line=='\0' || sscanf(line,"%f",&vec->ve[i]) < 1 );\n#endif\n     \n     return (vec);\n}\n\n/* bfin_vec -- batch-file input of vector */\n#ifndef ANSI_C\nVEC     *bfin_vec(fp,vec)\nFILE    *fp;\nVEC     *vec;\n#else\nVEC     *bfin_vec(FILE *fp,VEC *vec)\n#endif\n{\n     unsigned int      i,dim;\n     int        io_code;\n     \n     /* get dimension */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp," Vector: dim:%u",&dim)) < 1 ||\n	 dim>MAXDIM )\n	  error(io_code==EOF ? 7 : 6,"bfin_vec");\n     \n     /* allocate memory if necessary */\n     if ( vec==(VEC *)NULL )\n	  vec = v_resize(vec,dim);\n     \n     /* get entries */\n     skipjunk(fp);\n     for ( i=0; i<dim; i++ )\n#if REAL == DOUBLE\n	  if ((io_code=fscanf(fp,"%lf",&vec->ve[i])) < 1 )\n#elif REAL == FLOAT\n	  if ((io_code=fscanf(fp,"%f",&vec->ve[i])) < 1 )\n#endif\n	       error(io_code==EOF ? 7 : 6,"bfin_vec");\n     \n     return (vec);\n}\n\n/**************************************************************************\n  Output routines\n  **************************************************************************/\nstatic const char    *format = "%14.9g ";\n\n/* setformat -- sets the printf format string for the Meschach I/O operations\n	-- returns the previous format string */\n#ifndef ANSI_C\nchar	*setformat(f_string)\nchar    *f_string;\n#else\nconst char	*setformat(const char *f_string)\n#endif\n{\n    const char	*old_f_string;\n    old_f_string = format;\n    if ( f_string != (char *)NULL && *f_string != '\0' )\n	format = f_string;\n\n    return old_f_string;\n}\n\n/* m_foutput -- prints a representation of the matrix a onto file/stream fp */\n#ifndef ANSI_C\nvoid    m_foutput(fp,a)\nFILE    *fp;\nMAT     *a;\n#else\nvoid    m_foutput(FILE *fp, const MAT *a)\n#endif\n{\n     unsigned int      i, j, tmp;\n     \n     if ( a == (MAT *)NULL )\n     {  fprintf(fp,"Matrix: NULL\n");   return;         }\n     fprintf(fp,"Matrix: %d by %d\n",a->m,a->n);\n     if ( a->me == (Real **)NULL )\n     {  fprintf(fp,"NULL\n");           return;         }\n     for ( i=0; i<a->m; i++ )   /* for each row... */\n     {\n	  fprintf(fp,"row %u: ",i);\n	  for ( j=0, tmp=2; j<a->n; j++, tmp++ )\n	  {             /* for each col in row... */\n	       fprintf(fp,format,a->me[i][j]);\n	       if ( ! (tmp % 5) )       putc('\n',fp);\n	  }\n	  if ( tmp % 5 != 1 )   putc('\n',fp);\n     }\n}\n\n/* px_foutput -- prints a representation of px onto file/stream fp */\n#ifndef ANSI_C\nvoid    px_foutput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nvoid	px_foutput(FILE *fp, const PERM *px)\n#endif\n{\n     unsigned int      i;\n     \n     if ( px == (PERM *)NULL )\n     {  fprintf(fp,"Permutation: NULL\n");      return;         }\n     fprintf(fp,"Permutation: size: %u\n",px->size);\n     if ( px->pe == (unsigned int *)NULL )\n     {  fprintf(fp,"NULL\n");   return;         }\n     for ( i=0; i<px->size; i++ )\n	if ( ! (i % 8) && i != 0 )\n	  fprintf(fp,"\n  %u->%u ",i,px->pe[i]);\n	else\n	  fprintf(fp,"%u->%u ",i,px->pe[i]);\n     fprintf(fp,"\n");\n}\n\n/* v_foutput -- prints a representation of x onto file/stream fp */\n#ifndef ANSI_C\nvoid    v_foutput(fp,x)\nFILE    *fp;\nVEC     *x;\n#else\nvoid	v_foutput(FILE *fp, const VEC *x)\n#endif\n{\n     unsigned int      i, tmp;\n     \n     if ( x == (VEC *)NULL )\n     {  fprintf(fp,"Vector: NULL\n");   return;         }\n     fprintf(fp,"Vector: dim: %d\n",x->dim);\n     if ( x->ve == (Real *)NULL )\n     {  fprintf(fp,"NULL\n");   return;         }\n     for ( i=0, tmp=0; i<x->dim; i++, tmp++ )\n     {\n	  fprintf(fp,format,x->ve[i]);\n	  if ( tmp % 5 == 4 )   putc('\n',fp);\n     }\n     if ( tmp % 5 != 0 )        putc('\n',fp);\n}\n\n/* m_dump -- prints a dump of all pointers and data in a onto fp\n	-- suitable for low-level debugging */\n#ifndef ANSI_C\nvoid    m_dump(fp,a)\nFILE    *fp;\nMAT     *a;\n#else\nvoid	m_dump(FILE *fp, const MAT *a)\n#endif\n{\n	unsigned int   i, j, tmp;\n     \n     if ( a == (MAT *)NULL )\n     {  fprintf(fp,"Matrix: NULL\n");   return;         }\n     fprintf(fp,"Matrix: %d by %d @ 0x%lx\n",a->m,a->n,(long)a);\n     fprintf(fp,"\tmax_m = %d, max_n = %d, max_size = %d\n",\n	     a->max_m, a->max_n, a->max_size);\n     if ( a->me == (Real **)NULL )\n     {  fprintf(fp,"NULL\n");           return;         }\n     fprintf(fp,"a->me @ 0x%lx\n",(long)(a->me));\n     fprintf(fp,"a->base @ 0x%lx\n",(long)(a->base));\n     for ( i=0; i<a->m; i++ )   /* for each row... */\n     {\n	  fprintf(fp,"row %u: @ 0x%lx ",i,(long)(a->me[i]));\n	  for ( j=0, tmp=2; j<a->n; j++, tmp++ )\n	  {             /* for each col in row... */\n	       fprintf(fp,format,a->me[i][j]);\n	       if ( ! (tmp % 5) )       putc('\n',fp);\n	  }\n	  if ( tmp % 5 != 1 )   putc('\n',fp);\n     }\n}\n\n/* px_dump --  prints a dump of all pointers and data in a onto fp\n	-- suitable for low-level debugging */\n#ifndef ANSI_C\nvoid    px_dump(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nvoid	px_dump(FILE *fp, const PERM *px)\n#endif\n{\n     unsigned int      i;\n     \n     if ( ! px )\n     {  fprintf(fp,"Permutation: NULL\n");      return;         }\n     fprintf(fp,"Permutation: size: %u @ 0x%lx\n",px->size,(long)(px));\n     if ( ! px->pe )\n     {  fprintf(fp,"NULL\n");   return;         }\n     fprintf(fp,"px->pe @ 0x%lx\n",(long)(px->pe));\n     for ( i=0; i<px->size; i++ )\n	  fprintf(fp,"%u->%u ",i,px->pe[i]);\n     fprintf(fp,"\n");\n}\n\n\n/* v_dump --  prints a dump of all pointers and data in a onto fp\n	-- suitable for low-level debugging */\n#ifndef ANSI_C\nvoid    v_dump(fp,x)\nFILE    *fp;\nVEC     *x;\n#else\nvoid	v_dump(FILE *fp, const VEC *x)\n#endif\n{\n     unsigned int      i, tmp;\n     \n     if ( ! x )\n     {  fprintf(fp,"Vector: NULL\n");   return;         }\n     fprintf(fp,"Vector: dim: %d @ 0x%lx\n",x->dim,(long)(x));\n     if ( ! x->ve )\n     {  fprintf(fp,"NULL\n");   return;         }\n     fprintf(fp,"x->ve @ 0x%lx\n",(long)(x->ve));\n     for ( i=0, tmp=0; i<x->dim; i++, tmp++ )\n     {\n	  fprintf(fp,format,x->ve[i]);\n	  if ( tmp % 5 == 4 )   putc('\n',fp);\n     }\n     if ( tmp % 5 != 0 )        putc('\n',fp);\n}\n\n\n/* iv_foutput -- print a representation of iv on stream fp */\n#ifndef ANSI_C\nvoid	iv_foutput(fp,iv)\nFILE	*fp;\nIVEC	*iv;\n#else\nvoid	iv_foutput(FILE *fp, const IVEC *iv)\n#endif\n{\n   int	i;\n   \n   fprintf(fp,"IntVector: ");\n   if ( iv == IVNULL )\n   {\n      fprintf(fp,"**** NULL ****\n");\n      return;\n   }\n   fprintf(fp,"dim: %d\n",iv->dim);\n   for ( i = 0; i < iv->dim; i++ )\n   {\n      if ( (i+1) % 8 )\n	fprintf(fp,"%8d ",iv->ive[i]);\n      else\n	fprintf(fp,"%8d\n",iv->ive[i]);\n   }\n   if ( i % 8 )\n     fprintf(fp,"\n");\n}\n\n\n/* iv_finput -- input integer vector from stream fp\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by\n	iv_foutput except that whitespace and comments ("#...\n") \n	are skipped */\n#ifndef ANSI_C\nIVEC	*iv_finput(fp,x)\nFILE	*fp;\nIVEC	*x;\n#else\nIVEC	*iv_finput(FILE *fp, IVEC *x)\n#endif\n{\n   IVEC	*iiv_finput(),*biv_finput();\n   \n   if ( isatty(fileno(fp)) )\n     return iiv_finput(fp,x);\n   else\n     return biv_finput(fp,x);\n}\n\n/* iiv_finput -- interactive input of IVEC iv */\n#ifndef ANSI_C\nIVEC	*iiv_finput(fp,iv)\nFILE	*fp;\nIVEC	*iv;\n#else\nIVEC	*iiv_finput(FILE *fp, IVEC *iv)\n#endif\n{\n   unsigned int	i,dim,dynamic;	/* dynamic set if memory allocated here */\n   \n   /* get dimension */\n   if ( iv != (IVEC *)NULL && iv->dim<MAXDIM )\n   {	dim = iv->dim;	dynamic = FALSE;	}\n   else\n   {\n      dynamic = TRUE;\n      do\n      {\n	 fprintf(stderr,"IntVector: dim: ");\n	 if ( fgets(line,MAXLINE,fp)==NULL )\n	   error(E_INPUT,"iiv_finput");\n      } while ( sscanf(line,"%u",&dim)<1 || dim>MAXDIM );\n      iv = iv_get(dim);\n   }\n   \n   /* input elements */\n   for ( i=0; i<dim; i++ )\n     do\n     {\n      redo:\n	fprintf(stderr,"entry %u: ",i);\n	if ( !dynamic )\n	  fprintf(stderr,"old: %-9d  new: ",iv->ive[i]);\n	if ( fgets(line,MAXLINE,fp)==NULL )\n	  error(E_INPUT,"iiv_finput");\n	if ( (*line == 'b' || *line == 'B') && i > 0 )\n	{	i--;	dynamic = FALSE;	goto redo;	   }\n	if ( (*line == 'f' || *line == 'F') && i < dim-1 )\n	{	i++;	dynamic = FALSE;	goto redo;	   }\n     } while ( *line=='\0' || sscanf(line,"%d",&iv->ive[i]) < 1 );\n   \n   return (iv);\n}\n\n/* biv_finput -- batch-file input of IVEC iv */\n#ifndef ANSI_C\nIVEC	*biv_finput(fp,iv)\nFILE	*fp;\nIVEC	*iv;\n#else\nIVEC	*biv_finput(FILE *fp, IVEC *iv)\n#endif\n{\n   unsigned int	i,dim;\n   int	io_code;\n   \n   /* get dimension */\n   skipjunk(fp);\n   if ((io_code=fscanf(fp," IntVector: dim:%u",&dim)) < 1 ||\n       dim>MAXDIM )\n     error(io_code==EOF ? 7 : 6,"biv_finput");\n   \n   /* allocate memory if necessary */\n   if ( iv==(IVEC *)NULL || iv->dim<dim )\n     iv = iv_resize(iv,dim);\n   \n   /* get entries */\n   skipjunk(fp);\n   for ( i=0; i<dim; i++ )\n     if ((io_code=fscanf(fp,"%d",&iv->ive[i])) < 1 )\n       error(io_code==EOF ? 7 : 6,"biv_finput");\n   \n   return (iv);\n}\n\n/* iv_dump -- dumps all the contents of IVEC iv onto stream fp */\n#ifndef ANSI_C\nvoid	iv_dump(fp,iv)\nFILE*fp;\nIVEC*iv;\n#else\nvoid	iv_dump(FILE *fp, const IVEC *iv)\n#endif\n{\n   int		i;\n   \n   fprintf(fp,"IntVector: ");\n   if ( ! iv )\n   {\n      fprintf(fp,"**** NULL ****\n");\n      return;\n   }\n   fprintf(fp,"dim: %d, max_dim: %d\n",iv->dim,iv->max_dim);\n   fprintf(fp,"ive @ 0x%lx\n",(long)(iv->ive));\n   for ( i = 0; i < iv->max_dim; i++ )\n   {\n      if ( (i+1) % 8 )\n	fprintf(fp,"%8d ",iv->ive[i]);\n      else\n	fprintf(fp,"%8d\n",iv->ive[i]);\n   }\n   if ( i % 8 )\n     fprintf(fp,"\n");\n}	\n\n