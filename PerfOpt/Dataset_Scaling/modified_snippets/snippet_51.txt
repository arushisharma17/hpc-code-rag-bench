/*\n *  avilib.c\n *\n *  Copyright (C) Thomas streich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas streich \n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de> \n *\n *  This file is part of transcode, a linux video stream processing tool\n *      \n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *   \n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *   \n *  You should have received a copy of the GNU General Public License\n *  along with GNU Make; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. \n *\n */\n\n#include "avilib.h"\n//#include <time.h>\n\n#define INFO_LIST\n\n/* The following variable indicates the kind of error */\n\nlong AVI_errno;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n#ifndef PACKAGE\n#define PACKAGE "my"\n#define VERSION "0.00"\n#endif\n\n#ifndef O_BINARY\n/* win32 wants a binary flag to open(); this sets it to null\n   on platforms that don't have it. */\n#define O_BINARY 0\n#endif\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic size_t avi_read(int fd, char *buf, size_t len)\n{\n   size_t n = 0;\n   size_t r = 0;\n\n   while (r < len) {\n      n = read (fd, buf + r, len - r);\n\n      if (n <= 0)\n	  return r;\n      r += n;\n   }\n\n   return r;\n}\n\nstatic size_t avi_write (int fd, char *buf, size_t len)\n{\n   size_t n = 0;\n   size_t r = 0;\n\n   while (r < len) {\n      n = write (fd, buf + r, len - r);\n      if (n < 0)\n         return n;\n      \n      r += n;\n   }\n   return r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, int n)\n{\n   dst[0] = (n    )&0xff;\n   dst[1] = (n>> 8)&0xff;\n   dst[2] = (n>>16)&0xff;\n   dst[3] = (n>>24)&0xff;\n}\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic unsigned long str2ulong(unsigned char *str)\n{\n   return ( str[0] | (str[1]<<8) | (str[2]<<16) | (str[3]<<24) );\n}\nstatic unsigned long str2ushort(unsigned char *str)\n{\n   return ( str[0] | (str[1]<<8) );\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n   int s;\n   s = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n   //   if(s==0) s=1; /* avoid possible zero divisions */\n   if(s<4) s=4; /* avoid possible zero divisions */ \n   return s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, int length)\n{\n   unsigned char c[8];\n\n   /* Copy tag and length int c, so that we need only 1 write system call\n      for these two values */\n\n   memcpy(c,tag,4);\n   long2str(c+4,length);\n\n   /* Output tag, length and data, restore previous position\n      if the write fails */\n\n   length = PAD_EVEN(length);\n\n   if( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n       avi_write(AVI->fdes,(char *)data,length) != length )\n   {\n      lseek(AVI->fdes,AVI->pos,SEEK_SET);\n      AVI_errno = AVI_ERR_WRITE;\n      return -1;\n   }\n\n   /* Update file position */\n\n   AVI->pos += 8 + length;\n\n   //fprintf(stderr, "pos=%lu %s\n", AVI->pos, tag);\n\n   return 0;\n}\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, long flags, unsigned long pos, unsigned long len)\n{\n   void *ptr;\n\n   if(AVI->n_idx>=AVI->max_idx) {\n     ptr = realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n     \n     if(ptr == 0) {\n       AVI_errno = AVI_ERR_NO_MEM;\n       return -1;\n     }\n     AVI->max_idx += 4096;\n     AVI->idx = (unsigned char((*)[16]) ) ptr;\n   }\n   \n   /* Add index entry */\n\n   //   fprintf(stderr, "INDEX %s %ld %lu %lu\n", tag, flags, pos, len);\n\n   memcpy(AVI->idx[AVI->n_idx],tag,4);\n   long2str(AVI->idx[AVI->n_idx]+ 4,flags);\n   long2str(AVI->idx[AVI->n_idx]+ 8, pos);\n   long2str(AVI->idx[AVI->n_idx]+12, len);\n   \n   /* Update counter */\n\n   AVI->n_idx++;\n\n   if(len>AVI->max_len) AVI->max_len=len;\n\n   return 0;\n}\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\navi_t* AVI_open_output_file(char * filename)\n{\n   avi_t *AVI;\n   int i;\n\n   int mask = 0;\n   \n   unsigned char AVI_header[HEADERBYTES];\n\n   /* Allocate the avi_t struct and zero it */\n\n   AVI = (avi_t *) malloc(sizeof(avi_t));\n   if(AVI==0)\n   {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n   }\n   memset((void *)AVI,0,sizeof(avi_t));\n\n   /* Since Linux needs a long time when deleting big files,\n      we do not truncate the file when we open it.\n      Instead it is truncated when the AVI file is closed */\n\n  /* mask = umask (0);\n   umask (mask);*/\n\n   AVI->fdes = open(filename, O_RDWR|O_CREAT|O_BINARY, 0644 &~ mask);\n   if (AVI->fdes < 0)\n   {\n      AVI_errno = AVI_ERR_OPEN;\n      free(AVI);\n      return 0;\n   }\n\n   /* Write out HEADERBYTES bytes, the header will go here\n      when we are finished with writing */\n\n   for (i=0;i<HEADERBYTES;i++) AVI_header[i] = 0;\n   i = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n   if (i != HEADERBYTES)\n   {\n      close(AVI->fdes);\n      AVI_errno = AVI_ERR_WRITE;\n      free(AVI);\n      return 0;\n   }\n\n   AVI->pos  = HEADERBYTES;\n   AVI->mode = AVI_MODE_WRITE; /* open for writing */\n\n   //init\n   AVI->anum = 0;\n   AVI->aptr = 0;\n\n   return AVI;\n}\n\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n   /* may only be called if file is open for writing */\n\n   if(AVI->mode==AVI_MODE_READ) return;\n\n   AVI->width  = width;\n   AVI->height = height;\n   AVI->fps    = fps;\n   \n   if(strncmp(compressor, "RGB", 3)==0) {\n     memset(AVI->compressor, 0, 4);\n   } else {\n     memcpy(AVI->compressor,compressor,4);\n   }     \n   \n   AVI->compressor[4] = 0;\n\n   avi_update_header(AVI);\n}\n\nvoid AVI_set_audio(avi_t *AVI, int channels, long rate, int bits, int format, long mp3rate)\n{\n   /* may only be called if file is open for writing */\n\n   if(AVI->mode==AVI_MODE_READ) return;\n\n   //inc audio tracks\n   AVI->aptr=AVI->anum;\n   ++AVI->anum;\n\n   if(AVI->anum > AVI_MAX_TRACKS) {\n     fprintf(stderr, "error - only %d audio tracks supported\n", AVI_MAX_TRACKS);\n     exit(1);\n   }\n\n   AVI->track[AVI->aptr].a_chans = channels;\n   AVI->track[AVI->aptr].a_rate  = rate;\n   AVI->track[AVI->aptr].a_bits  = bits;\n   AVI->track[AVI->aptr].a_fmt   = format;\n   AVI->track[AVI->aptr].mp3rate = mp3rate;\n\n   avi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); nhb += 4\n\n#define OUTLONG(n) \\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb,n); nhb += 4\n\n#define OUTSHRT(n) \\n   if(nhb<=HEADERBYTES-2) { \\n      AVI_header[nhb  ] = (n   )&0xff; \\n      AVI_header[nhb+1] = (n>>8)&0xff; \\n   } \\n   nhb += 2\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n   int njunk, sampsize, hasIndex, ms_per_frame, frate, flag;\n   int movi_len, hdrl_start, strl_start, j;\n   unsigned char AVI_header[HEADERBYTES];\n   long nhb;\n\n   //assume max size\n   movi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n   //assume index will be written\n   hasIndex=1;\n\n   if(AVI->fps < 0.001) {\n     frate=0;\n     ms_per_frame=0;\n   } else {\n     frate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n     ms_per_frame=(int) (1000000/AVI->fps + 0.5);\n   }\n\n   /* Prepare the file header */\n\n   nhb = 0;\n\n   /* The RIFF header */\n\n   OUT4CC ("RIFF");\n   OUTLONG(movi_len);    // assume max size\n   OUT4CC ("AVI ");\n\n   /* Start the header list */\n\n   OUT4CC ("LIST");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   hdrl_start = nhb;  /* Store start position */\n   OUT4CC ("hdrl");\n\n   /* The main AVI header */\n\n   /* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n   OUT4CC ("avih");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUTLONG(ms_per_frame);       /* Microseconds per frame */\n   //ThOe ->0 \n   //   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n   OUTLONG(0);\n   OUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n                                /* Other sources call it 'reserved' */\n   flag = AVIF_ISINTERLEAVED;\n   if(hasIndex) flag |= AVIF_HASINDEX;\n   if(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n   OUTLONG(flag);               /* Flags */\n   OUTLONG(0);                  // no frames yet\n   OUTLONG(0);                  /* InitialFrames */\n\n   OUTLONG(AVI->anum+1);\n\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n                                /* MS calls the following 'reserved': */\n   OUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n   OUTLONG(0);                  /* DataRate:   Data rate of playback     */\n   OUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n   OUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n   /* Start the video stream list ---------------------------------- */\n\n   OUT4CC ("LIST");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   strl_start = nhb;  /* Store start position */\n   OUT4CC ("strl");\n\n   /* The video stream header */\n\n   OUT4CC ("strh");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUT4CC ("vids");             /* Type */\n   OUT4CC (AVI->compressor);    /* Handler */\n   OUTLONG(0);                  /* Flags */\n   OUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n   OUTLONG(0);                  /* InitialFrames */\n   OUTLONG(FRAME_RATE_SCALE);              /* Scale */\n   OUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n   OUTLONG(0);                  /* Start */\n   OUTLONG(0);                  // no frames yet\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(-1);                 /* Quality */\n   OUTLONG(0);                  /* SampleSize */\n   OUTLONG(0);                  /* Frame */\n   OUTLONG(0);                  /* Frame */\n   //   OUTLONG(0);                  /* Frame */\n   //OUTLONG(0);                  /* Frame */\n\n   /* The video stream format */\n\n   OUT4CC ("strf");\n   OUTLONG(40);                 /* # of bytes to follow */\n   OUTLONG(40);                 /* Size */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n   OUTSHRT(1); OUTSHRT(24);     /* Planes, Count */\n   OUT4CC (AVI->compressor);    /* Compression */\n   // ThOe (*3)\n   OUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n   OUTLONG(0);                  /* XPelsPerMeter */\n   OUTLONG(0);                  /* YPelsPerMeter */\n   OUTLONG(0);                  /* ClrUsed: Number of colors used */\n   OUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n   /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n   long2str(AVI_header+strl_start-4,nhb-strl_start);\n\n   \n   /* Start the audio stream list ---------------------------------- */\n   \n   for(j=0; j<AVI->anum; ++j) {\n       \n       sampsize = avi_sampsize(AVI, j);\n   \n       OUT4CC ("LIST");\n       OUTLONG(0);        /* Length of list in bytes, don't know yet */\n       strl_start = nhb;  /* Store start position */\n       OUT4CC ("strl");\n       \n       /* The audio stream header */\n       \n       OUT4CC ("strh");\n       OUTLONG(56);            /* # of bytes to follow */\n       OUT4CC ("auds");\n       \n       // -----------\n       // ThOe\n       OUTLONG(0);             /* Format (Optionally) */\n       // -----------\n       \n       OUTLONG(0);             /* Flags */\n       OUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n       OUTLONG(0);             /* InitialFrames */\n       \n       // ThOe /4\n       OUTLONG(sampsize/4);      /* Scale */\n       OUTLONG(1000*AVI->track[j].mp3rate/8);\n       OUTLONG(0);             /* Start */\n       OUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n       OUTLONG(0);             /* SuggestedBufferSize */\n       OUTLONG(-1);            /* Quality */\n       \n       // ThOe /4\n       OUTLONG(sampsize/4);    /* SampleSize */\n       \n       OUTLONG(0);             /* Frame */\n       OUTLONG(0);             /* Frame */\n       //       OUTLONG(0);             /* Frame */\n       //OUTLONG(0);             /* Frame */\n       \n       /* The audio stream format */\n       \n       OUT4CC ("strf");\n       OUTLONG(16);                   /* # of bytes to follow */\n       OUTSHRT(AVI->track[j].a_fmt);           /* Format */\n       OUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n       OUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n       // ThOe\n       OUTLONG(1000*AVI->track[j].mp3rate/8);\n       //ThOe (/4)\n       \n       OUTSHRT(sampsize/4);           /* BlockAlign */\n       \n       \n       OUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n       \n       /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n       \n       long2str(AVI_header+strl_start-4,nhb-strl_start);\n   }\n   \n   /* Finish header list */\n   \n   long2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n   \n   \n   /* Calculate the needed amount of junk bytes, output junk */\n   \n   njunk = HEADERBYTES - nhb - 8 - 12;\n   \n   /* Safety first: if njunk <= 0, somebody has played with\n      HEADERBYTES without knowing what (s)he did.\n      This is a fatal error */\n   \n   if(njunk<=0)\n     {\n       fprintf(stderr,"AVI_close_output_file: # of header bytes too small\n");\n       exit(1);\n     }\n   \n   OUT4CC ("JUNK");\n   OUTLONG(njunk);\n   memset(AVI_header+nhb,0,njunk);\n   \n   //11/14/01 added id string \n\n   if(njunk > strlen(id_str)+8) {\n     sprintf(id_str, "%s-%s", PACKAGE, VERSION);\n     memcpy(AVI_header+nhb, id_str, strlen(id_str));\n   }\n   \n   nhb += njunk;\n\n   /* Start the movi list */\n\n   OUT4CC ("LIST");\n   OUTLONG(movi_len); /* Length of list in bytes */\n   OUT4CC ("movi");\n\n   /* Output the header, truncate the file to the number of bytes\n      actually written, report an error if someting goes wrong */\n\n   if ( lseek(AVI->fdes,0,SEEK_SET)<0 ||\n        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n	lseek(AVI->fdes,AVI->pos,SEEK_SET)<0)\n     {\n       AVI_errno = AVI_ERR_CLOSE;\n       return -1;\n     }\n\n   return 0;\n}\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\n   int ret, njunk, sampsize, hasIndex, ms_per_frame, frate, idxerror, flag;\n   unsigned long movi_len;\n   int hdrl_start, strl_start, j;\n   unsigned char AVI_header[HEADERBYTES];\n   long nhb;\n\n#ifdef INFO_LIST\n   long info_len;\n//   time_t calptr;\n#endif\n\n   /* Calculate length of movi list */\n\n   movi_len = AVI->pos - HEADERBYTES + 4;\n\n   /* Try to ouput the index entries. This may fail e.g. if no space\n      is left on device. We will report this as an error, but we still\n      try to write the header correctly (so that the file still may be\n      readable in the most cases */\n\n   idxerror = 0;\n   //   fprintf(stderr, "pos=%lu, index_len=%ld             \n", AVI->pos, AVI->n_idx*16);\n   ret = avi_add_chunk(AVI, (unsigned char *)"idx1", (void*)AVI->idx, AVI->n_idx*16);\n   hasIndex = (ret==0);\n   //fprintf(stderr, "pos=%lu, index_len=%d\n", AVI->pos, hasIndex);\n\n   if(ret) {\n     idxerror = 1;\n     AVI_errno = AVI_ERR_WRITE_INDEX;\n   }\n   \n   /* Calculate Microseconds per frame */\n\n   if(AVI->fps < 0.001) {\n     frate=0;\n     ms_per_frame=0;\n   } else {\n     frate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n     ms_per_frame=(int) (1000000/AVI->fps + 0.5);\n   }\n\n   /* Prepare the file header */\n\n   nhb = 0;\n\n   /* The RIFF header */\n\n   OUT4CC ("RIFF");\n   OUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n   OUT4CC ("AVI ");\n\n   /* Start the header list */\n\n   OUT4CC ("LIST");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   hdrl_start = nhb;  /* Store start position */\n   OUT4CC ("hdrl");\n\n   /* The main AVI header */\n\n   /* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n   OUT4CC ("avih");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUTLONG(ms_per_frame);       /* Microseconds per frame */\n   //ThOe ->0 \n   //   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n   OUTLONG(0);\n   OUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n                                /* Other sources call it 'reserved' */\n   flag = AVIF_ISINTERLEAVED;\n   if(hasIndex) flag |= AVIF_HASINDEX;\n   if(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n   OUTLONG(flag);               /* Flags */\n   OUTLONG(AVI->video_frames);  /* TotalFrames */\n   OUTLONG(0);                  /* InitialFrames */\n\n   OUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n                                /* MS calls the following 'reserved': */\n   OUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n   OUTLONG(0);                  /* DataRate:   Data rate of playback     */\n   OUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n   OUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n   /* Start the video stream list ---------------------------------- */\n\n   OUT4CC ("LIST");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   strl_start = nhb;  /* Store start position */\n   OUT4CC ("strl");\n\n   /* The video stream header */\n\n   OUT4CC ("strh");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUT4CC ("vids");             /* Type */\n   OUT4CC (AVI->compressor);    /* Handler */\n   OUTLONG(0);                  /* Flags */\n   OUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n   OUTLONG(0);                  /* InitialFrames */\n   OUTLONG(FRAME_RATE_SCALE);              /* Scale */\n   OUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n   OUTLONG(0);                  /* Start */\n   OUTLONG(AVI->video_frames);  /* Length */\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(-1);                 /* Quality */\n   OUTLONG(0);                  /* SampleSize */\n   OUTLONG(0);                  /* Frame */\n   OUTLONG(0);                  /* Frame */\n   //   OUTLONG(0);                  /* Frame */\n   //OUTLONG(0);                  /* Frame */\n\n   /* The video stream format */\n\n   OUT4CC ("strf");\n   OUTLONG(40);                 /* # of bytes to follow */\n   OUTLONG(40);                 /* Size */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n   OUTSHRT(1); OUTSHRT(24);     /* Planes, Count */\n   OUT4CC (AVI->compressor);    /* Compression */\n   // ThOe (*3)\n   OUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n   OUTLONG(0);                  /* XPelsPerMeter */\n   OUTLONG(0);                  /* YPelsPerMeter */\n   OUTLONG(0);                  /* ClrUsed: Number of colors used */\n   OUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n   /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n   long2str(AVI_header+strl_start-4,nhb-strl_start);\n\n   /* Start the audio stream list ---------------------------------- */\n\n   for(j=0; j<AVI->anum; ++j) {\n     \n     //if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n       {\n	   \n	 sampsize = avi_sampsize(AVI, j);\n	   \n	 OUT4CC ("LIST");\n	 OUTLONG(0);        /* Length of list in bytes, don't know yet */\n	 strl_start = nhb;  /* Store start position */\n	 OUT4CC ("strl");\n	   \n	 /* The audio stream header */\n	 \n	 OUT4CC ("strh");\n	 OUTLONG(56);            /* # of bytes to follow */\n	 OUT4CC ("auds");\n	 \n	 // -----------\n	 // ThOe\n	 OUTLONG(0);             /* Format (Optionally) */\n	   // -----------\n	   \n	 OUTLONG(0);             /* Flags */\n	 OUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n	 OUTLONG(0);             /* InitialFrames */\n	   \n	 // ThOe /4\n	 OUTLONG(sampsize/4);      /* Scale */\n	 OUTLONG(1000*AVI->track[j].mp3rate/8);\n	 OUTLONG(0);             /* Start */\n	 OUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n	 OUTLONG(0);             /* SuggestedBufferSize */\n	 OUTLONG(-1);            /* Quality */\n	   \n	 // ThOe /4\n	 OUTLONG(sampsize/4);    /* SampleSize */\n	   \n	 OUTLONG(0);             /* Frame */\n	 OUTLONG(0);             /* Frame */\n	 //	 OUTLONG(0);             /* Frame */\n	 //OUTLONG(0);             /* Frame */\n	   \n	 /* The audio stream format */\n	 \n	 OUT4CC ("strf");\n	 OUTLONG(16);                   /* # of bytes to follow */\n	 OUTSHRT(AVI->track[j].a_fmt);           /* Format */\n	 OUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n	 OUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n	 // ThOe\n	 OUTLONG(1000*AVI->track[j].mp3rate/8);\n	 //ThOe (/4)\n	 \n	 OUTSHRT(sampsize/4);           /* BlockAlign */\n	 \n	 \n	 OUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n	 \n	 /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n       }\n       long2str(AVI_header+strl_start-4,nhb-strl_start);\n   }\n   \n   /* Finish header list */\n   \n   long2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n   // add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n   OUT4CC ("LIST");\n   \n   //FIXME\n   info_len = MAX_INFO_STRLEN + 12;\n   OUTLONG(info_len);\n   OUT4CC ("INFO");\n\n//   OUT4CC ("INAM");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   sprintf(id_str, "\t");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, strlen(id_str));\n//   nhb += MAX_INFO_STRLEN;\n\n   OUT4CC ("ISFT");\n   OUTLONG(MAX_INFO_STRLEN);\n\n   sprintf(id_str, "%s-%s", PACKAGE, VERSION);\n   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n   memcpy(AVI_header+nhb, id_str, strlen(id_str));\n   nhb += MAX_INFO_STRLEN;\n\n//   OUT4CC ("ICMT");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL); \n//   sprintf(id_str, "\t%s %s", ctime(&calptr), "");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n   // ----------------------------\n   \n   /* Calculate the needed amount of junk bytes, output junk */\n   \n   njunk = HEADERBYTES - nhb - 8 - 12;\n   \n   /* Safety first: if njunk <= 0, somebody has played with\n      HEADERBYTES without knowing what (s)he did.\n      This is a fatal error */\n   \n   if(njunk<=0)\n   {\n      fprintf(stderr,"AVI_close_output_file: # of header bytes too small\n");\n      exit(1);\n   }\n\n   OUT4CC ("JUNK");\n   OUTLONG(njunk);\n   memset(AVI_header+nhb,0,njunk);\n   \n   nhb += njunk;\n\n   /* Start the movi list */\n\n   OUT4CC ("LIST");\n   OUTLONG(movi_len); /* Length of list in bytes */\n   OUT4CC ("movi");\n\n   /* Output the header, truncate the file to the number of bytes\n      actually written, report an error if someting goes wrong */\n\n   if ( lseek(AVI->fdes,0,SEEK_SET)<0 ||\n        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES \n        //|| ftruncate(AVI->fdes,AVI->pos)<0 \n        )\n   {\n      AVI_errno = AVI_ERR_CLOSE;\n      return -1;\n   }\n\n   if(idxerror) return -1;\n\n   return 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned long length, int audio, int keyframe)\n{\n   int n;\n\n   unsigned char astr[5];\n\n   /* Check for maximum file length */\n   \n   if ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n     AVI_errno = AVI_ERR_SIZELIM;\n     return -1;\n   }\n   \n   /* Add index entry */\n\n   //set tag for current audio track\n   sprintf((char *)astr, "0%1dwb", AVI->aptr+1);\n\n   if(audio)\n     n = avi_add_index_entry(AVI,astr,0x00,AVI->pos,length);\n   else\n     n = avi_add_index_entry(AVI,(unsigned char *) "00db",((keyframe)?0x10:0x0),AVI->pos,length);\n   \n   if(n) return -1;\n   \n   /* Output tag and data */\n   \n   if(audio)\n     n = avi_add_chunk(AVI,(unsigned char *) astr, (unsigned char *)data,length);\n   else\n     n = avi_add_chunk(AVI,(unsigned char *)"00db",(unsigned char *)data,length);\n   \n   if (n) return -1;\n   \n   return 0;\n}\n\nint AVI_write_frame(avi_t *AVI, char *data, long bytes, int keyframe)\n{\n  unsigned long pos;\n  \n  if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  \n  pos = AVI->pos;\n\n  if(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n   \n  AVI->last_pos = pos;\n  AVI->last_len = bytes;\n  AVI->video_frames++;\n  return 0;\n}\n\nint AVI_dup_frame(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   if(AVI->last_pos==0) return 0; /* No previous real frame */\n   if(avi_add_index_entry(AVI,(unsigned char *)"00db",0x10,AVI->last_pos,AVI->last_len)) return -1;\n   AVI->video_frames++;\n   AVI->must_use_index = 1;\n   return 0;\n}\n\nint AVI_write_audio(avi_t *AVI, char *data, long bytes)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   if( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n   AVI->track[AVI->aptr].audio_bytes += bytes;\n   return 0;\n}\n\n\nint AVI_append_audio(avi_t *AVI, char *data, long bytes)\n{\n\n  long i, length, pos;\n  unsigned char c[4];\n\n  if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  \n  // update last index entry:\n  \n  --AVI->n_idx;\n  length = str2ulong(AVI->idx[AVI->n_idx]+12);\n  pos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n  //update;\n  long2str(AVI->idx[AVI->n_idx]+12,length+bytes);   \n\n  ++AVI->n_idx;\n\n  AVI->track[AVI->aptr].audio_bytes += bytes;\n\n  //update chunk header\n  lseek(AVI->fdes, pos+4, SEEK_SET);\n  long2str(c, length+bytes);     \n  avi_write(AVI->fdes,(char *) c, 4);\n\n  lseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n  i=PAD_EVEN(length + bytes);\n\n  bytes = i - length;\n  avi_write(AVI->fdes, data, bytes);\n  AVI->pos = pos + 8 + i;\n\n  return 0;\n}\n\n\nlong AVI_bytes_remain(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) return 0;\n\n   return ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nlong AVI_bytes_written(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) return 0;\n\n   return (AVI->pos + 8 + 16*AVI->n_idx);\n}\n\nint AVI_set_audio_track(avi_t *AVI, int track)\n{\n  \n  if(track < 0 || track + 1 > AVI->anum) return(-1);\n\n  //this info is not written to file anyway\n  AVI->aptr=track;\n  return 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n    return(AVI->aptr);\n}\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nint AVI_close(avi_t *AVI)\n{\n   int ret;\n\n   /* If the file was open for writing, the header and index still have\n      to be written */\n\n   if(AVI->mode == AVI_MODE_WRITE)\n      ret = avi_close_output_file(AVI);\n   else\n      ret = 0;\n\n   /* Even if there happened an error, we first clean up */\n\n   close(AVI->fdes);\n   if(AVI->idx) free(AVI->idx);\n   if(AVI->video_index) free(AVI->video_index);\n   //FIXME\n   //if(AVI->audio_index) free(AVI->audio_index);\n   free(AVI);\n\n   return ret;\n}\n\n\n#define ERR_EXIT(x) \\n{ \\n   AVI_close(AVI); \\n   AVI_errno = x; \\n   return 0; \\n}\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n  avi_t *AVI=NULL;\n  \n  /* Create avi_t structure */\n  \n  AVI = (avi_t *) malloc(sizeof(avi_t));\n  if(AVI==NULL)\n    {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n    }\n  memset((void *)AVI,0,sizeof(avi_t));\n  \n  AVI->mode = AVI_MODE_READ; /* open for reading */\n  \n  /* Open the file */\n  \n  AVI->fdes = open(filename,O_RDONLY|O_BINARY);\n  if(AVI->fdes < 0)\n    {\n      AVI_errno = AVI_ERR_OPEN;\n      free(AVI);\n      return 0;\n    }\n  \n  avi_parse_input_file(AVI, getIndex);\n\n  AVI->aptr=0; //reset  \n\n  return AVI;\n}\n\navi_t *AVI_open_fd(int fd, int getIndex)\n{\n  avi_t *AVI=NULL;\n  \n  /* Create avi_t structure */\n  \n  AVI = (avi_t *) malloc(sizeof(avi_t));\n  if(AVI==NULL)\n    {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n    }\n  memset((void *)AVI,0,sizeof(avi_t));\n  \n  AVI->mode = AVI_MODE_READ; /* open for reading */\n  \n  // file alread open\n  AVI->fdes = fd;\n  \n  avi_parse_input_file(AVI, getIndex);\n\n  AVI->aptr=0; //reset\n  \n  return AVI;\n}\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n  long i, n, rate, scale, idx_type;\n  unsigned char *hdrl_data;\n  long header_offset=0, hdrl_len=0;\n  long nvi, nai[AVI_MAX_TRACKS], ioff;\n  long tot[AVI_MAX_TRACKS];\n  int j;\n  int lasttag = 0;\n  int vids_strh_seen = 0;\n  int vids_strf_seen = 0;\n  int auds_strh_seen = 0;\n  //  int auds_strf_seen = 0;\n  int num_stream = 0;\n  char data[256];\n  \n  /* Read first 12 bytes and check that this is an AVI file */\n\n   if( avi_read(AVI->fdes,data,12) != 12 ) ERR_EXIT(AVI_ERR_READ)\n\n   if( strncasecmp(data  ,"RIFF",4) !=0 ||\n       strncasecmp(data+8,"AVI ",4) !=0 ) ERR_EXIT(AVI_ERR_NO_AVI)\n\n   /* Go through the AVI file and extract the header list,\n      the start position of the 'movi' list and an optionally\n      present idx1 tag */\n\n   hdrl_data = 0;\n\n   while(1)\n   {\n      if( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\n      n = str2ulong((unsigned char *) data+4);\n      n = PAD_EVEN(n);\n\n      if(strncasecmp(data,"LIST",4) == 0)\n      {\n         if( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n         n -= 4;\n         if(strncasecmp(data,"hdrl",4) == 0)\n         {\n            hdrl_len = n;\n            hdrl_data = (unsigned char *) malloc(n);\n            if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n				 \n	    // offset of header\n	    \n	    header_offset = lseek(AVI->fdes,0,SEEK_CUR);\n				 \n            if( avi_read(AVI->fdes,(char *)hdrl_data,n) != n ) ERR_EXIT(AVI_ERR_READ)\n         }\n         else if(strncasecmp(data,"movi",4) == 0)\n         {\n            AVI->movi_start = lseek(AVI->fdes,0,SEEK_CUR);\n            lseek(AVI->fdes,n,SEEK_CUR);\n         }\n         else\n            lseek(AVI->fdes,n,SEEK_CUR);\n      }\n      else if(strncasecmp(data,"idx1",4) == 0)\n      {\n         /* n must be a multiple of 16, but the reading does not\n            break if this is not the case */\n\n         AVI->n_idx = AVI->max_idx = n/16;\n         AVI->idx = (unsigned  char((*)[16]) ) malloc(n);\n         if(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n         if(avi_read(AVI->fdes, (char *) AVI->idx, n) != n ) ERR_EXIT(AVI_ERR_READ)\n      }\n      else\n         lseek(AVI->fdes,n,SEEK_CUR);\n   }\n\n   if(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n   if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n   /* Interpret the header list */\n\n   for(i=0;i<hdrl_len;)\n   {\n      /* List tags are completly ignored */\n\n      if(strncasecmp((char *) hdrl_data+i, "LIST",4)==0) { i+= 12; continue; }\n\n      n = str2ulong(hdrl_data+i+4);\n      n = PAD_EVEN(n);\n\n      /* Interpret the tag and its args */\n\n      if(strncasecmp((char *)hdrl_data+i,"strh",4)==0)\n      {\n         i += 8;\n         if(strncasecmp((char *)hdrl_data+i,"vids",4) == 0 && !vids_strh_seen)\n         {\n            memcpy(AVI->compressor,hdrl_data+i+4,4);\n            AVI->compressor[4] = 0;\n\n	    // ThOe\n	    AVI->v_codech_off = header_offset + i+4;\n\n            scale = str2ulong((unsigned char *)hdrl_data+i+20);\n            rate  = str2ulong(hdrl_data+i+24);\n            if(scale!=0) AVI->fps = (double)rate/(double)scale;\n            AVI->video_frames = str2ulong(hdrl_data+i+32);\n            AVI->video_strn = num_stream;\n	    AVI->max_len = 0;\n            vids_strh_seen = 1;\n            lasttag = 1; /* vids */\n         }\n         else if (strncasecmp ((char *) hdrl_data+i,"auds",4) ==0 && ! auds_strh_seen)\n         {\n\n	   //inc audio tracks\n	   AVI->aptr=AVI->anum;\n	   ++AVI->anum;\n	   \n	   if(AVI->anum > AVI_MAX_TRACKS) {\n	     fprintf(stderr, "error - only %d audio tracks supported\n", AVI_MAX_TRACKS);\n	     return(-1);\n	   }\n	   \n	   AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n	   AVI->track[AVI->aptr].audio_strn = num_stream;\n	   //	   auds_strh_seen = 1;\n	   lasttag = 2; /* auds */\n	   \n	   // ThOe\n	   AVI->track[AVI->aptr].a_codech_off = header_offset + i;\n	   \n         }\n         else\n            lasttag = 0;\n         num_stream++;\n      }\n      else if(strncasecmp((char *) hdrl_data+i,"strf",4)==0)\n      {\n         i += 8;\n         if(lasttag == 1)\n         {\n            AVI->width  = str2ulong(hdrl_data+i+4);\n            AVI->height = str2ulong(hdrl_data+i+8);\n            vids_strf_seen = 1;\n	    //ThOe\n	    AVI->v_codecf_off = header_offset + i+16;\n\n	    memcpy(AVI->compressor2, hdrl_data+i+16, 4);\n            AVI->compressor2[4] = 0;\n\n         }\n         else if(lasttag == 2)\n         {\n            AVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n	    //ThOe\n	    AVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n	    \n            AVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n            AVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n	    //ThOe: read mp3bitrate\n	    AVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n	    //:ThOe\n            AVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n	    //            auds_strf_seen = 1;\n         }\n         lasttag = 0;\n      }\n      else\n      {\n         i += 8;\n         lasttag = 0;\n      }\n\n      i += n;\n   }\n\n   free(hdrl_data);\n\n   if(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n   AVI->video_tag[0] = AVI->video_strn/10 + '0';\n   AVI->video_tag[1] = AVI->video_strn%10 + '0';\n   AVI->video_tag[2] = 'd';\n   AVI->video_tag[3] = 'b';\n\n   /* Audio tag is set to "99wb" if no audio present */\n   if(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n   for(j=0; j<AVI->anum; ++j) {\n     AVI->track[j].audio_tag[0] = (j+1)/10 + '0';\n     AVI->track[j].audio_tag[1] = (j+1)%10 + '0';\n     AVI->track[j].audio_tag[2] = 'w';\n     AVI->track[j].audio_tag[3] = 'b';\n   }\n\n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n   /* get index if wanted */\n\n   if(!getIndex) return(0);\n\n   /* if the file has an idx1, check if this is relative\n      to the start of the file or to the start of the movi list */\n\n   idx_type = 0;\n\n   if(AVI->idx)\n   {\n      long pos, len;\n\n      /* Search the first videoframe in the idx1 and look where\n         it is in the file */\n\n      for(i=0;i<AVI->n_idx;i++)\n         if( strncasecmp((char *) AVI->idx[i],(char *) AVI->video_tag,3)==0 ) break;\n      if(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n      pos = str2ulong(AVI->idx[i]+ 8);\n      len = str2ulong(AVI->idx[i]+12);\n\n      lseek(AVI->fdes,pos,SEEK_SET);\n      if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n      if( strncasecmp((char *)data,(char *)AVI->idx[i],4)==0 && \n      str2ulong((unsigned char *)data+4)==len )\n      {\n         idx_type = 1; /* Index from start of file */\n      }\n      else\n      {\n         lseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n         if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n         if( strncasecmp((char *)data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n         {\n            idx_type = 2; /* Index from start of movi list */\n         }\n      }\n      /* idx_type remains 0 if neither of the two tests above succeeds */\n   }\n\n   if(idx_type == 0)\n   {\n      /* we must search through the file to get the index */\n\n      lseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n      AVI->n_idx = 0;\n\n      while(1)\n      {\n         if( avi_read(AVI->fdes,data,8) != 8 ) break;\n         n = str2ulong((unsigned char *)data+4);\n\n         /* The movi list may contain sub-lists, ignore them */\n\n         if(strncasecmp(data,"LIST",4)==0)\n         {\n            lseek(AVI->fdes,4,SEEK_CUR);\n            continue;\n         }\n\n         /* Check if we got a tag ##db, ##dc or ##wb */\n	 \n         if( ( (data[2]=='d' || data[2]=='D') &&\n               (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n	     || ( (data[2]=='w' || data[2]=='W') &&\n		  (data[3]=='b' || data[3]=='B') ) )\n	   {\n	   avi_add_index_entry(AVI,(unsigned char *) data,0,lseek(AVI->fdes,0,SEEK_CUR)-8,n);\n         }\n	 \n         lseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n      }\n      idx_type = 1;\n   }\n\n   /* Now generate the video index and audio index arrays */\n\n   nvi = 0;\n   for(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n   for(i=0;i<AVI->n_idx;i++) {\n     \n     if(strncasecmp((char *)AVI->idx[i],(char *) AVI->video_tag,3) == 0) nvi++;\n     \n     for(j=0; j<AVI->anum; ++j) if(strncasecmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n   }\n   \n   AVI->video_frames = nvi;\n   for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n//   fprintf(stderr, "chunks = %ld %d %s\n", AVI->track[0].audio_chunks, AVI->anum, AVI->track[0].audio_tag);\n\n   if(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n   AVI->video_index = (video_index_entry *) malloc(nvi*sizeof(video_index_entry));\n   if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n   \n   for(j=0; j<AVI->anum; ++j) {\n       if(AVI->track[j].audio_chunks) {\n	   AVI->track[j].audio_index = (audio_index_entry *) malloc(nai[j]*sizeof(audio_index_entry));\n	   if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n       }\n   }   \n   \n   nvi = 0;\n   for(j=0; j<AVI->anum; ++j) nai[j] = tot[j] = 0;\n   \n   ioff = idx_type == 1 ? 8 : AVI->movi_start+4;\n   \n   for(i=0;i<AVI->n_idx;i++) {\n\n     //video\n     if(strncasecmp((char *)AVI->idx[i],(char *)AVI->video_tag,3) == 0) {\n       AVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n       AVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n       AVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n       nvi++;\n     }\n     \n     //audio\n     for(j=0; j<AVI->anum; ++j) {\n	 \n       if(strncasecmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n	 AVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n	 AVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n	 AVI->track[j].audio_index[nai[j]].tot = tot[j];\n	 tot[j] += AVI->track[j].audio_index[nai[j]].len;\n	 nai[j]++;\n       }\n     }\n   }\n   \n   \n   for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n   \n   /* Reposition the file */\n   \n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n   AVI->video_pos = 0;\n\n   return(0);\n}\n\nlong AVI_video_frames(avi_t *AVI)\n{\n   return AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n   return AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n   return AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n   return AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n   return AVI->compressor2;\n}\n\nlong AVI_max_video_chunk(avi_t *AVI)\n{\n   return AVI->max_len; \n}\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n    return(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_chans;\n}\n\nlong AVI_audio_mp3rate(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].mp3rate;\n}\n\nint AVI_audio_bits(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_fmt;\n}\n\nlong AVI_audio_rate(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_rate;\n}\n\nlong AVI_audio_bytes(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].audio_bytes;\n}\n\nlong AVI_audio_chunks(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].audio_chunks;\n}\n\nlong AVI_audio_codech_offset(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_codech_off;\n}\n\nlong AVI_audio_codecf_offset(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_codecf_off;\n}\n\nlong  AVI_video_codech_offset(avi_t *AVI)\n{\n    return AVI->v_codech_off;\n}\n\nlong  AVI_video_codecf_offset(avi_t *AVI)\n{\n    return AVI->v_codecf_off;\n}\n\nlong AVI_frame_size(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(frame < 0 || frame >= AVI->video_frames) return 0;\n   return(AVI->video_index[frame].len);\n}\n\nlong AVI_audio_size(avi_t *AVI, long frame)\n{\n  if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n  \n  if(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return 0;\n  return(AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nlong AVI_get_video_position(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(frame < 0 || frame >= AVI->video_frames) return 0;\n   return(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n   AVI->video_pos = 0;\n   return 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if (frame < 0 ) frame = 0;\n   AVI->video_pos = frame;\n   return 0;\n}\n\nint AVI_set_audio_bitrate(avi_t *AVI, long bitrate)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   AVI->track[AVI->aptr].mp3rate = bitrate;\n   return 0;\n}\n      \n\nlong AVI_read_frame(avi_t *AVI, char *vidbuf, int *keyframe)\n{\n   long n;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n   n = AVI->video_index[AVI->video_pos].len;\n\n   *keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n   lseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\n   if (avi_read(AVI->fdes,vidbuf,n) != n)\n   {\n      AVI_errno = AVI_ERR_READ;\n      return -1;\n   }\n\n   AVI->video_pos++;\n\n   return n;\n}\n\nint AVI_set_audio_position(avi_t *AVI, long byte)\n{\n   long n0, n1, n;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(byte < 0) byte = 0;\n\n   /* Binary search in the audio chunks */\n\n   n0 = 0;\n   n1 = AVI->track[AVI->aptr].audio_chunks;\n\n   while(n0<n1-1)\n   {\n      n = (n0+n1)/2;\n      if(AVI->track[AVI->aptr].audio_index[n].tot>byte)\n         n1 = n;\n      else\n         n0 = n;\n   }\n\n   AVI->track[AVI->aptr].audio_posc = n0;\n   AVI->track[AVI->aptr].audio_posb = byte - AVI->track[AVI->aptr].audio_index[n0].tot;\n\n   return 0;\n}\n\nlong AVI_read_audio(avi_t *AVI, char *audbuf, long bytes)\n{\n   long nr, pos, left, todo;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   nr = 0; /* total number of bytes read */\n\n   while(bytes>0)\n   {\n      left = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb;\n      if(left==0)\n      {\n         if(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n         AVI->track[AVI->aptr].audio_posc++;\n         AVI->track[AVI->aptr].audio_posb = 0;\n         continue;\n      }\n      if(bytes<left)\n         todo = bytes;\n      else\n         todo = left;\n      pos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n      lseek(AVI->fdes, pos, SEEK_SET);\n      if (avi_read(AVI->fdes,audbuf+nr,todo) != todo)\n      {\n         AVI_errno = AVI_ERR_READ;\n         return -1;\n      }\n      bytes -= todo;\n      nr    += todo;\n      AVI->track[AVI->aptr].audio_posb += todo;\n   }\n\n   return nr;\n}\n\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, long max_vidbuf,\n                              char *audbuf, long max_audbuf,\n                              long *len)\n{\n\n/*\n * Return codes:\n *\n *    1 = video data read\n *    2 = audio data read\n *    0 = reached EOF\n *   -1 = video buffer too small\n *   -2 = audio buffer too small\n */\n\n   int n;\n   char data[8];\n \n   if(AVI->mode==AVI_MODE_WRITE) return 0;\n\n   while(1)\n   {\n      /* Read tag and length */\n\n      if( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n      /* if we got a list tag, ignore it */\n\n      if(strncasecmp(data,"LIST",4) == 0)\n      {\n         lseek(AVI->fdes,4,SEEK_CUR);\n         continue;\n      }\n\n      n = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n      if(strncasecmp(data,AVI->video_tag,3) == 0)\n      {\n         *len = n;\n         AVI->video_pos++;\n         if(n>max_vidbuf)\n         {\n            lseek(AVI->fdes,n,SEEK_CUR);\n            return -1;\n         }\n         if(avi_read(AVI->fdes,vidbuf,n) != n ) return 0;\n         return 1;\n      }\n      else if(strncasecmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n      {\n         *len = n;\n         if(n>max_audbuf)\n         {\n            lseek(AVI->fdes,n,SEEK_CUR);\n            return -2;\n         }\n         if(avi_read(AVI->fdes,audbuf,n) != n ) return 0;\n         return 2;\n         break;\n      }\n      else\n         if(lseek(AVI->fdes,n,SEEK_CUR)<0)  return 0;\n   }\n}\n\n/* AVI_print_error: Print most recent error (similar to perror) */\n\nchar *(avi_errors[]) =\n{\n  /*  0 */ "avilib - No Error",\n  /*  1 */ "avilib - AVI file size limit reached",\n  /*  2 */ "avilib - Error opening AVI file",\n  /*  3 */ "avilib - Error reading from AVI file",\n  /*  4 */ "avilib - Error writing to AVI file",\n  /*  5 */ "avilib - Error writing index (file may still be useable)",\n  /*  6 */ "avilib - Error closing AVI file",\n  /*  7 */ "avilib - Operation (read/write) not permitted",\n  /*  8 */ "avilib - Out of memory (malloc failed)",\n  /*  9 */ "avilib - Not an AVI file",\n  /* 10 */ "avilib - AVI file has no header list (corrupted?)",\n  /* 11 */ "avilib - AVI file has no MOVI list (corrupted?)",\n  /* 12 */ "avilib - AVI file has no video data",\n  /* 13 */ "avilib - operation needs an index",\n  /* 14 */ "avilib - Unkown Error"\n};\nstatic int num_avi_errors = sizeof(avi_errors)/sizeof(char*);\n\nstatic char error_string[4096];\n\nvoid AVI_print_error(char *str)\n{\n   int aerrno;\n\n   aerrno = (AVI_errno>=0 && AVI_errno<num_avi_errors) ? AVI_errno : num_avi_errors-1;\n\n   fprintf(stderr,"%s: %s\n",str,avi_errors[aerrno]);\n\n   /* for the following errors, perror should report a more detailed reason: */\n\n   if(AVI_errno == AVI_ERR_OPEN ||\n      AVI_errno == AVI_ERR_READ ||\n      AVI_errno == AVI_ERR_WRITE ||\n      AVI_errno == AVI_ERR_WRITE_INDEX ||\n      AVI_errno == AVI_ERR_CLOSE )\n   {\n      perror("REASON");\n   }\n}\n\nchar *AVI_strerror()\n{\n   int aerrno;\n\n   aerrno = (AVI_errno>=0 && AVI_errno<num_avi_errors) ? AVI_errno : num_avi_errors-1;\n\n   if(AVI_errno == AVI_ERR_OPEN ||\n      AVI_errno == AVI_ERR_READ ||\n      AVI_errno == AVI_ERR_WRITE ||\n      AVI_errno == AVI_ERR_WRITE_INDEX ||\n      AVI_errno == AVI_ERR_CLOSE )\n   {\n      sprintf(error_string,"%s - %s",avi_errors[aerrno],strerror(errno));\n      return error_string;\n   }\n   else\n   {\n      return avi_errors[aerrno];\n   }\n}\n\nuint64_t AVI_max_size()\n{\n  return((uint64_t) AVI_MAX_LEN);\n}\n\n