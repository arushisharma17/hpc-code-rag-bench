Source,Code (optional)
lud/tools/gen_input.c,"#include <time.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n#ifdef FP_NUMBER\ntypedef double FP_NUMBER;\n#else\ntypedef float FP_NUMBER;\n#endif\n\n\n#define GET_RAND_FP ((FP_NUMBER)rand()/((FP_NUMBER)(RAND_MAX)+(FP_NUMBER)(1)))\nchar L_FNAME[32], U_FNAME[32], A_FNAME[32];\n\nint main (int argc, char **argv){\n    int i,j,k,MatrixDim;\n    FP_NUMBER sum, **L, **U, **A;\n    FILE *fl,*fu,*fa;\n\n    if ( argc < 2) {\n        printf(""./gen_input [Matrix_Dimension_size]\n"");\n        return 1;\n    }\n\n    MatrixDim = atoi(argv[1]);\n    L = (FP_NUMBER **) malloc(sizeof(FP_NUMBER*)*MatrixDim);\n    U = (FP_NUMBER **) malloc(sizeof(FP_NUMBER*)*MatrixDim);\n    A = (FP_NUMBER **) malloc(sizeof(FP_NUMBER*)*MatrixDim);\n\n    if ( !L || !U || !A){\n        printf(""Can not allocate memory\n"");\n        if (L) free(L);\n        if (U) free(U);\n        if (A) free(A);\n        return 1;\n    }\n\n    srand(time(NULL));\n\n    sprintf(L_FNAME, ""l-%d.dat"", MatrixDim);\n    fl = fopen(L_FNAME, ""wb"");\n    if (fl == NULL) {\n        printf(""Cannot open file %s\n"", L_FNAME);\n        return 1;\n    }\n\n    sprintf(U_FNAME, ""u-%d.dat"", MatrixDim);\n    fu = fopen(U_FNAME, ""wb"");\n    if (fu == NULL) {\n        printf(""Cannot open file %s\n"", U_FNAME);\n        return 1;\n    }\n\n    sprintf(A_FNAME, ""%d.dat"", MatrixDim);\n    fa = fopen(A_FNAME, ""wb"");\n    if (!fa) {\n        printf(""Cannot open file %s\n"", A_FNAME);\n        return 1;\n    }\n\n    for (i=0; i < MatrixDim; i ++){\n        L[i]=(FP_NUMBER*)malloc(sizeof(FP_NUMBER)*MatrixDim);\n        U[i]=(FP_NUMBER*)malloc(sizeof(FP_NUMBER)*MatrixDim);\n        A[i]=(FP_NUMBER*)malloc(sizeof(FP_NUMBER)*MatrixDim);\n    }\n#if 1\n#pragma omp parallel for default(none)\\n    private(i,j) shared(L,U,MatrixDim)\n#endif\n    for (i=0; i < MatrixDim; i ++){\n        for (j=0; j < MatrixDim; j++){\n            if ( i == j) {\n                L[i][j] = 1.0;\n                U[i][j] = GET_RAND_FP;\n            } else if (i < j){\n                L[i][j] = 0;\n                U[i][j] = GET_RAND_FP;\n            } else { // i > j\n                L[i][j] = GET_RAND_FP;\n                U[i][j] = 0;\n            }\n        }\n    }\n\n#if 1\n#pragma omp parallel for default(none) \\n    private(i,j,k,sum) shared(L,U,A,MatrixDim)\n#endif\n    for (i=0; i < MatrixDim; i++ ) {\n        for (j=0; j < MatrixDim; j++){\n            sum = 0;\n            for(k=0; k < MatrixDim; k++)\n                sum += L[i][k]*U[k][j];\n            A[i][j] = sum;\n        }\n    }\n\n    for (i=0; i < MatrixDim; i ++) {\n        for (j=0; j < MatrixDim; j++)\n            fprintf(fl, ""%f "", L[i][j]);\n        fprintf(fl, ""\n"");\n    }\n    fclose(fl);\n\n    for (i=0; i < MatrixDim; i ++) {\n        for (j=0; j < MatrixDim; j++)\n            fprintf(fu, ""%f "", U[i][j]);\n        fprintf(fu, ""\n"");\n    }\n    fclose(fu);\n\n    fprintf(fa, ""%d\n"", MatrixDim);\n    for (i=0; i < MatrixDim; i ++) {\n        for (j=0; j < MatrixDim; j++)\n            fprintf(fa, ""%f "", A[i][j]);\n        fprintf(fa, ""\n"");\n    }\n    fclose(fa);\n\n    for (i = 0; i < MatrixDim; i ++ ){\n        free(L[i]);\n        free(U[i]);\n        free(A[i]);\n    }\n    free(L);\n    free(U);\n    free(A);\n\n    return 0;\n}\n"
lud/common/common.c,"#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\n#include <math.h>\n\n#include ""common.h""\n\nvoid stopwatch_start(stopwatch *sw){\n    if (sw == NULL)\n        return;\n\n    bzero(&sw->begin, sizeof(struct timeval));\n    bzero(&sw->end  , sizeof(struct timeval));\n\n    gettimeofday(&sw->begin, NULL);\n}\n\nvoid stopwatch_stop(stopwatch *sw){\n    if (sw == NULL)\n        return;\n\n    gettimeofday(&sw->end, NULL);\n}\n\ndouble \nget_interval_by_sec(stopwatch *sw){\n    if (sw == NULL)\n        return 0;\n    return ((double)(sw->end.tv_sec-sw->begin.tv_sec)+(double)(sw->end.tv_usec-sw->begin.tv_usec)/1000000);\n}\n\nint \nget_interval_by_usec(stopwatch *sw){\n    if (sw == NULL)\n        return 0;\n    return ((sw->end.tv_sec-sw->begin.tv_sec)*1000000+(sw->end.tv_usec-sw->begin.tv_usec));\n}\n\nfunc_ret_t \ncreate_matrix_from_file(float **mp, const char* filename, int *size_p){\n  int i, j, size;\n  float *m;\n  FILE *fp = NULL;\n\n  fp = fopen(filename, ""rb"");\n  if ( fp == NULL) {\n      return RET_FAILURE;\n  }\n\n  fscanf(fp, ""%d\n"", &size);\n\n  m = (float*) malloc(sizeof(float)*size*size);\n  if ( m == NULL) {\n      fclose(fp);\n      return RET_FAILURE;\n  }\n\n  for (i=0; i < size; i++) {\n      for (j=0; j < size; j++) {\n          fscanf(fp, ""%f "", m+i*size+j);\n      }\n  }\n\n  fclose(fp);\n\n  *size_p = size;\n  *mp = m;\n\n  return RET_SUCCESS;\n}\n\n\nfunc_ret_t\ncreate_matrix_from_random(float **mp, int size){\n  float *l, *u, *m;\n  int i,j,k;\n\n  srand(time(NULL));\n\n  l = (float*)malloc(size*size*sizeof(float));\n  if ( l == NULL)\n    return RET_FAILURE;\n\n  u = (float*)malloc(size*size*sizeof(float));\n  if ( u == NULL) {\n      free(l);\n      return RET_FAILURE;\n  }\n\n  for (i = 0; i < size; i++) {\n      for (j=0; j < size; j++) {\n          if (i>j) {\n              l[i*size+j] = GET_RAND_FP;\n          } else if (i == j) {\n              l[i*size+j] = 1;\n          } else {\n              l[i*size+j] = 0;\n          }\n      }\n  }\n\n  for (j=0; j < size; j++) {\n      for (i=0; i < size; i++) {\n          if (i>j) {\n              u[j*size+i] = 0;\n          }else {\n              u[j*size+i] = GET_RAND_FP; \n          }\n      }\n  }\n\n  for (i=0; i < size; i++) {\n      for (j=0; j < size; j++) {\n          for (k=0; k <= MIN(i,j); k++)\n            m[i*size+j] = l[i*size+k] * u[j*size+k];\n      }\n  }\n\n  free(l);\n  free(u);\n\n  *mp = m;\n\n  return RET_SUCCESS;\n}\n\nvoid\nmatrix_multiply(float *inputa, float *inputb, float *output, int size){\n  int i, j, k;\n\n  for (i=0; i < size; i++)\n    for (k=0; k < size; k++)\n      for (j=0; j < size; j++)\n        output[i*size+j] = inputa[i*size+k] * inputb[k*size+j];\n\n}\n\nfunc_ret_t\nlud_verify(float *m, float *lu, int matrix_dim){\n  int i,j,k;\n  float *tmp = (float*)malloc(matrix_dim*matrix_dim*sizeof(float));\n\n  for (i=0; i < matrix_dim; i ++)\n    for (j=0; j< matrix_dim; j++) {\n        float sum = 0;\n        float l,u;\n        for (k=0; k <= MIN(i,j); k++){\n            if ( i==k)\n              l=1;\n            else\n              l=lu[i*matrix_dim+k];\n            u=lu[k*matrix_dim+j];\n            sum+=l*u;\n        }\n        tmp[i*matrix_dim+j] = sum;\n    }\n  /* printf("">>>>>LU<<<<<<<\n""); */\n  /* for (i=0; i<matrix_dim; i++){ */\n  /*   for (j=0; j<matrix_dim;j++){ */\n  /*       printf(""%f "", lu[i*matrix_dim+j]); */\n  /*   } */\n  /*   printf(""\n""); */\n  /* } */\n  /* printf("">>>>>result<<<<<<<\n""); */\n  /* for (i=0; i<matrix_dim; i++){ */\n  /*   for (j=0; j<matrix_dim;j++){ */\n  /*       printf(""%f "", tmp[i*matrix_dim+j]); */\n  /*   } */\n  /*   printf(""\n""); */\n  /* } */\n  /* printf("">>>>>input<<<<<<<\n""); */\n  /* for (i=0; i<matrix_dim; i++){ */\n  /*   for (j=0; j<matrix_dim;j++){ */\n  /*       printf(""%f "", m[i*matrix_dim+j]); */\n  /*   } */\n  /*   printf(""\n""); */\n  /* } */\n\n  for (i=0; i<matrix_dim; i++){\n      for (j=0; j<matrix_dim; j++){\n          if ( fabs(m[i*matrix_dim+j]-tmp[i*matrix_dim+j]) > 0.0001)\n            printf(""dismatch at (%d, %d): (o)%f (n)%f\n"", i, j, m[i*matrix_dim+j], tmp[i*matrix_dim+j]);\n      }\n  }\n  free(tmp);\n}\n\nvoid\nmatrix_duplicate(float *src, float **dst, int matrix_dim) {\n    int s = matrix_dim*matrix_dim*sizeof(float);\n   float *p = (float *) malloc (s);\n   memcpy(p, src, s);\n   *dst = p;\n}\n\nvoid\nprint_matrix(float *m, int matrix_dim) {\n    int i, j;\n    for (i=0; i<matrix_dim;i++) {\n      for (j=0; j<matrix_dim;j++)\n        printf(""%f "", m[i*matrix_dim+j]);\n      printf(""\n"");\n    }\n}\n\n\n// Generate well-conditioned matrix internally  by Ke Wang 2013/08/07 22:20:06\n\nfunc_ret_t\ncreate_matrix(float **mp, int size){\n  float *m;\n  int i,j;\n  float lamda = -0.001;\n  float coe[2*size-1];\n  float coe_i =0.0;\n\n  for (i=0; i < size; i++)\n    {\n      coe_i = 10*exp(lamda*i); \n      j=size-1+i;     \n      coe[j]=coe_i;\n      j=size-1-i;     \n      coe[j]=coe_i;\n    }\n\n  m = (float*) malloc(sizeof(float)*size*size);\n  if ( m == NULL) {\n      return RET_FAILURE;\n  }\n\n  for (i=0; i < size; i++) {\n      for (j=0; j < size; j++) {\n	m[i*size+j]=coe[size-1-i+j];\n      }\n  }\n\n  *mp = m;\n\n  return RET_SUCCESS;\n}\n"
lud/omp/lud_omp.c,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(""running OMP on host\n"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n"
lud/omp/lud.c,"/*\n * =====================================================================================\n *\n *       Filename:  suite.c\n *\n *    Description:  The main wrapper for the suite\n *\n *        Version:  1.0\n *        Created:  10/22/2009 08:40:34 PM\n *       Revision:  none\n *       Compiler:  gcc\n *\n *         Author:  Liang Wang (lw2aw), lw2aw@virginia.edu\n *        Company:  CS@UVa\n *\n * =====================================================================================\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include ""common.h""\n\nstatic int do_verify = 0;\nint omp_num_threads = 40;\n\nstatic struct option long_options[] = {\n  /* name, has_arg, flag, val */\n  {""input"", 1, NULL, 'i'},\n  {""size"", 1, NULL, 's'},\n  {""verify"", 0, NULL, 'v'},\n  {0,0,0,0}\n};\n\nextern void\nlud_omp(float *m, int matrix_dim);\n\nint\nmain ( int argc, char *argv[] )\n{\n  int matrix_dim = 32; /* default size */\n  int opt, option_index=0;\n  func_ret_t ret;\n  const char *input_file = NULL;\n  float *m, *mm;\n  stopwatch sw;\n\n	\n  while ((opt = getopt_long(argc, argv, ""::vs:n:i:"", \n                            long_options, &option_index)) != -1 ) {\n    switch(opt){\n    case 'i':\n      input_file = optarg;\n      break;\n    case 'v':\n      do_verify = 1;\n      break;\n    case 'n':\n      omp_num_threads = atoi(optarg);\n      break;\n    case 's':\n      matrix_dim = atoi(optarg);\n      printf(""Generate input matrix internally, size =%d\n"", matrix_dim);\n      // fprintf(stderr, ""Currently not supported, use -i instead\n"");\n      // fprintf(stderr, ""Usage: %s [-v] [-s matrix_size|-i input_file]\n"", argv[0]);\n      // exit(EXIT_FAILURE);\n      break;\n    case '?':\n      fprintf(stderr, ""invalid option\n"");\n      break;\n    case ':':\n      fprintf(stderr, ""missing argument\n"");\n      break;\n    default:\n      fprintf(stderr, ""Usage: %s [-v] [-s matrix_size|-i input_file]\n"",\n	      argv[0]);\n      exit(EXIT_FAILURE);\n    }\n  }\n  \n  if ( (optind < argc) || (optind == 1)) {\n    fprintf(stderr, ""Usage: %s [-v] [-n no. of threads] [-s matrix_size|-i input_file]\n"", argv[0]);\n    exit(EXIT_FAILURE);\n  }\n\n  if (input_file) {\n    printf(""Reading matrix from file %s\n"", input_file);\n    ret = create_matrix_from_file(&m, input_file, &matrix_dim);\n    if (ret != RET_SUCCESS) {\n      m = NULL;\n      fprintf(stderr, ""error create matrix from file %s\n"", input_file);\n      exit(EXIT_FAILURE);\n    }\n  }\n  else if (matrix_dim) {\n    printf(""Creating matrix internally size=%d\n"", matrix_dim);\n    ret = create_matrix(&m, matrix_dim);\n    if (ret != RET_SUCCESS) {\n      m = NULL;\n      fprintf(stderr, ""error create matrix internally size=%d\n"", matrix_dim);\n      exit(EXIT_FAILURE);\n    }\n  }\n \n  else {\n    printf(""No input file specified!\n"");\n    exit(EXIT_FAILURE);\n  } \n\n  if (do_verify){\n    printf(""Before LUD\n"");\n    /* print_matrix(m, matrix_dim); */\n    matrix_duplicate(m, &mm, matrix_dim);\n  }\n\n\n  stopwatch_start(&sw);\n  lud_omp(m, matrix_dim);\n  stopwatch_stop(&sw);\n  printf(""Time consumed(ms): %lf\n"", 1000*get_interval_by_sec(&sw));\n\n  if (do_verify){\n    printf(""After LUD\n"");\n    /* print_matrix(m, matrix_dim); */\n    printf("">>>Verify<<<<\n"");\n    lud_verify(mm, m, matrix_dim); \n    free(mm);\n  }\n  \n  free(m);\n\n  return EXIT_SUCCESS;\n}				/* ----------  end of function main  ---------- */\n"
lud/base/lud_base.c,"void lud_base(float *a, int size)\n{\n     int i,j,k;\n     float sum;\n\n     for (i=0; i<size; i++){\n         for (j=i; j<size; j++){\n             sum=a[i*size+j];\n             for (k=0; k<i; k++) sum -= a[i*size+k]*a[k*size+j];\n             a[i*size+j]=sum;\n         }\n\n         for (j=i+1;j<size; j++){\n             sum=a[j*size+i];\n             for (k=0; k<i; k++) sum -=a[j*size+k]*a[k*size+i];\n             a[j*size+i]=sum/a[i*size+i];\n         }\n     }\n}\n"
lud/base/lud.c,"/*\n * =====================================================================================\n *\n *       Filename:  suite.c\n *\n *    Description:  The main wrapper for the suite\n *\n *        Version:  1.0\n *        Created:  10/22/2009 08:40:34 PM\n *       Revision:  none\n *       Compiler:  gcc\n *\n *         Author:  Liang Wang (lw2aw), lw2aw@virginia.edu\n *        Company:  CS@UVa\n *\n * =====================================================================================\n */\n\n#include <stdio.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <stdlib.h>\n#include <assert.h>\n\n#include ""common.h""\n\nstatic int do_verify = 0;\n\nstatic struct option long_options[] = {\n      /* name, has_arg, flag, val */\n      {""input"", 1, NULL, 'i'},\n      {""size"", 1, NULL, 's'},\n      {""verify"", 0, NULL, 'v'},\n      {0,0,0,0}\n};\n\nextern void\nlud_base(float *m, int matrix_dim);\n\nint\nmain ( int argc, char *argv[] )\n{\n  int matrix_dim = 32; /* default matrix_dim */\n  int opt, option_index=0;\n  func_ret_t ret;\n  const char *input_file = NULL;\n  float *m, *mm;\n  stopwatch sw;\n\n  while ((opt = getopt_long(argc, argv, ""::vs:i:"", \n                            long_options, &option_index)) != -1 ) {\n      switch(opt){\n        case 'i':\n          input_file = optarg;\n          break;\n        case 'v':\n          do_verify = 1;\n          break;\n        case 's':\n          matrix_dim = atoi(optarg);\n          fprintf(stderr, ""Currently not supported, use -i instead\n"");\n          fprintf(stderr, ""Usage: %s [-v] [-s matrix_size|-i input_file]\n"", argv[0]);\n          exit(EXIT_FAILURE);\n        case '?':\n          fprintf(stderr, ""invalid option\n"");\n          break;\n        case ':':\n          fprintf(stderr, ""missing argument\n"");\n          break;\n        default:\n          fprintf(stderr, ""Usage: %s [-v] [-s matrix_size|-i input_file]\n"",\n                  argv[0]);\n          exit(EXIT_FAILURE);\n      }\n  }\n\n  if ( (optind < argc) || (optind == 1)) {\n      fprintf(stderr, ""Usage: %s [-v] [-s matrix_size|-i input_file]\n"", argv[0]);\n      exit(EXIT_FAILURE);\n  }\n  \n  if (input_file) {\n      printf(""Reading matrix from file %s\n"", input_file);\n      ret = create_matrix_from_file(&m, input_file, &matrix_dim);\n      if (ret != RET_SUCCESS) {\n          m = NULL;\n          fprintf(stderr, ""error create matrix from file %s\n"", input_file);\n          exit(EXIT_FAILURE);\n      }\n  } else {\n    printf(""No input file specified!\n"");\n    exit(EXIT_FAILURE);\n  } \n\n  if (do_verify){\n    printf(""Before LUD\n"");\n    print_matrix(m, matrix_dim);\n    matrix_duplicate(m, &mm, matrix_dim);\n  }\n\n  stopwatch_start(&sw);\n  lud_base(m, matrix_dim);\n  stopwatch_stop(&sw);\n  printf(""Time consumed(ms): %lf\n"", 1000*get_interval_by_sec(&sw));\n\n  if (do_verify){\n    printf(""After LUD\n"");\n    print_matrix(m, matrix_dim);\n    printf("">>>Verify<<<<\n"");\n    lud_verify(mm, m, matrix_dim); \n    free(mm);\n  }\n\n  free(m);\n\n  return EXIT_SUCCESS;\n}				/* ----------  end of function main  ---------- */\n"
hotspot3D/3D.c,"#include <stdio.h>\n#include <time.h>\n#include <assert.h>\n#include <stdlib.h> \n#include <math.h> \n#include <sys/time.h>\n#include <string.h>\n\n#define STR_SIZE (256)\n#define MAX_PD	(3.0e6)\n/* required precision in degrees	*/\n#define PRECISION	0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n/* capacitance fitting factor	*/\n#define FACTOR_CHIP	0.5\n\n\n/* chip parameters	*/\nfloat t_chip = 0.0005;\nfloat chip_height = 0.016; float chip_width = 0.016; \n/* ambient temperature, assuming no package at all	*/\nfloat amb_temp = 80.0;\n\nvoid fatal(char *s)\n{\n    fprintf(stderr, ""Error: %s\n"", s);\n}\n\nvoid readinput(float *vect, int grid_rows, int grid_cols, int layers, char *file) {\n    int i,j,k;\n    FILE *fp;\n    char str[STR_SIZE];\n    float val;\n\n    if( (fp  = fopen(file, ""r"" )) ==0 )\n      fatal( ""The file was not opened"" );\n\n\n    for (i=0; i <= grid_rows-1; i++) \n      for (j=0; j <= grid_cols-1; j++)\n        for (k=0; k <= layers-1; k++)\n          {\n            if (fgets(str, STR_SIZE, fp) == NULL) fatal(""Error reading file\n"");\n            if (feof(fp))\n              fatal(""not enough lines in file"");\n            if ((sscanf(str, ""%f"", &val) != 1))\n              fatal(""invalid file format"");\n            vect[i*grid_cols+j+k*grid_rows*grid_cols] = val;\n          }\n\n    fclose(fp);	\n\n}\n\n\nvoid writeoutput(float *vect, int grid_rows, int grid_cols, int layers, char *file) {\n\n    int i,j,k, index=0;\n    FILE *fp;\n    char str[STR_SIZE];\n\n    if( (fp = fopen(file, ""w"" )) == 0 )\n      printf( ""The file was not opened\n"" );\n\n    for (i=0; i < grid_rows; i++) \n      for (j=0; j < grid_cols; j++)\n        for (k=0; k < layers; k++)\n          {\n            sprintf(str, ""%d\t%g\n"", index, vect[i*grid_cols+j+k*grid_rows*grid_cols]);\n            fputs(str,fp);\n            index++;\n          }\n\n    fclose(fp);	\n}\n\n\n\nvoid computeTempCPU(float *pIn, float* tIn, float *tOut, \n        int nx, int ny, int nz, float Cap, \n        float Rx, float Ry, float Rz, \n        float dt, int numiter) \n{   float ce, cw, cn, cs, ct, cb, cc;\n    float stepDivCap = dt / Cap;\n    ce = cw =stepDivCap/ Rx;\n    cn = cs =stepDivCap/ Ry;\n    ct = cb =stepDivCap/ Rz;\n\n    cc = 1.0 - (2.0*ce + 2.0*cn + 3.0*ct);\n\n    int c,w,e,n,s,b,t;\n    int x,y,z;\n    int i = 0;\n    do{\n        for(z = 0; z < nz; z++)\n            for(y = 0; y < ny; y++)\n                for(x = 0; x < nx; x++)\n                {\n                    c = x + y * nx + z * nx * ny;\n\n                    w = (x == 0) ? c      : c - 1;\n                    e = (x == nx - 1) ? c : c + 1;\n                    n = (y == 0) ? c      : c - nx;\n                    s = (y == ny - 1) ? c : c + nx;\n                    b = (z == 0) ? c      : c - nx * ny;\n                    t = (z == nz - 1) ? c : c + nx * ny;\n\n\n                    tOut[c] = tIn[c]*cc + tIn[n]*cn + tIn[s]*cs + tIn[e]*ce + tIn[w]*cw + tIn[t]*ct + tIn[b]*cb + (dt/Cap) * pIn[c] + ct*amb_temp;\n                }\n        float *temp = tIn;\n        tIn = tOut;\n        tOut = temp; \n        i++;\n    }\n    while(i < numiter);\n\n}\n\nfloat accuracy(float *arr1, float *arr2, int len)\n{\n    float err = 0.0; \n    int i;\n    for(i = 0; i < len; i++)\n    {\n        err += (arr1[i]-arr2[i]) * (arr1[i]-arr2[i]);\n    }\n\n    return (float)sqrt(err/len);\n\n\n}\nvoid computeTempOMP(float *pIn, float* tIn, float *tOut, \n        int nx, int ny, int nz, float Cap, \n        float Rx, float Ry, float Rz, \n        float dt, int numiter) \n{  \n\n    float ce, cw, cn, cs, ct, cb, cc;\n\n    float stepDivCap = dt / Cap;\n    ce = cw =stepDivCap/ Rx;\n    cn = cs =stepDivCap/ Ry;\n    ct = cb =stepDivCap/ Rz;\n\n    cc = 1.0 - (2.0*ce + 2.0*cn + 3.0*ct);\n\n\n#pragma omp parallel\n    {\n        int count = 0;\n        float *tIn_t = tIn;\n        float *tOut_t = tOut;\n\n#pragma omp master\n        printf(""%d threads running\n"", omp_get_num_threads());\n\n        do {\n            int z; \n#pragma omp for \n            for (z = 0; z < nz; z++) {\n                int y;\n                for (y = 0; y < ny; y++) {\n                    int x;\n                    for (x = 0; x < nx; x++) {\n                        int c, w, e, n, s, b, t;\n                        c =  x + y * nx + z * nx * ny;\n                        w = (x == 0)    ? c : c - 1;\n                        e = (x == nx-1) ? c : c + 1;\n                        n = (y == 0)    ? c : c - nx;\n                        s = (y == ny-1) ? c : c + nx;\n                        b = (z == 0)    ? c : c - nx * ny;\n                        t = (z == nz-1) ? c : c + nx * ny;\n                        tOut_t[c] = cc * tIn_t[c] + cw * tIn_t[w] + ce * tIn_t[e]\n                            + cs * tIn_t[s] + cn * tIn_t[n] + cb * tIn_t[b] + ct * tIn_t[t]+(dt/Cap) * pIn[c] + ct*amb_temp;\n                    }\n                }\n            }\n            float *t = tIn_t;\n            tIn_t = tOut_t;\n            tOut_t = t; \n            count++;\n        } while (count < numiter);\n    } \n    return; \n} \n\nvoid usage(int argc, char **argv)\n{\n    fprintf(stderr, ""Usage: %s <rows/cols> <layers> <iterations> <powerFile> <tempFile> <outputFile>\n"", argv[0]);\n    fprintf(stderr, ""\t<rows/cols>  - number of rows/cols in the grid (positive integer)\n"");\n    fprintf(stderr, ""\t<layers>  - number of layers in the grid (positive integer)\n"");\n\n    fprintf(stderr, ""\t<iteration> - number of iterations\n"");\n    fprintf(stderr, ""\t<powerFile>  - name of the file containing the initial power values of each cell\n"");\n    fprintf(stderr, ""\t<tempFile>  - name of the file containing the initial temperature values of each cell\n"");\n    fprintf(stderr, ""\t<outputFile - output file\n"");\n    exit(1);\n}\n\n\n\nint main(int argc, char** argv)\n{\n    if (argc != 7)\n    {\n        usage(argc,argv);\n    }\n\n    char *pfile, *tfile, *ofile;// *testFile;\n    int iterations = atoi(argv[3]);\n\n    pfile = argv[4];\n    tfile = argv[5];\n    ofile = argv[6];\n    //testFile = argv[7];\n    int numCols = atoi(argv[1]);\n    int numRows = atoi(argv[1]);\n    int layers = atoi(argv[2]);\n\n    /* calculating parameters*/\n\n    float dx = chip_height/numRows;\n    float dy = chip_width/numCols;\n    float dz = t_chip/layers;\n\n    float Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * dx * dy;\n    float Rx = dy / (2.0 * K_SI * t_chip * dx);\n    float Ry = dx / (2.0 * K_SI * t_chip * dy);\n    float Rz = dz / (K_SI * dx * dy);\n\n    // cout << Rx << "" "" << Ry << "" "" << Rz << endl;\n    float max_slope = MAX_PD / (FACTOR_CHIP * t_chip * SPEC_HEAT_SI);\n    float dt = PRECISION / max_slope;\n\n\n    float *powerIn, *tempOut, *tempIn, *tempCopy;// *pCopy;\n    //    float *d_powerIn, *d_tempIn, *d_tempOut;\n    int size = numCols * numRows * layers;\n\n    powerIn = (float*)calloc(size, sizeof(float));\n    tempCopy = (float*)malloc(size * sizeof(float));\n    tempIn = (float*)calloc(size,sizeof(float));\n    tempOut = (float*)calloc(size, sizeof(float));\n    //pCopy = (float*)calloc(size,sizeof(float));\n    float* answer = (float*)calloc(size, sizeof(float));\n\n    // outCopy = (float*)calloc(size, sizeof(float));\n    readinput(powerIn,numRows, numCols, layers,pfile);\n    readinput(tempIn, numRows, numCols, layers, tfile);\n\n    memcpy(tempCopy,tempIn, size * sizeof(float));\n\n    struct timeval start, stop;\n    float time;\n    gettimeofday(&start,NULL);\n    computeTempOMP(powerIn, tempIn, tempOut, numCols, numRows, layers, Cap, Rx, Ry, Rz, dt,iterations);\n    gettimeofday(&stop,NULL);\n    time = (stop.tv_usec-start.tv_usec)*1.0e-6 + stop.tv_sec - start.tv_sec;\n    computeTempCPU(powerIn, tempCopy, answer, numCols, numRows, layers, Cap, Rx, Ry, Rz, dt,iterations);\n\n    float acc = accuracy(tempOut,answer,numRows*numCols*layers);\n    printf(""Time: %.3f (s)\n"",time);\n    printf(""Accuracy: %e\n"",acc);\n    writeoutput(tempOut,numRows, numCols, layers, ofile);\n    free(tempIn);\n    free(tempOut); free(powerIn);\n    return 0;\n}	\n\n\n"
hotspot/hotspot_openmp.cpp,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\n// Returns the current system time in microseconds \nlong long get_time()\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * 1000000) + tv.tv_usec;\n\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE	256\n\n/* maximum power density possible (say 300W for a 10mm x 10mm chip)	*/\n#define MAX_PD	(3.0e6)\n/* required precision in degrees	*/\n#define PRECISION	0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n/* capacitance fitting factor	*/\n#define FACTOR_CHIP	0.5\n#define OPEN\n//#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\n/* chip parameters	*/\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\n/* ambient temperature, assuming no package at all	*/\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\n/* Single iteration of the transient solver in the grid model.\n * advances the solution of the discretized difference equations \n * by one time step\n */\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\n					  FLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1, \n					  FLOAT step)\n{\n    FLOAT delta;\n    int r, c;\n    int chunk;\n    int num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\n    int chunks_in_row = col/BLOCK_SIZE_C;\n    int chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n    #ifndef __MIC__\n	omp_set_num_threads(num_omp_threads);\n    #endif\n    #pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\n    for ( chunk = 0; chunk < num_chunk; ++chunk )\n    {\n        int r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\n        int c_start = BLOCK_SIZE_C*(chunk%chunks_in_row); \n        int r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\n        int c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n       \n        if ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n        {\n            for ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\n                for ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\n                    /* Corner 1 */\n                    if ( (r == 0) && (c == 0) ) {\n                        delta = (Cap_1) * (power[0] +\n                            (temp[1] - temp[0]) * Rx_1 +\n                            (temp[col] - temp[0]) * Ry_1 +\n                            (amb_temp - temp[0]) * Rz_1);\n                    }	/* Corner 2 */\n                    else if ((r == 0) && (c == col-1)) {\n                        delta = (Cap_1) * (power[c] +\n                            (temp[c-1] - temp[c]) * Rx_1 +\n                            (temp[c+col] - temp[c]) * Ry_1 +\n                        (   amb_temp - temp[c]) * Rz_1);\n                    }	/* Corner 3 */\n                    else if ((r == row-1) && (c == col-1)) {\n                        delta = (Cap_1) * (power[r*col+c] + \n                            (temp[r*col+c-1] - temp[r*col+c]) * Rx_1 + \n                            (temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 + \n                        (   amb_temp - temp[r*col+c]) * Rz_1);					\n                    }	/* Corner 4	*/\n                    else if ((r == row-1) && (c == 0)) {\n                        delta = (Cap_1) * (power[r*col] + \n                            (temp[r*col+1] - temp[r*col]) * Rx_1 + \n                            (temp[(r-1)*col] - temp[r*col]) * Ry_1 + \n                            (amb_temp - temp[r*col]) * Rz_1);\n                    }	/* Edge 1 */\n                    else if (r == 0) {\n                        delta = (Cap_1) * (power[c] + \n                            (temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 + \n                            (temp[col+c] - temp[c]) * Ry_1 + \n                            (amb_temp - temp[c]) * Rz_1);\n                    }	/* Edge 2 */\n                    else if (c == col-1) {\n                        delta = (Cap_1) * (power[r*col+c] + \n                            (temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.0*temp[r*col+c]) * Ry_1 + \n                            (temp[r*col+c-1] - temp[r*col+c]) * Rx_1 + \n                            (amb_temp - temp[r*col+c]) * Rz_1);\n                    }	/* Edge 3 */\n                    else if (r == row-1) {\n                        delta = (Cap_1) * (power[r*col+c] + \n                            (temp[r*col+c+1] + temp[r*col+c-1] - 2.0*temp[r*col+c]) * Rx_1 + \n                            (temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 + \n                            (amb_temp - temp[r*col+c]) * Rz_1);\n                    }	/* Edge 4 */\n                    else if (c == 0) {\n                        delta = (Cap_1) * (power[r*col] + \n                            (temp[(r+1)*col] + temp[(r-1)*col] - 2.0*temp[r*col]) * Ry_1 + \n                            (temp[r*col+1] - temp[r*col]) * Rx_1 + \n                            (amb_temp - temp[r*col]) * Rz_1);\n                    }\n                    result[r*col+c] =temp[r*col+c]+ delta;\n                }\n            }\n            continue;\n        }\n\n        for ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\n#pragma omp simd        \n            for ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\n            /* Update Temperatures */\n                result[r*col+c] =temp[r*col+c]+ \n                     ( Cap_1 * (power[r*col+c] + \n                    (temp[(r+1)*col+c] + temp[(r-1)*col+c] - 2.f*temp[r*col+c]) * Ry_1 + \n                    (temp[r*col+c+1] + temp[r*col+c-1] - 2.f*temp[r*col+c]) * Rx_1 + \n                    (amb_temp - temp[r*col+c]) * Rz_1));\n            }\n        }\n    }\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n/* Transient solver driver routine: simply converts the heat \n * transfer differential equations to difference equations \n * and solves the difference equations by iterating\n */\nvoid compute_tran_temp(FLOAT *result, int num_iterations, FLOAT *temp, FLOAT *power, int row, int col) \n{\n	#ifdef VERBOSE\n	int i = 0;\n	#endif\n\n	FLOAT grid_height = chip_height / row;\n	FLOAT grid_width = chip_width / col;\n\n	FLOAT Cap = FACTOR_CHIP * SPEC_HEAT_SI * t_chip * grid_width * grid_height;\n	FLOAT Rx = grid_width / (2.0 * K_SI * t_chip * grid_height);\n	FLOAT Ry = grid_height / (2.0 * K_SI * t_chip * grid_width);\n	FLOAT Rz = t_chip / (K_SI * grid_height * grid_width);\n\n	FLOAT max_slope = MAX_PD / (FACTOR_CHIP * t_chip * SPEC_HEAT_SI);\n    FLOAT step = PRECISION / max_slope / 1000.0;\n\n    FLOAT Rx_1=1.f/Rx;\n    FLOAT Ry_1=1.f/Ry;\n    FLOAT Rz_1=1.f/Rz;\n    FLOAT Cap_1 = step/Cap;\n	#ifdef VERBOSE\n	fprintf(stdout, ""total iterations: %d s\tstep size: %g s\n"", num_iterations, step);\n	fprintf(stdout, ""Rx: %g\tRy: %g\tRz: %g\tCap: %g\n"", Rx, Ry, Rz, Cap);\n	#endif\n\n#ifdef OMP_OFFLOAD\n        int array_size = row*col;\n#pragma omp target \\n        map(temp[0:array_size]) \\n        map(to: power[0:array_size], row, col, Cap_1, Rx_1, Ry_1, Rz_1, step, num_iterations) \\n        map( result[0:array_size])\n#endif\n        {\n            FLOAT* r = result;\n            FLOAT* t = temp;\n            for (int i = 0; i < num_iterations ; i++)\n            {\n                #ifdef VERBOSE\n                fprintf(stdout, ""iteration %d\n"", i++);\n                #endif\n                single_iteration(r, t, power, row, col, Cap_1, Rx_1, Ry_1, Rz_1, step);\n                FLOAT* tmp = t;\n                t = r;\n                r = tmp;\n            }	\n        }\n	#ifdef VERBOSE\n	fprintf(stdout, ""iteration %d\n"", i++);\n	#endif\n}\n\nvoid fatal(char *s)\n{\n	fprintf(stderr, ""error: %s\n"", s);\n	exit(1);\n}\n\nvoid writeoutput(FLOAT *vect, int grid_rows, int grid_cols, char *file) {\n\n    int i,j, index=0;\n    FILE *fp;\n    char str[STR_SIZE];\n\n    if( (fp = fopen(file, ""w"" )) == 0 )\n        printf( ""The file was not opened\n"" );\n\n\n    for (i=0; i < grid_rows; i++) \n        for (j=0; j < grid_cols; j++)\n        {\n\n            sprintf(str, ""%d\t%g\n"", index, vect[i*grid_cols+j]);\n            fputs(str,fp);\n            index++;\n        }\n\n    fclose(fp);	\n}\n\nvoid read_input(FLOAT *vect, int grid_rows, int grid_cols, char *file)\n{\n  	int i, index;\n	FILE *fp;\n	char str[STR_SIZE];\n	FLOAT val;\n\n	fp = fopen (file, ""r"");\n	if (!fp)\n		fatal (""file could not be opened for reading"");\n\n	for (i=0; i < grid_rows * grid_cols; i++) {\n		fgets(str, STR_SIZE, fp);\n		if (feof(fp))\n			fatal(""not enough lines in file"");\n		if ((sscanf(str, ""%f"", &val) != 1) )\n			fatal(""invalid file format"");\n		vect[i] = val;\n	}\n\n	fclose(fp);	\n}\n\nvoid usage(int argc, char **argv)\n{\n	fprintf(stderr, ""Usage: %s <grid_rows> <grid_cols> <sim_time> <no. of threads><temp_file> <power_file>\n"", argv[0]);\n	fprintf(stderr, ""\t<grid_rows>  - number of rows in the grid (positive integer)\n"");\n	fprintf(stderr, ""\t<grid_cols>  - number of columns in the grid (positive integer)\n"");\n	fprintf(stderr, ""\t<sim_time>   - number of iterations\n"");\n	fprintf(stderr, ""\t<no. of threads>   - number of threads\n"");\n	fprintf(stderr, ""\t<temp_file>  - name of the file containing the initial temperature values of each cell\n"");\n	fprintf(stderr, ""\t<power_file> - name of the file containing the dissipated power values of each cell\n"");\n        fprintf(stderr, ""\t<output_file> - name of the output file\n"");\n	exit(1);\n}\n\nint main(int argc, char **argv)\n{\n	int grid_rows, grid_cols, sim_time, i;\n	FLOAT *temp, *power, *result;\n	char *tfile, *pfile, *ofile;\n	\n	/* check validity of inputs	*/\n	if (argc != 8)\n		usage(argc, argv);\n	if ((grid_rows = atoi(argv[1])) <= 0 ||\n		(grid_cols = atoi(argv[2])) <= 0 ||\n		(sim_time = atoi(argv[3])) <= 0 || \n		(num_omp_threads = atoi(argv[4])) <= 0\n		)\n		usage(argc, argv);\n\n	/* allocate memory for the temperature and power arrays	*/\n	temp = (FLOAT *) calloc (grid_rows * grid_cols, sizeof(FLOAT));\n	power = (FLOAT *) calloc (grid_rows * grid_cols, sizeof(FLOAT));\n	result = (FLOAT *) calloc (grid_rows * grid_cols, sizeof(FLOAT));\n	if(!temp || !power)\n		fatal(""unable to allocate memory"");\n\n	/* read initial temperatures and input power	*/\n	tfile = argv[5];\n	pfile = argv[6];\n    ofile = argv[7];\n\n	read_input(temp, grid_rows, grid_cols, tfile);\n	read_input(power, grid_rows, grid_cols, pfile);\n\n	printf(""Start computing the transient temperature\n"");\n	\n    long long start_time = get_time();\n\n    compute_tran_temp(result,sim_time, temp, power, grid_rows, grid_cols);\n\n    long long end_time = get_time();\n\n    printf(""Ending simulation\n"");\n    printf(""Total time: %.3f seconds\n"", ((float) (end_time - start_time)) / (1000*1000));\n\n    writeoutput((1&sim_time) ? result : temp, grid_rows, grid_cols, ofile);\n\n	/* output results	*/\n#ifdef VERBOSE\n	fprintf(stdout, ""Final Temperatures:\n"");\n#endif\n\n#ifdef OUTPUT\n	for(i=0; i < grid_rows * grid_cols; i++)\n	fprintf(stdout, ""%d\t%g\n"", i, temp[i]);\n#endif\n	/* cleanup	*/\n	free(temp);\n	free(power);\n\n	return 0;\n}\n/* vim: set ts=4 sw=4  sts=4 et si ai: */\n"
pathfinder/pathfinder.cpp,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include ""timer.h""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(""timer: %Lu\n"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n	if(argc==3){\n		cols = atoi(argv[1]);\n		rows = atoi(argv[2]);\n	}else{\n                printf(""Usage: pathfiner width num_of_steps\n"");\n                exit(0);\n        }\n	data = new int[rows*cols];\n	wall = new int*[rows];\n	for(int n=0; n<rows; n++)\n		wall[n]=data+cols*n;\n	result = new int[cols];\n	\n	int seed = M_SEED;\n	srand(seed);\n\n	for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(""%d "",wall[i][j]) ;\n        }\n        printf(""\n"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n	fprintf(stderr, ""error: %s\n"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(""%d "",data[i]) ;\n\n    printf(""\n"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(""%d "",dst[i]) ;\n\n    printf(""\n"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n\n"
b+tree/main.c,"// # ifdef __cplusplus\n// extern ""C"" {\n// # endif\n\n//========================================================================================================================================================================================================200\n//======================================================================================================================================================150\n//====================================================================================================100\n//==================================================50\n\n//========================================================================================================================================================================================================200\n//	INFORMATION\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	UPDATE\n//======================================================================================================================================================150\n\n// 2009; Amittai Aviram; entire code written in C; \n// 2010; Jordan Fix and Andrew Wilkes; code converted to CUDA; \n// 2011.10; Lukasz G. Szafaryn; code converted to portable form, to C, OpenMP, CUDA, PGI versions; \n// 2011.12; Lukasz G. Szafaryn; Split different versions for Rodinia.\n// 2011.12; Lukasz G. Szafaryn; code converted to OpenCL;\n\n//======================================================================================================================================================150\n//	DESCRIPTION\n//======================================================================================================================================================150\n\n// Description\n\n//======================================================================================================================================================150\n//	USE\n//======================================================================================================================================================150\n\n// EXAMPLE:\n// ./a.out -file ./input/mil.txt -cores 16\n// ...then enter any of the following commands after the prompt > :\n// f <x>  -- Find the value under key <x>\n// p <x> -- Print the path from the root to key k and its associated value\n// t -- Print the B+ tree\n// l -- Print the keys of the leaves (bottom row of the tree)\n// v -- Toggle output of pointer addresses (""verbose"") in tree and leaves.\n// k <x> -- Run <x> bundled queries on the CPU and GPU (B+Tree) (Selects random values for each search)\n// j <x> <y> -- Run a range search of <x> bundled queries on the CPU and GPU (B+Tree) with the range of each search of size <y>\n// x <z> -- Run a single search for value z on the GPU and CPU\n// y <a> <b> -- Run a single range search for range a-b on the GPU and CPU\n// q -- Quit. (Or use Ctl-D.)\n\n//======================================================================================================================================================150\n//	END\n//======================================================================================================================================================150\n\n//========================================================================================================================================================================================================200\n//	DEFINE/INCLUDE\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	LIBRARIES\n//======================================================================================================================================================150\n\n#include <stdio.h>									// (in directory known to compiler)			needed by printf, stderr\n#include <limits.h>									// (in directory known to compiler)			needed by INT_MIN, INT_MAX\n// #include <sys/time.h>							// (in directory known to compiler)			needed by ???\n#include <math.h>									// (in directory known to compiler)			needed by log, pow\n#include <string.h>									// (in directory known to compiler)			needed by memset\n\n//======================================================================================================================================================150\n//	COMMON\n//======================================================================================================================================================150\n\n#include ""./common.h""								// (in directory provided here)\n\n//======================================================================================================================================================150\n//	DEFINE\n//======================================================================================================================================================150\n\n//======================================================================================================================================================150\n//	UTILITIES\n//======================================================================================================================================================150\n\n#include ""./util/timer/timer.h""						// (in directory provided here)\n#include ""./util/num/num.h""							// (in directory provided here)\n\n//======================================================================================================================================================150\n//	KERNEL HEADERS\n//======================================================================================================================================================150\n\n#include ""./kernel/kernel_cpu.h""					// (in directory provided here)\n#include ""./kernel/kernel_cpu_2.h""					// (in directory provided here)\n\n//======================================================================================================================================================150\n//	HEADER\n//======================================================================================================================================================150\n\n#include ""./main.h""									// (in directory provided here)\n\n//======================================================================================================================================================150\n//	END\n//======================================================================================================================================================150\n\n//========================================================================================================================================================================================================200\n//	VARIABLES\n//========================================================================================================================================================================================================200\n\n// general variables\nknode *knodes;\nrecord *krecords;\nchar *mem;\nlong freeptr;\nlong malloc_size;\nlong size;\nlong maxheight;\n\n/* The order determines the maximum and minimum\n* number of entries (keys and pointers) in any\n* node.  Every node has at most order - 1 keys and\n* at least (roughly speaking) half that number.\n* Every leaf has as many pointers to data as keys,\n* and every internal node has one more pointer\n* to a subtree than the number of keys.\n* This global variable is initialized to the\n* default value.\n*/\nint order = DEFAULT_ORDER;\n\n/* The queue is used to print the tree in\n* level order, starting from the root\n* printing each entire rank on a separate\n* line, finishing with the leaves.\n*/\nnode *queue = NULL;\n\n/* The user can toggle on and off the ""verbose""\n* property, which causes the pointer addresses\n* to be printed out in hexadecimal notation\n* next to their corresponding keys.\n*/\nbool verbose_output = false;\n\n//========================================================================================================================================================================================================200\n//	FUNCTIONS\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	Components\n//======================================================================================================================================================150\n\nvoid \nlist_init(	list_t *l,\n			int32_t (*compare)(const void *key, \n			const void *with),\n			void (*datum_delete)(void *))\n{\n  l->head = l->tail = NULL;\n  l->length = 0;\n  l->compare = compare;\n  l->datum_delete = datum_delete;\n}\n\nvoid \nlist_delete(list_t *l)\n{\n\n  list_item_t *li, *del;\n\n  for (li = l->head; li;) {\n\n    del = li;\n    li = li->next;\n    list_item_delete(del, l->datum_delete);\n  }\n\n  l->head = l->tail = NULL;\n  l->length = 0;\n}\n\nvoid \nlist_reset(list_t *l)\n{\n  list_delete(l);\n}\n\nvoid \nlist_insert_item_head(	list_t *l, \n						list_item_t *i)\n{\n  if (l->head) {\n    i->next = l->head;\n    l->head->pred = i;\n    l->head = i;\n    l->head->pred = NULL;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_tail(	list_t *l, \n						list_item_t *i)\n{\n  if (l->head) {\n    l->tail->next = i;\n    i->pred = l->tail;\n    i->next = NULL;\n    l->tail = i;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_before(list_t *l, \n						list_item_t *next, \n						list_item_t *i)\n{\n  /* Assume next is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->head == next) {\n    i->next = next;\n    i->pred = NULL;\n    l->head = i;\n    next->pred = i;\n  } else {\n    i->next = next;\n    i->pred = next->pred;\n    next->pred->next = i;\n    next->pred = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_after(	list_t *l, \n						list_item_t *pred, \n						list_item_t *i)\n{\n  /* Assume pred is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->tail == pred) {\n    i->pred = pred;\n    i->next = NULL;\n    l->tail = i;\n    pred->next = i;\n  } else {\n    i->pred = pred;\n    i->next = pred->next;\n    pred->next->pred = i;\n    pred->next = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_item_sorted(list_t *l, \n						list_item_t *i)\n{\n  list_item_t *itr;\n\n  if (l->head) {\n    for (itr = l->head; itr && l->compare(list_item_get_datum(i),\n					  list_item_get_datum(itr)) < 0;\n	 itr = itr->next)\n      ;\n    if (itr) {\n      i->next = itr;\n      i->pred = itr->pred;\n      itr->pred = i;\n      i->pred->next = i;\n    } else {\n      l->tail->next = i;\n      i->pred = l->tail;\n      i->next = NULL;\n      l->tail = i;\n    }\n  } else {\n    l->head = l->tail = i;\n    i->pred = i->next = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_head(	list_t *l, \n					void *v)\n{\n  list_item_t *i;\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n  if (l->head) {\n    i->next = l->head;\n    l->head->pred = i;\n    l->head = i;\n    l->head->pred = NULL;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n\n}\n\nvoid \nlist_insert_tail(	list_t *l, \n					void *v)\n{\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n  if (l->head) {\n    l->tail->next = i;\n    i->pred = l->tail;\n    i->next = NULL;\n    l->tail = i;\n  } else {\n    l->head = l->tail = i;\n    i->next = i->pred = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_before(	list_t *l, \n					list_item_t *next, \n					void *v)\n{\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n\n  /* Assume next is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->head == next) {\n    i->next = next;\n    i->pred = NULL;\n    l->head = i;\n    next->pred = i;\n  } else {\n    i->next = next;\n    i->pred = next->pred;\n    next->pred->next = i;\n    next->pred = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_after(	list_t *l, \n					list_item_t *pred, \n					void *v)\n{\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n\n  /* Assume pred is actually in the list! */\n  /* If it's not, we may lose the list.   */\n  if (l->tail == pred) {\n    i->pred = pred;\n    i->next = NULL;\n    l->tail = i;\n    pred->next = i;\n  } else {\n    i->pred = pred;\n    i->next = pred->next;\n    pred->next->pred = i;\n    pred->next = i;\n  }\n  l->length++;\n}\n\nvoid \nlist_insert_sorted(	list_t *l, \n					void *v)\n{\n  list_item_t *itr;\n  list_item_t *i;\n\n  i = (list_item_t *)malloc(sizeof (*i));\n  list_item_init(i, v);\n\n\n  if (l->head) {\n    for (itr = l->head; itr && l->compare(list_item_get_datum(i),\n					  list_item_get_datum(itr)) < 0;\n	 itr = itr->next)\n      ;\n    if (itr) {\n      i->next = itr;\n      i->pred = itr->pred;\n      itr->pred = i;\n      i->pred->next = i;\n    } else {\n      l->tail->next = i;\n      i->pred = l->tail;\n      i->next = NULL;\n      l->tail = i;\n    }\n  } else {\n    l->head = l->tail = i;\n    i->pred = i->next = NULL;\n  }\n  l->length++;\n}\n\nvoid \nlist_remove_item(	list_t *l, \n					list_item_t *i)\n{\n  if (i == l->head) {\n    l->head = l->head->next;\n    if (l->head)\n      l->head->pred = NULL;\n    else\n      l->tail = NULL;\n  } else if (i == l->tail) {\n    l->tail = l->tail->pred;\n    l->tail->next = NULL;\n  } else {\n    i->pred->next = i->next;\n    i->next->pred = i->pred;\n  }\n  l->length--;\n  list_item_delete(i, l->datum_delete);\n}\n\nvoid \nlist_remove_head(list_t *l)\n{\n  list_remove_item(l, l->head);\n}\n\nvoid \nlist_remove_tail(list_t *l)\n{\n  list_remove_item(l, l->tail);\n}\n\nlist_item_t* \nlist_find_item(	list_t *l, \n				void *datum)\n{\n  list_item_t *li;\n\n  for (li = l->head; li && l->compare(datum, list_item_get_datum(li));\n       li = li->next)\n    ;\n\n  return li;\n}\n\nlist_item_t* \nlist_get_head_item(list_t *l)\n{\n  return l->head;\n}\n\nlist_item_t* \nlist_get_tail_item(list_t *l)\n{\n  return l->tail;\n}\n\nvoid* \nlist_find(	list_t *l, \n			void *datum)\n{\n  list_item_t *li;\n\n  for (li = l->head; li && l->compare(datum, list_item_get_datum(li));\n       li = li->next)\n    ;\n\n  return li ? li->datum : NULL;\n}\n\nvoid* \nlist_get_head(list_t *l)\n{\n  return l->head ? l->head->datum : NULL;\n}\n\nvoid* \nlist_get_tail(list_t *l)\n{\n  return l->tail ? l->tail->datum : NULL;\n}\n\nuint32_t \nlist_get_length(list_t *l)\n{\n  return l->length;\n}\n\nbool \nlist_is_empty(list_t *l)\n{\n  return (l->length == 0);\n}\n\nbool \nlist_not_empty(list_t *l)\n{\n  return (l->length != 0);\n}\n\nvoid \nlist_visit_items(	list_t *l, \n					void (*visitor)(void *v))\n{\n  list_item_t *li;\n\n  for (li = l->head; li; li = li->next)\n    visitor(list_item_get_datum(li));\n}\n\nvoid \nlist_item_init(	list_item_t *li, \n				void *datum)\n{\n  li->pred = li->next = NULL;\n  li->datum = datum;\n}\n\nvoid \nlist_item_delete(	list_item_t *li, \n					void (*datum_delete)(void *datum))\n{\n  if (datum_delete) {\n    datum_delete(li->datum);\n  }\n\n  free(li);\n}\n\nvoid *\nlist_item_get_datum(list_item_t *li)\n{\n  return li->datum;\n}\n\nvoid \nlist_iterator_init(	list_t *l, \n					list_iterator_t *li)\n{\n  *li = l ? l->head : NULL;\n}\n\nvoid \nlist_iterator_delete(list_iterator_t *li)\n{\n  *li = NULL;\n}\n\nvoid \nlist_iterator_next(list_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->next;\n}\n\nvoid \nlist_iterator_prev(list_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->pred;\n}\n\nvoid *\nlist_iterator_get_datum(list_iterator_t *li)\n{\n  return *li ? (*li)->datum : NULL;\n}\n\nbool \nlist_iterator_is_valid(list_iterator_t *li)\n{\n  return (*li != NULL);\n}\n\nvoid \nlist_reverse_iterator_init(	list_t *l, \n							list_reverse_iterator_t *li)\n{\n  *li = l ? l->tail : NULL;\n}\n\nvoid \nlist_reverse_iterator_delete(list_reverse_iterator_t *li)\n{\n  *li = NULL;\n}\n\nvoid \nlist_reverse_iterator_next(list_reverse_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->pred;\n}\n\nvoid \nlist_reverse_iterator_prev(list_reverse_iterator_t *li)\n{\n  if (*li)\n    *li = (*li)->next;\n}\n\nvoid *\nlist_reverse_iterator_get_datum(list_reverse_iterator_t *li)\n{\n  return *li ? (*li)->datum : NULL;\n}\n\nbool \nlist_reverse_iterator_is_valid(list_reverse_iterator_t *li)\n{\n  return (li != NULL);\n}\n\n//======================================================================================================================================================150\n// OUTPUT AND UTILITIES\n//======================================================================================================================================================150\n\n/*   */\nvoid *\nkmalloc(int size)\n{\n\n	//printf(""size: %d, current offset: %p\n"",size,freeptr);\n	void * r = (void *)freeptr;\n	freeptr+=size;\n	if(freeptr > malloc_size+(long)mem){\n		printf(""Memory Overflow\n"");\n		exit(1);\n	}\n	return r;\n}\n\n//transforms the current B+ Tree into a single, contiguous block of memory to be used on the GPU\nlong \ntransform_to_cuda(	node * root, \n					bool verbose)\n{\n\n	struct timeval one,two;\n	double time;\n	gettimeofday (&one, NULL);\n	long max_nodes = (long)(pow(order,log(size)/log(order/2.0)-1) + 1);\n	malloc_size = size*sizeof(record) + max_nodes*sizeof(knode); \n	mem = (char*)malloc(malloc_size);\n	if(mem==NULL){\n		printf(""Initial malloc error\n"");\n		exit(1);\n	}\n	freeptr = (long)mem;\n\n	krecords = (record * )kmalloc(size*sizeof(record));\n	// printf(""%d records\n"", size);\n	knodes = (knode *)kmalloc(max_nodes*sizeof(knode));\n	// printf(""%d knodes\n"", max_nodes);\n\n	queue = NULL;\n	enqueue(root);\n	node * n;\n	knode * k;\n	int i;\n	long nodeindex = 0;\n	long recordindex = 0;\n	long queueindex = 0;\n	knodes[0].location = nodeindex++;\n	\n	while( queue != NULL ) {\n		n = dequeue();\n		k = &knodes[queueindex];\n		k->location = queueindex++;\n		k->is_leaf = n->is_leaf;\n		k->num_keys = n->num_keys+2;\n		//start at 1 because 0 is set to INT_MIN\n		k->keys[0]=INT_MIN; \n		k->keys[k->num_keys-1]=INT_MAX;\n		for(i=k->num_keys; i < order; i++)k->keys[i]=INT_MAX;\n		if(!k->is_leaf){\n			k->indices[0]=nodeindex++;\n			// if(k->indices[0]>3953){\n				// printf(""ERROR: %d\n"", k->indices[0]);\n			// }\n			for(i=1;i<k->num_keys-1;i++){\n				k->keys[i] = n->keys[i-1];\n				enqueue((node * )n->pointers[i-1]);\n				k->indices[i] = nodeindex++;\n				// if(k->indices[i]>3953){\n					// printf(""ERROR 1: %d\n"", k->indices[i]);\n				// }\n				//knodes[nodeindex].location = nodeindex++;\n			}\n			//for final point of n\n			enqueue((node * )n->pointers[i-1]);\n		}\n		else{\n			k->indices[0]=0;\n			for(i=1;i<k->num_keys-1;i++){\n				k->keys[i] = n->keys[i-1];\n				krecords[recordindex].value=((record *)n->pointers[i-1])->value;\n				k->indices[i] = recordindex++;\n				// if(k->indices[i]>3953){\n					// printf(""ERROR 2: %d\n"", k->indices[i]);\n				// }\n			}\n		}\n		\n		k->indices[k->num_keys-1]=queueindex;\n		// if(k->indices[k->num_keys-1]>3953){\n			// printf(""ERROR 3: %d\n"", k->indices[k->num_keys-1]);\n		// }\n\n		if(verbose){\n			printf(""Successfully created knode with index %d\n"", k->location);\n			printf(""Is Leaf: %d, Num Keys: %d\n"", k->is_leaf, k->num_keys);\n			printf(""Pointers: "");\n			for(i=0;i<k->num_keys;i++)\n				printf(""%d | "", k->indices[i]);\n			printf(""\nKeys: "");\n			for(i=0;i<k->num_keys;i++)\n				printf(""%d | "", k->keys[i]);\n			printf(""\n\n"");\n		}\n	}\n	long mem_used = size*sizeof(record)+(nodeindex)*sizeof(knode);\n	if(verbose){\n		for(i = 0; i < size; i++)\n			printf(""%d "", krecords[i].value);\n		printf(""\nNumber of records = %d, sizeof(record)=%d, total=%d\n"",size,sizeof(record),size*sizeof(record));\n		printf(""Number of knodes = %d, sizeof(knode)=%d, total=%d\n"",nodeindex,sizeof(knode),(nodeindex)*sizeof(knode));\n		printf(""\nDone Transformation. Mem used: %d\n"", mem_used);\n	}\n	gettimeofday (&two, NULL);\n	double oneD = one.tv_sec + (double)one.tv_usec * .000001;\n	double twoD = two.tv_sec + (double)two.tv_usec * .000001;\n	time = twoD-oneD;\n	printf(""Tree transformation took %f\n"", time);\n\n	return mem_used;\n\n}\n\n/*   */\nlist_t *\nfindRange(	node * root, \n			int start, \n			int end) \n{\n\n	int i;\n	node * c = find_leaf( root, start, false );\n\n	if (c == NULL) return NULL;\n	\n	list_t * retList = (list_t *)malloc(sizeof(list_t));\n	list_init(retList,NULL,NULL);\n	\n	int counter = 0;\n	bool cont = true;\n	while(cont && c!=0){\n		cont = false;\n		for(i = 0;i  < c->num_keys;i++){\n			if(c->keys[i] >= start && c->keys[i] <= end){\n				//list_insert_tail(retList,(record *)c->pointers[i]);\n				counter++;\n				cont = true;\n			}else{\n				cont = false;\n				break;\n			}\n		}\n		c = (node *)c->pointers[order-1];\n	}\n	return retList;\n}\n\n/* First message to the user. */\nvoid \nusage_1( void ) \n{\n\n	printf(""B+ Tree of Order %d.\n"", order);\n	printf(""\tAmittai Aviram -- amittai.aviram@yale.edu  Version %s\n"", Version);\n	printf(""\tfollowing Silberschatz, Korth, Sidarshan, Database Concepts, 5th ed.\n\n"");\n	printf(""To build a B+ tree of a different order, start again and enter the order\n"");\n	printf(""as an integer argument:  bpt <order>.  "");\n	printf(""3 <= order <=20\n"");\n	printf(""To start with input from a file of newline-delimited integers, start again and enter\n"");\n	printf(""the order followed by the filename:  bpt <order> <inputfile>.\n"");\n\n}\n\n/* Second message to the user. */\nvoid \nusage_2( void ) \n{\n\n	printf(""Enter any of the following commands after the prompt > :\n"");\n	printf(""\ti <k>  -- Insert <k> (an integer) as both key and value).\n"");\n	printf(""\tf <k>  -- Find the value under key <k>.\n"");\n	printf(""\tp <k> -- Print the path from the root to key k and its associated value.\n"");\n	printf(""\td <k>  -- Delete key <k> and its associated value.\n"");\n	printf(""\tx -- Destroy the whole tree.  Start again with an empty tree of the same order.\n"");\n	printf(""\tt -- Print the B+ tree.\n"");\n	printf(""\tl -- Print the keys of the leaves (bottom row of the tree).\n"");\n	printf(""\tv -- Toggle output of pointer addresses (\""verbose\"") in tree and leaves.\n"");\n	printf(""\tq -- Quit. (Or use Ctl-D.)\n"");\n	printf(""\t? -- Print this help message.\n"");\n}\n\n/* Helper function for printing the tree out.  See print_tree. */\nvoid \nenqueue( node* new_node ) \n{\n	node * c;\n	if (queue == NULL) {\n		queue = new_node;\n		queue->next = NULL;\n	}\n	else {\n		c = queue;\n		while(c->next != NULL) {\n			c = c->next;\n		}\n		c->next = new_node;\n		new_node->next = NULL;\n	}\n}\n\n/* Helper function for printing the tree out.  See print_tree. */\nnode *\ndequeue( void ) \n{\n	node * n = queue;\n	queue = queue->next;\n	n->next = NULL;\n	return n;\n}\n\n/* Prints the bottom row of keys of the tree (with their respective pointers, if the verbose_output flag is set. */\nvoid \nprint_leaves( node* root ) \n{\n	int i;\n	node * c = root;\n	if (root == NULL) {\n		printf(""Empty tree.\n"");\n		return;\n	}\n	while (!c->is_leaf)\n	c = (node *) c->pointers[0];\n	while (true) {\n		for (i = 0; i < c->num_keys; i++) {\n			if (verbose_output)\n			//printf(""%x "", (unsigned int)c->pointers[i]);\n			printf(""%d "", c->keys[i]);\n		}\n		if (verbose_output)\n		//printf(""%x "", (unsigned int)c->pointers[order - 1]);\n		if (c->pointers[order - 1] != NULL) {\n			printf("" | "");\n			c = (node *) c->pointers[order - 1];\n		}\n		else\n		break;\n	}\n	printf(""\n"");\n}\n\n/* Utility function to give the height of the tree, which length in number of edges of the path from the root to any leaf. */\nint \nheight( node* root ) \n{\n	int h = 0;\n	node * c = root;\n	while (!c->is_leaf) {\n		c = (node *) c->pointers[0];\n		h++;\n	}\n	return h;\n}\n\n/* Utility function to give the length in edges of the path from any node to the root. */\nint \npath_to_root( node* root, node* child ) \n{\n	int length = 0;\n	node * c = child;\n	while (c != root) {\n		c = c->parent;\n		length++;\n	}\n	return length;\n}\n\n/* Prints the B+ tree in the command line in level (rank) order, with the keys in each node and the '|' symbol to separate nodes. With the verbose_output flag set. the values of the pointers corresponding to the keys also appear next to their respective keys, in hexadecimal notation. */\nvoid \nprint_tree( node* root ) \n{\n\n	node * n = NULL;\n	int i = 0;\n	int rank = 0;\n	int new_rank = 0;\n\n	if (root == NULL) {\n		printf(""Empty tree.\n"");\n		return;\n	}\n	queue = NULL;\n	enqueue(root);\n	while( queue != NULL ) {\n		n = dequeue();\n		if (n->parent != NULL && n == n->parent->pointers[0]) {\n			new_rank = path_to_root( root, n );\n			if (new_rank != rank) {\n				rank = new_rank;\n				printf(""\n"");\n			}\n		}\n		if (verbose_output) \n		printf(""(%x)"", n);\n		for (i = 0; i < n->num_keys; i++) {\n			if (verbose_output)\n			printf(""%x "", n->pointers[i]);\n			printf(""%d "", n->keys[i]);\n		}\n		if (!n->is_leaf)\n		for (i = 0; i <= n->num_keys; i++)\n		enqueue((node *) n->pointers[i]);\n		if (verbose_output) {\n			if (n->is_leaf) \n			printf(""%x "", n->pointers[order - 1]);\n			else\n			printf(""%x "", n->pointers[n->num_keys]);\n		}\n		printf(""| "");\n	}\n	printf(""\n"");\n}\n\n/* Traces the path from the root to a leaf, searching by key.  Displays information about the path if the verbose flag is set. Returns the leaf containing the given key. */\nnode *\nfind_leaf( node* root, int key, bool verbose ) \n{\n\n	int i = 0;\n	node * c = root;\n	if (c == NULL) {\n		if (verbose) \n			printf(""Empty tree.\n"");\n		return c;\n	}\n	while (!c->is_leaf) {\n		if (verbose) {\n			printf(""["");\n			for (i = 0; i < c->num_keys - 1; i++)\n				printf(""%d "", c->keys[i]);\n			printf(""%d] "", c->keys[i]);\n		}\n		i = 0;\n		while (i < c->num_keys) {\n			if (key >= c->keys[i]) \n				i++;\n			else \n				break;\n		}\n		if (verbose)\n			printf(""%d ->\n"", i);\n		c = (node *)c->pointers[i];\n	}\n	if (verbose) {\n		printf(""Leaf ["");\n		for (i = 0; i < c->num_keys - 1; i++)\n			printf(""%d "", c->keys[i]);\n		printf(""%d] ->\n"", c->keys[i]);\n	}\n	return c;\n\n}\n\n/* Finds and returns the record to which a key refers. */\nrecord *\nfind( node* root, int key, bool verbose ) \n{\n\n	int i = 0;\n	node * c = find_leaf( root, key, verbose );\n	if (c == NULL) \n		return NULL;\n	for (i = 0; i < c->num_keys; i++)\n		if (c->keys[i] == key) \n			break;\n	if (i == c->num_keys) \n		return NULL;\n	else\n		return (record *)c->pointers[i];\n\n}\n\n/* Finds the appropriate place to split a node that is too big into two. */\nint \ncut( int length ) \n{\n	if (length % 2 == 0)\n	return length/2;\n	else\n	return length/2 + 1;\n}\n\n//======================================================================================================================================================150\n// INSERTION\n//======================================================================================================================================================150\n\n/* Creates a new record to hold the value to which a key refers. */\nrecord *\nmake_record(int value) \n{\n	record * new_record = (record *)malloc(sizeof(record));\n	if (new_record == NULL) {\n		perror(""Record creation."");\n		exit(EXIT_FAILURE);\n	}\n	else {\n		new_record->value = value;\n	}\n	return new_record;\n}\n\n/* Creates a new general node, which can be adapted to serve as either a leaf or an internal node. */\nnode *\nmake_node( void ) \n{\n	node * new_node;\n	new_node = (node *) malloc(sizeof(node));\n	if (new_node == NULL) {\n		perror(""Node creation."");\n		exit(EXIT_FAILURE);\n	}\n	new_node->keys = (int *) malloc( (order - 1) * sizeof(int) );\n	if (new_node->keys == NULL) {\n		perror(""New node keys array."");\n		exit(EXIT_FAILURE);\n	}\n	new_node->pointers = (void **) malloc( order * sizeof(void *) );\n	if (new_node->pointers == NULL) {\n		perror(""New node pointers array."");\n		exit(EXIT_FAILURE);\n	}\n	new_node->is_leaf = false;\n	new_node->num_keys = 0;\n	new_node->parent = NULL;\n	new_node->next = NULL;\n	return new_node;\n}\n\n/* Creates a new leaf by creating a node and then adapting it appropriately. */\nnode *\nmake_leaf( void ) \n{\n	node* leaf = make_node();\n	leaf->is_leaf = true;\n	return leaf;\n}\n\n/* Helper function used in insert_into_parent to find the index of the parent's pointer to the node to the left of the key to be inserted. */\nint \nget_left_index(node* parent, node* left) \n{\n\n	int left_index = 0;\n	while (left_index <= parent->num_keys && \n	parent->pointers[left_index] != left)\n	left_index++;\n	return left_index;\n}\n\n/* Inserts a new pointer to a record and its corresponding key into a leaf. Returns the altered leaf. */\nnode *\ninsert_into_leaf( node* leaf, int key, record* pointer ) \n{\n\n	int i, insertion_point;\n\n	insertion_point = 0;\n	while (insertion_point < leaf->num_keys && leaf->keys[insertion_point] < key)\n	insertion_point++;\n\n	for (i = leaf->num_keys; i > insertion_point; i--) {\n		leaf->keys[i] = leaf->keys[i - 1];\n		leaf->pointers[i] = leaf->pointers[i - 1];\n	}\n	leaf->keys[insertion_point] = key;\n	leaf->pointers[insertion_point] = pointer;\n	leaf->num_keys++;\n	return leaf;\n}\n\n/* Inserts a new key and pointer to a new record into a leaf so as to exceed the tree's order, causing the leaf to be split in half. */\nnode *\ninsert_into_leaf_after_splitting(	node* root, \n									node* leaf, \n									int key, \n									record* pointer) \n{\n\n	node * new_leaf;\n	int * temp_keys;\n	void ** temp_pointers;\n	int insertion_index, split, new_key, i, j;\n\n	new_leaf = make_leaf();\n\n	temp_keys = (int *) malloc( order * sizeof(int) );\n	if (temp_keys == NULL) {\n		perror(""Temporary keys array."");\n		exit(EXIT_FAILURE);\n	}\n\n	temp_pointers = (void **) malloc( order * sizeof(void *) );\n	if (temp_pointers == NULL) {\n		perror(""Temporary pointers array."");\n		exit(EXIT_FAILURE);\n	}\n\n	insertion_index = 0;\n	while (leaf->keys[insertion_index] < key && insertion_index < order - 1)\n	insertion_index++;\n\n	for (i = 0, j = 0; i < leaf->num_keys; i++, j++) {\n		if (j == insertion_index) j++;\n		temp_keys[j] = leaf->keys[i];\n		temp_pointers[j] = leaf->pointers[i];\n	}\n\n	temp_keys[insertion_index] = key;\n	temp_pointers[insertion_index] = pointer;\n\n	leaf->num_keys = 0;\n\n	split = cut(order - 1);\n\n	for (i = 0; i < split; i++) {\n		leaf->pointers[i] = temp_pointers[i];\n		leaf->keys[i] = temp_keys[i];\n		leaf->num_keys++;\n	}\n\n	for (i = split, j = 0; i < order; i++, j++) {\n		new_leaf->pointers[j] = temp_pointers[i];\n		new_leaf->keys[j] = temp_keys[i];\n		new_leaf->num_keys++;\n	}\n\n	free(temp_pointers);\n	free(temp_keys);\n\n	new_leaf->pointers[order - 1] = leaf->pointers[order - 1];\n	leaf->pointers[order - 1] = new_leaf;\n\n	for (i = leaf->num_keys; i < order - 1; i++)\n	leaf->pointers[i] = NULL;\n	for (i = new_leaf->num_keys; i < order - 1; i++)\n	new_leaf->pointers[i] = NULL;\n\n	new_leaf->parent = leaf->parent;\n	new_key = new_leaf->keys[0];\n\n	return insert_into_parent(root, leaf, new_key, new_leaf);\n}\n\n/* Inserts a new key and pointer to a node into a node into which these can fit without violating the B+ tree properties. */\nnode *\ninsert_into_node(	node* root, \n					node* n, \n					int left_index, \n					int key, \n					node* right) \n{\n\n	int i;\n\n	for (i = n->num_keys; i > left_index; i--) {\n		n->pointers[i + 1] = n->pointers[i];\n		n->keys[i] = n->keys[i - 1];\n	}\n	n->pointers[left_index + 1] = right;\n	n->keys[left_index] = key;\n	n->num_keys++;\n	return root;\n}\n\n/* Inserts a new key and pointer to a node into a node, causing the node's size to exceed the order, and causing the node to split into two. */\nnode *\ninsert_into_node_after_splitting(	node* root, \n									node* old_node, \n									int left_index, \n									int key, \n									node * right) \n{\n\n	int i, j, split, k_prime;\n	node * new_node, * child;\n	int * temp_keys;\n	node ** temp_pointers;\n\n	/* First create a temporary set of keys and pointers\n* to hold everything in order, including\n* the new key and pointer, inserted in their\n* correct places. \n* Then create a new node and copy half of the \n* keys and pointers to the old node and\n* the other half to the new.\n*/\n\n	temp_pointers = (node **) malloc( (order + 1) * sizeof(node *) );\n	if (temp_pointers == NULL) {\n		perror(""Temporary pointers array for splitting nodes."");\n		exit(EXIT_FAILURE);\n	}\n	temp_keys = (int *) malloc( order * sizeof(int) );\n	if (temp_keys == NULL) {\n		perror(""Temporary keys array for splitting nodes."");\n		exit(EXIT_FAILURE);\n	}\n\n	for (i = 0, j = 0; i < old_node->num_keys + 1; i++, j++) {\n		if (j == left_index + 1) j++;\n		temp_pointers[j] = (node *) old_node->pointers[i];\n	}\n\n	for (i = 0, j = 0; i < old_node->num_keys; i++, j++) {\n		if (j == left_index) j++;\n		temp_keys[j] = old_node->keys[i];\n	}\n\n	temp_pointers[left_index + 1] = right;\n	temp_keys[left_index] = key;\n\n	/* Create the new node and copy\n* half the keys and pointers to the\n* old and half to the new.\n*/  \n	split = cut(order);\n	new_node = make_node();\n	old_node->num_keys = 0;\n	for (i = 0; i < split - 1; i++) {\n		old_node->pointers[i] = temp_pointers[i];\n		old_node->keys[i] = temp_keys[i];\n		old_node->num_keys++;\n	}\n	old_node->pointers[i] = temp_pointers[i];\n	k_prime = temp_keys[split - 1];\n	for (++i, j = 0; i < order; i++, j++) {\n		new_node->pointers[j] = temp_pointers[i];\n		new_node->keys[j] = temp_keys[i];\n		new_node->num_keys++;\n	}\n	new_node->pointers[j] = temp_pointers[i];\n	free(temp_pointers);\n	free(temp_keys);\n	new_node->parent = old_node->parent;\n	for (i = 0; i <= new_node->num_keys; i++) {\n		child = (node *) new_node->pointers[i];\n		child->parent = new_node;\n	}\n\n	/* Insert a new key into the parent of the two\n* nodes resulting from the split, with\n* the old node to the left and the new to the right.\n*/\n\n	return insert_into_parent(root, old_node, k_prime, new_node);\n}\n\n/* Inserts a new node (leaf or internal node) into the B+ tree. Returns the root of the tree after insertion. */\nnode *\ninsert_into_parent(	node* root, \n					node* left, \n					int key, \n					node* right) \n{\n\n	int left_index;\n	node * parent;\n\n	parent = left->parent;\n\n	/* Case: new root. */\n\n	if (parent == NULL)\n	return insert_into_new_root(left, key, right);\n\n	/* Case: leaf or node. (Remainder of\n* function body.)  \n*/\n\n	/* Find the parent's pointer to the left \n* node.\n*/\n\n	left_index = get_left_index(parent, left);\n\n\n	/* Simple case: the new key fits into the node. \n*/\n\n	if (parent->num_keys < order - 1)\n	return insert_into_node(root, parent, left_index, key, right);\n\n	/* Harder case:  split a node in order \n* to preserve the B+ tree properties.\n*/\n\n	return insert_into_node_after_splitting(root, parent, left_index, key, right);\n}\n\n/* Creates a new root for two subtrees and inserts the appropriate key into the new root. */\nnode *\ninsert_into_new_root(	node* left, \n						int key, \n						node* right) \n{\n\n	node * root = make_node();\n	root->keys[0] = key;\n	root->pointers[0] = left;\n	root->pointers[1] = right;\n	root->num_keys++;\n	root->parent = NULL;\n	left->parent = root;\n	right->parent = root;\n	return root;\n}\n\n/* First insertion: start a new tree. */\nnode *\nstart_new_tree(	int key, \n				record* pointer) \n{\n\n	node * root = make_leaf();\n	root->keys[0] = key;\n	root->pointers[0] = pointer;\n	root->pointers[order - 1] = NULL;\n	root->parent = NULL;\n	root->num_keys++;\n	return root;\n}\n\n/* Master insertion function. Inserts a key and an associated value into the B+ tree, causing the tree to be adjusted however necessary to maintain the B+ tree properties. */\nnode *\ninsert(	node* root, \n		int key, \n		int value ) \n{\n\n	record* pointer;\n	node* leaf;\n\n	/* The current implementation ignores duplicates. */\n	if (find(root, key, false) != NULL)\n		return root;\n\n	/* Create a new record for the value. */\n	pointer = make_record(value);\n\n	/* Case: the tree does not exist yet. Start a new tree. */\n	if (root == NULL) \n		return start_new_tree(key, pointer);\n\n	/* Case: the tree already exists. (Rest of function body.) */\n	leaf = find_leaf(root, key, false);\n\n	/* Case: leaf has room for key and pointer. */\n	if (leaf->num_keys < order - 1) {\n		leaf = insert_into_leaf(leaf, key, pointer);\n		return root;\n	}\n\n	/* Case:  leaf must be split. */\n	return insert_into_leaf_after_splitting(root, leaf, key, pointer);\n}\n\n//======================================================================================================================================================150\n// DELETION\n//======================================================================================================================================================150\n\n/* Utility function for deletion. Retrieves the index of a node's nearest neighbor (sibling) to the left if one exists.  If not (the node is the leftmost child), returns -1 to signify this special case. */\nint \nget_neighbor_index( node* n ) \n{\n\n	int i;\n\n	/* Return the index of the key to the left\n* of the pointer in the parent pointing\n* to n.  \n* If n is the leftmost child, this means\n* return -1.\n*/\n	for (i = 0; i <= n->parent->num_keys; i++)\n	if (n->parent->pointers[i] == n)\n	return i - 1;\n\n	// Error state.\n	printf(""Search for nonexistent pointer to node in parent.\n"");\n	//printf(""Node:  %#x\n"", (unsigned int)n);\n	exit(EXIT_FAILURE);\n}\n\n/*   */\nnode* \nremove_entry_from_node(	node* n, \n						int key, \n						node * pointer) \n{\n\n	int i, num_pointers;\n\n	// Remove the key and shift other keys accordingly.\n	i = 0;\n	while (n->keys[i] != key)\n	i++;\n	for (++i; i < n->num_keys; i++)\n	n->keys[i - 1] = n->keys[i];\n\n	// Remove the pointer and shift other pointers accordingly.\n	// First determine number of pointers.\n	num_pointers = n->is_leaf ? n->num_keys : n->num_keys + 1;\n	i = 0;\n	while (n->pointers[i] != pointer)\n	i++;\n	for (++i; i < num_pointers; i++)\n	n->pointers[i - 1] = n->pointers[i];\n\n\n	// One key fewer.\n	n->num_keys--;\n\n	// Set the other pointers to NULL for tidiness.\n	// A leaf uses the last pointer to point to the next leaf.\n	if (n->is_leaf)\n	for (i = n->num_keys; i < order - 1; i++)\n	n->pointers[i] = NULL;\n	else\n	for (i = n->num_keys + 1; i < order; i++)\n	n->pointers[i] = NULL;\n\n	return n;\n}\n\n/*   */\nnode* \nadjust_root(node* root) \n{\n\n	node * new_root;\n\n	/* Case: nonempty root.\n* Key and pointer have already been deleted,\n* so nothing to be done.\n*/\n\n	if (root->num_keys > 0)\n	return root;\n\n	/* Case: empty root. \n*/\n\n	// If it has a child, promote \n	// the first (only) child\n	// as the new root.\n\n	if (!root->is_leaf) {\n		new_root = (node *) root->pointers[0];\n		new_root->parent = NULL;\n	}\n\n	// If it is a leaf (has no children),\n	// then the whole tree is empty.\n\n	else\n	new_root = NULL;\n\n	free(root->keys);\n	free(root->pointers);\n	free(root);\n\n	return new_root;\n}\n\n/* Coalesces a node that has become too small after deletion with a neighboring node that can accept the additional entries without exceeding the maximum. */\nnode* \ncoalesce_nodes(	node* root, \n				node* n, \n				node* neighbor, \n				int neighbor_index, \n				int k_prime) \n				{\n\n	int i, j, neighbor_insertion_index, n_start, n_end, new_k_prime;\n	node * tmp;\n	bool split;\n\n	/* Swap neighbor with node if node is on the\n* extreme left and neighbor is to its right.\n*/\n\n	if (neighbor_index == -1) {\n		tmp = n;\n		n = neighbor;\n		neighbor = tmp;\n	}\n\n	/* Starting point in the neighbor for copying\n* keys and pointers from n.\n* Recall that n and neighbor have swapped places\n* in the special case of n being a leftmost child.\n*/\n\n	neighbor_insertion_index = neighbor->num_keys;\n	\n	/*\n* Nonleaf nodes may sometimes need to remain split,\n* if the insertion of k_prime would cause the resulting\n* single coalesced node to exceed the limit order - 1.\n* The variable split is always false for leaf nodes\n* and only sometimes set to true for nonleaf nodes.\n*/\n\n	split = false;\n\n	/* Case:  nonleaf node.\n* Append k_prime and the following pointer.\n* If there is room in the neighbor, append\n* all pointers and keys from the neighbor.\n* Otherwise, append only cut(order) - 2 keys and\n* cut(order) - 1 pointers.\n*/\n\n	if (!n->is_leaf) {\n\n		/* Append k_prime.\n	*/\n\n		neighbor->keys[neighbor_insertion_index] = k_prime;\n		neighbor->num_keys++;\n\n\n		/* Case (default):  there is room for all of n's keys and pointers\n	* in the neighbor after appending k_prime.\n	*/\n\n		n_end = n->num_keys;\n\n		/* Case (special): k cannot fit with all the other keys and pointers\n	* into one coalesced node.\n	*/\n		n_start = 0; // Only used in this special case.\n		if (n->num_keys + neighbor->num_keys >= order) {\n			split = true;\n			n_end = cut(order) - 2;\n		}\n\n		for (i = neighbor_insertion_index + 1, j = 0; j < n_end; i++, j++) {\n			neighbor->keys[i] = n->keys[j];\n			neighbor->pointers[i] = n->pointers[j];\n			neighbor->num_keys++;\n			n->num_keys--;\n			n_start++;\n		}\n\n		/* The number of pointers is always\n	* one more than the number of keys.\n	*/\n\n		neighbor->pointers[i] = n->pointers[j];\n\n		/* If the nodes are still split, remove the first key from\n	* n.\n	*/\n		if (split) {\n			new_k_prime = n->keys[n_start];\n			for (i = 0, j = n_start + 1; i < n->num_keys; i++, j++) {\n				n->keys[i] = n->keys[j];\n				n->pointers[i] = n->pointers[j];\n			}\n			n->pointers[i] = n->pointers[j];\n			n->num_keys--;\n		}\n\n		/* All children must now point up to the same parent.\n	*/\n\n		for (i = 0; i < neighbor->num_keys + 1; i++) {\n			tmp = (node *)neighbor->pointers[i];\n			tmp->parent = neighbor;\n		}\n	}\n\n	/* In a leaf, append the keys and pointers of\n* n to the neighbor.\n* Set the neighbor's last pointer to point to\n* what had been n's right neighbor.\n*/\n\n	else {\n		for (i = neighbor_insertion_index, j = 0; j < n->num_keys; i++, j++) {\n			neighbor->keys[i] = n->keys[j];\n			neighbor->pointers[i] = n->pointers[j];\n			neighbor->num_keys++;\n		}\n		neighbor->pointers[order - 1] = n->pointers[order - 1];\n	}\n\n	if (!split) {\n		root = delete_entry(root, n->parent, k_prime, n);\n		free(n->keys);\n		free(n->pointers);\n		free(n); \n	}\n	else\n	for (i = 0; i < n->parent->num_keys; i++)\n	if (n->parent->pointers[i + 1] == n) {\n		n->parent->keys[i] = new_k_prime;\n		break;\n	}\n\n	return root;\n\n}\n\n/* Redistributes entries between two nodes when one has become too small after deletion but its neighbor is too big to append the small node's entries without exceeding the maximum */\nnode* \nredistribute_nodes(	node* root, \n					node* n, \n					node* neighbor, \n					int neighbor_index, \n					int k_prime_index, \n					int k_prime) \n{  \n\n	int i;\n	node * tmp;\n\n	/* Case: n has a neighbor to the left. \n* Pull the neighbor's last key-pointer pair over\n* from the neighbor's right end to n's left end.\n*/\n\n	if (neighbor_index != -1) {\n		if (!n->is_leaf)\n		n->pointers[n->num_keys + 1] = n->pointers[n->num_keys];\n		for (i = n->num_keys; i > 0; i--) {\n			n->keys[i] = n->keys[i - 1];\n			n->pointers[i] = n->pointers[i - 1];\n		}\n		if (!n->is_leaf) {\n			n->pointers[0] = neighbor->pointers[neighbor->num_keys];\n			tmp = (node *)n->pointers[0];\n			tmp->parent = n;\n			neighbor->pointers[neighbor->num_keys] = NULL;\n			n->keys[0] = k_prime;\n			n->parent->keys[k_prime_index] = neighbor->keys[neighbor->num_keys - 1];\n		}\n		else {\n			n->pointers[0] = neighbor->pointers[neighbor->num_keys - 1];\n			neighbor->pointers[neighbor->num_keys - 1] = NULL;\n			n->keys[0] = neighbor->keys[neighbor->num_keys - 1];\n			n->parent->keys[k_prime_index] = n->keys[0];\n		}\n	}\n\n	/* Case: n is the leftmost child.\n* Take a key-pointer pair from the neighbor to the right.\n* Move the neighbor's leftmost key-pointer pair\n* to n's rightmost position.\n*/\n\n	else {  \n		if (n->is_leaf) {\n			n->keys[n->num_keys] = neighbor->keys[0];\n			n->pointers[n->num_keys] = neighbor->pointers[0];\n			n->parent->keys[k_prime_index] = neighbor->keys[1];\n		}\n		else {\n			n->keys[n->num_keys] = k_prime;\n			n->pointers[n->num_keys + 1] = neighbor->pointers[0];\n			tmp = (node *)n->pointers[n->num_keys + 1];\n			tmp->parent = n;\n			n->parent->keys[k_prime_index] = neighbor->keys[0];\n		}\n		for (i = 0; i < neighbor->num_keys; i++) {\n			neighbor->keys[i] = neighbor->keys[i + 1];\n			neighbor->pointers[i] = neighbor->pointers[i + 1];\n		}\n		if (!n->is_leaf)\n		neighbor->pointers[i] = neighbor->pointers[i + 1];\n	}\n\n	/* n now has one more key and one more pointer;\n* the neighbor has one fewer of each.\n*/\n\n	n->num_keys++;\n	neighbor->num_keys--;\n\n	return root;\n}\n\n/* Deletes an entry from the B+ tree. Removes the record and its key and pointer from the leaf, and then makes all appropriate changes to preserve the B+ tree properties. */\nnode* \ndelete_entry(	node* root, \n				node* n, \n				int key, \n				void* pointer ) \n{\n\n	int min_keys;\n	node * neighbor;\n	int neighbor_index;\n	int k_prime_index, k_prime;\n	int capacity;\n\n	// Remove key and pointer from node.\n\n	n = remove_entry_from_node(n, key, (node *) pointer);\n\n	/* Case:  deletion from the root. \n*/\n\n	if (n == root) \n	return adjust_root(root);\n\n\n	/* Case:  deletion from a node below the root.\n* (Rest of function body.)\n*/\n\n	/* Determine minimum allowable size of node,\n* to be preserved after deletion.\n*/\n\n	min_keys = n->is_leaf ? cut(order - 1) : cut(order) - 1;\n\n	/* Case:  node stays at or above minimum.\n* (The simple case.)\n*/\n\n	if (n->num_keys >= min_keys)\n	return root;\n\n	/* Case:  node falls below minimum.\n* Either coalescence or redistribution\n* is needed.\n*/\n\n	/* Find the appropriate neighbor node with which\n* to coalesce.\n* Also find the key (k_prime) in the parent\n* between the pointer to node n and the pointer\n* to the neighbor.\n*/\n\n	neighbor_index = get_neighbor_index( n );\n	k_prime_index = neighbor_index == -1 ? 0 : neighbor_index;\n	k_prime = n->parent->keys[k_prime_index];\n	neighbor = neighbor_index == -1 ? (node *) n->parent->pointers[1] : \n	(node *)n->parent->pointers[neighbor_index];\n\n	capacity = n->is_leaf ? order : order - 1;\n\n	/* Coalescence. */\n\n	if (neighbor->num_keys + n->num_keys < capacity)\n	return coalesce_nodes(root, n, neighbor, neighbor_index, k_prime);\n\n	/* Redistribution. */\n\n	else\n	return redistribute_nodes(root, n, neighbor, neighbor_index, k_prime_index, k_prime);\n}\n\n/* Master deletion function. */\nnode* \ndeleteVal(	node* root, \n			int key) \n{\n\n	node * key_leaf;\n	record * key_record;\n\n	key_record = find(root, key, false);\n	key_leaf = find_leaf(root, key, false);\n	if (key_record != NULL && key_leaf != NULL) {\n		free(key_record);\n		root = delete_entry(root, key_leaf, key, key_record);\n	}\n	return root;\n}\n\n/*   */\nvoid \ndestroy_tree_nodes(node* root) \n{\n	int i;\n	if (root->is_leaf)\n	for (i = 0; i < root->num_keys; i++)\n	free(root->pointers[i]);\n	else\n	for (i = 0; i < root->num_keys + 1; i++)\n	destroy_tree_nodes((node *) root->pointers[i]);\n	free(root->pointers);\n	free(root->keys);\n	free(root);\n}\n\n/*   */\nnode* \ndestroy_tree(node* root) \n{\n	destroy_tree_nodes(root);\n	return NULL;\n}\n\n//======================================================================================================================================================150\n//	END\n//======================================================================================================================================================150\n\n//========================================================================================================================================================================================================200\n//	MAIN FUNCTION\n//========================================================================================================================================================================================================200\n\nint \nmain(	int argc, \n		char** argv ) \n{\n	// assing default values\n	int cur_arg;\n	int cores_arg =1;\n	char *input_file = NULL;\n	char *command_file = NULL;\n	char *output=""output.txt"";\n	FILE * pFile;\n\n\n	// go through arguments\n	for(cur_arg=1; cur_arg<argc; cur_arg++){\n	  if(strcmp(argv[cur_arg], ""cores"")==0){\n	    // check if value provided\n	    if(argc>=cur_arg+1){\n	      // check if value is a number\n	      if(isInteger(argv[cur_arg+1])==1){\n		cores_arg = atoi(argv[cur_arg+1]);\n		if(cores_arg<0){\n		  printf(""ERROR: Wrong value to cores parameter, cannot be <=0\n"");\n		  return -1;\n		}\n		cur_arg = cur_arg+1;\n	      }\n	      // value is not a number\n	      else{\n		printf(""ERROR: Value to cores parameter in not a number\n"");\n		return 0;\n	      }\n	    }\n	  }\n	  // check if -file\n	  else if(strcmp(argv[cur_arg], ""file"")==0){\n	    // check if value provided\n	    if(argc>=cur_arg+1){\n	      input_file = argv[cur_arg+1];\n	      cur_arg = cur_arg+1;\n	      // value is not a number\n	    }\n	    // value not provided\n	    else{\n	      printf(""ERROR: Missing value to -file parameter\n"");\n	      return -1;\n	    }\n	  }\n	  else if(strcmp(argv[cur_arg], ""command"")==0){\n	    // check if value provided\n	    if(argc>=cur_arg+1){\n	      command_file = argv[cur_arg+1];\n	      cur_arg = cur_arg+1;\n	      // value is not a number\n	    }\n	    // value not provided\n	    else{\n	      printf(""ERROR: Missing value to command parameter\n"");\n	      return -1;\n	    }\n	  }\n	}\n	// Print configuration\n	  if((input_file==NULL)||(command_file==NULL))\n	    printf(""Usage: ./b+tree file input_file command command_list\n"");\n\n	  // For debug\n	  printf(""Input File: %s \n"", input_file);\n	  printf(""Command File: %s \n"", command_file);\n\n     FILE * commandFile;\n     long lSize;\n     char * commandBuffer;\n     size_t result;\n\n     commandFile = fopen ( command_file, ""rb"" );\n     if (commandFile==NULL) {fputs (""Command File error"",stderr); exit (1);}\n     \n     // obtain file size:\n     fseek (commandFile , 0 , SEEK_END);\n     lSize = ftell (commandFile);\n     rewind (commandFile);\n\n     // allocate memory to contain the whole file:\n     commandBuffer = (char*) malloc (sizeof(char)*lSize);\n     if (commandBuffer == NULL) {fputs (""Command Buffer memory error"",stderr); exit (2);}\n     \n     // copy the file into the buffer:\n     result = fread (commandBuffer,1,lSize,commandFile);\n     if (result != lSize) {fputs (""Command file reading error"",stderr); exit (3);}\n\n     /* the whole file is now loaded in the memory buffer. */\n\n  // terminate\n     fclose (commandFile);\n\n     // For Debug\n     char *sPointer=commandBuffer;\n     printf(""Command Buffer: \n"");\n     printf(""%s"",commandBuffer);\n     //\n\n\n     pFile = fopen (output,""w+"");\n     if (pFile==NULL) \n       fputs (""Fail to open %s !\n"",output);\n     fprintf(pFile,""******starting******\n"");\n     fclose(pFile);\n\n\n	// ------------------------------------------------------------60\n	// general variables\n	// ------------------------------------------------------------60\n\n	FILE *file_pointer;\n	node *root;\n	root = NULL;\n	record *r;\n	int input;\n	char instruction;\n	order = DEFAULT_ORDER;\n	verbose_output = false;\n\n	//usage_1();  \n	//usage_2();\n\n	// ------------------------------------------------------------60\n	// get input from file, if file provided\n	// ------------------------------------------------------------60\n\n	if (input_file != NULL) {\n\n		printf(""Getting input from file %s...\n"", argv[1]);\n\n		// open input file\n		file_pointer = fopen(input_file, ""r"");\n		if (file_pointer == NULL) {\n			perror(""Failure to open input file."");\n			exit(EXIT_FAILURE);\n		}\n\n		// get # of numbers in the file\n		fscanf(file_pointer, ""%d\n"", &input);\n		size = input;\n\n		// save all numbers\n		while (!feof(file_pointer)) {\n			fscanf(file_pointer, ""%d\n"", &input);\n			root = insert(root, input, input);\n		}\n\n		// close file\n		fclose(file_pointer);\n		//print_tree(root);\n		//printf(""Height of tree = %d\n"", height(root));\n\n	}\n	else{\n		printf(""ERROR: Argument -file missing\n"");\n		return 0;\n	}\n\n	// ------------------------------------------------------------60\n	// get tree statistics\n	// ------------------------------------------------------------60\n\n	printf(""Transforming data to a GPU suitable structure...\n"");\n	long mem_used = transform_to_cuda(root,0);\n	maxheight = height(root);\n	long rootLoc = (long)knodes - (long)mem;\n\n	// ------------------------------------------------------------60\n	// process commands\n	// ------------------------------------------------------------60\n	char *commandPointer=commandBuffer;\n\n	printf(""Waiting for command\n"");\n	printf(""> "");\n	while (sscanf(commandPointer, ""%c"", &instruction) != EOF) {\n	  commandPointer++;\n		switch (instruction) {\n			// ----------------------------------------40\n			// Insert\n			// ----------------------------------------40\n\n			case 'i':\n			{\n				scanf(""%d"", &input);\n				while (getchar() != (int)'\n');\n				root = insert(root, input, input);\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// n/a\n			// ----------------------------------------40\n\n			case 'f':\n			{\n			}\n\n			// ----------------------------------------40\n			// find\n			// ----------------------------------------40\n\n			case 'p':\n			{\n				scanf(""%d"", &input);\n				while (getchar() != (int)'\n');\n				r = find(root, input, instruction == 'p');\n				if (r == NULL)\n				printf(""Record not found under key %d.\n"", input);\n				else \n				printf(""Record found: %d\n"",r->value);\n				break;\n			}\n\n			// ----------------------------------------40\n			// delete value\n			// ----------------------------------------40\n\n			case 'd':\n			{\n				scanf(""%d"", &input);\n				while (getchar() != (int)'\n');\n				root = (node *) deleteVal(root, input);\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// destroy tree\n			// ----------------------------------------40\n\n			case 'x':\n			{\n				while (getchar() != (int)'\n');\n				root = destroy_tree(root);\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// print leaves\n			// ----------------------------------------40\n\n			case 'l':\n			{\n				while (getchar() != (int)'\n');\n				print_leaves(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// print tree\n			// ----------------------------------------40\n\n			case 't':\n			{\n				while (getchar() != (int)'\n');\n				print_tree(root);\n				break;\n			}\n\n			// ----------------------------------------40\n			// toggle verbose output\n			// ----------------------------------------40\n\n			case 'v':\n			{\n				while (getchar() != (int)'\n');\n				verbose_output = !verbose_output;\n				break;\n			}\n\n			// ----------------------------------------40\n			// quit\n			// ----------------------------------------40\n\n			case 'q':\n			{\n				while (getchar() != (int)'\n');\n				return EXIT_SUCCESS;\n			}\n\n			// ----------------------------------------40\n			// [OpenMP] find K (initK, findK)\n			// ----------------------------------------40\n\n			case 'k':\n			{\n\n				// get # of queries from user\n				int count;\n				sscanf(commandPointer, ""%d"", &count);\n				while(*commandPointer!=32 && commandPointer!='\n')\n				  commandPointer++;\n\n				printf(""\n ******command: k count=%d \n"",count);\n\n				if(count > 65535){\n					printf(""ERROR: Number of requested querries should be 65,535 at most. (limited by # of CUDA blocks)\n"");\n					exit(0);\n				}\n\n				// INPUT: records CPU allocation (setting pointer in mem variable)\n				record *records = (record *)mem;\n				long records_elem = (long)rootLoc / sizeof(record);\n				long records_mem = (long)rootLoc;\n				// printf(""records_elem=%d, records_unit_mem=%d, records_mem=%d\n"", (int)records_elem, sizeof(record), (int)records_mem);\n\n				// INPUT: knodes CPU allocation (setting pointer in mem variable)\n				knode *knodes = (knode *)((long)mem + (long)rootLoc);\n				long knodes_elem = ((long)(mem_used) - (long)rootLoc) / sizeof(knode);\n				long knodes_mem = (long)(mem_used) - (long)rootLoc;\n				// printf(""knodes_elem=%d, knodes_unit_mem=%d, knodes_mem=%d\n"", (int)knodes_elem, sizeof(knode), (int)knodes_mem);\n\n				// INPUT: currKnode CPU allocation\n				long *currKnode;\n				currKnode = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset(currKnode, 0, count*sizeof(long));\n\n				// INPUT: offset CPU allocation\n				long *offset;\n				offset = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset(offset, 0, count*sizeof(long));\n\n				// INPUT: keys CPU allocation\n				int *keys;\n				keys = (int *)malloc(count*sizeof(int));\n				// INPUT: keys CPU initialization\n				int i;\n				for(i = 0; i < count; i++){\n					keys[i] = (rand()/(float)RAND_MAX)*size;\n				}\n\n				// OUTPUT: ans CPU allocation\n				record *ans = (record *)malloc(sizeof(record)*count);\n				// OUTPUT: ans CPU initialization\n				for(i = 0; i < count; i++){\n					ans[i].value = -1;\n				}\n\n				// New OpenMP kernel, same algorighm across all versions(OpenMP, CUDA, OpenCL) for comparison purposes\n				kernel_cpu(	cores_arg,\n\n							records,\n							knodes,\n							knodes_elem,\n\n							order,\n							maxheight,\n							count,\n\n							currKnode,\n							offset,\n							keys,\n							ans);\n\n				// Original OpenMP kernel, different algorithm\n				// int j;\n				// for(j = 0; j < count; j++){\n					// find(	root,				// node *\n\n							// keys[j],			// int\n							// false);				// bool\n				// }\n\n\n				pFile = fopen (output,""aw+"");\n				if (pFile==NULL)\n				  {\n				    fputs (""Fail to open %s !\n"",output);\n				  }\n				\n				fprintf(pFile,""\n ******command: k count=%d \n"",count);\n				for(i = 0; i < count; i++){\n				  fprintf(pFile, ""%d    %d\n"",i, ans[i].value);\n				}\n				fprintf(pFile, "" \n"");\n                                fclose(pFile);\n\n				// free memory\n				free(currKnode);\n				free(offset);\n				free(keys);\n				free(ans);\n\n				// break out of case\n				break;\n\n			}\n\n			// ----------------------------------------40\n			// find range\n			// ----------------------------------------40\n\n			case 'r':\n			{\n				int start, end;\n				scanf(""%d"", &start);\n				scanf(""%d"", &end);\n				if(start > end){\n					input = start;\n					start = end;\n					end = input;\n				}\n				printf(""For range %d to %d, "",start,end);\n				list_t * ansList;\n				ansList = findRange(root, start, end);\n				printf(""%d records found\n"", list_get_length(ansList));\n				//list_iterator_t iter;\n				free(ansList);\n				break;\n			}\n\n			// ----------------------------------------40\n			// [OpenMP] find Range K (initK, findRangeK)\n			// ----------------------------------------40\n\n			case 'j':\n			{\n\n				// get # of queries from user\n				int count;\n				sscanf(commandPointer, ""%d"", &count);\n				while(*commandPointer!=32 && commandPointer!='\n')\n				  commandPointer++;\n\n				int rSize;\n				sscanf(commandPointer, ""%d"", &rSize);\n				while(*commandPointer!=32 && commandPointer!='\n')\n				  commandPointer++;\n\n				printf(""\n******command: j count=%d, rSize=%d \n"",count, rSize);\n\n				if(rSize > size || rSize < 0) {\n					printf(""Search range size is larger than data set size %d.\n"", (int)size);\n					exit(0);\n				}\n\n				// INPUT: knodes CPU allocation (setting pointer in mem variable)\n				knode *knodes = (knode *)((long)mem + (long)rootLoc);\n				long knodes_elem = ((long)(mem_used) - (long)rootLoc) / sizeof(knode);\n				long knodes_mem = (long)(mem_used) - (long)rootLoc;\n				// printf(""knodes_elem=%d, knodes_unit_mem=%d, knodes_mem=%d\n"", (int)knodes_elem, sizeof(knode), (int)knodes_mem);\n\n				// INPUT: currKnode CPU allocation\n				long *currKnode;\n				currKnode = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (currKnode, 0, count*sizeof(long));\n\n				// INPUT: offset CPU allocation\n				long *offset;\n				offset = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (offset, 0, count*sizeof(long));\n\n				// INPUT: lastKnode CPU allocation\n				long *lastKnode;\n				lastKnode = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (lastKnode, 0, count*sizeof(long));\n\n				// INPUT: offset_2 CPU allocation\n				long *offset_2;\n				offset_2 = (long *)malloc(count*sizeof(long));\n				// INPUT: offset CPU initialization\n				memset (offset_2, 0, count*sizeof(long));\n\n				// INPUT: start, end CPU allocation\n				int *start;\n				start = (int *)malloc(count*sizeof(int));\n				int *end;\n				end = (int *)malloc(count*sizeof(int));\n				// INPUT: start, end CPU initialization\n				int i;\n				for(i = 0; i < count; i++){\n					start[i] = (rand()/(float)RAND_MAX)*size;\n					end[i] = start[i]+rSize;\n					if(end[i] >= size){ \n						start[i] = start[i] - (end[i] - size);\n						end[i]= size-1;\n					}\n				}\n\n				// INPUT: recstart, reclenght CPU allocation\n				int *recstart;\n				recstart = (int *)malloc(count*sizeof(int));\n				int *reclength;\n				reclength = (int *)malloc(count*sizeof(int));\n				// OUTPUT: ans CPU initialization\n				for(i = 0; i < count; i++){\n					recstart[i] = 0;\n					reclength[i] = 0;\n				}\n\n				// New kernel, same algorighm across all versions(OpenMP, CUDA, OpenCL) for comparison purposes\n				kernel_cpu_2(	cores_arg,\n\n								knodes,\n								knodes_elem,\n\n								order,\n								maxheight,\n								count,\n\n								currKnode,\n								offset,\n								lastKnode,\n								offset_2,\n								start,\n								end,\n								recstart,\n								reclength);\n\n				// Original [CPU] kernel, different algorithm\n				// int k;\n				// for(k = 0; k < count; k++){\n					// findRange(	root,\n\n								// start[k], \n								// end[k]);\n				// }\n				pFile = fopen (output,""aw+"");\n				if (pFile==NULL)\n				  {\n				    fputs (""Fail to open %s !\n"",output);\n				  }\n\n				fprintf(pFile,""\n******command: j count=%d, rSize=%d \n"",count, rSize);				\n				for(i = 0; i < count; i++){\n				  fprintf(pFile, ""%d    %d    %d\n"",i, recstart[i],reclength[i]);\n				}\n				fprintf(pFile, "" \n"");\n                                fclose(pFile);\n\n				// free memory\n				free(currKnode);\n				free(offset);\n				free(lastKnode);\n				free(offset_2);\n				free(start);\n				free(end);\n				free(recstart);\n				free(reclength);\n\n				// break out of case\n				break;\n\n			}\n\n			// ----------------------------------------40\n			// default\n			// ----------------------------------------40\n\n			default:\n			{\n\n				//usage_2();\n				break;\n\n			}\n\n		}\n		printf(""> "");\n\n	}\n	printf(""\n"");\n\n	// ------------------------------------------------------------60\n	// free remaining memory and exit\n	// ------------------------------------------------------------60\n\n	free(mem);\n	return EXIT_SUCCESS;\n\n}\n\n//========================================================================================================================================================================================================200\n//	END\n//========================================================================================================================================================================================================200\n\n// # ifdef __cplusplus\n// }\n// # endif\n"
b+tree/kernel/kernel_cpu_2.c,"// #ifdef __cplusplus\n// extern ""C"" {\n// #endif\n\n//========================================================================================================================================================================================================200\n//	DEFINE/INCLUDE\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	LIBRARIES\n//======================================================================================================================================================150\n\n#include <omp.h>									// (in directory known to compiler)\n#include <stdlib.h>									// (in directory known to compiler)\n\n//======================================================================================================================================================150\n//	COMMON\n//======================================================================================================================================================150\n\n#include ""../common.h""								// (in directory provided here)\n\n//======================================================================================================================================================150\n//	UTILITIES\n//======================================================================================================================================================150\n\n#include ""../util/timer/timer.h""					// (in directory provided here)	needed by timer\n\n//======================================================================================================================================================150\n//	HEADER\n//======================================================================================================================================================150\n\n#include ""./kernel_cpu_2.h""							// (in directory provided here)\n\n//========================================================================================================================================================================================================200\n//	PLASMAKERNEL_GPU\n//========================================================================================================================================================================================================200\n\nvoid \nkernel_cpu_2(	int cores_arg,\n\n				knode *knodes,\n				long knodes_elem,\n\n				int order,\n				long maxheight,\n				int count,\n\n				long *currKnode,\n				long *offset,\n				long *lastKnode,\n				long *offset_2,\n				int *start,\n				int *end,\n				int *recstart,\n				int *reclength)\n{\n\n	//======================================================================================================================================================150\n	//	Variables\n	//======================================================================================================================================================150\n\n	// timer\n	long long time0;\n	long long time1;\n	long long time2;\n\n	// common variables\n	int i;\n\n	time0 = get_time();\n\n	//======================================================================================================================================================150\n	//	MCPU SETUP\n	//======================================================================================================================================================150\n\n	int max_nthreads;\n	max_nthreads = omp_get_max_threads();\n	// printf(""max # of threads = %d\n"", max_nthreads);\n	omp_set_num_threads(cores_arg);\n	// printf(""set # of threads = %d\n"", cores_arg);\n\n	int threadsPerBlock;\n	threadsPerBlock = order < 1024 ? order : 1024;\n\n	time1 = get_time();\n\n	//======================================================================================================================================================150\n	//	PROCESS INTERACTIONS\n	//======================================================================================================================================================150\n\n	// private thread IDs\n	int thid;\n	int bid;\n\n	// process number of querries\n	#pragma omp parallel for private (i, thid)\n	for(bid = 0; bid < count; bid++){\n\n		// process levels of the tree\n		for(i = 0; i < maxheight; i++){\n\n			// process all leaves at each level\n			for(thid = 0; thid < threadsPerBlock; thid++){\n\n				if((knodes[currKnode[bid]].keys[thid] <= start[bid]) && (knodes[currKnode[bid]].keys[thid+1] > start[bid])){\n					// this conditional statement is inserted to avoid crush due to but in original code\n					// ""offset[bid]"" calculated below that later addresses part of knodes goes outside of its bounds cause segmentation fault\n					// more specifically, values saved into knodes->indices in the main function are out of bounds of knodes that they address\n					if(knodes[currKnode[bid]].indices[thid] < knodes_elem){\n						offset[bid] = knodes[currKnode[bid]].indices[thid];\n					}\n				}\n				if((knodes[lastKnode[bid]].keys[thid] <= end[bid]) && (knodes[lastKnode[bid]].keys[thid+1] > end[bid])){\n					// this conditional statement is inserted to avoid crush due to but in original code\n					// ""offset_2[bid]"" calculated below that later addresses part of knodes goes outside of its bounds cause segmentation fault\n					// more specifically, values saved into knodes->indices in the main function are out of bounds of knodes that they address\n					if(knodes[lastKnode[bid]].indices[thid] < knodes_elem){\n						offset_2[bid] = knodes[lastKnode[bid]].indices[thid];\n					}\n				}\n\n			}\n\n			// set for next tree level\n			currKnode[bid] = offset[bid];\n			lastKnode[bid] = offset_2[bid];\n\n		}\n\n		// process leaves\n		for(thid = 0; thid < threadsPerBlock; thid++){\n\n			// Find the index of the starting record\n			if(knodes[currKnode[bid]].keys[thid] == start[bid]){\n				recstart[bid] = knodes[currKnode[bid]].indices[thid];\n			}\n\n		}\n\n		// process leaves\n		for(thid = 0; thid < threadsPerBlock; thid++){\n\n			// Find the index of the ending record\n			if(knodes[lastKnode[bid]].keys[thid] == end[bid]){\n				reclength[bid] = knodes[lastKnode[bid]].indices[thid] - recstart[bid]+1;\n			}\n\n		}\n\n	}\n\n	time2 = get_time();\n\n	//======================================================================================================================================================150\n	//	DISPLAY TIMING\n	//======================================================================================================================================================150\n\n	printf(""Time spent in different stages of CPU/MCPU KERNEL:\n"");\n\n	printf(""%15.12f s, %15.12f % : MCPU: SET DEVICE\n"",					(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time2-time0) * 100);\n	printf(""%15.12f s, %15.12f % : CPU/MCPU: KERNEL\n"",					(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time2-time0) * 100);\n\n	printf(""Total time:\n"");\n	printf(""%.12f s\n"", 												(float) (time2-time0) / 1000000);\n\n} // main\n\n//========================================================================================================================================================================================================200\n//	END\n//========================================================================================================================================================================================================200\n\n// #ifdef __cplusplus\n// }\n// #endif\n"
b+tree/kernel/kernel_cpu.c,"// #ifdef __cplusplus\n// extern ""C"" {\n// #endif\n\n//========================================================================================================================================================================================================200\n//	DEFINE/INCLUDE\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	LIBRARIES\n//======================================================================================================================================================150\n\n#include <omp.h>									// (in directory known to compiler)			needed by openmp\n#include <stdlib.h>									// (in directory known to compiler)			needed by malloc\n#include <stdio.h>									// (in directory known to compiler)			needed by printf, stderr\n\n//======================================================================================================================================================150\n//	COMMON\n//======================================================================================================================================================150\n\n#include ""../common.h""								// (in directory provided here)\n\n//======================================================================================================================================================150\n//	UTILITIES\n//======================================================================================================================================================150\n\n#include ""../util/timer/timer.h""					// (in directory provided here)\n\n//========================================================================================================================================================================================================200\n//	KERNEL_CPU FUNCTION\n//========================================================================================================================================================================================================200\n\nvoid \nkernel_cpu(	int cores_arg,\n\n			record *records,\n			knode *knodes,\n			long knodes_elem,\n\n			int order,\n			long maxheight,\n			int count,\n\n			long *currKnode,\n			long *offset,\n			int *keys,\n			record *ans)\n{\n\n	//======================================================================================================================================================150\n	//	Variables\n	//======================================================================================================================================================150\n\n	// timer\n	long long time0;\n	long long time1;\n	long long time2;\n\n	time0 = get_time();\n\n	//======================================================================================================================================================150\n	//	MCPU SETUP\n	//======================================================================================================================================================150\n\n	int max_nthreads;\n	max_nthreads = omp_get_max_threads();\n	// printf(""max # of threads = %d\n"", max_nthreads);\n	omp_set_num_threads(cores_arg);\n	// printf(""set # of threads = %d\n"", cores_arg);\n\n	int threadsPerBlock;\n	threadsPerBlock = order < 1024 ? order : 1024;\n\n	time1 = get_time();\n\n	//======================================================================================================================================================150\n	//	PROCESS INTERACTIONS\n	//======================================================================================================================================================150\n\n	// private thread IDs\n	int thid;\n	int bid;\n	int i;\n\n	// process number of querries\n	#pragma omp parallel for private (i, thid)\n	for(bid = 0; bid < count; bid++){\n\n		// process levels of the tree\n		for(i = 0; i < maxheight; i++){\n\n			// process all leaves at each level\n			for(thid = 0; thid < threadsPerBlock; thid++){\n\n				// if value is between the two keys\n				if((knodes[currKnode[bid]].keys[thid]) <= keys[bid] && (knodes[currKnode[bid]].keys[thid+1] > keys[bid])){\n					// this conditional statement is inserted to avoid crush due to but in original code\n					// ""offset[bid]"" calculated below that addresses knodes[] in the next iteration goes outside of its bounds cause segmentation fault\n					// more specifically, values saved into knodes->indices in the main function are out of bounds of knodes that they address\n					if(knodes[offset[bid]].indices[thid] < knodes_elem){\n						offset[bid] = knodes[offset[bid]].indices[thid];\n					}\n				}\n\n			}\n\n			// set for next tree level\n			currKnode[bid] = offset[bid];\n\n		}\n\n		//At this point, we have a candidate leaf node which may contain\n		//the target record.  Check each key to hopefully find the record\n		// process all leaves at each level\n		for(thid = 0; thid < threadsPerBlock; thid++){\n\n			if(knodes[currKnode[bid]].keys[thid] == keys[bid]){\n				ans[bid].value = records[knodes[currKnode[bid]].indices[thid]].value;\n			}\n\n		}\n\n	}\n\n	time2 = get_time();\n\n	//======================================================================================================================================================150\n	//	DISPLAY TIMING\n	//======================================================================================================================================================150\n\n	printf(""Time spent in different stages of CPU/MCPU KERNEL:\n"");\n\n	printf(""%15.12f s, %15.12f % : MCPU: SET DEVICE\n"",					(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time2-time0) * 100);\n	printf(""%15.12f s, %15.12f % : CPU/MCPU: KERNEL\n"",					(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time2-time0) * 100);\n\n	printf(""Total time:\n"");\n	printf(""%.12f s\n"", 												(float) (time2-time0) / 1000000);\n\n}\n\n//========================================================================================================================================================================================================200\n//	END\n//========================================================================================================================================================================================================200\n\n// #ifdef __cplusplus\n// }\n// #endif\n\n"
b+tree/util/timer/timer.c,"#ifdef __cplusplus\nextern ""C"" {\n#endif\n\n//===============================================================================================================================================================================================================200\n//	TIMER CODE\n//===============================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	INCLUDE/DEFINE\n//======================================================================================================================================================150\n\n#include <stdlib.h>\n\n//======================================================================================================================================================150\n//	FUNCTIONS\n//======================================================================================================================================================150\n\n//====================================================================================================100\n//	DISPLAY TIME\n//====================================================================================================100\n\n // Returns the current system time in microseconds\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\n//===============================================================================================================================================================================================================200\n//	END TIMER CODE\n//===============================================================================================================================================================================================================200\n\n#ifdef __cplusplus\n}\n#endif\n"
b+tree/util/num/num.c,"#ifdef __cplusplus\nextern ""C"" {\n#endif\n\n//===============================================================================================================================================================================================================200\n//	DESCRIPTION\n//===============================================================================================================================================================================================================200\n\n// Returns:	0 if string does not represent integer\n//			1 if string represents integer\n\n//===============================================================================================================================================================================================================200\n//	NUM CODE\n//===============================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	ISINTEGER FUNCTION\n//======================================================================================================================================================150\n\nint isInteger(char *str){\n\n	//====================================================================================================100\n	//	make sure it's not empty\n	//====================================================================================================100\n\n	if (*str == '\0'){\n		return 0;\n	}\n\n	//====================================================================================================100\n	//	if any digit is not a number, return false\n	//====================================================================================================100\n\n	for(; *str != '\0'; str++){\n		if (*str < 48 || *str > 57){	// digit characters (need to include . if checking for float)\n			return 0;\n		}\n	}\n\n	//====================================================================================================100\n	//	it got past all my checks so I think it's a number\n	//====================================================================================================100\n\n	return 1;\n}\n\n//===============================================================================================================================================================================================================200\n//	END NUM CODE\n//===============================================================================================================================================================================================================200\n\n#ifdef __cplusplus\n}\n#endif\n"
cfd/pre_euler3d_cpu_double.cpp,"// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu\n// This code is from the AIAA-2009-4001 paper\n\n\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <omp.h>\n\nstruct double3 { double x, y, z; };\n\n#ifndef block_length\n#error ""you need to define block_length""\n#endif\n\n/*\n * Options\n *\n */\n#define GAMMA 1.4\n#define iterations 2000\n\n#define NDIM 3\n#define NNB 4\n\n#define RK 3	// 3rd order RK\n#define ff_mach 1.2\n#define deg_angle_of_attack 0.0\n\n/*\n * not options\n */\n#define VAR_DENSITY 0\n#define VAR_MOMENTUM  1\n#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)\n#define NVAR (VAR_DENSITY_ENERGY+1)\n\n\n/*\n * Generic functions\n */\ntemplate <typename T>\nT* alloc(int N)\n{\n	return new T[N];\n}\n\ntemplate <typename T>\nvoid dealloc(T* array)\n{\n	delete[] array;\n}\n\ntemplate <typename T>\nvoid copy(T* dst, T* src, int N)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < N; i++)\n	{\n		dst[i] = src[i];\n	}\n}\n\n\nvoid dump(double* variables, int nel, int nelr)\n{\n\n\n	{\n		std::ofstream file(""density"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;\n	}\n\n\n	{\n		std::ofstream file(""momentum"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++)\n		{\n			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << "" "";\n			file << std::endl;\n		}\n	}\n\n	{\n		std::ofstream file(""density_energy"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;\n	}\n\n}\n\n/*\n * Element-based Cell-centered FVM solver functions\n */\ndouble ff_variable[NVAR];\ndouble3 ff_fc_momentum_x;\ndouble3 ff_fc_momentum_y;\ndouble3 ff_fc_momentum_z;\ndouble3 ff_fc_density_energy;\n\n\nvoid initialize_variables(int nelr, double* variables)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];\n	}\n}\n\ninline void compute_flux_contribution(double& density, double3& momentum, double& density_energy, double& pressure, double3& velocity, double3& fc_momentum_x, double3& fc_momentum_y, double3& fc_momentum_z, double3& fc_density_energy)\n{\n	fc_momentum_x.x = velocity.x*momentum.x + pressure;\n	fc_momentum_x.y = velocity.x*momentum.y;\n	fc_momentum_x.z = velocity.x*momentum.z;\n\n	fc_momentum_y.x = fc_momentum_x.y;\n	fc_momentum_y.y = velocity.y*momentum.y + pressure;\n	fc_momentum_y.z = velocity.y*momentum.z;\n\n	fc_momentum_z.x = fc_momentum_x.z;\n	fc_momentum_z.y = fc_momentum_y.z;\n	fc_momentum_z.z = velocity.z*momentum.z + pressure;\n\n	double de_p = density_energy+pressure;\n	fc_density_energy.x = velocity.x*de_p;\n	fc_density_energy.y = velocity.y*de_p;\n	fc_density_energy.z = velocity.z*de_p;\n}\n\ninline void compute_velocity(double& density, double3& momentum, double3& velocity)\n{\n	velocity.x = momentum.x / density;\n	velocity.y = momentum.y / density;\n	velocity.z = momentum.z / density;\n}\n\ninline double compute_speed_sqd(double3& velocity)\n{\n	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;\n}\n\ninline double compute_pressure(double& density, double& density_energy, double& speed_sqd)\n{\n	return (double(GAMMA)-double(1.0))*(density_energy - double(0.5)*density*speed_sqd);\n}\n\ninline double compute_speed_of_sound(double& density, double& pressure)\n{\n	return std::sqrt(double(GAMMA)*pressure/density);\n}\n\n\n\nvoid compute_step_factor(int nelr, double* variables, double* areas, double* step_factors)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double density = variables[NVAR*i + VAR_DENSITY];\n\n		double3 momentum;\n		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		double density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];\n		double3 velocity;	   compute_velocity(density, momentum, velocity);\n		double speed_sqd      = compute_speed_sqd(velocity);\n		double pressure       = compute_pressure(density, density_energy, speed_sqd);\n		double speed_of_sound = compute_speed_of_sound(density, pressure);\n\n		// dt = double(0.5) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once\n		step_factors[i] = double(0.5) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));\n	}\n}\n\n\nvoid compute_flux_contributions(int nelr, double* variables, double* fc_momentum_x, double* fc_momentum_y, double* fc_momentum_z, double* fc_density_energy)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double density_i = variables[NVAR*i + VAR_DENSITY];\n		double3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		double3 velocity_i;             				compute_velocity(density_i, momentum_i, velocity_i);\n		double speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		double speed_i                              = sqrtf(speed_sqd_i);\n		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		double3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;\n		double3 fc_i_density_energy;	\n		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z, fc_i_density_energy);\n\n		fc_momentum_x[i*NDIM + 0] = fc_i_momentum_x.x;\n		fc_momentum_x[i*NDIM + 1] = fc_i_momentum_x.y;\n		fc_momentum_x[i*NDIM+  2] = fc_i_momentum_x.z;\n\n		fc_momentum_y[i*NDIM+ 0] = fc_i_momentum_y.x;\n		fc_momentum_y[i*NDIM+ 1] = fc_i_momentum_y.y;\n		fc_momentum_y[i*NDIM+ 2] = fc_i_momentum_y.z;\n\n\n		fc_momentum_z[i*NDIM+ 0] = fc_i_momentum_z.x;\n		fc_momentum_z[i*NDIM+ 1] = fc_i_momentum_z.y;\n		fc_momentum_z[i*NDIM+ 2] = fc_i_momentum_z.z;\n\n		fc_density_energy[i*NDIM+ 0] = fc_i_density_energy.x;\n		fc_density_energy[i*NDIM+ 1] = fc_i_density_energy.y;\n		fc_density_energy[i*NDIM+ 2] = fc_i_density_energy.z;\n	}\n\n}\n\n/*\n *\n *\n*/\n\nvoid compute_flux(int nelr, int* elements_surrounding_elements, double* normals, double* variables, double* fc_momentum_x, double* fc_momentum_y, double* fc_momentum_z, double* fc_density_energy, double* fluxes)\n{\n	const double smoothing_coefficient = double(0.2);\n\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		int j, nb;\n		double3 normal; double normal_len;\n		double factor;\n\n		double density_i = variables[NVAR*i + VAR_DENSITY];\n		double3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		double3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);\n		double speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		double speed_i                              = std::sqrt(speed_sqd_i);\n		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		double3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;\n		double3 fc_i_density_energy;\n\n		fc_i_momentum_x.x = fc_momentum_x[i*NDIM + 0];\n		fc_i_momentum_x.y = fc_momentum_x[i*NDIM + 1];\n		fc_i_momentum_x.z = fc_momentum_x[i*NDIM + 2];\n\n		fc_i_momentum_y.x = fc_momentum_y[i*NDIM + 0];\n		fc_i_momentum_y.y = fc_momentum_y[i*NDIM + 1];\n		fc_i_momentum_y.z = fc_momentum_y[i*NDIM + 2];\n\n		fc_i_momentum_z.x = fc_momentum_z[i*NDIM + 0];\n		fc_i_momentum_z.y = fc_momentum_z[i*NDIM + 1];\n		fc_i_momentum_z.z = fc_momentum_z[i*NDIM + 2];\n\n		fc_i_density_energy.x = fc_density_energy[i*NDIM + 0];\n		fc_i_density_energy.y = fc_density_energy[i*NDIM + 1];\n		fc_i_density_energy.z = fc_density_energy[i*NDIM + 2];\n\n		double flux_i_density = double(0.0);\n		double3 flux_i_momentum;\n		flux_i_momentum.x = double(0.0);\n		flux_i_momentum.y = double(0.0);\n		flux_i_momentum.z = double(0.0);\n		double flux_i_density_energy = double(0.0);\n\n		double3 velocity_nb;\n		double density_nb, density_energy_nb;\n		double3 momentum_nb;\n		double3 fc_nb_momentum_x, fc_nb_momentum_y, fc_nb_momentum_z;\n		double3 fc_nb_density_energy;\n		double speed_sqd_nb, speed_of_sound_nb, pressure_nb;\n\n		for(j = 0; j < NNB; j++)\n		{\n			nb = elements_surrounding_elements[i*NNB + j];\n			normal.x = normals[(i*NNB + j)*NDIM + 0];\n			normal.y = normals[(i*NNB + j)*NDIM + 1];\n			normal.z = normals[(i*NNB + j)*NDIM + 2];\n			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);\n\n			if(nb >= 0) 	// a legitimate neighbor\n			{\n				density_nb =        variables[nb*NVAR + VAR_DENSITY];\n				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];\n				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];\n				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];\n				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];\n													compute_velocity(density_nb, momentum_nb, velocity_nb);\n				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);\n				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);\n				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);\n\n				fc_nb_momentum_x.x = fc_momentum_x[nb*NDIM + 0];\n				fc_nb_momentum_x.y = fc_momentum_x[nb*NDIM + 1];\n				fc_nb_momentum_x.z = fc_momentum_x[nb*NDIM + 2];\n\n				fc_nb_momentum_y.x = fc_momentum_y[nb*NDIM + 0];\n				fc_nb_momentum_y.y = fc_momentum_y[nb*NDIM + 1];\n				fc_nb_momentum_y.z = fc_momentum_y[nb*NDIM + 2];\n\n				fc_nb_momentum_z.x = fc_momentum_z[nb*NDIM + 0];\n				fc_nb_momentum_z.y = fc_momentum_z[nb*NDIM + 1];\n				fc_nb_momentum_z.z = fc_momentum_z[nb*NDIM + 2];\n\n				fc_nb_density_energy.x = fc_density_energy[nb*NDIM + 0];\n				fc_nb_density_energy.y = fc_density_energy[nb*NDIM + 1];\n\n				// artificial viscosity\n				factor = -normal_len*smoothing_coefficient*double(0.5)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);\n				flux_i_density += factor*(density_i-density_nb);\n				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);\n				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);\n				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);\n				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);\n\n				// accumulate cell-centered fluxes\n				factor = double(0.5)*normal.x;\n				flux_i_density += factor*(momentum_nb.x+momentum_i.x);\n				flux_i_density_energy += factor*(fc_nb_density_energy.x+fc_i_density_energy.x);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.x+fc_i_momentum_x.x);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.x+fc_i_momentum_y.x);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.x+fc_i_momentum_z.x);\n\n				factor = double(0.5)*normal.y;\n				flux_i_density += factor*(momentum_nb.y+momentum_i.y);\n				flux_i_density_energy += factor*(fc_nb_density_energy.y+fc_i_density_energy.y);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.y+fc_i_momentum_x.y);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.y+fc_i_momentum_y.y);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.y+fc_i_momentum_z.y);\n\n				factor = double(0.5)*normal.z;\n				flux_i_density += factor*(momentum_nb.z+momentum_i.z);\n				flux_i_density_energy += factor*(fc_nb_density_energy.z+fc_i_density_energy.z);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.z+fc_i_momentum_x.z);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.z+fc_i_momentum_y.z);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.z+fc_i_momentum_z.z);\n			}\n			else if(nb == -1)	// a wing boundary\n			{\n				flux_i_momentum.x += normal.x*pressure_i;\n				flux_i_momentum.y += normal.y*pressure_i;\n				flux_i_momentum.z += normal.z*pressure_i;\n			}\n			else if(nb == -2) // a far field boundary\n			{\n				factor = double(0.5)*normal.x;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);\n				flux_i_density_energy += factor*(ff_fc_density_energy.x+fc_i_density_energy.x);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.x + fc_i_momentum_x.x);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.x + fc_i_momentum_y.x);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.x + fc_i_momentum_z.x);\n\n				factor = double(0.5)*normal.y;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);\n				flux_i_density_energy += factor*(ff_fc_density_energy.y+fc_i_density_energy.y);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.y + fc_i_momentum_x.y);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.y + fc_i_momentum_y.y);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.y + fc_i_momentum_z.y);\n\n				factor = double(0.5)*normal.z;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);\n				flux_i_density_energy += factor*(ff_fc_density_energy.z+fc_i_density_energy.z);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.z + fc_i_momentum_x.z);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.z + fc_i_momentum_y.z);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.z + fc_i_momentum_z.z);\n\n			}\n		}\n\n		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;\n		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;\n		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;\n		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;\n		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;\n	}\n}\n\nvoid time_step(int j, int nelr, double* old_variables, double* variables, double* step_factors, double* fluxes)\n{\n	#pragma omp parallel for  default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double factor = step_factors[i]/double(RK+1-j);\n\n		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];\n		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];\n		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];\n		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];\n		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];\n	}\n}\n/*\n * Main function\n */\nint main(int argc, char** argv)\n{\n	if (argc < 2)\n	{\n		std::cout << ""specify data file name"" << std::endl;\n		return 0;\n	}\n	const char* data_file_name = argv[1];\n\n	// set far field conditions\n	{\n		const double angle_of_attack = double(3.1415926535897931 / 180.0) * double(deg_angle_of_attack);\n\n		ff_variable[VAR_DENSITY] = double(1.4);\n\n		double ff_pressure = double(1.0);\n		double ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);\n		double ff_speed = double(ff_mach)*ff_speed_of_sound;\n\n		double3 ff_velocity;\n		ff_velocity.x = ff_speed*double(cos((double)angle_of_attack));\n		ff_velocity.y = ff_speed*double(sin((double)angle_of_attack));\n		ff_velocity.z = 0.0;\n\n		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;\n		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;\n		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;\n\n		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(double(0.5)*(ff_speed*ff_speed)) + (ff_pressure / double(GAMMA-1.0));\n\n		double3 ff_momentum;\n		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);\n		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);\n		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);\n		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_fc_momentum_x, ff_fc_momentum_y, ff_fc_momentum_z, ff_fc_density_energy);\n	}\n	int nel;\n	int nelr;\n\n	// read in domain geometry\n	double* areas;\n	int* elements_surrounding_elements;\n	double* normals;\n	{\n		std::ifstream file(data_file_name);\n\n		file >> nel;\n		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));\n\n		areas = new double[nelr];\n		elements_surrounding_elements = new int[nelr*NNB];\n		normals = new double[NDIM*NNB*nelr];\n\n		// read in data\n		for(int i = 0; i < nel; i++)\n		{\n			file >> areas[i];\n			for(int j = 0; j < NNB; j++)\n			{\n				file >> elements_surrounding_elements[i*NNB + j];\n				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;\n				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering\n\n				for(int k = 0; k < NDIM; k++)\n				{\n					file >>  normals[(i*NNB + j)*NDIM + k];\n					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];\n				}\n			}\n		}\n\n		// fill in remaining data\n		int last = nel-1;\n		for(int i = nel; i < nelr; i++)\n		{\n			areas[i] = areas[last];\n			for(int j = 0; j < NNB; j++)\n			{\n				// duplicate the last element\n				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];\n				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];\n			}\n		}\n	}\n\n	// Create arrays and set initial conditions\n	double* variables = alloc<double>(nelr*NVAR);\n	initialize_variables(nelr, variables);\n\n	double* old_variables = alloc<double>(nelr*NVAR);\n	double* fluxes = alloc<double>(nelr*NVAR);\n	double* step_factors = alloc<double>(nelr);\n	double* fc_momentum_x = alloc<double>(nelr*NDIM); \n	double* fc_momentum_y = alloc<double>(nelr*NDIM);\n	double* fc_momentum_z = alloc<double>(nelr*NDIM);\n	double* fc_density_energy = alloc<double>(nelr*NDIM);\n\n	// these need to be computed the first time in order to compute time step\n	std::cout << ""Starting..."" << std::endl;\n	double start = omp_get_wtime();\n\n	// Begin iterations\n	for(int i = 0; i < iterations; i++)\n	{\n		copy<double>(old_variables, variables, nelr*NVAR);\n\n		// for the first iteration we compute the time step\n		compute_step_factor(nelr, variables, areas, step_factors);\n\n		for(int j = 0; j < RK; j++)\n		{\n			compute_flux_contributions(nelr, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy);\n			compute_flux(nelr, elements_surrounding_elements, normals, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy, fluxes);\n			time_step(j, nelr, old_variables, variables, step_factors, fluxes);\n		}\n	}\n\n	double end = omp_get_wtime();\n	std::cout  << (end-start)  / iterations << "" seconds per iteration"" << std::endl;\n\n	std::cout << ""Saving solution..."" << std::endl;\n	dump(variables, nel, nelr);\n	std::cout << ""Saved solution..."" << std::endl;\n\n\n	std::cout << ""Cleaning up..."" << std::endl;\n	dealloc<double>(areas);\n	dealloc<int>(elements_surrounding_elements);\n	dealloc<double>(normals);\n\n	dealloc<double>(variables);\n	dealloc<double>(old_variables);\n	dealloc<double>(fluxes);\n	dealloc<double>(step_factors);\n	dealloc<double>(fc_momentum_x); \n	dealloc<double>(fc_momentum_y);\n	dealloc<double>(fc_momentum_z);\n	dealloc<double>(fc_density_energy);\n	std::cout << ""Done..."" << std::endl;\n\n	return 0;\n}\n"
cfd/euler3d_cpu.cpp,"// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu\n// This code is from the AIAA-2009-4001 paper\n\n#include <iostream>\n#include <fstream>\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\n#include <cmath>\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n\n#include <omp.h>\n\nstruct float3 { float x, y, z; };\n\n#ifndef block_length\n	#ifdef _OPENMP\n	#error ""you need to define block_length""\n	#else\n	#define block_length 1\n	#endif\n#endif\n\n/*\n * Options\n *\n */\n#define GAMMA 1.4\n#define iterations 2000\n\n#define NDIM 3\n#define NNB 4\n\n#define RK 3	// 3rd order RK\n#define ff_mach 1.2\n#define deg_angle_of_attack 0.0f\n\n/*\n * not options\n */\n#define VAR_DENSITY 0\n#define VAR_MOMENTUM  1\n#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)\n#define NVAR (VAR_DENSITY_ENERGY+1)\n\n\n#ifdef restrict\n#define __restrict restrict\n#else\n#define __restrict \n#endif\n\n/*\n * Generic functions\n */\ntemplate <typename T>\nT* alloc(int N)\n{\n	return new T[N];\n}\n\ntemplate <typename T>\nvoid dealloc(T* array)\n{\n	delete[] array;\n}\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\ntemplate <typename T>\nvoid copy(T* dst, T* src, int N)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < N; i++)\n	{\n		dst[i] = src[i];\n	}\n}\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n\n\nvoid dump(float* variables, int nel, int nelr)\n{\n\n\n	{\n		std::ofstream file(""density"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i + VAR_DENSITY*nelr] << std::endl;\n	}\n\n\n	{\n		std::ofstream file(""momentum"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++)\n		{\n			for(int j = 0; j != NDIM; j++) file << variables[i + (VAR_MOMENTUM+j)*nelr] << "" "";\n			file << std::endl;\n		}\n	}\n\n	{\n		std::ofstream file(""density_energy"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i + VAR_DENSITY_ENERGY*nelr] << std::endl;\n	}\n\n}\n\nvoid initialize_variables(int nelr, float* variables, float* ff_variable)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		for(int j = 0; j < NVAR; j++) variables[i + j*nelr] = ff_variable[j];\n	}\n}\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\ninline void compute_flux_contribution(float& density, float3& momentum, float& density_energy, float& pressure, float3& velocity, float3& fc_momentum_x, float3& fc_momentum_y, float3& fc_momentum_z, float3& fc_density_energy)\n{\n	fc_momentum_x.x = velocity.x*momentum.x + pressure;\n	fc_momentum_x.y = velocity.x*momentum.y;\n	fc_momentum_x.z = velocity.x*momentum.z;\n\n	fc_momentum_y.x = fc_momentum_x.y;\n	fc_momentum_y.y = velocity.y*momentum.y + pressure;\n	fc_momentum_y.z = velocity.y*momentum.z;\n\n	fc_momentum_z.x = fc_momentum_x.z;\n	fc_momentum_z.y = fc_momentum_y.z;\n	fc_momentum_z.z = velocity.z*momentum.z + pressure;\n\n	float de_p = density_energy+pressure;\n	fc_density_energy.x = velocity.x*de_p;\n	fc_density_energy.y = velocity.y*de_p;\n	fc_density_energy.z = velocity.z*de_p;\n}\n\ninline void compute_velocity(float& density, float3& momentum, float3& velocity)\n{\n	velocity.x = momentum.x / density;\n	velocity.y = momentum.y / density;\n	velocity.z = momentum.z / density;\n}\n\ninline float compute_speed_sqd(float3& velocity)\n{\n	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;\n}\n\ninline float compute_pressure(float& density, float& density_energy, float& speed_sqd)\n{\n	return (float(GAMMA)-float(1.0f))*(density_energy - float(0.5f)*density*speed_sqd);\n}\n\ninline float compute_speed_of_sound(float& density, float& pressure)\n{\n	return std::sqrt(float(GAMMA)*pressure/density);\n}\n\n\nvoid compute_step_factor(int nelr, float* __restrict variables, float* areas, float* __restrict step_factors)\n{\n	#pragma omp parallel for default(shared) schedule(auto)\n        for(int blk = 0; blk < nelr/block_length; ++blk)\n        {\n            int b_start = blk*block_length;\n            int b_end = (blk+1)*block_length > nelr ? nelr : (blk+1)*block_length;\n#pragma omp simd\n	for(int i = b_start; i < b_end; i++)\n	{\n		float density = variables[i + VAR_DENSITY*nelr];\n\n		float3 momentum;\n		momentum.x = variables[i + (VAR_MOMENTUM+0)*nelr];\n		momentum.y = variables[i + (VAR_MOMENTUM+1)*nelr];\n		momentum.z = variables[i + (VAR_MOMENTUM+2)*nelr];\n\n		float density_energy = variables[i + VAR_DENSITY_ENERGY*nelr];\n		float3 velocity;	   compute_velocity(density, momentum, velocity);\n		float speed_sqd      = compute_speed_sqd(velocity);\n		float pressure       = compute_pressure(density, density_energy, speed_sqd);\n		float speed_of_sound = compute_speed_of_sound(density, pressure);\n\n		// dt = float(0.5f) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once\n		step_factors[i] = float(0.5f) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));\n	}\n        }\n}\n\n\n/*\n *\n *\n*/\n\nvoid compute_flux(int nelr, int* elements_surrounding_elements, float* normals, float* variables, float* fluxes, float* ff_variable, float3 ff_flux_contribution_momentum_x, float3 ff_flux_contribution_momentum_y, float3 ff_flux_contribution_momentum_z, float3 ff_flux_contribution_density_energy)\n{\n	const float smoothing_coefficient = float(0.2f);\n\n	#pragma omp parallel for default(shared) schedule(auto)\n        for(int blk = 0; blk < nelr/block_length; ++blk)\n        {\n            int b_start = blk*block_length;\n            int b_end = (blk+1)*block_length > nelr ? nelr : (blk+1)*block_length;\n#pragma omp simd\n	for(int i = b_start; i < b_end; ++i)\n	{\n                float density_i = variables[i + VAR_DENSITY*nelr];\n		float3 momentum_i;\n		momentum_i.x = variables[i + (VAR_MOMENTUM+0)*nelr];\n		momentum_i.y = variables[i + (VAR_MOMENTUM+1)*nelr];\n		momentum_i.z = variables[i + (VAR_MOMENTUM+2)*nelr];\n\n		float density_energy_i = variables[i + VAR_DENSITY_ENERGY*nelr];\n\n		float3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);\n		float speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		float speed_i                              = std::sqrt(speed_sqd_i);\n		float pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		float speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		float3 flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z;\n		float3 flux_contribution_i_density_energy;\n		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z, flux_contribution_i_density_energy);\n\n		float flux_i_density = float(0.0f);\n		float3 flux_i_momentum;\n		flux_i_momentum.x = float(0.0f);\n		flux_i_momentum.y = float(0.0f);\n		flux_i_momentum.z = float(0.0f);\n		float flux_i_density_energy = float(0.0f);\n\n		float3 velocity_nb;\n		float density_nb, density_energy_nb;\n		float3 momentum_nb;\n		float3 flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z;\n		float3 flux_contribution_nb_density_energy;\n		float speed_sqd_nb, speed_of_sound_nb, pressure_nb;\n#pragma unroll\n		for(int j = 0; j < NNB; j++)\n		{\n                        float3 normal; float normal_len;\n		        float factor;\n\n			int nb = elements_surrounding_elements[i + j*nelr];\n			normal.x = normals[i + (j + 0*NNB)*nelr];\n			normal.y = normals[i + (j + 1*NNB)*nelr];\n			normal.z = normals[i + (j + 2*NNB)*nelr];\n			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);\n\n			if(nb >= 0) 	// a legitimate neighbor\n			{\n				density_nb =        variables[nb + VAR_DENSITY*nelr];\n				momentum_nb.x =     variables[nb + (VAR_MOMENTUM+0)*nelr];\n				momentum_nb.y =     variables[nb + (VAR_MOMENTUM+1)*nelr];\n				momentum_nb.z =     variables[nb + (VAR_MOMENTUM+2)*nelr];\n				density_energy_nb = variables[nb + VAR_DENSITY_ENERGY*nelr];\n													compute_velocity(density_nb, momentum_nb, velocity_nb);\n				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);\n				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);\n				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);\n													compute_flux_contribution(density_nb, momentum_nb, density_energy_nb, pressure_nb, velocity_nb, flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z, flux_contribution_nb_density_energy);\n\n				// artificial viscosity\n				factor = -normal_len*smoothing_coefficient*float(0.5f)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);\n				flux_i_density += factor*(density_i-density_nb);\n				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);\n				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);\n				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);\n				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);\n\n				// accumulate cell-centered fluxes\n				factor = float(0.5f)*normal.x;\n				flux_i_density += factor*(momentum_nb.x+momentum_i.x);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.x+flux_contribution_i_density_energy.x);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.x+flux_contribution_i_momentum_x.x);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.x+flux_contribution_i_momentum_y.x);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.x+flux_contribution_i_momentum_z.x);\n\n				factor = float(0.5f)*normal.y;\n				flux_i_density += factor*(momentum_nb.y+momentum_i.y);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.y+flux_contribution_i_density_energy.y);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.y+flux_contribution_i_momentum_x.y);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.y+flux_contribution_i_momentum_y.y);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.y+flux_contribution_i_momentum_z.y);\n\n				factor = float(0.5f)*normal.z;\n				flux_i_density += factor*(momentum_nb.z+momentum_i.z);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.z+flux_contribution_i_density_energy.z);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.z+flux_contribution_i_momentum_x.z);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.z+flux_contribution_i_momentum_y.z);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.z+flux_contribution_i_momentum_z.z);\n			}\n			else if(nb == -1)	// a wing boundary\n			{\n				flux_i_momentum.x += normal.x*pressure_i;\n				flux_i_momentum.y += normal.y*pressure_i;\n				flux_i_momentum.z += normal.z*pressure_i;\n			}\n			else if(nb == -2) // a far field boundary\n			{\n				factor = float(0.5f)*normal.x;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.x+flux_contribution_i_density_energy.x);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.x + flux_contribution_i_momentum_x.x);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.x + flux_contribution_i_momentum_y.x);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.x + flux_contribution_i_momentum_z.x);\n\n				factor = float(0.5f)*normal.y;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.y+flux_contribution_i_density_energy.y);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.y + flux_contribution_i_momentum_x.y);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.y + flux_contribution_i_momentum_y.y);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.y + flux_contribution_i_momentum_z.y);\n\n				factor = float(0.5f)*normal.z;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.z+flux_contribution_i_density_energy.z);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.z + flux_contribution_i_momentum_x.z);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.z + flux_contribution_i_momentum_y.z);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.z + flux_contribution_i_momentum_z.z);\n\n			}\n                }\n		fluxes[i + VAR_DENSITY*nelr] = flux_i_density;\n		fluxes[i + (VAR_MOMENTUM+0)*nelr] = flux_i_momentum.x;\n		fluxes[i + (VAR_MOMENTUM+1)*nelr] = flux_i_momentum.y;\n		fluxes[i + (VAR_MOMENTUM+2)*nelr] = flux_i_momentum.z;\n		fluxes[i + VAR_DENSITY_ENERGY*nelr] = flux_i_density_energy;\n                \n	}\n        }\n}\n\nvoid time_step(int j, int nelr, float* old_variables, float* variables, float* step_factors, float* fluxes)\n{\n    #pragma omp parallel for  default(shared) schedule(auto)\n    for(int blk = 0; blk < nelr/block_length; ++blk)\n    {\n        int b_start = blk*block_length;\n        int b_end = (blk+1)*block_length > nelr ? nelr : (blk+1)*block_length;\n        #pragma omp simd\n        for(int i = b_start; i < b_end; ++i)\n        {\n            float factor = step_factors[i]/float(RK+1-j);\n\n            variables[i + VAR_DENSITY*nelr] = old_variables[i + VAR_DENSITY*nelr] + factor*fluxes[i + VAR_DENSITY*nelr];\n            variables[i + (VAR_MOMENTUM+0)*nelr] = old_variables[i + (VAR_MOMENTUM+0)*nelr] + factor*fluxes[i + (VAR_MOMENTUM+0)*nelr];\n            variables[i + (VAR_MOMENTUM+1)*nelr] = old_variables[i + (VAR_MOMENTUM+1)*nelr] + factor*fluxes[i + (VAR_MOMENTUM+1)*nelr];\n            variables[i + (VAR_MOMENTUM+2)*nelr] = old_variables[i + (VAR_MOMENTUM+2)*nelr] + factor*fluxes[i + (VAR_MOMENTUM+2)*nelr];\n            variables[i + VAR_DENSITY_ENERGY*nelr] = old_variables[i + VAR_DENSITY_ENERGY*nelr] + factor*fluxes[i + VAR_DENSITY_ENERGY*nelr];\n\n        }\n    }\n}\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n/*\n * Main function\n */\nint main(int argc, char** argv)\n{\n	if (argc < 2)\n	{\n		std::cout << ""specify data file name"" << std::endl;\n		return 0;\n	}\n	const char* data_file_name = argv[1];\n\n        float ff_variable[NVAR];\n        float3 ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy;\n\n	// set far field conditions\n	{\n		const float angle_of_attack = float(3.1415926535897931 / 180.0f) * float(deg_angle_of_attack);\n\n		ff_variable[VAR_DENSITY] = float(1.4);\n\n		float ff_pressure = float(1.0f);\n		float ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);\n		float ff_speed = float(ff_mach)*ff_speed_of_sound;\n\n		float3 ff_velocity;\n		ff_velocity.x = ff_speed*float(cos((float)angle_of_attack));\n		ff_velocity.y = ff_speed*float(sin((float)angle_of_attack));\n		ff_velocity.z = 0.0f;\n\n		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;\n		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;\n		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;\n\n		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(float(0.5f)*(ff_speed*ff_speed)) + (ff_pressure / float(GAMMA-1.0f));\n\n		float3 ff_momentum;\n		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);\n		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);\n		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);\n		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy);\n	}\n	int nel;\n	int nelr;\n\n\n	// read in domain geometry\n	float* areas;\n	int* elements_surrounding_elements;\n	float* normals;\n	{\n		std::ifstream file(data_file_name);\n\n		file >> nel;\n		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));\n\n		areas = new float[nelr];\n		elements_surrounding_elements = new int[nelr*NNB];\n		normals = new float[NDIM*NNB*nelr];\n\n		// read in data\n		for(int i = 0; i < nel; i++)\n		{\n			file >> areas[i];\n			for(int j = 0; j < NNB; j++)\n			{\n				file >> elements_surrounding_elements[i + j*nelr];\n				if(elements_surrounding_elements[i+j*nelr] < 0) elements_surrounding_elements[i+j*nelr] = -1;\n				elements_surrounding_elements[i + j*nelr]--; //it's coming in with Fortran numbering\n\n				for(int k = 0; k < NDIM; k++)\n				{\n					file >>  normals[i + (j + k*NNB)*nelr];\n					normals[i + (j + k*NNB)*nelr] = -normals[i + (j + k*NNB)*nelr];\n				}\n			}\n		}\n\n		// fill in remaining data\n		int last = nel-1;\n		for(int i = nel; i < nelr; i++)\n		{\n			areas[i] = areas[last];\n			for(int j = 0; j < NNB; j++)\n			{\n				// duplicate the last element\n				elements_surrounding_elements[i + j*nelr] = elements_surrounding_elements[last + j*nelr];\n				for(int k = 0; k < NDIM; k++) normals[i + (j + k*NNB)*nelr] = normals[last + (j + k*NNB)*nelr];\n			}\n		}\n	}\n\n	// Create arrays and set initial conditions\n	float* variables = alloc<float>(nelr*NVAR);\n	initialize_variables(nelr, variables, ff_variable);\n\n	float* old_variables = alloc<float>(nelr*NVAR);\n	float* fluxes = alloc<float>(nelr*NVAR);\n	float* step_factors = alloc<float>(nelr);\n\n	// these need to be computed the first time in order to compute time step\n	std::cout << ""Starting..."" << std::endl;\n#ifdef _OPENMP\n	double start = omp_get_wtime();\n    #ifdef OMP_OFFLOAD\n        #pragma omp target map(alloc: old_variables[0:(nelr*NVAR)]) map(to: nelr, areas[0:nelr], step_factors[0:nelr], elements_surrounding_elements[0:(nelr*NNB)], normals[0:(NDIM*NNB*nelr)], fluxes[0:(nelr*NVAR)], ff_variable[0:NVAR], ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy) map(variables[0:(nelr*NVAR)])\n    #endif\n#endif\n	// Begin iterations\n	for(int i = 0; i < iterations; i++)\n	{\n                copy<float>(old_variables, variables, nelr*NVAR);\n\n		// for the first iteration we compute the time step\n		compute_step_factor(nelr, variables, areas, step_factors);\n\n		for(int j = 0; j < RK; j++)\n		{\n			compute_flux(nelr, elements_surrounding_elements, normals, variables, fluxes, ff_variable, ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy);\n			time_step(j, nelr, old_variables, variables, step_factors, fluxes);\n		}\n	}\n\n#ifdef _OPENMP\n	double end = omp_get_wtime();\n	std::cout  << ""Compute time: "" << (end-start) << std::endl;\n#endif\n\n\n	std::cout << ""Saving solution..."" << std::endl;\n	dump(variables, nel, nelr);\n	std::cout << ""Saved solution..."" << std::endl;\n\n\n	std::cout << ""Cleaning up..."" << std::endl;\n	dealloc<float>(areas);\n	dealloc<int>(elements_surrounding_elements);\n	dealloc<float>(normals);\n\n	dealloc<float>(variables);\n	dealloc<float>(old_variables);\n	dealloc<float>(fluxes);\n	dealloc<float>(step_factors);\n\n	std::cout << ""Done..."" << std::endl;\n\n	return 0;\n}\n"
cfd/euler3d_cpu_double.cpp,"// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu\n// This code is from the AIAA-2009-4001 paper\n\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <omp.h>\n\nstruct double3 { double x, y, z; };\n\n#ifndef block_length\n#error ""you need to define block_length""\n#endif\n\n/*\n * Options\n *\n */\n#define GAMMA 1.4\n#define iterations 2000\n\n#define NDIM 3\n#define NNB 4\n\n#define RK 3	// 3rd order RK\n#define ff_mach 1.2\n#define deg_angle_of_attack 0.0\n\n/*\n * not options\n */\n#define VAR_DENSITY 0\n#define VAR_MOMENTUM  1\n#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)\n#define NVAR (VAR_DENSITY_ENERGY+1)\n\n\n/*\n * Generic functions\n */\ntemplate <typename T>\nT* alloc(int N)\n{\n	return new T[N];\n}\n\ntemplate <typename T>\nvoid dealloc(T* array)\n{\n	delete[] array;\n}\n\ntemplate <typename T>\nvoid copy(T* dst, T* src, int N)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < N; i++)\n	{\n		dst[i] = src[i];\n	}\n}\n\n\nvoid dump(double* variables, int nel, int nelr)\n{\n\n\n	{\n		std::ofstream file(""density"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;\n	}\n\n\n	{\n		std::ofstream file(""momentum"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++)\n		{\n			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << "" "";\n			file << std::endl;\n		}\n	}\n\n	{\n		std::ofstream file(""density_energy"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;\n	}\n\n}\n\n/*\n * Element-based Cell-centered FVM solver functions\n */\ndouble ff_variable[NVAR];\ndouble3 ff_flux_contribution_momentum_x;\ndouble3 ff_flux_contribution_momentum_y;\ndouble3 ff_flux_contribution_momentum_z;\ndouble3 ff_flux_contribution_density_energy;\n\n\nvoid initialize_variables(int nelr, double* variables)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];\n	}\n}\n\ninline void compute_flux_contribution(double& density, double3& momentum, double& density_energy, double& pressure, double3& velocity, double3& fc_momentum_x, double3& fc_momentum_y, double3& fc_momentum_z, double3& fc_density_energy)\n{\n	fc_momentum_x.x = velocity.x*momentum.x + pressure;\n	fc_momentum_x.y = velocity.x*momentum.y;\n	fc_momentum_x.z = velocity.x*momentum.z;\n\n	fc_momentum_y.x = fc_momentum_x.y;\n	fc_momentum_y.y = velocity.y*momentum.y + pressure;\n	fc_momentum_y.z = velocity.y*momentum.z;\n\n	fc_momentum_z.x = fc_momentum_x.z;\n	fc_momentum_z.y = fc_momentum_y.z;\n	fc_momentum_z.z = velocity.z*momentum.z + pressure;\n\n	double de_p = density_energy+pressure;\n	fc_density_energy.x = velocity.x*de_p;\n	fc_density_energy.y = velocity.y*de_p;\n	fc_density_energy.z = velocity.z*de_p;\n}\n\ninline void compute_velocity(double& density, double3& momentum, double3& velocity)\n{\n	velocity.x = momentum.x / density;\n	velocity.y = momentum.y / density;\n	velocity.z = momentum.z / density;\n}\n\ninline double compute_speed_sqd(double3& velocity)\n{\n	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;\n}\n\ninline double compute_pressure(double& density, double& density_energy, double& speed_sqd)\n{\n	return (double(GAMMA)-double(1.0))*(density_energy - double(0.5)*density*speed_sqd);\n}\n\ninline double compute_speed_of_sound(double& density, double& pressure)\n{\n	return std::sqrt(double(GAMMA)*pressure/density);\n}\n\n\n\nvoid compute_step_factor(int nelr, double* variables, double* areas, double* step_factors)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double density = variables[NVAR*i + VAR_DENSITY];\n\n		double3 momentum;\n		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		double density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];\n		double3 velocity;	   compute_velocity(density, momentum, velocity);\n		double speed_sqd      = compute_speed_sqd(velocity);\n		double pressure       = compute_pressure(density, density_energy, speed_sqd);\n		double speed_of_sound = compute_speed_of_sound(density, pressure);\n\n		// dt = double(0.5) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once\n		step_factors[i] = double(0.5) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));\n	}\n}\n\n\n/*\n *\n *\n*/\n\nvoid compute_flux(int nelr, int* elements_surrounding_elements, double* normals, double* variables, double* fluxes)\n{\n	const double smoothing_coefficient = double(0.2f);\n\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		int j, nb;\n		double3 normal; double normal_len;\n		double factor;\n\n		double density_i = variables[NVAR*i + VAR_DENSITY];\n		double3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		double density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		double3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);\n		double speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		double speed_i                              = std::sqrt(speed_sqd_i);\n		double pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		double speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		double3 flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z;\n		double3 flux_contribution_i_density_energy;\n		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, flux_contribution_i_momentum_x, flux_contribution_i_momentum_y, flux_contribution_i_momentum_z, flux_contribution_i_density_energy);\n\n		double flux_i_density = double(0.0);\n		double3 flux_i_momentum;\n		flux_i_momentum.x = double(0.0);\n		flux_i_momentum.y = double(0.0);\n		flux_i_momentum.z = double(0.0);\n		double flux_i_density_energy = double(0.0);\n\n		double3 velocity_nb;\n		double density_nb, density_energy_nb;\n		double3 momentum_nb;\n		double3 flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z;\n		double3 flux_contribution_nb_density_energy;\n		double speed_sqd_nb, speed_of_sound_nb, pressure_nb;\n\n		for(j = 0; j < NNB; j++)\n		{\n			nb = elements_surrounding_elements[i*NNB + j];\n			normal.x = normals[(i*NNB + j)*NDIM + 0];\n			normal.y = normals[(i*NNB + j)*NDIM + 1];\n			normal.z = normals[(i*NNB + j)*NDIM + 2];\n			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);\n\n			if(nb >= 0) 	// a legitimate neighbor\n			{\n				density_nb =        variables[nb*NVAR + VAR_DENSITY];\n				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];\n				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];\n				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];\n				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];\n													compute_velocity(density_nb, momentum_nb, velocity_nb);\n				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);\n				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);\n				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);\n													compute_flux_contribution(density_nb, momentum_nb, density_energy_nb, pressure_nb, velocity_nb, flux_contribution_nb_momentum_x, flux_contribution_nb_momentum_y, flux_contribution_nb_momentum_z, flux_contribution_nb_density_energy);\n\n				// artificial viscosity\n				factor = -normal_len*smoothing_coefficient*double(0.5)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);\n				flux_i_density += factor*(density_i-density_nb);\n				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);\n				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);\n				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);\n				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);\n\n				// accumulate cell-centered fluxes\n				factor = double(0.5)*normal.x;\n				flux_i_density += factor*(momentum_nb.x+momentum_i.x);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.x+flux_contribution_i_density_energy.x);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.x+flux_contribution_i_momentum_x.x);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.x+flux_contribution_i_momentum_y.x);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.x+flux_contribution_i_momentum_z.x);\n\n				factor = double(0.5)*normal.y;\n				flux_i_density += factor*(momentum_nb.y+momentum_i.y);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.y+flux_contribution_i_density_energy.y);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.y+flux_contribution_i_momentum_x.y);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.y+flux_contribution_i_momentum_y.y);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.y+flux_contribution_i_momentum_z.y);\n\n				factor = double(0.5)*normal.z;\n				flux_i_density += factor*(momentum_nb.z+momentum_i.z);\n				flux_i_density_energy += factor*(flux_contribution_nb_density_energy.z+flux_contribution_i_density_energy.z);\n				flux_i_momentum.x += factor*(flux_contribution_nb_momentum_x.z+flux_contribution_i_momentum_x.z);\n				flux_i_momentum.y += factor*(flux_contribution_nb_momentum_y.z+flux_contribution_i_momentum_y.z);\n				flux_i_momentum.z += factor*(flux_contribution_nb_momentum_z.z+flux_contribution_i_momentum_z.z);\n			}\n			else if(nb == -1)	// a wing boundary\n			{\n				flux_i_momentum.x += normal.x*pressure_i;\n				flux_i_momentum.y += normal.y*pressure_i;\n				flux_i_momentum.z += normal.z*pressure_i;\n			}\n			else if(nb == -2) // a far field boundary\n			{\n				factor = double(0.5)*normal.x;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.x+flux_contribution_i_density_energy.x);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.x + flux_contribution_i_momentum_x.x);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.x + flux_contribution_i_momentum_y.x);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.x + flux_contribution_i_momentum_z.x);\n\n				factor = double(0.5)*normal.y;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.y+flux_contribution_i_density_energy.y);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.y + flux_contribution_i_momentum_x.y);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.y + flux_contribution_i_momentum_y.y);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.y + flux_contribution_i_momentum_z.y);\n\n				factor = double(0.5)*normal.z;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);\n				flux_i_density_energy += factor*(ff_flux_contribution_density_energy.z+flux_contribution_i_density_energy.z);\n				flux_i_momentum.x += factor*(ff_flux_contribution_momentum_x.z + flux_contribution_i_momentum_x.z);\n				flux_i_momentum.y += factor*(ff_flux_contribution_momentum_y.z + flux_contribution_i_momentum_y.z);\n				flux_i_momentum.z += factor*(ff_flux_contribution_momentum_z.z + flux_contribution_i_momentum_z.z);\n\n			}\n		}\n\n		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;\n		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;\n		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;\n		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;\n		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;\n	}\n}\n\nvoid time_step(int j, int nelr, double* old_variables, double* variables, double* step_factors, double* fluxes)\n{\n	#pragma omp parallel for  default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		double factor = step_factors[i]/double(RK+1-j);\n\n		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];\n		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];\n		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];\n		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];\n		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];\n	}\n}\n/*\n * Main function\n */\nint main(int argc, char** argv)\n{\n	if (argc < 2)\n	{\n		std::cout << ""specify data file name"" << std::endl;\n		return 0;\n	}\n	const char* data_file_name = argv[1];\n\n	// set far field conditions\n	{\n		const double angle_of_attack = double(3.1415926535897931 / 180.0) * double(deg_angle_of_attack);\n\n		ff_variable[VAR_DENSITY] = double(1.4);\n\n		double ff_pressure = double(1.0);\n		double ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);\n		double ff_speed = double(ff_mach)*ff_speed_of_sound;\n\n		double3 ff_velocity;\n		ff_velocity.x = ff_speed*double(cos((double)angle_of_attack));\n		ff_velocity.y = ff_speed*double(sin((double)angle_of_attack));\n		ff_velocity.z = 0.0;\n\n		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;\n		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;\n		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;\n\n		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(double(0.5)*(ff_speed*ff_speed)) + (ff_pressure / double(GAMMA-1.0));\n\n		double3 ff_momentum;\n		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);\n		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);\n		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);\n		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_flux_contribution_momentum_x, ff_flux_contribution_momentum_y, ff_flux_contribution_momentum_z, ff_flux_contribution_density_energy);\n	}\n	int nel;\n	int nelr;\n\n	// read in domain geometry\n	double* areas;\n	int* elements_surrounding_elements;\n	double* normals;\n	{\n		std::ifstream file(data_file_name);\n\n		file >> nel;\n		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));\n\n		areas = new double[nelr];\n		elements_surrounding_elements = new int[nelr*NNB];\n		normals = new double[NDIM*NNB*nelr];\n\n		// read in data\n		for(int i = 0; i < nel; i++)\n		{\n			file >> areas[i];\n			for(int j = 0; j < NNB; j++)\n			{\n				file >> elements_surrounding_elements[i*NNB + j];\n				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;\n				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering\n\n				for(int k = 0; k < NDIM; k++)\n				{\n					file >>  normals[(i*NNB + j)*NDIM + k];\n					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];\n				}\n			}\n		}\n\n		// fill in remaining data\n		int last = nel-1;\n		for(int i = nel; i < nelr; i++)\n		{\n			areas[i] = areas[last];\n			for(int j = 0; j < NNB; j++)\n			{\n				// duplicate the last element\n				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];\n				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];\n			}\n		}\n	}\n\n	// Create arrays and set initial conditions\n	double* variables = alloc<double>(nelr*NVAR);\n	initialize_variables(nelr, variables);\n\n	double* old_variables = alloc<double>(nelr*NVAR);\n	double* fluxes = alloc<double>(nelr*NVAR);\n	double* step_factors = alloc<double>(nelr);\n\n	// these need to be computed the first time in order to compute time step\n	std::cout << ""Starting..."" << std::endl;\n	double start = omp_get_wtime();\n\n	// Begin iterations\n	for(int i = 0; i < iterations; i++)\n	{\n		copy<double>(old_variables, variables, nelr*NVAR);\n\n		// for the first iteration we compute the time step\n		compute_step_factor(nelr, variables, areas, step_factors);\n\n		for(int j = 0; j < RK; j++)\n		{\n			compute_flux(nelr, elements_surrounding_elements, normals, variables, fluxes);\n			time_step(j, nelr, old_variables, variables, step_factors, fluxes);\n		}\n	}\n\n	double end = omp_get_wtime();\n	std::cout  << (end-start)  / iterations << "" seconds per iteration"" << std::endl;\n\n	std::cout << ""Saving solution..."" << std::endl;\n	dump(variables, nel, nelr);\n	std::cout << ""Saved solution..."" << std::endl;\n\n\n	std::cout << ""Cleaning up..."" << std::endl;\n	dealloc<double>(areas);\n	dealloc<int>(elements_surrounding_elements);\n	dealloc<double>(normals);\n\n	dealloc<double>(variables);\n	dealloc<double>(old_variables);\n	dealloc<double>(fluxes);\n	dealloc<double>(step_factors);\n\n	std::cout << ""Done..."" << std::endl;\n\n	return 0;\n}\n"
cfd/pre_euler3d_cpu.cpp,"// Copyright 2009, Andrew Corrigan, acorriga@gmu.edu\n// This code is from the AIAA-2009-4001 paper\n\n#include <iostream>\n#include <fstream>\n#include <cmath>\n#include <omp.h>\n\nstruct float3 { float x, y, z; };\n\n#ifndef block_length\n#error ""you need to define block_length""\n#endif\n\n/*\n * Options\n *\n */\n#define GAMMA 1.4\n#define iterations 2000\n\n#define NDIM 3\n#define NNB 4\n\n#define RK 3	// 3rd order RK\n#define ff_mach 1.2\n#define deg_angle_of_attack 0.0f\n\n/*\n * not options\n */\n#define VAR_DENSITY 0\n#define VAR_MOMENTUM  1\n#define VAR_DENSITY_ENERGY (VAR_MOMENTUM+NDIM)\n#define NVAR (VAR_DENSITY_ENERGY+1)\n\n\n/*\n * Generic functions\n */\ntemplate <typename T>\nT* alloc(int N)\n{\n	return new T[N];\n}\n\ntemplate <typename T>\nvoid dealloc(T* array)\n{\n	delete[] array;\n}\n\ntemplate <typename T>\nvoid copy(T* dst, T* src, int N)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < N; i++)\n	{\n		dst[i] = src[i];\n	}\n}\n\n\nvoid dump(float* variables, int nel, int nelr)\n{\n\n\n	{\n		std::ofstream file(""density"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY] << std::endl;\n	}\n\n\n	{\n		std::ofstream file(""momentum"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++)\n		{\n			for(int j = 0; j != NDIM; j++) file << variables[i*NVAR + (VAR_MOMENTUM+j)] << "" "";\n			file << std::endl;\n		}\n	}\n\n	{\n		std::ofstream file(""density_energy"");\n		file << nel << "" "" << nelr << std::endl;\n		for(int i = 0; i < nel; i++) file << variables[i*NVAR + VAR_DENSITY_ENERGY] << std::endl;\n	}\n\n}\n\n/*\n * Element-based Cell-centered FVM solver functions\n */\nfloat ff_variable[NVAR];\nfloat3 ff_fc_momentum_x;\nfloat3 ff_fc_momentum_y;\nfloat3 ff_fc_momentum_z;\nfloat3 ff_fc_density_energy;\n\n\nvoid initialize_variables(int nelr, float* variables)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		for(int j = 0; j < NVAR; j++) variables[i*NVAR + j] = ff_variable[j];\n	}\n}\n\ninline void compute_flux_contribution(float& density, float3& momentum, float& density_energy, float& pressure, float3& velocity, float3& fc_momentum_x, float3& fc_momentum_y, float3& fc_momentum_z, float3& fc_density_energy)\n{\n	fc_momentum_x.x = velocity.x*momentum.x + pressure;\n	fc_momentum_x.y = velocity.x*momentum.y;\n	fc_momentum_x.z = velocity.x*momentum.z;\n\n	fc_momentum_y.x = fc_momentum_x.y;\n	fc_momentum_y.y = velocity.y*momentum.y + pressure;\n	fc_momentum_y.z = velocity.y*momentum.z;\n\n	fc_momentum_z.x = fc_momentum_x.z;\n	fc_momentum_z.y = fc_momentum_y.z;\n	fc_momentum_z.z = velocity.z*momentum.z + pressure;\n\n	float de_p = density_energy+pressure;\n	fc_density_energy.x = velocity.x*de_p;\n	fc_density_energy.y = velocity.y*de_p;\n	fc_density_energy.z = velocity.z*de_p;\n}\n\ninline void compute_velocity(float& density, float3& momentum, float3& velocity)\n{\n	velocity.x = momentum.x / density;\n	velocity.y = momentum.y / density;\n	velocity.z = momentum.z / density;\n}\n\ninline float compute_speed_sqd(float3& velocity)\n{\n	return velocity.x*velocity.x + velocity.y*velocity.y + velocity.z*velocity.z;\n}\n\ninline float compute_pressure(float& density, float& density_energy, float& speed_sqd)\n{\n	return (float(GAMMA)-float(1.0f))*(density_energy - float(0.5f)*density*speed_sqd);\n}\n\ninline float compute_speed_of_sound(float& density, float& pressure)\n{\n	return std::sqrt(float(GAMMA)*pressure/density);\n}\n\n\n\nvoid compute_step_factor(int nelr, float* variables, float* areas, float* step_factors)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		float density = variables[NVAR*i + VAR_DENSITY];\n\n		float3 momentum;\n		momentum.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n\n		float density_energy = variables[NVAR*i + VAR_DENSITY_ENERGY];\n		float3 velocity;	   compute_velocity(density, momentum, velocity);\n		float speed_sqd      = compute_speed_sqd(velocity);\n		float pressure       = compute_pressure(density, density_energy, speed_sqd);\n		float speed_of_sound = compute_speed_of_sound(density, pressure);\n\n		// dt = float(0.5f) * std::sqrt(areas[i]) /  (||v|| + c).... but when we do time stepping, this later would need to be divided by the area, so we just do it all at once\n		step_factors[i] = float(0.5f) / (std::sqrt(areas[i]) * (std::sqrt(speed_sqd) + speed_of_sound));\n	}\n}\n\nvoid compute_flux_contributions(int nelr, float* variables, float* fc_momentum_x, float* fc_momentum_y, float* fc_momentum_z, float* fc_density_energy)\n{\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		float density_i = variables[NVAR*i + VAR_DENSITY];\n		float3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n		float density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		float3 velocity_i;             				compute_velocity(density_i, momentum_i, velocity_i);\n		float speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		float speed_i                              = sqrtf(speed_sqd_i);\n		float pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		float speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		float3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;\n		float3 fc_i_density_energy;	\n		compute_flux_contribution(density_i, momentum_i, density_energy_i, pressure_i, velocity_i, fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z, fc_i_density_energy);\n\n		fc_momentum_x[i*NDIM + 0] = fc_i_momentum_x.x;\n		fc_momentum_x[i*NDIM + 1] = fc_i_momentum_x.y;\n		fc_momentum_x[i*NDIM+  2] = fc_i_momentum_x.z;\n\n		fc_momentum_y[i*NDIM+ 0] = fc_i_momentum_y.x;\n		fc_momentum_y[i*NDIM+ 1] = fc_i_momentum_y.y;\n		fc_momentum_y[i*NDIM+ 2] = fc_i_momentum_y.z;\n\n\n		fc_momentum_z[i*NDIM+ 0] = fc_i_momentum_z.x;\n		fc_momentum_z[i*NDIM+ 1] = fc_i_momentum_z.y;\n		fc_momentum_z[i*NDIM+ 2] = fc_i_momentum_z.z;\n\n		fc_density_energy[i*NDIM+ 0] = fc_i_density_energy.x;\n		fc_density_energy[i*NDIM+ 1] = fc_i_density_energy.y;\n		fc_density_energy[i*NDIM+ 2] = fc_i_density_energy.z;\n	}\n\n}\n\n/*\n *\n *\n*/\n\nvoid compute_flux(int nelr, int* elements_surrounding_elements, float* normals, float* variables, float* fc_momentum_x, float* fc_momentum_y, float* fc_momentum_z, float* fc_density_energy, float* fluxes)\n{\n	const float smoothing_coefficient = float(0.2f);\n\n	#pragma omp parallel for default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		int j, nb;\n		float3 normal; float normal_len;\n		float factor;\n\n		float density_i = variables[NVAR*i + VAR_DENSITY];\n		float3 momentum_i;\n		momentum_i.x = variables[NVAR*i + (VAR_MOMENTUM+0)];\n		momentum_i.y = variables[NVAR*i + (VAR_MOMENTUM+1)];\n		momentum_i.z = variables[NVAR*i + (VAR_MOMENTUM+2)];\n		float density_energy_i = variables[NVAR*i + VAR_DENSITY_ENERGY];\n\n		float3 velocity_i;             				 compute_velocity(density_i, momentum_i, velocity_i);\n		float speed_sqd_i                          = compute_speed_sqd(velocity_i);\n		float speed_i                              = std::sqrt(speed_sqd_i);\n		float pressure_i                           = compute_pressure(density_i, density_energy_i, speed_sqd_i);\n		float speed_of_sound_i                     = compute_speed_of_sound(density_i, pressure_i);\n		float3 fc_i_momentum_x, fc_i_momentum_y, fc_i_momentum_z;\n		float3 fc_i_density_energy;\n\n		fc_i_momentum_x.x = fc_momentum_x[i*NDIM + 0];\n		fc_i_momentum_x.y = fc_momentum_x[i*NDIM + 1];\n		fc_i_momentum_x.z = fc_momentum_x[i*NDIM + 2];\n\n		fc_i_momentum_y.x = fc_momentum_y[i*NDIM + 0];\n		fc_i_momentum_y.y = fc_momentum_y[i*NDIM + 1];\n		fc_i_momentum_y.z = fc_momentum_y[i*NDIM + 2];\n\n		fc_i_momentum_z.x = fc_momentum_z[i*NDIM + 0];\n		fc_i_momentum_z.y = fc_momentum_z[i*NDIM + 1];\n		fc_i_momentum_z.z = fc_momentum_z[i*NDIM + 2];\n\n		fc_i_density_energy.x = fc_density_energy[i*NDIM + 0];\n		fc_i_density_energy.y = fc_density_energy[i*NDIM + 1];\n		fc_i_density_energy.z = fc_density_energy[i*NDIM + 2];\n\n		float flux_i_density = float(0.0f);\n		float3 flux_i_momentum;\n		flux_i_momentum.x = float(0.0f);\n		flux_i_momentum.y = float(0.0f);\n		flux_i_momentum.z = float(0.0f);\n		float flux_i_density_energy = float(0.0f);\n\n		float3 velocity_nb;\n		float density_nb, density_energy_nb;\n		float3 momentum_nb;\n		float3 fc_nb_momentum_x, fc_nb_momentum_y, fc_nb_momentum_z;\n		float3 fc_nb_density_energy;\n		float speed_sqd_nb, speed_of_sound_nb, pressure_nb;\n\n		for(j = 0; j < NNB; j++)\n		{\n			nb = elements_surrounding_elements[i*NNB + j];\n			normal.x = normals[(i*NNB + j)*NDIM + 0];\n			normal.y = normals[(i*NNB + j)*NDIM + 1];\n			normal.z = normals[(i*NNB + j)*NDIM + 2];\n			normal_len = std::sqrt(normal.x*normal.x + normal.y*normal.y + normal.z*normal.z);\n\n			if(nb >= 0) 	// a legitimate neighbor\n			{\n				density_nb =        variables[nb*NVAR + VAR_DENSITY];\n				momentum_nb.x =     variables[nb*NVAR + (VAR_MOMENTUM+0)];\n				momentum_nb.y =     variables[nb*NVAR + (VAR_MOMENTUM+1)];\n				momentum_nb.z =     variables[nb*NVAR + (VAR_MOMENTUM+2)];\n				density_energy_nb = variables[nb*NVAR + VAR_DENSITY_ENERGY];\n													compute_velocity(density_nb, momentum_nb, velocity_nb);\n				speed_sqd_nb                      = compute_speed_sqd(velocity_nb);\n				pressure_nb                       = compute_pressure(density_nb, density_energy_nb, speed_sqd_nb);\n				speed_of_sound_nb                 = compute_speed_of_sound(density_nb, pressure_nb);\n				fc_nb_momentum_x.x = fc_momentum_x[nb*NDIM + 0];\n				fc_nb_momentum_x.y = fc_momentum_x[nb*NDIM + 1];\n				fc_nb_momentum_x.z = fc_momentum_x[nb*NDIM + 2];\n\n				fc_nb_momentum_y.x = fc_momentum_y[nb*NDIM + 0];\n				fc_nb_momentum_y.y = fc_momentum_y[nb*NDIM + 1];\n				fc_nb_momentum_y.z = fc_momentum_y[nb*NDIM + 2];\n\n				fc_nb_momentum_z.x = fc_momentum_z[nb*NDIM + 0];\n				fc_nb_momentum_z.y = fc_momentum_z[nb*NDIM + 1];\n				fc_nb_momentum_z.z = fc_momentum_z[nb*NDIM + 2];\n\n				fc_nb_density_energy.x = fc_density_energy[nb*NDIM + 0];\n				fc_nb_density_energy.y = fc_density_energy[nb*NDIM + 1];\n				fc_nb_density_energy.z = fc_density_energy[nb*NDIM + 2];\n\n				// artificial viscosity\n				factor = -normal_len*smoothing_coefficient*float(0.5f)*(speed_i + std::sqrt(speed_sqd_nb) + speed_of_sound_i + speed_of_sound_nb);\n				flux_i_density += factor*(density_i-density_nb);\n				flux_i_density_energy += factor*(density_energy_i-density_energy_nb);\n				flux_i_momentum.x += factor*(momentum_i.x-momentum_nb.x);\n				flux_i_momentum.y += factor*(momentum_i.y-momentum_nb.y);\n				flux_i_momentum.z += factor*(momentum_i.z-momentum_nb.z);\n\n				// accumulate cell-centered fluxes\n				factor = float(0.5f)*normal.x;\n				flux_i_density += factor*(momentum_nb.x+momentum_i.x);\n				flux_i_density_energy += factor*(fc_nb_density_energy.x+fc_i_density_energy.x);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.x+fc_i_momentum_x.x);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.x+fc_i_momentum_y.x);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.x+fc_i_momentum_z.x);\n\n				factor = float(0.5f)*normal.y;\n				flux_i_density += factor*(momentum_nb.y+momentum_i.y);\n				flux_i_density_energy += factor*(fc_nb_density_energy.y+fc_i_density_energy.y);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.y+fc_i_momentum_x.y);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.y+fc_i_momentum_y.y);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.y+fc_i_momentum_z.y);\n\n				factor = float(0.5f)*normal.z;\n				flux_i_density += factor*(momentum_nb.z+momentum_i.z);\n				flux_i_density_energy += factor*(fc_nb_density_energy.z+fc_i_density_energy.z);\n				flux_i_momentum.x += factor*(fc_nb_momentum_x.z+fc_i_momentum_x.z);\n				flux_i_momentum.y += factor*(fc_nb_momentum_y.z+fc_i_momentum_y.z);\n				flux_i_momentum.z += factor*(fc_nb_momentum_z.z+fc_i_momentum_z.z);\n			}\n			else if(nb == -1)	// a wing boundary\n			{\n				flux_i_momentum.x += normal.x*pressure_i;\n				flux_i_momentum.y += normal.y*pressure_i;\n				flux_i_momentum.z += normal.z*pressure_i;\n			}\n			else if(nb == -2) // a far field boundary\n			{\n				factor = float(0.5f)*normal.x;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+0]+momentum_i.x);\n				flux_i_density_energy += factor*(ff_fc_density_energy.x+fc_i_density_energy.x);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.x + fc_i_momentum_x.x);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.x + fc_i_momentum_y.x);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.x + fc_i_momentum_z.x);\n\n				factor = float(0.5f)*normal.y;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+1]+momentum_i.y);\n				flux_i_density_energy += factor*(ff_fc_density_energy.y+fc_i_density_energy.y);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.y + fc_i_momentum_x.y);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.y + fc_i_momentum_y.y);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.y + fc_i_momentum_z.y);\n\n				factor = float(0.5f)*normal.z;\n				flux_i_density += factor*(ff_variable[VAR_MOMENTUM+2]+momentum_i.z);\n				flux_i_density_energy += factor*(ff_fc_density_energy.z+fc_i_density_energy.z);\n				flux_i_momentum.x += factor*(ff_fc_momentum_x.z + fc_i_momentum_x.z);\n				flux_i_momentum.y += factor*(ff_fc_momentum_y.z + fc_i_momentum_y.z);\n				flux_i_momentum.z += factor*(ff_fc_momentum_z.z + fc_i_momentum_z.z);\n\n			}\n		}\n\n		fluxes[i*NVAR + VAR_DENSITY] = flux_i_density;\n		fluxes[i*NVAR + (VAR_MOMENTUM+0)] = flux_i_momentum.x;\n		fluxes[i*NVAR + (VAR_MOMENTUM+1)] = flux_i_momentum.y;\n		fluxes[i*NVAR + (VAR_MOMENTUM+2)] = flux_i_momentum.z;\n		fluxes[i*NVAR + VAR_DENSITY_ENERGY] = flux_i_density_energy;\n	}\n}\n\nvoid time_step(int j, int nelr, float* old_variables, float* variables, float* step_factors, float* fluxes)\n{\n	#pragma omp parallel for  default(shared) schedule(static)\n	for(int i = 0; i < nelr; i++)\n	{\n		float factor = step_factors[i]/float(RK+1-j);\n\n		variables[NVAR*i + VAR_DENSITY] = old_variables[NVAR*i + VAR_DENSITY] + factor*fluxes[NVAR*i + VAR_DENSITY];\n		variables[NVAR*i + VAR_DENSITY_ENERGY] = old_variables[NVAR*i + VAR_DENSITY_ENERGY] + factor*fluxes[NVAR*i + VAR_DENSITY_ENERGY];\n		variables[NVAR*i + (VAR_MOMENTUM+0)] = old_variables[NVAR*i + (VAR_MOMENTUM+0)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+0)];\n		variables[NVAR*i + (VAR_MOMENTUM+1)] = old_variables[NVAR*i + (VAR_MOMENTUM+1)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+1)];\n		variables[NVAR*i + (VAR_MOMENTUM+2)] = old_variables[NVAR*i + (VAR_MOMENTUM+2)] + factor*fluxes[NVAR*i + (VAR_MOMENTUM+2)];\n	}\n}\n/*\n * Main function\n */\nint main(int argc, char** argv)\n{\n	if (argc < 2)\n	{\n		std::cout << ""specify data file name"" << std::endl;\n		return 0;\n	}\n	const char* data_file_name = argv[1];\n\n	// set far field conditions\n	{\n		const float angle_of_attack = float(3.1415926535897931 / 180.0f) * float(deg_angle_of_attack);\n\n		ff_variable[VAR_DENSITY] = float(1.4);\n\n		float ff_pressure = float(1.0f);\n		float ff_speed_of_sound = sqrt(GAMMA*ff_pressure / ff_variable[VAR_DENSITY]);\n		float ff_speed = float(ff_mach)*ff_speed_of_sound;\n\n		float3 ff_velocity;\n		ff_velocity.x = ff_speed*float(cos((float)angle_of_attack));\n		ff_velocity.y = ff_speed*float(sin((float)angle_of_attack));\n		ff_velocity.z = 0.0f;\n\n		ff_variable[VAR_MOMENTUM+0] = ff_variable[VAR_DENSITY] * ff_velocity.x;\n		ff_variable[VAR_MOMENTUM+1] = ff_variable[VAR_DENSITY] * ff_velocity.y;\n		ff_variable[VAR_MOMENTUM+2] = ff_variable[VAR_DENSITY] * ff_velocity.z;\n\n		ff_variable[VAR_DENSITY_ENERGY] = ff_variable[VAR_DENSITY]*(float(0.5f)*(ff_speed*ff_speed)) + (ff_pressure / float(GAMMA-1.0f));\n\n		float3 ff_momentum;\n		ff_momentum.x = *(ff_variable+VAR_MOMENTUM+0);\n		ff_momentum.y = *(ff_variable+VAR_MOMENTUM+1);\n		ff_momentum.z = *(ff_variable+VAR_MOMENTUM+2);\n		compute_flux_contribution(ff_variable[VAR_DENSITY], ff_momentum, ff_variable[VAR_DENSITY_ENERGY], ff_pressure, ff_velocity, ff_fc_momentum_x, ff_fc_momentum_y, ff_fc_momentum_z, ff_fc_density_energy);\n	}\n	int nel;\n	int nelr;\n\n\n	// read in domain geometry\n	float* areas;\n	int* elements_surrounding_elements;\n	float* normals;\n	{\n		std::ifstream file(data_file_name);\n\n		file >> nel;\n		nelr = block_length*((nel / block_length )+ std::min(1, nel % block_length));\n\n		areas = new float[nelr];\n		elements_surrounding_elements = new int[nelr*NNB];\n		normals = new float[NDIM*NNB*nelr];\n\n		// read in data\n		for(int i = 0; i < nel; i++)\n		{\n			file >> areas[i];\n			for(int j = 0; j < NNB; j++)\n			{\n				file >> elements_surrounding_elements[i*NNB + j];\n				if(elements_surrounding_elements[i*NNB+j] < 0) elements_surrounding_elements[i*NNB+j] = -1;\n				elements_surrounding_elements[i*NNB + j]--; //it's coming in with Fortran numbering\n\n				for(int k = 0; k < NDIM; k++)\n				{\n					file >>  normals[(i*NNB + j)*NDIM + k];\n					normals[(i*NNB + j)*NDIM + k] = -normals[(i*NNB + j)*NDIM + k];\n				}\n			}\n		}\n\n		// fill in remaining data\n		int last = nel-1;\n		for(int i = nel; i < nelr; i++)\n		{\n			areas[i] = areas[last];\n			for(int j = 0; j < NNB; j++)\n			{\n				// duplicate the last element\n				elements_surrounding_elements[i*NNB + j] = elements_surrounding_elements[last*NNB + j];\n				for(int k = 0; k < NDIM; k++) normals[(i*NNB + j)*NDIM + k] = normals[(last*NNB + j)*NDIM + k];\n			}\n		}\n	}\n\n	// Create arrays and set initial conditions\n	float* variables = alloc<float>(nelr*NVAR);\n	initialize_variables(nelr, variables);\n\n	float* old_variables = alloc<float>(nelr*NVAR);\n	float* fluxes = alloc<float>(nelr*NVAR);\n	float* step_factors = alloc<float>(nelr);\n	float* fc_momentum_x = alloc<float>(nelr*NDIM); \n	float* fc_momentum_y = alloc<float>(nelr*NDIM);\n	float* fc_momentum_z = alloc<float>(nelr*NDIM);\n	float* fc_density_energy = alloc<float>(nelr*NDIM);\n\n	// these need to be computed the first time in order to compute time step\n	std::cout << ""Starting..."" << std::endl;\n	double start = omp_get_wtime();\n\n	// Begin iterations\n	for(int i = 0; i < iterations; i++)\n	{\n		copy<float>(old_variables, variables, nelr*NVAR);\n\n		// for the first iteration we compute the time step\n		compute_step_factor(nelr, variables, areas, step_factors);\n\n		for(int j = 0; j < RK; j++)\n		{\n			compute_flux_contributions(nelr, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy);\n			compute_flux(nelr, elements_surrounding_elements, normals, variables, fc_momentum_x, fc_momentum_y, fc_momentum_z, fc_density_energy, fluxes);\n			time_step(j, nelr, old_variables, variables, step_factors, fluxes);\n		}\n	}\n\n	double end = omp_get_wtime();\n	std::cout  << (end-start)  / iterations << "" seconds per iteration"" << std::endl;\n\n\n\n	std::cout << ""Saving solution..."" << std::endl;\n	dump(variables, nel, nelr);\n	std::cout << ""Saved solution..."" << std::endl;\n\n\n	std::cout << ""Cleaning up..."" << std::endl;\n	dealloc<float>(areas);\n	dealloc<int>(elements_surrounding_elements);\n	dealloc<float>(normals);\n\n	dealloc<float>(variables);\n	dealloc<float>(old_variables);\n	dealloc<float>(fluxes);\n	dealloc<float>(step_factors);\n	dealloc<float>(fc_momentum_x); \n	dealloc<float>(fc_momentum_y);\n	dealloc<float>(fc_momentum_z);\n	dealloc<float>(fc_density_energy);\n	std::cout << ""Done..."" << std::endl;\n\n	return 0;\n}\n"
streamcluster/streamcluster_omp.cpp,"/***********************************************\n	streamcluster_omp.cpp\n	: parallelized code of streamcluster using OpenMP\n	\n	- original code from PARSEC Benchmark Suite\n	- parallelization with OpenMP API has been applied by\n	\n	Sang-Ha (a.k.a Shawn) Lee - sl4ge@virginia.edu\n	University of Virginia\n	Department of Electrical and Computer Engineering\n	Department of Computer Science\n	\n***********************************************/\n\n#include <stdio.h>\n#include <iostream>\n#include <fstream>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <string.h>\n#include <assert.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <limits.h>\n#include <omp.h>\n\n#ifdef ENABLE_PARSEC_HOOKS\n#include <hooks.h>\n#endif\n\nusing namespace std;\n\n#define MAXNAMESIZE 1024 // max filename length\n#define SEED 1\n/* increase this to reduce probability of random error */\n/* increasing it also ups running time of ""speedy"" part of the code */\n/* SP = 1 seems to be fine */\n#define SP 1 // number of repetitions of speedy must be >=1\n\n/* higher ITER --> more likely to get correct # of centers */\n/* higher ITER also scales the running time almost linearly */\n#define ITER 3 // iterate ITER* k log k times; ITER >= 1\n\n//#define PRINTINFO //comment this out to disable output\n#define PROFILE // comment this out to disable instrumentation code\n//#define ENABLE_THREADS  // comment this out to disable threads\n//#define INSERT_WASTE //uncomment this to insert waste computation into dist function\n\n#define CACHE_LINE 512 // cache line in byte\n\n/* this structure represents a point */\n/* these will be passed around to avoid copying coordinates */\ntypedef struct {\n  float weight;\n  float *coord;\n  long assign;  /* number of point where this one is assigned */\n  float cost;  /* cost of that assignment, weight*distance */\n} Point;\n\n/* this is the array of points */\ntypedef struct {\n  long num; /* number of points; may not be N if this is a sample */\n  int dim;  /* dimensionality */\n  Point *p; /* the array itself */\n} Points;\n\nstatic bool *switch_membership; //whether to switch membership in pgain\nstatic bool* is_center; //whether a point is a center\nstatic int* center_table; //index table of centers\nfloat* block;\n\nstatic int nproc; //# of threads\nstatic int c, d;\nstatic int ompthreads;\n\n// instrumentation code\n#ifdef PROFILE\ndouble time_local_search;\ndouble time_speedy;\ndouble time_select_feasible;\ndouble time_gain;\ndouble time_shuffle;\ndouble time_gain_dist;\ndouble time_gain_init;\n#endif \n\ndouble gettime() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return (double)t.tv_sec+t.tv_usec*1e-6;\n}\n\nint isIdentical(float *i, float *j, int D)\n// tells whether two points of D dimensions are identical\n{\n  int a = 0;\n  int equal = 1;\n\n  while (equal && a < D) {\n    if (i[a] != j[a]) equal = 0;\n    else a++;\n  }\n  if (equal) return 1;\n  else return 0;\n\n}\n\n/* comparator for floating point numbers */\nstatic int floatcomp(const void *i, const void *j)\n{\n  float a, b;\n  a = *(float *)(i);\n  b = *(float *)(j);\n  if (a > b) return (1);\n  if (a < b) return (-1);\n  return(0);\n}\n\n/* shuffle points into random order */\nvoid shuffle(Points *points)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n  long i, j;\n  Point temp;\n  for (i=0;i<points->num-1;i++) {\n    j=(lrand48()%(points->num - i)) + i;\n    temp = points->p[i];\n    points->p[i] = points->p[j];\n    points->p[j] = temp;\n  }\n#ifdef PROFILE\n  double t2 = gettime();\n  time_shuffle += t2-t1;\n#endif\n}\n\n/* shuffle an array of integers */\nvoid intshuffle(int *intarray, int length)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n  long i, j;\n  int temp;\n  for (i=0;i<length;i++) {\n    j=(lrand48()%(length - i))+i;\n    temp = intarray[i];\n    intarray[i]=intarray[j];\n    intarray[j]=temp;\n  }\n#ifdef PROFILE\n  double t2 = gettime();\n  time_shuffle += t2-t1;\n#endif\n}\n\n#ifdef INSERT_WASTE\ndouble waste(double s )\n{\n  for( int i =0 ; i< 4; i++ ) {\n    s += pow(s,0.78);\n  }\n  return s;\n}\n#endif\n\n/* compute Euclidean distance squared between two points */\nfloat dist(Point p1, Point p2, int dim)\n{\n  int i;\n  float result=0.0;\n  for (i=0;i<dim;i++)\n    result += (p1.coord[i] - p2.coord[i])*(p1.coord[i] - p2.coord[i]);\n#ifdef INSERT_WASTE\n  double s = waste(result);\n  result += s;\n  result -= s;\n#endif\n  return(result);\n}\n\n/* run speedy on the points, return total cost of solution */\nfloat pspeedy(Points *points, float z, long *kcenter, int pid, pthread_barrier_t* barrier)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n  static double totalcost;\n\n  static bool open = false;\n  static double* costs; //cost for each thread. \n  static int i;\n\n#ifdef ENABLE_THREADS\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n#endif\n\n#ifdef PRINTINFO\n  if( pid == 0 ){\n    fprintf(stderr, ""Speedy: facility cost %lf\n"", z);\n  }\n#endif\n\n  /* create center at first point, send it to itself */\n  for( int k = k1; k < k2; k++ )    {\n    float distance = dist(points->p[k],points->p[0],points->dim);\n    points->p[k].cost = distance * points->p[k].weight;\n    points->p[k].assign=0;\n  }\n\n  if( pid==0 )   {\n    *kcenter = 1;\n    costs = (double*)malloc(sizeof(double)*nproc);\n  }\n    \n  if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.\n    while(1) {\n#ifdef ENABLE_THREADS\n      pthread_mutex_lock(&mutex);\n      while(!open) pthread_cond_wait(&cond,&mutex);\n      pthread_mutex_unlock(&mutex);\n#endif\n      if( i >= points->num ) break;\n      for( int k = k1; k < k2; k++ )\n	{\n	  float distance = dist(points->p[i],points->p[k],points->dim);\n	  if( distance*points->p[k].weight < points->p[k].cost )\n	    {\n	      points->p[k].cost = distance * points->p[k].weight;\n	      points->p[k].assign=i;\n	    }\n	}\n#ifdef ENABLE_THREADS\n      pthread_barrier_wait(barrier);\n      pthread_barrier_wait(barrier);\n#endif\n    } \n  }\n  else  { // I am the master thread. I decide whether to open a center and notify others if so. \n    for(i = 1; i < points->num; i++ )  {\n      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);\n      if( to_open )  {\n	(*kcenter)++;\n#ifdef ENABLE_THREADS\n	pthread_mutex_lock(&mutex);\n#endif\n	open = true;\n#ifdef ENABLE_THREADS\n	pthread_mutex_unlock(&mutex);\n	pthread_cond_broadcast(&cond);\n#endif\n	for( int k = k1; k < k2; k++ )  {\n	  float distance = dist(points->p[i],points->p[k],points->dim);\n	  if( distance*points->p[k].weight < points->p[k].cost )  {\n	    points->p[k].cost = distance * points->p[k].weight;\n	    points->p[k].assign=i;\n	  }\n	}\n#ifdef ENABLE_THREADS\n	pthread_barrier_wait(barrier);\n#endif\n	open = false;\n#ifdef ENABLE_THREADS\n	pthread_barrier_wait(barrier);\n#endif\n      }\n    }\n#ifdef ENABLE_THREADS\n    pthread_mutex_lock(&mutex);\n#endif\n    open = true;\n#ifdef ENABLE_THREADS\n    pthread_mutex_unlock(&mutex);\n    pthread_cond_broadcast(&cond);\n#endif\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  open = false;\n  double mytotal = 0;\n  for( int k = k1; k < k2; k++ )  {\n    mytotal += points->p[k].cost;\n  }\n  costs[pid] = mytotal;\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  // aggregate costs from each thread\n  if( pid == 0 )\n    {\n      totalcost=z*(*kcenter);\n      for( int i = 0; i < nproc; i++ )\n	{\n	  totalcost += costs[i];\n	} \n      free(costs);\n    }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    {\n      fprintf(stderr, ""Speedy opened %d facilities for total cost %lf\n"",\n	      *kcenter, totalcost);\n      fprintf(stderr, ""Distance Cost %lf\n"", totalcost - z*(*kcenter));\n    }\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  if( pid== 0 ) {\n    time_speedy += t2 -t1;\n  }\n#endif\n  return(totalcost);\n}\n\n\n/* For a given point x, find the cost of the following operation:\n * -- open a facility at x if there isn't already one there,\n * -- for points y such that the assignment distance of y exceeds dist(y, x),\n *    make y a member of x,\n * -- for facilities y such that reassigning y and all its members to x \n *    would save cost, realize this closing and reassignment.\n * \n * If the cost of this operation is negative (i.e., if this entire operation\n * saves cost), perform this operation and return the amount of cost saved;\n * otherwise, do nothing.\n */\n\n/* numcenters will be updated to reflect the new number of centers */\n/* z is the facility cost, x is the number of this point in the array \n   points */\n\ndouble pgain(long x, Points *points, double z, long int *numcenters, int pid, pthread_barrier_t* barrier)\n{\n  //  printf(""pgain pthread %d begin\n"",pid);\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n#ifdef PROFILE\n  double t0 = gettime();\n#endif	\n\n	\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n  int i;\n  int number_of_centers_to_close = 0;\n\n  static double *work_mem;\n  static double gl_cost_of_opening_x;\n  static int gl_number_of_centers_to_close;\n	\n  //each thread takes a block of working_mem.\n  int stride = *numcenters+2;\n  //make stride a multiple of CACHE_LINE\n  int cl = CACHE_LINE/sizeof(double);\n  if( stride % cl != 0 ) { \n    stride = cl * ( stride / cl + 1);\n  }\n  int K = stride -2 ; // K==*numcenters\n  \n  //my own cost of opening x\n  double cost_of_opening_x = 0;\n\n  if( pid==0 )    { \n    work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));\n    gl_cost_of_opening_x = 0;\n    gl_number_of_centers_to_close = 0;\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  /*For each center, we have a *lower* field that indicates \n    how much we will save by closing the center. \n    Each thread has its own copy of the *lower* fields as an array.\n    We first build a table to index the positions of the *lower* fields. \n  */\n	\n  int count = 0;\n  for( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      center_table[i] = count++;\n    }		\n  }	\n  work_mem[pid*stride] = count;\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  if( pid == 0 ) {\n    int accum = 0;\n    for( int p = 0; p < nproc; p++ ) {\n      int tmp = (int)work_mem[p*stride];\n      work_mem[p*stride] = accum;\n      accum += tmp;\n    }\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  for( int i = k1; i < k2; i++ ) {		\n    if( is_center[i] ) {\n      center_table[i] += (int)work_mem[pid*stride];\n    }		\n  }	\n	\n  //now we finish building the table. clear the working memory.\n  memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));\n  memset(work_mem+pid*stride, 0, stride*sizeof(double));\n  if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));\n	\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n#ifdef PROFILE\n  double t1 = gettime();\n  if( pid == 0 ) time_gain_init += t1-t0;\n#endif\n  //my *lower* fields\n  double* lower = &work_mem[pid*stride];\n  //global *lower* fields\n  double* gl_lower = &work_mem[nproc*stride];\n	\n	// OpenMP parallelization\n//	#pragma omp parallel for \n	#pragma omp parallel for reduction(+: cost_of_opening_x)\n  for ( i = k1; i < k2; i++ ) {\n    float x_cost = dist(points->p[i], points->p[x], points->dim) \n      * points->p[i].weight;\n    float current_cost = points->p[i].cost;\n		\n    if ( x_cost < current_cost ) {\n\n      // point i would save cost just by switching to x\n      // (note that i cannot be a median, \n      // or else dist(p[i], p[x]) would be 0)			\n      switch_membership[i] = 1;\n      cost_of_opening_x += x_cost - current_cost;			\n    } else {\n\n      // cost of assigning i to x is at least current assignment cost of i\n\n      // consider the savings that i's **current** median would realize\n      // if we reassigned that median and all its members to x;\n      // note we've already accounted for the fact that the median\n      // would save z by closing; now we have to subtract from the savings\n      // the extra cost of reassigning that median and its members \n      int assign = points->p[i].assign;\n      lower[center_table[assign]] += current_cost - x_cost;			\n    }\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif	\n#ifdef PROFILE\n  double t2 = gettime();\n  if( pid==0){\n    time_gain_dist += t2 - t1;\n  }\n#endif	\n  // at this time, we can calculate the cost of opening a center\n  // at x; if it is negative, we'll go through with opening it\n	\n	\n  for ( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      double low = z;\n      //aggregate from all threads\n      for( int p = 0; p < nproc; p++ ) {\n				low += work_mem[center_table[i]+p*stride];\n      }\n      gl_lower[center_table[i]] = low;\n			//printf(""%d : %f %f\n"", i, low, work_mem[center_table[i]+stride]);\n      if ( low > 0 ) {\n	// i is a median, and\n	// if we were to open x (which we still may not) we'd close i\n\n	// note, we'll ignore the following quantity unless we do open x\n	++number_of_centers_to_close;  \n	cost_of_opening_x -= low;\n      }\n    }\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n		\n  //use the rest of working memory to store the following\n  work_mem[pid*stride + K] = number_of_centers_to_close;\n  work_mem[pid*stride + K+1] = cost_of_opening_x;\n	\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  //  printf(""thread %d cost complete\n"",pid); \n\n  if( pid==0 ) {\n    gl_cost_of_opening_x = z;\n    //aggregate\n    for( int p = 0; p < nproc; p++ ) {\n      gl_number_of_centers_to_close += (int)work_mem[p*stride + K];\n      gl_cost_of_opening_x += work_mem[p*stride+K+1];\n    }\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  // Now, check whether opening x would save cost; if so, do it, and\n  // otherwise do nothing\n\n  if ( gl_cost_of_opening_x < 0 ) {\n    //  we'd save money by opening x; we'll do it\n		#pragma omp parallel for\n    for ( int i = k1; i < k2; i++ ) {\n      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;\n      if ( switch_membership[i] || close_center ) {\n				// Either i's median (which may be i itself) is closing,\n				// or i is closer to x than to its current median\n				points->p[i].cost = points->p[i].weight *\n					dist(points->p[i], points->p[x], points->dim);\n				points->p[i].assign = x;\n      }\n    }\n		\n    for( int i = k1; i < k2; i++ ) {\n      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {\n				is_center[i] = false;\n      }\n    }\n    if( x >= k1 && x < k2 ) {\n      is_center[x] = true;\n    }\n    //    pthread_barrier_wait(barrier);\n\n    if( pid==0 ) {\n      *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;\n    }\n  }\n  else {\n    if( pid==0 )\n      gl_cost_of_opening_x = 0;  // the value we'll return\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  if( pid == 0 ) {\n    free(work_mem);\n    //    free(is_center);\n    //    free(switch_membership);\n    //    free(proc_cost_of_opening_x);\n    //    free(proc_number_of_centers_to_close);\n  }\n\n#ifdef PROFILE\n  double t3 = gettime();\n  if( pid==0 )\n  time_gain += t3-t0;\n#endif\n	//printf(""cost=%f\n"", -gl_cost_of_opening_x);\n  return -gl_cost_of_opening_x;\n}\n\n\n/* facility location on the points using local search */\n/* z is the facility cost, returns the total cost and # of centers */\n/* assumes we are seeded with a reasonable solution */\n/* cost should represent this solution's cost */\n/* halt if there is < e improvement after iter calls to gain */\n/* feasible is an array of numfeasible points which may be centers */\n\nfloat pFL(Points *points, int *feasible, int numfeasible,\n	  float z, long *k, double cost, long iter, float e, \n	  int pid, pthread_barrier_t* barrier)\n{\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  long i;\n  long x;\n  double change;\n  long numberOfPoints;\n\n  change = cost;\n  /* continue until we run iter iterations without improvement */\n  /* stop instead if improvement is less than e */\n  while (change/cost > 1.0*e) {\n    change = 0.0;\n    numberOfPoints = points->num;\n    /* randomize order in which centers are considered */\n\n    if( pid == 0 ) {\n      intshuffle(feasible, numfeasible);\n    }\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n    for (i=0;i<iter;i++) {\n      x = i%numfeasible;\n			//printf(""iteration %d started********\n"", i);\n      change += pgain(feasible[x], points, z, k, pid, barrier);\n			c++;\n			//printf(""iteration %d finished @@@@@@\n"", i);\n    }\n\n    cost -= change;\n#ifdef PRINTINFO\n    if( pid == 0 ) {\n      fprintf(stderr, ""%d centers, cost %lf, total distance %lf\n"",\n	      *k, cost, cost - z*(*k));\n    }\n#endif\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n  }\n  return(cost);\n}\n\nint selectfeasible_fast(Points *points, int **feasible, int kmin, int pid, pthread_barrier_t* barrier)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n  int numfeasible = points->num;\n  if (numfeasible > (ITER*kmin*log((double)kmin)))\n    numfeasible = (int)(ITER*kmin*log((double)kmin));\n  *feasible = (int *)malloc(numfeasible*sizeof(int));\n  \n  float* accumweight;\n  float totalweight;\n\n  /* \n     Calcuate my block. \n     For now this routine does not seem to be the bottleneck, so it is not parallelized. \n     When necessary, this can be parallelized by setting k1 and k2 to \n     proper values and calling this routine from all threads ( it is called only\n     by thread 0 for now ). \n     Note that when parallelized, the randomization might not be the same and it might\n     not be difficult to measure the parallel speed-up for the whole program. \n   */\n  //  long bsize = numfeasible;\n  long k1 = 0;\n  long k2 = numfeasible;\n\n  float w;\n  int l,r,k;\n\n  /* not many points, all will be feasible */\n  if (numfeasible == points->num) {\n    for (int i=k1;i<k2;i++)\n      (*feasible)[i] = i;\n    return numfeasible;\n  }\n\n  accumweight= (float*)malloc(sizeof(float)*points->num);\n  accumweight[0] = points->p[0].weight;\n  totalweight=0;\n  for( int i = 1; i < points->num; i++ ) {\n    accumweight[i] = accumweight[i-1] + points->p[i].weight;\n  }\n  totalweight=accumweight[points->num-1];\n\n  for(int i=k1; i<k2; i++ ) {\n    w = (lrand48()/(float)INT_MAX)*totalweight;\n    //binary search\n    l=0;\n    r=points->num-1;\n    if( accumweight[0] > w )  { \n      (*feasible)[i]=0; \n      continue;\n    }\n    while( l+1 < r ) {\n      k = (l+r)/2;\n      if( accumweight[k] > w ) {\n	r = k;\n      } \n      else {\n	l=k;\n      }\n    }\n    (*feasible)[i]=r;\n  }\n\n  free(accumweight); \n\n#ifdef PROFILE\n  double t2 = gettime();\n  time_select_feasible += t2-t1;\n#endif\n  return numfeasible;\n}\n\n/* compute approximate kmedian on the points */\nfloat pkmedian(Points *points, long kmin, long kmax, long* kfinal,\n	       int pid, pthread_barrier_t* barrier )\n{\n  int i;\n  double cost;\n  double lastcost;\n  double hiz, loz, z;\n\n  static long k;\n  static int *feasible;\n  static int numfeasible;\n  static double* hizs;\n\n  if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));\n  hiz = loz = 0.0;\n  long numberOfPoints = points->num;\n  long ptDimension = points->dim;\n\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    {\n      printf(""Starting Kmedian procedure\n"");\n      printf(""%i points in %i dimensions\n"", numberOfPoints, ptDimension);\n    }\n#endif\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  double myhiz = 0;\n  for (long kk=k1;kk < k2; kk++ ) {\n    myhiz += dist(points->p[kk], points->p[0],\n		      ptDimension)*points->p[kk].weight;\n  }\n  hizs[pid] = myhiz;\n\n#ifdef ENABLE_THREADS  \n  pthread_barrier_wait(barrier);\n#endif\n\n  for( int i = 0; i < nproc; i++ )   {\n    hiz += hizs[i];\n  }\n\n  loz=0.0; z = (hiz+loz)/2.0;\n  /* NEW: Check whether more centers than points! */\n  if (points->num <= kmax) {\n    /* just return all points as facilities */\n    for (long kk=k1;kk<k2;kk++) {\n      points->p[kk].assign = kk;\n      points->p[kk].cost = 0;\n    }\n    cost = 0;\n    if( pid== 0 ) {\n      free(hizs); \n      *kfinal = k;\n    }\n    return cost;\n  }\n\n  if( pid == 0 ) shuffle(points);\n  cost = pspeedy(points, z, &k, pid, barrier);\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    printf(""thread %d: Finished first call to speedy, cost=%lf, k=%i\n"",pid,cost,k);\n#endif\n  i=0;\n  /* give speedy SP chances to get at least kmin/2 facilities */\n  while ((k < kmin)&&(i<SP)) {\n    cost = pspeedy(points, z, &k, pid, barrier);\n    i++;\n  }\n\n#ifdef PRINTINFO\n  if( pid==0)\n    printf(""thread %d: second call to speedy, cost=%lf, k=%d\n"",pid,cost,k);\n#endif \n  /* if still not enough facilities, assume z is too high */\n  while (k < kmin) {\n#ifdef PRINTINFO\n    if( pid == 0 ) {\n      printf(""%lf %lf\n"", loz, hiz);\n      printf(""Speedy indicates we should try lower z\n"");\n    }\n#endif\n    if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}\n    if( pid == 0 ) shuffle(points);\n    cost = pspeedy(points, z, &k, pid, barrier);\n    i++;\n  }\n\n  /* now we begin the binary search for real */\n  /* must designate some points as feasible centers */\n  /* this creates more consistancy between FL runs */\n  /* helps to guarantee correct # of centers at the end */\n  \n  if( pid == 0 )\n    {\n      numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);\n      for( int i = 0; i< points->num; i++ ) {\n	is_center[points->p[i].assign]= true;\n      }\n    }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  while(1) {\n		d++;\n#ifdef PRINTINFO\n    if( pid==0 )\n      {\n	printf(""loz = %lf, hiz = %lf\n"", loz, hiz);\n	printf(""Running Local Search...\n"");\n      }\n#endif\n    /* first get a rough estimate on the FL solution */\n    //    pthread_barrier_wait(barrier);\n\n    lastcost = cost;\n    cost = pFL(points, feasible, numfeasible,\n	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);\n\n    /* if number of centers seems good, try a more accurate FL */\n    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||\n	((k <= kmax+2)&&(k >= kmin-2))) {\n\n#ifdef PRINTINFO\n      if( pid== 0)\n	{\n	  printf(""Trying a more accurate local search...\n"");\n	}\n#endif\n      /* may need to run a little longer here before halting without\n	 improvement */\n      cost = pFL(points, feasible, numfeasible,\n		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);\n    }\n\n    if (k > kmax) {\n      /* facilities too cheap */\n      /* increase facility cost and up the cost accordingly */\n      loz = z; z = (hiz+loz)/2.0;\n      cost += (z-loz)*k;\n    }\n    if (k < kmin) {\n      /* facilities too expensive */\n      /* decrease facility cost and reduce the cost accordingly */\n      hiz = z; z = (hiz+loz)/2.0;\n      cost += (z-hiz)*k;\n    }\n\n    /* if k is good, return the result */\n    /* if we're stuck, just give up and return what we have */\n    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )\n      { \n	break;\n      }\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n  }\n\n  //clean up...\n  if( pid==0 ) {\n    free(feasible); \n    free(hizs);\n    *kfinal = k;\n  }\n\n  return cost;\n}\n\n/* compute the means for the k clusters */\nint contcenters(Points *points)\n{\n  long i, ii;\n  float relweight;\n\n  for (i=0;i<points->num;i++) {\n    /* compute relative weight of this point to the cluster */\n    if (points->p[i].assign != i) {\n      relweight=points->p[points->p[i].assign].weight + points->p[i].weight;\n      relweight = points->p[i].weight/relweight;\n      for (ii=0;ii<points->dim;ii++) {\n	points->p[points->p[i].assign].coord[ii]*=1.0-relweight;\n	points->p[points->p[i].assign].coord[ii]+=\n	  points->p[i].coord[ii]*relweight;\n      }\n      points->p[points->p[i].assign].weight += points->p[i].weight;\n    }\n  }\n  \n  return 0;\n}\n\n/* copy centers from points to centers */\nvoid copycenters(Points *points, Points* centers, long* centerIDs, long offset)\n{\n  long i;\n  long k;\n\n  bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));\n\n  /* mark the centers */\n  for ( i = 0; i < points->num; i++ ) {\n    is_a_median[points->p[i].assign] = 1;\n  }\n\n  k=centers->num;\n\n  /* count how many  */\n  for ( i = 0; i < points->num; i++ ) {\n    if ( is_a_median[i] ) {\n      memcpy( centers->p[k].coord, points->p[i].coord, points->dim * sizeof(float));\n      centers->p[k].weight = points->p[i].weight;\n      centerIDs[k] = i + offset;\n      k++;\n    }\n  }\n\n  centers->num = k;\n\n  free(is_a_median);\n}\n\nstruct pkmedian_arg_t\n{\n  Points* points;\n  long kmin;\n  long kmax;\n  long* kfinal;\n  int pid;\n  pthread_barrier_t* barrier;\n};\n\nvoid* localSearchSub(void* arg_) {\n\n  pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;\n  pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);\n\n  return NULL;\n}\n\nvoid localSearch( Points* points, long kmin, long kmax, long* kfinal ) {\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n    pthread_barrier_t barrier;\n#ifdef ENABLE_THREADS\n    pthread_barrier_init(&barrier,NULL,nproc);\n#endif\n    pthread_t* threads = new pthread_t[nproc];\n    pkmedian_arg_t* arg = new pkmedian_arg_t[nproc];\n\n\n    for( int i = 0; i < nproc; i++ ) {\n      arg[i].points = points;\n      arg[i].kmin = kmin;\n      arg[i].kmax = kmax;\n      arg[i].pid = i;\n      arg[i].kfinal = kfinal;\n\n      arg[i].barrier = &barrier;\n#ifdef ENABLE_THREADS\n      pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);\n#else\n      localSearchSub(&arg[0]);\n#endif\n    }\n\n    for ( int i = 0; i < nproc; i++) {\n#ifdef ENABLE_THREADS\n      pthread_join(threads[i],NULL);\n#endif\n    }\n\n    delete[] threads;\n    delete[] arg;\n#ifdef ENABLE_THREADS\n    pthread_barrier_destroy(&barrier);\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  time_local_search += t2-t1;\n#endif\n \n}\n\nclass PStream {\npublic:\n  virtual size_t read( float* dest, int dim, int num ) = 0;\n  virtual int ferror() = 0;\n  virtual int feof() = 0;\n  virtual ~PStream() {\n  }\n};\n\n//synthetic stream\nclass SimStream : public PStream {\npublic:\n  SimStream(long n_ ) {\n    n = n_;\n  }\n  size_t read( float* dest, int dim, int num ) {\n    size_t count = 0;\n    for( int i = 0; i < num && n > 0; i++ ) {\n      for( int k = 0; k < dim; k++ ) {\n	dest[i*dim + k] = lrand48()/(float)INT_MAX;\n      }\n      n--;\n      count++;\n    }\n    return count;\n  }\n  int ferror() {\n    return 0;\n  }\n  int feof() {\n    return n <= 0;\n  }\n  ~SimStream() { \n  }\nprivate:\n  long n;\n};\n\nclass FileStream : public PStream {\npublic:\n  FileStream(char* filename) {\n    fp = fopen( filename, ""rb"");\n    if( fp == NULL ) {\n      fprintf(stderr,""error opening file %s\n."",filename);\n      exit(1);\n    }\n  }\n  size_t read( float* dest, int dim, int num ) {\n    return std::fread(dest, sizeof(float)*dim, num, fp); \n  }\n  int ferror() {\n    return std::ferror(fp);\n  }\n  int feof() {\n    return std::feof(fp);\n  }\n  ~FileStream() {\n    printf(""closing file stream\n"");\n    fclose(fp);\n  }\nprivate:\n  FILE* fp;\n};\n\nvoid outcenterIDs( Points* centers, long* centerIDs, char* outfile ) {\n  FILE* fp = fopen(outfile, ""w"");\n  if( fp==NULL ) {\n    fprintf(stderr, ""error opening %s\n"",outfile);\n    exit(1);\n  }\n  int* is_a_median = (int*)calloc( sizeof(int), centers->num );\n  for( int i =0 ; i< centers->num; i++ ) {\n    is_a_median[centers->p[i].assign] = 1;\n  }\n\n  for( int i = 0; i < centers->num; i++ ) {\n    if( is_a_median[i] ) {\n      fprintf(fp, ""%u\n"", centerIDs[i]);\n      fprintf(fp, ""%lf\n"", centers->p[i].weight);\n      for( int k = 0; k < centers->dim; k++ ) {\n	fprintf(fp, ""%lf "", centers->p[i].coord[k]);\n      }\n      fprintf(fp,""\n\n"");\n    }\n  }\n  fclose(fp);\n}\n\nvoid streamCluster( PStream* stream, \n		    long kmin, long kmax, int dim,\n		    long chunksize, long centersize, char* outfile )\n{\n  block = (float*)malloc( chunksize*dim*sizeof(float) );\n  float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );\n  long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));\n\n  if( block == NULL ) { \n    fprintf(stderr,""not enough memory for a chunk!\n"");\n    exit(1);\n  }\n\n  Points points;\n  points.dim = dim;\n  points.num = chunksize;\n  points.p = (Point *)malloc(chunksize*sizeof(Point));\n  for( int i = 0; i < chunksize; i++ ) {		\n    points.p[i].coord = &block[i*dim];\n  }\n\n	\n	\n  Points centers;\n  centers.dim = dim;\n  centers.p = (Point *)malloc(centersize*sizeof(Point));\n  centers.num = 0;\n\n  for( int i = 0; i< centersize; i++ ) {\n    centers.p[i].coord = &centerBlock[i*dim];\n    centers.p[i].weight = 1.0;\n  }\n\n  long IDoffset = 0;\n  long kfinal;\n  while(1) {\n\n    size_t numRead  = stream->read(block, dim, chunksize ); \n    fprintf(stderr,""read %d points\n"",numRead);\n\n    if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {\n      fprintf(stderr, ""error reading data!\n"");\n      exit(1);\n    }\n\n    points.num = numRead;\n    for( int i = 0; i < points.num; i++ ) {\n      points.p[i].weight = 1.0;\n    }\n\n    switch_membership = (bool*)malloc(points.num*sizeof(bool));\n    is_center = (bool*)calloc(points.num,sizeof(bool));\n    center_table = (int*)malloc(points.num*sizeof(int));\n\n    localSearch(&points,kmin, kmax,&kfinal);\n\n    fprintf(stderr,""finish local search\n"");\n    contcenters(&points);\n    if( kfinal + centers.num > centersize ) {\n      //here we don't handle the situation where # of centers gets too large. \n      fprintf(stderr,""oops! no more space for centers\n"");\n      exit(1);\n    }\n\n#ifdef PRINTINFO\n    printf(""finish cont center\n"");\n#endif\n\n    copycenters(&points, &centers, centerIDs, IDoffset);\n    IDoffset += numRead;\n\n#ifdef PRINTINFO\n    printf(""finish copy centers\n""); \n#endif\n\n    free(is_center);\n    free(switch_membership);\n    free(center_table);\n\n    if( stream->feof() ) {\n      break;\n    }\n  }\n\n  //finally cluster all temp centers\n  switch_membership = (bool*)malloc(centers.num*sizeof(bool));\n  is_center = (bool*)calloc(centers.num,sizeof(bool));\n  center_table = (int*)malloc(centers.num*sizeof(int));\n\n  localSearch( &centers, kmin, kmax ,&kfinal );\n  contcenters(&centers);\n  outcenterIDs( &centers, centerIDs, outfile);\n}\n\nint main(int argc, char **argv)\n{\n  char *outfilename = new char[MAXNAMESIZE];\n  char *infilename = new char[MAXNAMESIZE];\n  long kmin, kmax, n, chunksize, clustersize;\n  int dim;\n	int numthreads;\n	c = 0;\n	d = 0;\n#ifdef PARSEC_VERSION\n#define __PARSEC_STRING(x) #x\n#define __PARSEC_XSTRING(x) __PARSEC_STRING(x)\n        printf(""PARSEC Benchmark Suite Version ""__PARSEC_XSTRING(PARSEC_VERSION)""\n"");\n	fflush(NULL);\n#else\n        printf(""PARSEC Benchmark Suite\n"");\n	fflush(NULL);\n#endif //PARSEC_VERSION\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_bench_begin(__parsec_streamcluster);\n#endif\n\n  if (argc<10) {\n    fprintf(stderr,""usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n"",\n	    argv[0]);\n    fprintf(stderr,""  k1:          Min. number of centers allowed\n"");\n    fprintf(stderr,""  k2:          Max. number of centers allowed\n"");\n    fprintf(stderr,""  d:           Dimension of each data point\n"");\n    fprintf(stderr,""  n:           Number of data points\n"");\n    fprintf(stderr,""  chunksize:   Number of data points to handle per step\n"");\n    fprintf(stderr,""  clustersize: Maximum number of intermediate centers\n"");\n    fprintf(stderr,""  infile:      Input file (if n<=0)\n"");\n    fprintf(stderr,""  outfile:     Output file\n"");\n    fprintf(stderr,""  nproc:       Number of threads to use\n"");\n    fprintf(stderr,""\n"");\n    fprintf(stderr, ""if n > 0, points will be randomly generated instead of reading from infile.\n"");\n    exit(1);\n  }\n  kmin = atoi(argv[1]);\n  kmax = atoi(argv[2]);\n  dim = atoi(argv[3]);\n  n = atoi(argv[4]);\n  chunksize = atoi(argv[5]);\n  clustersize = atoi(argv[6]);\n  strcpy(infilename, argv[7]);\n  strcpy(outfilename, argv[8]);\n  nproc = atoi(argv[9]);\n	\n	ompthreads = nproc;\n	nproc = 1;\n	omp_set_num_threads(ompthreads);\n	\n  srand48(SEED);\n  PStream* stream;\n  if( n > 0 ) {\n    stream = new SimStream(n);\n  }\n  else {\n    stream = new FileStream(infilename);\n  }\n\n  double t1 = gettime();\n\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_roi_begin();\n#endif\n  streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_roi_end();\n#endif\n\n  double t2 = gettime();\n\n  printf(""time = %lf\n"",t2-t1);\n\n  delete stream;\n\n  printf(""time pgain = %lf\n"", time_gain);\n  printf(""time pgain_dist = %lf\n"", time_gain_dist);\n  printf(""time pgain_init = %lf\n"", time_gain_init);\n  printf(""time pselect = %lf\n"", time_select_feasible);\n  printf(""time pspeedy = %lf\n"", time_speedy);\n  printf(""time pshuffle = %lf\n"", time_shuffle);\n  printf(""time localSearch = %lf\n"", time_local_search);\n	printf(""loops=%d\n"", d);\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_bench_end();\n#endif\n  \n  return 0;\n}\n"
streamcluster/streamcluster_original.cpp,"//Copyright (c) 2006-2009 Princeton University\n//All rights reserved.\n\n//Redistribution and use in source and binary forms, with or without\n//modification, are permitted provided that the following conditions are met:\n//    * Redistributions of source code must retain the above copyright\n//      notice, this list of conditions and the following disclaimer.\n//    * Redistributions in binary form must reproduce the above copyright\n//      notice, this list of conditions and the following disclaimer in the\n//      documentation and/or other materials provided with the distribution.\n//    * Neither the name of Princeton University nor the\n//      names of its contributors may be used to endorse or promote products\n//      derived from this software without specific prior written permission.\n\n//THIS SOFTWARE IS PROVIDED BY PRINCETON UNIVERSITY ``AS IS'' AND ANY\n//EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n//WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n//DISCLAIMED. IN NO EVENT SHALL PRINCETON UNIVERSITY BE LIABLE FOR ANY\n//DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n//(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n//LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n//ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n//(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n//SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\n#include <stdio.h>\n#include <iostream>\n#include <fstream>\n#include <stdlib.h>\n#include <sys/time.h>\n#include <string.h>\n#include <assert.h>\n#include <math.h>\n#include <sys/resource.h>\n#include <limits.h>\n\n#ifdef ENABLE_PARSEC_HOOKS\n#include <hooks.h>\n#endif\n\nusing namespace std;\n\n#define MAXNAMESIZE 1024 // max filename length\n#define SEED 1\n/* increase this to reduce probability of random error */\n/* increasing it also ups running time of ""speedy"" part of the code */\n/* SP = 1 seems to be fine */\n#define SP 1 // number of repetitions of speedy must be >=1\n\n/* higher ITER --> more likely to get correct # of centers */\n/* higher ITER also scales the running time almost linearly */\n#define ITER 3 // iterate ITER* k log k times; ITER >= 1\n\n//#define PRINTINFO //comment this out to disable output\n//#define PROFILE // comment this out to disable instrumentation code\n//#define ENABLE_THREADS  // comment this out to disable threads\n//#define INSERT_WASTE //uncomment this to insert waste computation into dist function\n\n#define CACHE_LINE 512 // cache line in byte\n\n/* this structure represents a point */\n/* these will be passed around to avoid copying coordinates */\ntypedef struct {\n  float weight;\n  float *coord;\n  long assign;  /* number of point where this one is assigned */\n  float cost;  /* cost of that assignment, weight*distance */\n} Point;\n\n/* this is the array of points */\ntypedef struct {\n  long num; /* number of points; may not be N if this is a sample */\n  int dim;  /* dimensionality */\n  Point *p; /* the array itself */\n} Points;\n\nstatic bool *switch_membership; //whether to switch membership in pgain\nstatic bool* is_center; //whether a point is a center\nstatic int* center_table; //index table of centers\n\nstatic int nproc; //# of threads\n\n// instrumentation code\n#ifdef PROFILE\ndouble time_local_search;\ndouble time_speedy;\ndouble time_select_feasible;\ndouble time_gain;\ndouble time_shuffle;\ndouble time_gain_dist;\ndouble time_gain_init;\n#endif \n\ndouble gettime() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return (double)t.tv_sec+t.tv_usec*1e-6;\n}\n\nint isIdentical(float *i, float *j, int D)\n// tells whether two points of D dimensions are identical\n{\n  int a = 0;\n  int equal = 1;\n\n  while (equal && a < D) {\n    if (i[a] != j[a]) equal = 0;\n    else a++;\n  }\n  if (equal) return 1;\n  else return 0;\n\n}\n\n/* comparator for floating point numbers */\nstatic int floatcomp(const void *i, const void *j)\n{\n  float a, b;\n  a = *(float *)(i);\n  b = *(float *)(j);\n  if (a > b) return (1);\n  if (a < b) return (-1);\n  return(0);\n}\n\n/* shuffle points into random order */\nvoid shuffle(Points *points)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n  long i, j;\n  Point temp;\n  for (i=0;i<points->num-1;i++) {\n    j=(lrand48()%(points->num - i)) + i;\n    temp = points->p[i];\n    points->p[i] = points->p[j];\n    points->p[j] = temp;\n  }\n#ifdef PROFILE\n  double t2 = gettime();\n  time_shuffle += t2-t1;\n#endif\n}\n\n/* shuffle an array of integers */\nvoid intshuffle(int *intarray, int length)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n  long i, j;\n  int temp;\n  for (i=0;i<length;i++) {\n    j=(lrand48()%(length - i))+i;\n    temp = intarray[i];\n    intarray[i]=intarray[j];\n    intarray[j]=temp;\n  }\n#ifdef PROFILE\n  double t2 = gettime();\n  time_shuffle += t2-t1;\n#endif\n}\n\n#ifdef INSERT_WASTE\ndouble waste(double s )\n{\n  for( int i =0 ; i< 4; i++ ) {\n    s += pow(s,0.78);\n  }\n  return s;\n}\n#endif\n\n/* compute Euclidean distance squared between two points */\nfloat dist(Point p1, Point p2, int dim)\n{\n  int i;\n  float result=0.0;\n  for (i=0;i<dim;i++)\n    result += (p1.coord[i] - p2.coord[i])*(p1.coord[i] - p2.coord[i]);\n#ifdef INSERT_WASTE\n  double s = waste(result);\n  result += s;\n  result -= s;\n#endif\n  return(result);\n}\n\n/* run speedy on the points, return total cost of solution */\nfloat pspeedy(Points *points, float z, long *kcenter, int pid, pthread_barrier_t* barrier)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n  static double totalcost;\n\n  static bool open = false;\n  static double* costs; //cost for each thread. \n  static int i;\n\n#ifdef ENABLE_THREADS\n  static pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\n  static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n#endif\n\n#ifdef PRINTINFO\n  if( pid == 0 ){\n    fprintf(stderr, ""Speedy: facility cost %lf\n"", z);\n  }\n#endif\n\n  /* create center at first point, send it to itself */\n  for( int k = k1; k < k2; k++ )    {\n    float distance = dist(points->p[k],points->p[0],points->dim);\n    points->p[k].cost = distance * points->p[k].weight;\n    points->p[k].assign=0;\n  }\n\n  if( pid==0 )   {\n    *kcenter = 1;\n    costs = (double*)malloc(sizeof(double)*nproc);\n  }\n    \n  if( pid != 0 ) { // we are not the master threads. we wait until a center is opened.\n    while(1) {\n#ifdef ENABLE_THREADS\n      pthread_mutex_lock(&mutex);\n      while(!open) pthread_cond_wait(&cond,&mutex);\n      pthread_mutex_unlock(&mutex);\n#endif\n      if( i >= points->num ) break;\n      for( int k = k1; k < k2; k++ )\n	{\n	  float distance = dist(points->p[i],points->p[k],points->dim);\n	  if( distance*points->p[k].weight < points->p[k].cost )\n	    {\n	      points->p[k].cost = distance * points->p[k].weight;\n	      points->p[k].assign=i;\n	    }\n	}\n#ifdef ENABLE_THREADS\n      pthread_barrier_wait(barrier);\n      pthread_barrier_wait(barrier);\n#endif\n    } \n  }\n  else  { // I am the master thread. I decide whether to open a center and notify others if so. \n    for(i = 1; i < points->num; i++ )  {\n      bool to_open = ((float)lrand48()/(float)INT_MAX)<(points->p[i].cost/z);\n      if( to_open )  {\n	(*kcenter)++;\n#ifdef ENABLE_THREADS\n	pthread_mutex_lock(&mutex);\n#endif\n	open = true;\n#ifdef ENABLE_THREADS\n	pthread_mutex_unlock(&mutex);\n	pthread_cond_broadcast(&cond);\n#endif\n	for( int k = k1; k < k2; k++ )  {\n	  float distance = dist(points->p[i],points->p[k],points->dim);\n	  if( distance*points->p[k].weight < points->p[k].cost )  {\n	    points->p[k].cost = distance * points->p[k].weight;\n	    points->p[k].assign=i;\n	  }\n	}\n#ifdef ENABLE_THREADS\n	pthread_barrier_wait(barrier);\n#endif\n	open = false;\n#ifdef ENABLE_THREADS\n	pthread_barrier_wait(barrier);\n#endif\n      }\n    }\n#ifdef ENABLE_THREADS\n    pthread_mutex_lock(&mutex);\n#endif\n    open = true;\n#ifdef ENABLE_THREADS\n    pthread_mutex_unlock(&mutex);\n    pthread_cond_broadcast(&cond);\n#endif\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  open = false;\n  double mytotal = 0;\n  for( int k = k1; k < k2; k++ )  {\n    mytotal += points->p[k].cost;\n  }\n  costs[pid] = mytotal;\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  // aggregate costs from each thread\n  if( pid == 0 )\n    {\n      totalcost=z*(*kcenter);\n      for( int i = 0; i < nproc; i++ )\n	{\n	  totalcost += costs[i];\n	} \n      free(costs);\n    }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    {\n      fprintf(stderr, ""Speedy opened %d facilities for total cost %lf\n"",\n	      *kcenter, totalcost);\n      fprintf(stderr, ""Distance Cost %lf\n"", totalcost - z*(*kcenter));\n    }\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  if( pid== 0 ) {\n    time_speedy += t2 -t1;\n  }\n#endif\n  return(totalcost);\n}\n\n\n/* For a given point x, find the cost of the following operation:\n * -- open a facility at x if there isn't already one there,\n * -- for points y such that the assignment distance of y exceeds dist(y, x),\n *    make y a member of x,\n * -- for facilities y such that reassigning y and all its members to x \n *    would save cost, realize this closing and reassignment.\n * \n * If the cost of this operation is negative (i.e., if this entire operation\n * saves cost), perform this operation and return the amount of cost saved;\n * otherwise, do nothing.\n */\n\n/* numcenters will be updated to reflect the new number of centers */\n/* z is the facility cost, x is the number of this point in the array \n   points */\n\ndouble pgain(long x, Points *points, double z, long int *numcenters, int pid, pthread_barrier_t* barrier)\n{\n  //  printf(""pgain pthread %d begin\n"",pid);\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n#ifdef PROFILE\n  double t0 = gettime();\n#endif\n\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n  int i;\n  int number_of_centers_to_close = 0;\n\n  static double *work_mem;\n  static double gl_cost_of_opening_x;\n  static int gl_number_of_centers_to_close;\n\n  //each thread takes a block of working_mem.\n  int stride = *numcenters+2;\n  //make stride a multiple of CACHE_LINE\n  int cl = CACHE_LINE/sizeof(double);\n  if( stride % cl != 0 ) { \n    stride = cl * ( stride / cl + 1);\n  }\n  int K = stride -2 ; // K==*numcenters\n  \n  //my own cost of opening x\n  double cost_of_opening_x = 0;\n\n  if( pid==0 )    { \n    work_mem = (double*) malloc(stride*(nproc+1)*sizeof(double));\n    gl_cost_of_opening_x = 0;\n    gl_number_of_centers_to_close = 0;\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  /*For each center, we have a *lower* field that indicates \n    how much we will save by closing the center. \n    Each thread has its own copy of the *lower* fields as an array.\n    We first build a table to index the positions of the *lower* fields. \n  */\n\n  int count = 0;\n  for( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      center_table[i] = count++;\n    }\n  }\n  work_mem[pid*stride] = count;\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  if( pid == 0 ) {\n    int accum = 0;\n    for( int p = 0; p < nproc; p++ ) {\n      int tmp = (int)work_mem[p*stride];\n      work_mem[p*stride] = accum;\n      accum += tmp;\n    }\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  for( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      center_table[i] += (int)work_mem[pid*stride];\n    }\n  }\n\n  //now we finish building the table. clear the working memory.\n  memset(switch_membership + k1, 0, (k2-k1)*sizeof(bool));\n  memset(work_mem+pid*stride, 0, stride*sizeof(double));\n  if( pid== 0 ) memset(work_mem+nproc*stride,0,stride*sizeof(double));\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n#ifdef PROFILE\n  double t1 = gettime();\n  if( pid == 0 ) time_gain_init += t1-t0;\n#endif\n  //my *lower* fields\n  double* lower = &work_mem[pid*stride];\n  //global *lower* fields\n  double* gl_lower = &work_mem[nproc*stride];\n\n  for ( i = k1; i < k2; i++ ) {\n    float x_cost = dist(points->p[i], points->p[x], points->dim) \n      * points->p[i].weight;\n    float current_cost = points->p[i].cost;\n\n    if ( x_cost < current_cost ) {\n\n      // point i would save cost just by switching to x\n      // (note that i cannot be a median, \n      // or else dist(p[i], p[x]) would be 0)\n      \n      switch_membership[i] = 1;\n      cost_of_opening_x += x_cost - current_cost;\n\n    } else {\n\n      // cost of assigning i to x is at least current assignment cost of i\n\n      // consider the savings that i's **current** median would realize\n      // if we reassigned that median and all its members to x;\n      // note we've already accounted for the fact that the median\n      // would save z by closing; now we have to subtract from the savings\n      // the extra cost of reassigning that median and its members \n      int assign = points->p[i].assign;\n      lower[center_table[assign]] += current_cost - x_cost;\n    }\n  }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  if( pid==0){\n    time_gain_dist += t2 - t1;\n  }\n#endif\n\n  // at this time, we can calculate the cost of opening a center\n  // at x; if it is negative, we'll go through with opening it\n\n  for ( int i = k1; i < k2; i++ ) {\n    if( is_center[i] ) {\n      double low = z;\n      //aggregate from all threads\n      for( int p = 0; p < nproc; p++ ) {\n	low += work_mem[center_table[i]+p*stride];\n      }\n      gl_lower[center_table[i]] = low;\n      if ( low > 0 ) {\n	// i is a median, and\n	// if we were to open x (which we still may not) we'd close i\n\n	// note, we'll ignore the following quantity unless we do open x\n	++number_of_centers_to_close;  \n	cost_of_opening_x -= low;\n      }\n    }\n  }\n  //use the rest of working memory to store the following\n  work_mem[pid*stride + K] = number_of_centers_to_close;\n  work_mem[pid*stride + K+1] = cost_of_opening_x;\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  //  printf(""thread %d cost complete\n"",pid); \n\n  if( pid==0 ) {\n    gl_cost_of_opening_x = z;\n    //aggregate\n    for( int p = 0; p < nproc; p++ ) {\n      gl_number_of_centers_to_close += (int)work_mem[p*stride + K];\n      gl_cost_of_opening_x += work_mem[p*stride+K+1];\n    }\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  // Now, check whether opening x would save cost; if so, do it, and\n  // otherwise do nothing\n\n  if ( gl_cost_of_opening_x < 0 ) {\n    //  we'd save money by opening x; we'll do it\n    for ( int i = k1; i < k2; i++ ) {\n      bool close_center = gl_lower[center_table[points->p[i].assign]] > 0 ;\n      if ( switch_membership[i] || close_center ) {\n	// Either i's median (which may be i itself) is closing,\n	// or i is closer to x than to its current median\n	points->p[i].cost = points->p[i].weight *\n	  dist(points->p[i], points->p[x], points->dim);\n	points->p[i].assign = x;\n      }\n    }\n    for( int i = k1; i < k2; i++ ) {\n      if( is_center[i] && gl_lower[center_table[i]] > 0 ) {\n	is_center[i] = false;\n      }\n    }\n    if( x >= k1 && x < k2 ) {\n      is_center[x] = true;\n    }\n    //    pthread_barrier_wait(barrier);\n\n    if( pid==0 ) {\n      *numcenters = *numcenters + 1 - gl_number_of_centers_to_close;\n    }\n  }\n  else {\n    if( pid==0 )\n      gl_cost_of_opening_x = 0;  // the value we'll return\n  }\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  if( pid == 0 ) {\n    free(work_mem);\n    //    free(is_center);\n    //    free(switch_membership);\n    //    free(proc_cost_of_opening_x);\n    //    free(proc_number_of_centers_to_close);\n  }\n\n#ifdef PROFILE\n  double t3 = gettime();\n  if( pid==0 )\n  time_gain += t3-t0;\n#endif\n  return -gl_cost_of_opening_x;\n}\n\n\n/* facility location on the points using local search */\n/* z is the facility cost, returns the total cost and # of centers */\n/* assumes we are seeded with a reasonable solution */\n/* cost should represent this solution's cost */\n/* halt if there is < e improvement after iter calls to gain */\n/* feasible is an array of numfeasible points which may be centers */\n\nfloat pFL(Points *points, int *feasible, int numfeasible,\n	  float z, long *k, double cost, long iter, float e, \n	  int pid, pthread_barrier_t* barrier)\n{\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n  long i;\n  long x;\n  double change;\n  long numberOfPoints;\n\n  change = cost;\n  /* continue until we run iter iterations without improvement */\n  /* stop instead if improvement is less than e */\n  while (change/cost > 1.0*e) {\n    change = 0.0;\n    numberOfPoints = points->num;\n    /* randomize order in which centers are considered */\n\n    if( pid == 0 ) {\n      intshuffle(feasible, numfeasible);\n    }\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n    for (i=0;i<iter;i++) {\n      x = i%numfeasible;\n      change += pgain(feasible[x], points, z, k, pid, barrier);\n    }\n\n    cost -= change;\n#ifdef PRINTINFO\n    if( pid == 0 ) {\n      fprintf(stderr, ""%d centers, cost %lf, total distance %lf\n"",\n	      *k, cost, cost - z*(*k));\n    }\n#endif\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n  }\n  return(cost);\n}\n\nint selectfeasible_fast(Points *points, int **feasible, int kmin, int pid, pthread_barrier_t* barrier)\n{\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n  int numfeasible = points->num;\n  if (numfeasible > (ITER*kmin*log((double)kmin)))\n    numfeasible = (int)(ITER*kmin*log((double)kmin));\n  *feasible = (int *)malloc(numfeasible*sizeof(int));\n  \n  float* accumweight;\n  float totalweight;\n\n  /* \n     Calcuate my block. \n     For now this routine does not seem to be the bottleneck, so it is not parallelized. \n     When necessary, this can be parallelized by setting k1 and k2 to \n     proper values and calling this routine from all threads ( it is called only\n     by thread 0 for now ). \n     Note that when parallelized, the randomization might not be the same and it might\n     not be difficult to measure the parallel speed-up for the whole program. \n   */\n  //  long bsize = numfeasible;\n  long k1 = 0;\n  long k2 = numfeasible;\n\n  float w;\n  int l,r,k;\n\n  /* not many points, all will be feasible */\n  if (numfeasible == points->num) {\n    for (int i=k1;i<k2;i++)\n      (*feasible)[i] = i;\n    return numfeasible;\n  }\n\n  accumweight= (float*)malloc(sizeof(float)*points->num);\n  accumweight[0] = points->p[0].weight;\n  totalweight=0;\n  for( int i = 1; i < points->num; i++ ) {\n    accumweight[i] = accumweight[i-1] + points->p[i].weight;\n  }\n  totalweight=accumweight[points->num-1];\n\n  for(int i=k1; i<k2; i++ ) {\n    w = (lrand48()/(float)INT_MAX)*totalweight;\n    //binary search\n    l=0;\n    r=points->num-1;\n    if( accumweight[0] > w )  { \n      (*feasible)[i]=0; \n      continue;\n    }\n    while( l+1 < r ) {\n      k = (l+r)/2;\n      if( accumweight[k] > w ) {\n	r = k;\n      } \n      else {\n	l=k;\n      }\n    }\n    (*feasible)[i]=r;\n  }\n\n  free(accumweight); \n\n#ifdef PROFILE\n  double t2 = gettime();\n  time_select_feasible += t2-t1;\n#endif\n  return numfeasible;\n}\n\n/* compute approximate kmedian on the points */\nfloat pkmedian(Points *points, long kmin, long kmax, long* kfinal,\n	       int pid, pthread_barrier_t* barrier )\n{\n  int i;\n  double cost;\n  double lastcost;\n  double hiz, loz, z;\n\n  static long k;\n  static int *feasible;\n  static int numfeasible;\n  static double* hizs;\n\n  if( pid==0 ) hizs = (double*)calloc(nproc,sizeof(double));\n  hiz = loz = 0.0;\n  long numberOfPoints = points->num;\n  long ptDimension = points->dim;\n\n  //my block\n  long bsize = points->num/nproc;\n  long k1 = bsize * pid;\n  long k2 = k1 + bsize;\n  if( pid == nproc-1 ) k2 = points->num;\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    {\n      printf(""Starting Kmedian procedure\n"");\n      printf(""%i points in %i dimensions\n"", numberOfPoints, ptDimension);\n    }\n#endif\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  double myhiz = 0;\n  for (long kk=k1;kk < k2; kk++ ) {\n    myhiz += dist(points->p[kk], points->p[0],\n		      ptDimension)*points->p[kk].weight;\n  }\n  hizs[pid] = myhiz;\n\n#ifdef ENABLE_THREADS  \n  pthread_barrier_wait(barrier);\n#endif\n\n  for( int i = 0; i < nproc; i++ )   {\n    hiz += hizs[i];\n  }\n\n  loz=0.0; z = (hiz+loz)/2.0;\n  /* NEW: Check whether more centers than points! */\n  if (points->num <= kmax) {\n    /* just return all points as facilities */\n    for (long kk=k1;kk<k2;kk++) {\n      points->p[kk].assign = kk;\n      points->p[kk].cost = 0;\n    }\n    cost = 0;\n    if( pid== 0 ) {\n      free(hizs); \n      *kfinal = k;\n    }\n    return cost;\n  }\n\n  if( pid == 0 ) shuffle(points);\n  cost = pspeedy(points, z, &k, pid, barrier);\n\n#ifdef PRINTINFO\n  if( pid == 0 )\n    printf(""thread %d: Finished first call to speedy, cost=%lf, k=%i\n"",pid,cost,k);\n#endif\n  i=0;\n  /* give speedy SP chances to get at least kmin/2 facilities */\n  while ((k < kmin)&&(i<SP)) {\n    cost = pspeedy(points, z, &k, pid, barrier);\n    i++;\n  }\n\n#ifdef PRINTINFO\n  if( pid==0)\n    printf(""thread %d: second call to speedy, cost=%lf, k=%d\n"",pid,cost,k);\n#endif \n  /* if still not enough facilities, assume z is too high */\n  while (k < kmin) {\n#ifdef PRINTINFO\n    if( pid == 0 ) {\n      printf(""%lf %lf\n"", loz, hiz);\n      printf(""Speedy indicates we should try lower z\n"");\n    }\n#endif\n    if (i >= SP) {hiz=z; z=(hiz+loz)/2.0; i=0;}\n    if( pid == 0 ) shuffle(points);\n    cost = pspeedy(points, z, &k, pid, barrier);\n    i++;\n  }\n\n  /* now we begin the binary search for real */\n  /* must designate some points as feasible centers */\n  /* this creates more consistancy between FL runs */\n  /* helps to guarantee correct # of centers at the end */\n  \n  if( pid == 0 )\n    {\n      numfeasible = selectfeasible_fast(points,&feasible,kmin,pid,barrier);\n      for( int i = 0; i< points->num; i++ ) {\n	is_center[points->p[i].assign]= true;\n      }\n    }\n\n#ifdef ENABLE_THREADS\n  pthread_barrier_wait(barrier);\n#endif\n\n  while(1) {\n#ifdef PRINTINFO\n    if( pid==0 )\n      {\n	printf(""loz = %lf, hiz = %lf\n"", loz, hiz);\n	printf(""Running Local Search...\n"");\n      }\n#endif\n    /* first get a rough estimate on the FL solution */\n    //    pthread_barrier_wait(barrier);\n\n    lastcost = cost;\n    cost = pFL(points, feasible, numfeasible,\n	       z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.1, pid, barrier);\n\n    /* if number of centers seems good, try a more accurate FL */\n    if (((k <= (1.1)*kmax)&&(k >= (0.9)*kmin))||\n	((k <= kmax+2)&&(k >= kmin-2))) {\n\n#ifdef PRINTINFO\n      if( pid== 0)\n	{\n	  printf(""Trying a more accurate local search...\n"");\n	}\n#endif\n      /* may need to run a little longer here before halting without\n	 improvement */\n      cost = pFL(points, feasible, numfeasible,\n		 z, &k, cost, (long)(ITER*kmax*log((double)kmax)), 0.001, pid, barrier);\n    }\n\n    if (k > kmax) {\n      /* facilities too cheap */\n      /* increase facility cost and up the cost accordingly */\n      loz = z; z = (hiz+loz)/2.0;\n      cost += (z-loz)*k;\n    }\n    if (k < kmin) {\n      /* facilities too expensive */\n      /* decrease facility cost and reduce the cost accordingly */\n      hiz = z; z = (hiz+loz)/2.0;\n      cost += (z-hiz)*k;\n    }\n\n    /* if k is good, return the result */\n    /* if we're stuck, just give up and return what we have */\n    if (((k <= kmax)&&(k >= kmin))||((loz >= (0.999)*hiz)) )\n      { \n	break;\n      }\n#ifdef ENABLE_THREADS\n    pthread_barrier_wait(barrier);\n#endif\n  }\n\n  //clean up...\n  if( pid==0 ) {\n    free(feasible); \n    free(hizs);\n    *kfinal = k;\n  }\n\n  return cost;\n}\n\n/* compute the means for the k clusters */\nint contcenters(Points *points)\n{\n  long i, ii;\n  float relweight;\n\n  for (i=0;i<points->num;i++) {\n    /* compute relative weight of this point to the cluster */\n    if (points->p[i].assign != i) {\n      relweight=points->p[points->p[i].assign].weight + points->p[i].weight;\n      relweight = points->p[i].weight/relweight;\n      for (ii=0;ii<points->dim;ii++) {\n	points->p[points->p[i].assign].coord[ii]*=1.0-relweight;\n	points->p[points->p[i].assign].coord[ii]+=\n	  points->p[i].coord[ii]*relweight;\n      }\n      points->p[points->p[i].assign].weight += points->p[i].weight;\n    }\n  }\n  \n  return 0;\n}\n\n/* copy centers from points to centers */\nvoid copycenters(Points *points, Points* centers, long* centerIDs, long offset)\n{\n  long i;\n  long k;\n\n  bool *is_a_median = (bool *) calloc(points->num, sizeof(bool));\n\n  /* mark the centers */\n  for ( i = 0; i < points->num; i++ ) {\n    is_a_median[points->p[i].assign] = 1;\n  }\n\n  k=centers->num;\n\n  /* count how many  */\n  for ( i = 0; i < points->num; i++ ) {\n    if ( is_a_median[i] ) {\n      memcpy( centers->p[k].coord, points->p[i].coord, points->dim * sizeof(float));\n      centers->p[k].weight = points->p[i].weight;\n      centerIDs[k] = i + offset;\n      k++;\n    }\n  }\n\n  centers->num = k;\n\n  free(is_a_median);\n}\n\nstruct pkmedian_arg_t\n{\n  Points* points;\n  long kmin;\n  long kmax;\n  long* kfinal;\n  int pid;\n  pthread_barrier_t* barrier;\n};\n\nvoid* localSearchSub(void* arg_) {\n\n  pkmedian_arg_t* arg= (pkmedian_arg_t*)arg_;\n  pkmedian(arg->points,arg->kmin,arg->kmax,arg->kfinal,arg->pid,arg->barrier);\n\n  return NULL;\n}\n\nvoid localSearch( Points* points, long kmin, long kmax, long* kfinal ) {\n#ifdef PROFILE\n  double t1 = gettime();\n#endif\n\n    pthread_barrier_t barrier;\n#ifdef ENABLE_THREADS\n    pthread_barrier_init(&barrier,NULL,nproc);\n#endif\n    pthread_t* threads = new pthread_t[nproc];\n    pkmedian_arg_t* arg = new pkmedian_arg_t[nproc];\n\n\n    for( int i = 0; i < nproc; i++ ) {\n      arg[i].points = points;\n      arg[i].kmin = kmin;\n      arg[i].kmax = kmax;\n      arg[i].pid = i;\n      arg[i].kfinal = kfinal;\n\n      arg[i].barrier = &barrier;\n#ifdef ENABLE_THREADS\n      pthread_create(threads+i,NULL,localSearchSub,(void*)&arg[i]);\n#else\n      localSearchSub(&arg[0]);\n#endif\n    }\n\n    for ( int i = 0; i < nproc; i++) {\n#ifdef ENABLE_THREADS\n      pthread_join(threads[i],NULL);\n#endif\n    }\n\n    delete[] threads;\n    delete[] arg;\n#ifdef ENABLE_THREADS\n    pthread_barrier_destroy(&barrier);\n#endif\n\n#ifdef PROFILE\n  double t2 = gettime();\n  time_local_search += t2-t1;\n#endif\n \n}\n\nclass PStream {\npublic:\n  virtual size_t read( float* dest, int dim, int num ) = 0;\n  virtual int ferror() = 0;\n  virtual int feof() = 0;\n  virtual ~PStream() {\n  }\n};\n\n//synthetic stream\nclass SimStream : public PStream {\npublic:\n  SimStream(long n_ ) {\n    n = n_;\n  }\n  size_t read( float* dest, int dim, int num ) {\n    size_t count = 0;\n    for( int i = 0; i < num && n > 0; i++ ) {\n      for( int k = 0; k < dim; k++ ) {\n	dest[i*dim + k] = lrand48()/(float)INT_MAX;\n      }\n      n--;\n      count++;\n    }\n    return count;\n  }\n  int ferror() {\n    return 0;\n  }\n  int feof() {\n    return n <= 0;\n  }\n  ~SimStream() { \n  }\nprivate:\n  long n;\n};\n\nclass FileStream : public PStream {\npublic:\n  FileStream(char* filename) {\n    fp = fopen( filename, ""rb"");\n    if( fp == NULL ) {\n      fprintf(stderr,""error opening file %s\n."",filename);\n      exit(1);\n    }\n  }\n  size_t read( float* dest, int dim, int num ) {\n    return std::fread(dest, sizeof(float)*dim, num, fp); \n  }\n  int ferror() {\n    return std::ferror(fp);\n  }\n  int feof() {\n    return std::feof(fp);\n  }\n  ~FileStream() {\n    printf(""closing file stream\n"");\n    fclose(fp);\n  }\nprivate:\n  FILE* fp;\n};\n\nvoid outcenterIDs( Points* centers, long* centerIDs, char* outfile ) {\n  FILE* fp = fopen(outfile, ""w"");\n  if( fp==NULL ) {\n    fprintf(stderr, ""error opening %s\n"",outfile);\n    exit(1);\n  }\n  int* is_a_median = (int*)calloc( sizeof(int), centers->num );\n  for( int i =0 ; i< centers->num; i++ ) {\n    is_a_median[centers->p[i].assign] = 1;\n  }\n\n  for( int i = 0; i < centers->num; i++ ) {\n    if( is_a_median[i] ) {\n      fprintf(fp, ""%u\n"", centerIDs[i]);\n      fprintf(fp, ""%lf\n"", centers->p[i].weight);\n      for( int k = 0; k < centers->dim; k++ ) {\n	fprintf(fp, ""%lf "", centers->p[i].coord[k]);\n      }\n      fprintf(fp,""\n\n"");\n    }\n  }\n  fclose(fp);\n}\n\nvoid streamCluster( PStream* stream, \n		    long kmin, long kmax, int dim,\n		    long chunksize, long centersize, char* outfile )\n{\n  float* block = (float*)malloc( chunksize*dim*sizeof(float) );\n  float* centerBlock = (float*)malloc(centersize*dim*sizeof(float) );\n  long* centerIDs = (long*)malloc(centersize*dim*sizeof(long));\n\n  if( block == NULL ) { \n    fprintf(stderr,""not enough memory for a chunk!\n"");\n    exit(1);\n  }\n\n  Points points;\n  points.dim = dim;\n  points.num = chunksize;\n  points.p = (Point *)malloc(chunksize*sizeof(Point));\n  for( int i = 0; i < chunksize; i++ ) {\n    points.p[i].coord = &block[i*dim];\n  }\n\n  Points centers;\n  centers.dim = dim;\n  centers.p = (Point *)malloc(centersize*sizeof(Point));\n  centers.num = 0;\n\n  for( int i = 0; i< centersize; i++ ) {\n    centers.p[i].coord = &centerBlock[i*dim];\n    centers.p[i].weight = 1.0;\n  }\n\n  long IDoffset = 0;\n  long kfinal;\n  while(1) {\n\n    size_t numRead  = stream->read(block, dim, chunksize ); \n    fprintf(stderr,""read %d points\n"",numRead);\n\n    if( stream->ferror() || numRead < (unsigned int)chunksize && !stream->feof() ) {\n      fprintf(stderr, ""error reading data!\n"");\n      exit(1);\n    }\n\n    points.num = numRead;\n    for( int i = 0; i < points.num; i++ ) {\n      points.p[i].weight = 1.0;\n    }\n\n    switch_membership = (bool*)malloc(points.num*sizeof(bool));\n    is_center = (bool*)calloc(points.num,sizeof(bool));\n    center_table = (int*)malloc(points.num*sizeof(int));\n\n    localSearch(&points,kmin, kmax,&kfinal);\n\n    fprintf(stderr,""finish local search\n"");\n    contcenters(&points);\n    if( kfinal + centers.num > centersize ) {\n      //here we don't handle the situation where # of centers gets too large. \n      fprintf(stderr,""oops! no more space for centers\n"");\n      exit(1);\n    }\n\n#ifdef PRINTINFO\n    printf(""finish cont center\n"");\n#endif\n\n    copycenters(&points, &centers, centerIDs, IDoffset);\n    IDoffset += numRead;\n\n#ifdef PRINTINFO\n    printf(""finish copy centers\n""); \n#endif\n\n    free(is_center);\n    free(switch_membership);\n    free(center_table);\n\n    if( stream->feof() ) {\n      break;\n    }\n  }\n\n  //finally cluster all temp centers\n  switch_membership = (bool*)malloc(centers.num*sizeof(bool));\n  is_center = (bool*)calloc(centers.num,sizeof(bool));\n  center_table = (int*)malloc(centers.num*sizeof(int));\n\n  localSearch( &centers, kmin, kmax ,&kfinal );\n  contcenters(&centers);\n  outcenterIDs( &centers, centerIDs, outfile);\n}\n\nint main(int argc, char **argv)\n{\n  char *outfilename = new char[MAXNAMESIZE];\n  char *infilename = new char[MAXNAMESIZE];\n  long kmin, kmax, n, chunksize, clustersize;\n  int dim;\n\n#ifdef PARSEC_VERSION\n#define __PARSEC_STRING(x) #x\n#define __PARSEC_XSTRING(x) __PARSEC_STRING(x)\n        printf(""PARSEC Benchmark Suite Version ""__PARSEC_XSTRING(PARSEC_VERSION)""\n"");\n	fflush(NULL);\n#else\n        printf(""PARSEC Benchmark Suite\n"");\n	fflush(NULL);\n#endif //PARSEC_VERSION\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_bench_begin(__parsec_streamcluster);\n#endif\n\n  if (argc<10) {\n    fprintf(stderr,""usage: %s k1 k2 d n chunksize clustersize infile outfile nproc\n"",\n	    argv[0]);\n    fprintf(stderr,""  k1:          Min. number of centers allowed\n"");\n    fprintf(stderr,""  k2:          Max. number of centers allowed\n"");\n    fprintf(stderr,""  d:           Dimension of each data point\n"");\n    fprintf(stderr,""  n:           Number of data points\n"");\n    fprintf(stderr,""  chunksize:   Number of data points to handle per step\n"");\n    fprintf(stderr,""  clustersize: Maximum number of intermediate centers\n"");\n    fprintf(stderr,""  infile:      Input file (if n<=0)\n"");\n    fprintf(stderr,""  outfile:     Output file\n"");\n    fprintf(stderr,""  nproc:       Number of threads to use\n"");\n    fprintf(stderr,""\n"");\n    fprintf(stderr, ""if n > 0, points will be randomly generated instead of reading from infile.\n"");\n    exit(1);\n  }\n  kmin = atoi(argv[1]);\n  kmax = atoi(argv[2]);\n  dim = atoi(argv[3]);\n  n = atoi(argv[4]);\n  chunksize = atoi(argv[5]);\n  clustersize = atoi(argv[6]);\n  strcpy(infilename, argv[7]);\n  strcpy(outfilename, argv[8]);\n  nproc = atoi(argv[9]);\n\n  srand48(SEED);\n  PStream* stream;\n  if( n > 0 ) {\n    stream = new SimStream(n);\n  }\n  else {\n    stream = new FileStream(infilename);\n  }\n\n  double t1 = gettime();\n\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_roi_begin();\n#endif\n  streamCluster(stream, kmin, kmax, dim, chunksize, clustersize, outfilename );\n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_roi_end();\n#endif\n\n  double t2 = gettime();\n\n  printf(""time = %lf\n"",t2-t1);\n\n  delete stream;\n#ifdef PROFILE\n  printf(""time pgain = %lf\n"", time_gain);\n  printf(""time pgain_dist = %lf\n"", time_gain_dist);\n  printf(""time pgain_init = %lf\n"", time_gain_init);\n  printf(""time pselect = %lf\n"", time_select_feasible);\n  printf(""time pspeedy = %lf\n"", time_speedy);\n  printf(""time pshuffle = %lf\n"", time_shuffle);\n  printf(""time localSearch = %lf\n"", time_local_search);\n #endif\n  \n#ifdef ENABLE_PARSEC_HOOKS\n  __parsec_bench_end();\n#endif\n  \n  return 0;\n}\n"
particlefilter/ex_particle_OPENMP_seq.c,"/**\n * @file ex_particle_OPENMP_seq.c\n * @author Michael Trotter & Matt Goodrum\n * @brief Particle filter implementation in C/OpenMP \n */\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI 3.1415926535897932\n/**\n@var M value for Linear Congruential Generator (LCG); use GCC's value\n*/\nlong M = INT_MAX;\n/**\n@var A value for LCG\n*/\nint A = 1103515245;\n/**\n@var C value for LCG\n*/\nint C = 12345;\n/*****************************\n*GET_TIME\n*returns a long int representing the time\n*****************************/\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n// Returns the number of seconds elapsed between the two specified times\nfloat elapsed_time(long long start_time, long long end_time) {\n        return (float) (end_time - start_time) / (1000 * 1000);\n}\n/** \n* Takes in a double and returns an integer that approximates to that double\n* @return if the mantissa < .5 => return value < input value; else return value > input value\n*/\ndouble roundDouble(double value){\n	int newValue = (int)(value);\n	if(value - newValue < .5)\n	return newValue;\n	else\n	return newValue++;\n}\n/**\n* Set values of the 3D array to a newValue if that value is equal to the testValue\n* @param testValue The value to be replaced\n* @param newValue The value to replace testValue with\n* @param array3D The image vector\n* @param dimX The x dimension of the frame\n* @param dimY The y dimension of the frame\n* @param dimZ The number of frames\n*/\nvoid setIf(int testValue, int newValue, int * array3D, int * dimX, int * dimY, int * dimZ){\n	int x, y, z;\n	for(x = 0; x < *dimX; x++){\n		for(y = 0; y < *dimY; y++){\n			for(z = 0; z < *dimZ; z++){\n				if(array3D[x * *dimY * *dimZ+y * *dimZ + z] == testValue)\n				array3D[x * *dimY * *dimZ + y * *dimZ + z] = newValue;\n			}\n		}\n	}\n}\n/**\n* Generates a uniformly distributed random number using the provided seed and GCC's settings for the Linear Congruential Generator (LCG)\n* @see http://en.wikipedia.org/wiki/Linear_congruential_generator\n* @note This function is thread-safe\n* @param seed The seed array\n* @param index The specific index of the seed to be advanced\n* @return a uniformly distributed number [0, 1)\n*/\ndouble randu(int * seed, int index)\n{\n	int num = A*seed[index] + C;\n	seed[index] = num % M;\n	return fabs(seed[index]/((double) M));\n}\n/**\n* Generates a normally distributed random number using the Box-Muller transformation\n* @note This function is thread-safe\n* @param seed The seed array\n* @param index The specific index of the seed to be advanced\n* @return a double representing random number generated using the Box-Muller algorithm\n* @see http://en.wikipedia.org/wiki/Normal_distribution, section computing value for normal random distribution\n*/\ndouble randn(int * seed, int index){\n	/*Box-Muller algorithm*/\n	double u = randu(seed, index);\n	double v = randu(seed, index);\n	double cosine = cos(2*PI*v);\n	double rt = -2*log(u);\n	return sqrt(rt)*cosine;\n}\n/**\n* Sets values of 3D matrix using randomly generated numbers from a normal distribution\n* @param array3D The video to be modified\n* @param dimX The x dimension of the frame\n* @param dimY The y dimension of the frame\n* @param dimZ The number of frames\n* @param seed The seed array\n*/\nvoid addNoise(int * array3D, int * dimX, int * dimY, int * dimZ, int * seed){\n	int x, y, z;\n	for(x = 0; x < *dimX; x++){\n		for(y = 0; y < *dimY; y++){\n			for(z = 0; z < *dimZ; z++){\n				array3D[x * *dimY * *dimZ + y * *dimZ + z] = array3D[x * *dimY * *dimZ + y * *dimZ + z] + (int)(5*randn(seed, 0));\n			}\n		}\n	}\n}\n/**\n* Fills a radius x radius matrix representing the disk\n* @param disk The pointer to the disk to be made\n* @param radius  The radius of the disk to be made\n*/\nvoid strelDisk(int * disk, int radius)\n{\n	int diameter = radius*2 - 1;\n	int x, y;\n	for(x = 0; x < diameter; x++){\n		for(y = 0; y < diameter; y++){\n			double distance = sqrt(pow((double)(x-radius+1),2) + pow((double)(y-radius+1),2));\n			if(distance < radius)\n			disk[x*diameter + y] = 1;\n		}\n	}\n}\n/**\n* Dilates the provided video\n* @param matrix The video to be dilated\n* @param posX The x location of the pixel to be dilated\n* @param posY The y location of the pixel to be dilated\n* @param poxZ The z location of the pixel to be dilated\n* @param dimX The x dimension of the frame\n* @param dimY The y dimension of the frame\n* @param dimZ The number of frames\n* @param error The error radius\n*/\nvoid dilate_matrix(int * matrix, int posX, int posY, int posZ, int dimX, int dimY, int dimZ, int error)\n{\n	int startX = posX - error;\n	while(startX < 0)\n	startX++;\n	int startY = posY - error;\n	while(startY < 0)\n	startY++;\n	int endX = posX + error;\n	while(endX > dimX)\n	endX--;\n	int endY = posY + error;\n	while(endY > dimY)\n	endY--;\n	int x,y;\n	for(x = startX; x < endX; x++){\n		for(y = startY; y < endY; y++){\n			double distance = sqrt( pow((double)(x-posX),2) + pow((double)(y-posY),2) );\n			if(distance < error)\n			matrix[x*dimY*dimZ + y*dimZ + posZ] = 1;\n		}\n	}\n}\n\n/**\n* Dilates the target matrix using the radius as a guide\n* @param matrix The reference matrix\n* @param dimX The x dimension of the video\n* @param dimY The y dimension of the video\n* @param dimZ The z dimension of the video\n* @param error The error radius to be dilated\n* @param newMatrix The target matrix\n*/\nvoid imdilate_disk(int * matrix, int dimX, int dimY, int dimZ, int error, int * newMatrix)\n{\n	int x, y, z;\n	for(z = 0; z < dimZ; z++){\n		for(x = 0; x < dimX; x++){\n			for(y = 0; y < dimY; y++){\n				if(matrix[x*dimY*dimZ + y*dimZ + z] == 1){\n					dilate_matrix(newMatrix, x, y, z, dimX, dimY, dimZ, error);\n				}\n			}\n		}\n	}\n}\n/**\n* Fills a 2D array describing the offsets of the disk object\n* @param se The disk object\n* @param numOnes The number of ones in the disk\n* @param neighbors The array that will contain the offsets\n* @param radius The radius used for dilation\n*/\nvoid getneighbors(int * se, int numOnes, double * neighbors, int radius){\n	int x, y;\n	int neighY = 0;\n	int center = radius - 1;\n	int diameter = radius*2 -1;\n	for(x = 0; x < diameter; x++){\n		for(y = 0; y < diameter; y++){\n			if(se[x*diameter + y]){\n				neighbors[neighY*2] = (int)(y - center);\n				neighbors[neighY*2 + 1] = (int)(x - center);\n				neighY++;\n			}\n		}\n	}\n}\n/**\n* The synthetic video sequence we will work with here is composed of a\n* single moving object, circular in shape (fixed radius)\n* The motion here is a linear motion\n* the foreground intensity and the backgrounf intensity is known\n* the image is corrupted with zero mean Gaussian noise\n* @param I The video itself\n* @param IszX The x dimension of the video\n* @param IszY The y dimension of the video\n* @param Nfr The number of frames of the video\n* @param seed The seed array used for number generation\n*/\nvoid videoSequence(int * I, int IszX, int IszY, int Nfr, int * seed){\n	int k;\n	int max_size = IszX*IszY*Nfr;\n	/*get object centers*/\n	int x0 = (int)roundDouble(IszY/2.0);\n	int y0 = (int)roundDouble(IszX/2.0);\n	I[x0 *IszY *Nfr + y0 * Nfr  + 0] = 1;\n	\n	/*move point*/\n	int xk, yk, pos;\n	for(k = 1; k < Nfr; k++){\n		xk = abs(x0 + (k-1));\n		yk = abs(y0 - 2*(k-1));\n		pos = yk * IszY * Nfr + xk *Nfr + k;\n		if(pos >= max_size)\n		pos = 0;\n		I[pos] = 1;\n	}\n	\n	/*dilate matrix*/\n	int * newMatrix = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);\n	imdilate_disk(I, IszX, IszY, Nfr, 5, newMatrix);\n	int x, y;\n	for(x = 0; x < IszX; x++){\n		for(y = 0; y < IszY; y++){\n			for(k = 0; k < Nfr; k++){\n				I[x*IszY*Nfr + y*Nfr + k] = newMatrix[x*IszY*Nfr + y*Nfr + k];\n			}\n		}\n	}\n	free(newMatrix);\n	\n	/*define background, add noise*/\n	setIf(0, 100, I, &IszX, &IszY, &Nfr);\n	setIf(1, 228, I, &IszX, &IszY, &Nfr);\n	/*add noise*/\n	addNoise(I, &IszX, &IszY, &Nfr, seed);\n}\n/**\n* Determines the likelihood sum based on the formula: SUM( (IK[IND] - 100)^2 - (IK[IND] - 228)^2)/ 100\n* @param I The 3D matrix\n* @param ind The current ind array\n* @param numOnes The length of ind array\n* @return A double representing the sum\n*/\ndouble calcLikelihoodSum(int * I, int * ind, int numOnes){\n	double likelihoodSum = 0.0;\n	int y;\n	for(y = 0; y < numOnes; y++)\n	likelihoodSum += (pow((I[ind[y]] - 100),2) - pow((I[ind[y]]-228),2))/50.0;\n	return likelihoodSum;\n}\n/**\n* Finds the first element in the CDF that is greater than or equal to the provided value and returns that index\n* @note This function uses sequential search\n* @param CDF The CDF\n* @param lengthCDF The length of CDF\n* @param value The value to be found\n* @return The index of value in the CDF; if value is never found, returns the last index\n*/\nint findIndex(double * CDF, int lengthCDF, double value){\n	int index = -1;\n	int x;\n	for(x = 0; x < lengthCDF; x++){\n		if(CDF[x] >= value){\n			index = x;\n			break;\n		}\n	}\n	if(index == -1){\n		return lengthCDF-1;\n	}\n	return index;\n}\n/**\n* Finds the first element in the CDF that is greater than or equal to the provided value and returns that index\n* @note This function uses binary search before switching to sequential search\n* @param CDF The CDF\n* @param beginIndex The index to start searching from\n* @param endIndex The index to stop searching\n* @param value The value to find\n* @return The index of value in the CDF; if value is never found, returns the last index\n* @warning Use at your own risk; not fully tested\n*/\nint findIndexBin(double * CDF, int beginIndex, int endIndex, double value){\n	if(endIndex < beginIndex)\n	return -1;\n	int middleIndex = beginIndex + ((endIndex - beginIndex)/2);\n	/*check the value*/\n	if(CDF[middleIndex] >= value)\n	{\n		/*check that it's good*/\n		if(middleIndex == 0)\n		return middleIndex;\n		else if(CDF[middleIndex-1] < value)\n		return middleIndex;\n		else if(CDF[middleIndex-1] == value)\n		{\n			while(middleIndex > 0 && CDF[middleIndex-1] == value)\n			middleIndex--;\n			return middleIndex;\n		}\n	}\n	if(CDF[middleIndex] > value)\n	return findIndexBin(CDF, beginIndex, middleIndex+1, value);\n	return findIndexBin(CDF, middleIndex-1, endIndex, value);\n}\n/**\n* The implementation of the particle filter using OpenMP for many frames\n* @see http://openmp.org/wp/\n* @note This function is designed to work with a video of several frames. In addition, it references a provided MATLAB function which takes the video, the objxy matrix and the x and y arrays as arguments and returns the likelihoods\n* @param I The video to be run\n* @param IszX The x dimension of the video\n* @param IszY The y dimension of the video\n* @param Nfr The number of frames\n* @param seed The seed array used for random number generation\n* @param Nparticles The number of particles to be used\n*/\nvoid particleFilter(int * I, int IszX, int IszY, int Nfr, int * seed, int Nparticles){\n	\n	int max_size = IszX*IszY*Nfr;\n	long long start = get_time();\n	//original particle centroid\n	double xe = roundDouble(IszY/2.0);\n	double ye = roundDouble(IszX/2.0);\n	\n	//expected object locations, compared to center\n	int radius = 5;\n	int diameter = radius*2 - 1;\n	int * disk = (int *)malloc(diameter*diameter*sizeof(int));\n	strelDisk(disk, radius);\n	int countOnes = 0;\n	int x, y;\n	for(x = 0; x < diameter; x++){\n		for(y = 0; y < diameter; y++){\n			if(disk[x*diameter + y] == 1)\n				countOnes++;\n		}\n	}\n	double * objxy = (double *)malloc(countOnes*2*sizeof(double));\n	getneighbors(disk, countOnes, objxy, radius);\n	\n	long long get_neighbors = get_time();\n	printf(""TIME TO GET NEIGHBORS TOOK: %f\n"", elapsed_time(start, get_neighbors));\n	//initial weights are all equal (1/Nparticles)\n	double * weights = (double *)malloc(sizeof(double)*Nparticles);\n	#pragma omp parallel for shared(weights, Nparticles) private(x)\n	for(x = 0; x < Nparticles; x++){\n		weights[x] = 1/((double)(Nparticles));\n	}\n	long long get_weights = get_time();\n	printf(""TIME TO GET WEIGHTSTOOK: %f\n"", elapsed_time(get_neighbors, get_weights));\n	//initial likelihood to 0.0\n	double * likelihood = (double *)malloc(sizeof(double)*Nparticles);\n	double * arrayX = (double *)malloc(sizeof(double)*Nparticles);\n	double * arrayY = (double *)malloc(sizeof(double)*Nparticles);\n	double * xj = (double *)malloc(sizeof(double)*Nparticles);\n	double * yj = (double *)malloc(sizeof(double)*Nparticles);\n	double * CDF = (double *)malloc(sizeof(double)*Nparticles);\n	double * u = (double *)malloc(sizeof(double)*Nparticles);\n	int * ind = (int*)malloc(sizeof(int)*countOnes*Nparticles);\n	#pragma omp parallel for shared(arrayX, arrayY, xe, ye) private(x)\n	for(x = 0; x < Nparticles; x++){\n		arrayX[x] = xe;\n		arrayY[x] = ye;\n	}\n	int k;\n	\n	printf(""TIME TO SET ARRAYS TOOK: %f\n"", elapsed_time(get_weights, get_time()));\n	int indX, indY;\n	for(k = 1; k < Nfr; k++){\n		long long set_arrays = get_time();\n		//apply motion model\n		//draws sample from motion model (random walk). The only prior information\n		//is that the object moves 2x as fast as in the y direction\n		#pragma omp parallel for shared(arrayX, arrayY, Nparticles, seed) private(x)\n		for(x = 0; x < Nparticles; x++){\n			arrayX[x] += 1 + 5*randn(seed, x);\n			arrayY[x] += -2 + 2*randn(seed, x);\n		}\n		long long error = get_time();\n		printf(""TIME TO SET ERROR TOOK: %f\n"", elapsed_time(set_arrays, error));\n		//particle filter likelihood\n		#pragma omp parallel for shared(likelihood, I, arrayX, arrayY, objxy, ind) private(x, y, indX, indY)\n		for(x = 0; x < Nparticles; x++){\n			//compute the likelihood: remember our assumption is that you know\n			// foreground and the background image intensity distribution.\n			// Notice that we consider here a likelihood ratio, instead of\n			// p(z|x). It is possible in this case. why? a hometask for you.		\n			//calc ind\n			for(y = 0; y < countOnes; y++){\n				indX = roundDouble(arrayX[x]) + objxy[y*2 + 1];\n				indY = roundDouble(arrayY[x]) + objxy[y*2];\n				ind[x*countOnes + y] = fabs(indX*IszY*Nfr + indY*Nfr + k);\n				if(ind[x*countOnes + y] >= max_size)\n					ind[x*countOnes + y] = 0;\n			}\n			likelihood[x] = 0;\n			for(y = 0; y < countOnes; y++)\n				likelihood[x] += (pow((I[ind[x*countOnes + y]] - 100),2) - pow((I[ind[x*countOnes + y]]-228),2))/50.0;\n			likelihood[x] = likelihood[x]/((double) countOnes);\n		}\n		long long likelihood_time = get_time();\n		printf(""TIME TO GET LIKELIHOODS TOOK: %f\n"", elapsed_time(error, likelihood_time));\n		// update & normalize weights\n		// using equation (63) of Arulampalam Tutorial\n		#pragma omp parallel for shared(Nparticles, weights, likelihood) private(x)\n		for(x = 0; x < Nparticles; x++){\n			weights[x] = weights[x] * exp(likelihood[x]);\n		}\n		long long exponential = get_time();\n		printf(""TIME TO GET EXP TOOK: %f\n"", elapsed_time(likelihood_time, exponential));\n		double sumWeights = 0;\n		#pragma omp parallel for private(x) reduction(+:sumWeights)\n		for(x = 0; x < Nparticles; x++){\n			sumWeights += weights[x];\n		}\n		long long sum_time = get_time();\n		printf(""TIME TO SUM WEIGHTS TOOK: %f\n"", elapsed_time(exponential, sum_time));\n		#pragma omp parallel for shared(sumWeights, weights) private(x)\n		for(x = 0; x < Nparticles; x++){\n			weights[x] = weights[x]/sumWeights;\n		}\n		long long normalize = get_time();\n		printf(""TIME TO NORMALIZE WEIGHTS TOOK: %f\n"", elapsed_time(sum_time, normalize));\n		xe = 0;\n		ye = 0;\n		// estimate the object location by expected values\n		#pragma omp parallel for private(x) reduction(+:xe, ye)\n		for(x = 0; x < Nparticles; x++){\n			xe += arrayX[x] * weights[x];\n			ye += arrayY[x] * weights[x];\n		}\n		long long move_time = get_time();\n		printf(""TIME TO MOVE OBJECT TOOK: %f\n"", elapsed_time(normalize, move_time));\n		printf(""XE: %lf\n"", xe);\n		printf(""YE: %lf\n"", ye);\n		double distance = sqrt( pow((double)(xe-(int)roundDouble(IszY/2.0)),2) + pow((double)(ye-(int)roundDouble(IszX/2.0)),2) );\n		printf(""%lf\n"", distance);\n		//display(hold off for now)\n		\n		//pause(hold off for now)\n		\n		//resampling\n		\n		\n		CDF[0] = weights[0];\n		for(x = 1; x < Nparticles; x++){\n			CDF[x] = weights[x] + CDF[x-1];\n		}\n		long long cum_sum = get_time();\n		printf(""TIME TO CALC CUM SUM TOOK: %f\n"", elapsed_time(move_time, cum_sum));\n		double u1 = (1/((double)(Nparticles)))*randu(seed, 0);\n		#pragma omp parallel for shared(u, u1, Nparticles) private(x)\n		for(x = 0; x < Nparticles; x++){\n			u[x] = u1 + x/((double)(Nparticles));\n		}\n		long long u_time = get_time();\n		printf(""TIME TO CALC U TOOK: %f\n"", elapsed_time(cum_sum, u_time));\n		int j, i;\n		\n		#pragma omp parallel for shared(CDF, Nparticles, xj, yj, u, arrayX, arrayY) private(i, j)\n		for(j = 0; j < Nparticles; j++){\n			i = findIndex(CDF, Nparticles, u[j]);\n			if(i == -1)\n				i = Nparticles-1;\n			xj[j] = arrayX[i];\n			yj[j] = arrayY[i];\n			\n		}\n		long long xyj_time = get_time();\n		printf(""TIME TO CALC NEW ARRAY X AND Y TOOK: %f\n"", elapsed_time(u_time, xyj_time));\n		\n		//#pragma omp parallel for shared(weights, Nparticles) private(x)\n		for(x = 0; x < Nparticles; x++){\n			//reassign arrayX and arrayY\n			arrayX[x] = xj[x];\n			arrayY[x] = yj[x];\n			weights[x] = 1/((double)(Nparticles));\n		}\n		long long reset = get_time();\n		printf(""TIME TO RESET WEIGHTS TOOK: %f\n"", elapsed_time(xyj_time, reset));\n	}\n	free(disk);\n	free(objxy);\n	free(weights);\n	free(likelihood);\n	free(xj);\n	free(yj);\n	free(arrayX);\n	free(arrayY);\n	free(CDF);\n	free(u);\n	free(ind);\n}\nint main(int argc, char * argv[]){\n	\n	char* usage = ""openmp.out -x <dimX> -y <dimY> -z <Nfr> -np <Nparticles>"";\n	//check number of arguments\n	if(argc != 9)\n	{\n		printf(""%s\n"", usage);\n		return 0;\n	}\n	//check args deliminators\n	if( strcmp( argv[1], ""-x"" ) ||  strcmp( argv[3], ""-y"" ) || strcmp( argv[5], ""-z"" ) || strcmp( argv[7], ""-np"" ) ) {\n		printf( ""%s\n"",usage );\n		return 0;\n	}\n	\n	int IszX, IszY, Nfr, Nparticles;\n	\n	//converting a string to a integer\n	if( sscanf( argv[2], ""%d"", &IszX ) == EOF ) {\n	   printf(""ERROR: dimX input is incorrect"");\n	   return 0;\n	}\n	\n	if( IszX <= 0 ) {\n		printf(""dimX must be > 0\n"");\n		return 0;\n	}\n	\n	//converting a string to a integer\n	if( sscanf( argv[4], ""%d"", &IszY ) == EOF ) {\n	   printf(""ERROR: dimY input is incorrect"");\n	   return 0;\n	}\n	\n	if( IszY <= 0 ) {\n		printf(""dimY must be > 0\n"");\n		return 0;\n	}\n	\n	//converting a string to a integer\n	if( sscanf( argv[6], ""%d"", &Nfr ) == EOF ) {\n	   printf(""ERROR: Number of frames input is incorrect"");\n	   return 0;\n	}\n	\n	if( Nfr <= 0 ) {\n		printf(""number of frames must be > 0\n"");\n		return 0;\n	}\n	\n	//converting a string to a integer\n	if( sscanf( argv[8], ""%d"", &Nparticles ) == EOF ) {\n	   printf(""ERROR: Number of particles input is incorrect"");\n	   return 0;\n	}\n	\n	if( Nparticles <= 0 ) {\n		printf(""Number of particles must be > 0\n"");\n		return 0;\n	}\n	//establish seed\n	int * seed = (int *)malloc(sizeof(int)*Nparticles);\n	int i;\n	for(i = 0; i < Nparticles; i++)\n		seed[i] = time(0)*i;\n	//malloc matrix\n	int * I = (int *)malloc(sizeof(int)*IszX*IszY*Nfr);\n	long long start = get_time();\n	//call video sequence\n	videoSequence(I, IszX, IszY, Nfr, seed);\n	long long endVideoSequence = get_time();\n	printf(""VIDEO SEQUENCE TOOK %f\n"", elapsed_time(start, endVideoSequence));\n	//call particle filter\n	particleFilter(I, IszX, IszY, Nfr, seed, Nparticles);\n	long long endParticleFilter = get_time();\n	printf(""PARTICLE FILTER TOOK %f\n"", elapsed_time(endVideoSequence, endParticleFilter));\n	printf(""ENTIRE PROGRAM TOOK %f\n"", elapsed_time(start, endParticleFilter));\n	\n	free(seed);\n	free(I);\n	return 0;\n}\n"
nw/needle.cpp,"#define LIMIT -999\n//#define TRACE\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#define OPENMP\n//#define NUM_THREAD 4\n\n#define BLOCK_SIZE 16\n\n////////////////////////////////////////////////////////////////////////////////\n// declaration, forward\nvoid runTest( int argc, char** argv);\n\n// Returns the current system time in microseconds \nlong long get_time()\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    return (tv.tv_sec * 1000000) + tv.tv_usec;\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma omp declare target\n#endif\nint maximum( int a,\n		 int b,\n		 int c){\n\n	int k;\n	if( a <= b )\n		k = b;\n	else \n	k = a;\n\n	if( k <=c )\n	return(c);\n	else\n	return(k);\n}\n#ifdef OMP_OFFLOAD\n#pragma omp end declare target\n#endif\n\n\nint blosum62[24][24] = {\n{ 4, -1, -2, -2,  0, -1, -1,  0, -2, -1, -1, -1, -1, -2, -1,  1,  0, -3, -2,  0, -2, -1,  0, -4},\n{-1,  5,  0, -2, -3,  1,  0, -2,  0, -3, -2,  2, -1, -3, -2, -1, -1, -3, -2, -3, -1,  0, -1, -4},\n{-2,  0,  6,  1, -3,  0,  0,  0,  1, -3, -3,  0, -2, -3, -2,  1,  0, -4, -2, -3,  3,  0, -1, -4},\n{-2, -2,  1,  6, -3,  0,  2, -1, -1, -3, -4, -1, -3, -3, -1,  0, -1, -4, -3, -3,  4,  1, -1, -4},\n{ 0, -3, -3, -3,  9, -3, -4, -3, -3, -1, -1, -3, -1, -2, -3, -1, -1, -2, -2, -1, -3, -3, -2, -4},\n{-1,  1,  0,  0, -3,  5,  2, -2,  0, -3, -2,  1,  0, -3, -1,  0, -1, -2, -1, -2,  0,  3, -1, -4},\n{-1,  0,  0,  2, -4,  2,  5, -2,  0, -3, -3,  1, -2, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},\n{ 0, -2,  0, -1, -3, -2, -2,  6, -2, -4, -4, -2, -3, -3, -2,  0, -2, -2, -3, -3, -1, -2, -1, -4},\n{-2,  0,  1, -1, -3,  0,  0, -2,  8, -3, -3, -1, -2, -1, -2, -1, -2, -2,  2, -3,  0,  0, -1, -4},\n{-1, -3, -3, -3, -1, -3, -3, -4, -3,  4,  2, -3,  1,  0, -3, -2, -1, -3, -1,  3, -3, -3, -1, -4},\n{-1, -2, -3, -4, -1, -2, -3, -4, -3,  2,  4, -2,  2,  0, -3, -2, -1, -2, -1,  1, -4, -3, -1, -4},\n{-1,  2,  0, -1, -3,  1,  1, -2, -1, -3, -2,  5, -1, -3, -1,  0, -1, -3, -2, -2,  0,  1, -1, -4},\n{-1, -1, -2, -3, -1,  0, -2, -3, -2,  1,  2, -1,  5,  0, -2, -1, -1, -1, -1,  1, -3, -1, -1, -4},\n{-2, -3, -3, -3, -2, -3, -3, -3, -1,  0,  0, -3,  0,  6, -4, -2, -2,  1,  3, -1, -3, -3, -1, -4},\n{-1, -2, -2, -1, -3, -1, -1, -2, -2, -3, -3, -1, -2, -4,  7, -1, -1, -4, -3, -2, -2, -1, -2, -4},\n{ 1, -1,  1,  0, -1,  0,  0,  0, -1, -2, -2,  0, -1, -2, -1,  4,  1, -3, -2, -2,  0,  0,  0, -4},\n{ 0, -1,  0, -1, -1, -1, -1, -2, -2, -1, -1, -1, -1, -2, -1,  1,  5, -2, -2,  0, -1, -1,  0, -4},\n{-3, -3, -4, -4, -2, -2, -3, -2, -2, -3, -2, -3, -1,  1, -4, -3, -2, 11,  2, -3, -4, -3, -2, -4},\n{-2, -2, -2, -3, -2, -1, -2, -3,  2, -1, -1, -2, -1,  3, -3, -2, -2,  2,  7, -1, -3, -2, -1, -4},\n{ 0, -3, -3, -3, -1, -2, -2, -3, -3,  3,  1, -2,  1, -1, -2, -2,  0, -3, -1,  4, -3, -2, -1, -4},\n{-2, -1,  3,  4, -3,  0,  1, -1,  0, -3, -4,  0, -3, -3, -2,  0, -1, -4, -3, -3,  4,  1, -1, -4},\n{-1,  0,  0,  1, -3,  3,  4, -2,  0, -3, -3,  1, -1, -3, -1,  0, -1, -3, -2, -2,  1,  4, -1, -4},\n{ 0, -1, -1, -1, -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -2,  0,  0, -2, -1, -1, -1, -1, -1, -4},\n{-4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4,  1}\n};\n\ndouble gettime() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return t.tv_sec+t.tv_usec*1e-6;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Program main\n////////////////////////////////////////////////////////////////////////////////\nint\nmain( int argc, char** argv) \n{\n    runTest( argc, argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid usage(int argc, char **argv)\n{\n	fprintf(stderr, ""Usage: %s <max_rows/max_cols> <penalty> <num_threads>\n"", argv[0]);\n	fprintf(stderr, ""\t<dimension>      - x and y dimensions\n"");\n	fprintf(stderr, ""\t<penalty>        - penalty(positive integer)\n"");\n	fprintf(stderr, ""\t<num_threads>    - no. of threads\n"");\n	exit(1);\n}\n\nvoid nw_optimized(int *input_itemsets, int *output_itemsets, int *referrence,\n        int max_rows, int max_cols, int penalty)\n{\n#ifdef OMP_OFFLOAD\n    int transfer_size = max_rows * max_cols;\n    #pragma omp target data map(to: max_cols, penalty, referrence[0:transfer_size]) map(input_itemsets[0:transfer_size])\n    {\n\n    #pragma omp target \n#endif\n    for( int blk = 1; blk <= (max_cols-1)/BLOCK_SIZE; blk++ )\n    {\n#ifdef OPENMP\n#pragma omp parallel for schedule(static) shared(input_itemsets, referrence) firstprivate(blk, max_rows, max_cols, penalty)\n#endif\n        for( int b_index_x = 0; b_index_x < blk; ++b_index_x)\n        {\n            int b_index_y = blk - 1 - b_index_x;\n            int input_itemsets_l[(BLOCK_SIZE + 1) *(BLOCK_SIZE+1)] __attribute__ ((aligned (64)));\n            int reference_l[BLOCK_SIZE * BLOCK_SIZE] __attribute__ ((aligned (64)));\n\n            // Copy referrence to local memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    reference_l[i*BLOCK_SIZE + j] = referrence[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1];\n                }\n            }\n\n            // Copy input_itemsets to local memory\n            for ( int i = 0; i < BLOCK_SIZE + 1; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i) + b_index_x*BLOCK_SIZE +  j];\n                }\n            }\n\n            // Compute\n            for ( int i = 1; i < BLOCK_SIZE + 1; ++i )\n            {\n                for ( int j = 1; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = maximum( input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j - 1] + reference_l[(i - 1)*BLOCK_SIZE + j - 1],\n                            input_itemsets_l[i*(BLOCK_SIZE + 1) + j - 1] - penalty,\n                            input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j] - penalty);\n                }\n            }\n\n            // Copy results to global memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1] = input_itemsets_l[(i + 1)*(BLOCK_SIZE+1) + j + 1];\n                }\n            }\n            \n        }\n    }    \n        \n    printf(""Processing bottom-right matrix\n"");\n\n#ifdef OMP_OFFLOAD\n    #pragma omp target\n#endif\n    for ( int blk = 2; blk <= (max_cols-1)/BLOCK_SIZE; blk++ )\n    {\n#ifdef OPENMP\n#pragma omp parallel for schedule(static) shared(input_itemsets, referrence) firstprivate(blk, max_rows, max_cols, penalty)\n#endif\n        for( int b_index_x = blk - 1; b_index_x < (max_cols-1)/BLOCK_SIZE; ++b_index_x)\n        {\n            int b_index_y = (max_cols-1)/BLOCK_SIZE + blk - 2 - b_index_x;\n\n            int input_itemsets_l[(BLOCK_SIZE + 1) *(BLOCK_SIZE+1)] __attribute__ ((aligned (64)));\n            int reference_l[BLOCK_SIZE * BLOCK_SIZE] __attribute__ ((aligned (64)));\n \n            // Copy referrence to local memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    reference_l[i*BLOCK_SIZE + j] = referrence[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1];\n                }\n            }\n\n            // Copy input_itemsets to local memory\n            for ( int i = 0; i < BLOCK_SIZE + 1; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i) + b_index_x*BLOCK_SIZE +  j];\n                }\n            }\n\n            // Compute\n            for ( int i = 1; i < BLOCK_SIZE + 1; ++i )\n            {\n                for ( int j = 1; j < BLOCK_SIZE + 1; ++j)\n                {\n                    input_itemsets_l[i*(BLOCK_SIZE + 1) + j] = maximum( input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j - 1] + reference_l[(i - 1)*BLOCK_SIZE + j - 1],\n                            input_itemsets_l[i*(BLOCK_SIZE + 1) + j - 1] - penalty,\n                            input_itemsets_l[(i - 1)*(BLOCK_SIZE + 1) + j] - penalty);\n                }\n            }\n\n            // Copy results to global memory\n            for ( int i = 0; i < BLOCK_SIZE; ++i )\n            {\n#pragma omp simd\n                for ( int j = 0; j < BLOCK_SIZE; ++j)\n                {\n                    input_itemsets[max_cols*(b_index_y*BLOCK_SIZE + i + 1) + b_index_x*BLOCK_SIZE +  j + 1] = input_itemsets_l[(i + 1)*(BLOCK_SIZE+1) + j +1];\n                }\n            }\n        }\n    }\n\n#ifdef OMP_OFFLOAD\n    }\n#endif\n   \n}\n\n////////////////////////////////////////////////////////////////////////////////\n//! Run a simple test for CUDA\n////////////////////////////////////////////////////////////////////////////////\nvoid\nrunTest( int argc, char** argv) \n{\n    int max_rows, max_cols, penalty;\n    int *input_itemsets, *output_itemsets, *referrence;\n    //int *matrix_cuda, *matrix_cuda_out, *referrence_cuda;\n    //int size;\n    int omp_num_threads;\n\n\n    // the lengths of the two sequences should be able to divided by 16.\n    // And at current stage  max_rows needs to equal max_cols\n    if (argc == 4)\n    {\n        max_rows = atoi(argv[1]);\n        max_cols = atoi(argv[1]);\n        penalty = atoi(argv[2]);\n        omp_num_threads = atoi(argv[3]);\n    }\n    else{\n        usage(argc, argv);\n    }\n\n    max_rows = max_rows + 1;\n    max_cols = max_cols + 1;\n    referrence = (int *)malloc( max_rows * max_cols * sizeof(int) );\n    input_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );\n    output_itemsets = (int *)malloc( max_rows * max_cols * sizeof(int) );\n\n\n    if (!input_itemsets)\n        fprintf(stderr, ""error: can not allocate memory"");\n\n    srand ( 7 );\n\n    for (int i = 0 ; i < max_cols; i++){\n        for (int j = 0 ; j < max_rows; j++){\n            input_itemsets[i*max_cols+j] = 0;\n        }\n    }\n\n    printf(""Start Needleman-Wunsch\n"");\n\n    for( int i=1; i< max_rows ; i++){    //please define your own sequence. \n        input_itemsets[i*max_cols] = rand() % 10 + 1;\n    }\n    for( int j=1; j< max_cols ; j++){    //please define your own sequence.\n        input_itemsets[j] = rand() % 10 + 1;\n    }\n\n\n    for (int i = 1 ; i < max_cols; i++){\n        for (int j = 1 ; j < max_rows; j++){\n            referrence[i*max_cols+j] = blosum62[input_itemsets[i*max_cols]][input_itemsets[j]];\n        }\n    }\n\n    for( int i = 1; i< max_rows ; i++)\n        input_itemsets[i*max_cols] = -i * penalty;\n    for( int j = 1; j< max_cols ; j++)\n        input_itemsets[j] = -j * penalty;\n\n\n\n    //Compute top-left matrix \n    printf(""Num of threads: %d\n"", omp_num_threads);\n    printf(""Processing top-left matrix\n"");\n   \n    long long start_time = get_time();\n\n    nw_optimized( input_itemsets, output_itemsets, referrence,\n        max_rows, max_cols, penalty );\n\n    long long end_time = get_time();\n\n    printf(""Total time: %.3f seconds\n"", ((float) (end_time - start_time)) / (1000*1000));\n\n#define TRACEBACK\n#ifdef TRACEBACK\n\n    FILE *fpo = fopen(""result.txt"",""w"");\n    fprintf(fpo, ""print traceback value GPU:\n"");\n\n    for (int i = max_rows - 2,  j = max_rows - 2; i>=0, j>=0;){\n        int nw, n, w, traceback;\n        if ( i == max_rows - 2 && j == max_rows - 2 )\n            fprintf(fpo, ""%d "", input_itemsets[ i * max_cols + j]); //print the first element\n        if ( i == 0 && j == 0 )\n            break;\n        if ( i > 0 && j > 0 ){\n            nw = input_itemsets[(i - 1) * max_cols + j - 1];\n            w  = input_itemsets[ i * max_cols + j - 1 ];\n            n  = input_itemsets[(i - 1) * max_cols + j];\n        }\n        else if ( i == 0 ){\n            nw = n = LIMIT;\n            w  = input_itemsets[ i * max_cols + j - 1 ];\n        }\n        else if ( j == 0 ){\n            nw = w = LIMIT;\n            n  = input_itemsets[(i - 1) * max_cols + j];\n        }\n        else{\n        }\n\n        //traceback = maximum(nw, w, n);\n        int new_nw, new_w, new_n;\n        new_nw = nw + referrence[i * max_cols + j];\n        new_w = w - penalty;\n        new_n = n - penalty;\n\n        traceback = maximum(new_nw, new_w, new_n);\n        if(traceback == new_nw)\n            traceback = nw;\n        if(traceback == new_w)\n            traceback = w;\n        if(traceback == new_n)\n            traceback = n;\n\n        fprintf(fpo, ""%d "", traceback);\n\n        if(traceback == nw )\n        {i--; j--; continue;}\n\n        else if(traceback == w )\n        {j--; continue;}\n\n        else if(traceback == n )\n        {i--; continue;}\n\n        else\n            ;\n    }\n\n    fclose(fpo);\n\n#endif\n\n    free(referrence);\n    free(input_itemsets);\n    free(output_itemsets);\n\n}\n\n\n\n"
myocyte/main.c,"//====================================================================================================100\n//		UPDATE\n//====================================================================================================100\n\n// Lukasz G. Szafaryn 24 JAN 09\n\n//====================================================================================================100\n//		DESCRIPTION\n//====================================================================================================100\n\n// Myocyte application models cardiac myocyte (heart muscle cell) and simulates its behavior according to the work by Saucerman and Bers [8]. The model integrates \n// cardiac myocyte electrical activity with the calcineurin pathway, which is a key aspect of the development of heart failure. The model spans large number of temporal \n// scales to reflect how changes in heart rate as observed during exercise or stress contribute to calcineurin pathway activation, which ultimately leads to the expression \n// of numerous genes that remodel the hearts structure. It can be used to identify potential therapeutic targets that may be useful for the treatment of heart failure. \n// Biochemical reactions, ion transport and electrical activity in the cell are modeled with 91 ordinary differential equations (ODEs) that are determined by more than 200 \n// experimentally validated parameters. The model is simulated by solving this group of ODEs for a specified time interval. The process of ODE solving is based on the \n// causal relationship between values of ODEs at different time steps, thus it is mostly sequential. At every dynamically determined time step, the solver evaluates the \n// model consisting of a set of 91 ODEs and 480 supporting equations to determine behavior of the system at that particular time instance. If evaluation results are not \n// within the expected tolerance at a given time step (usually as a result of incorrect determination of the time step), another calculation attempt is made at a modified \n// (usually reduced) time step. Since the ODEs are stiff (exhibit fast rate of change within short time intervals), they need to be simulated at small time scales with an \n// adaptive step size solver. \n\n//	1) The original version of the current solver code was obtained from: Mathematics Source Library (http://mymathlib.webtrellis.net/index.html). The solver has been \n//      somewhat modified to tailor it to our needs. However, it can be reverted back to original form or modified to suit other simulations.\n// 2) This solver and particular solving algorithm used with it (embedded_fehlberg_7_8) were adapted to work with a set of equations, not just one like in original version.\n//	3) In order for solver to provide deterministic number of steps (needed for particular amount of memore previousely allocated for results), every next step is \n//      incremented by 1 time unit (h_init).\n//	4) Function assumes that simulation starts at some point of time (whatever time the initial values are provided for) and runs for the number of miliseconds (xmax) \n//      specified by the uses as a parameter on command line.\n// 5) The appropriate amount of memory is previousely allocated for that range (y).\n//	6) This setup in 3) - 5) allows solver to adjust the step ony from current time instance to current time instance + 0.9. The next time instance is current time instance + 1;\n//	7) The original solver cannot handle cases when equations return NAN and INF values due to discontinuities and /0. That is why equations provided by user need to \n//      make sure that no NAN and INF are returned.\n// 8) Application reads initial data and parameters from text files: y.txt and params.txt respectively that need to be located in the same folder as source files. \n//     For simplicity and testing purposes only, when multiple number of simulation instances is specified, application still reads initial data from the same input files. That \n//     can be modified in this source code.\n\n//====================================================================================================100\n//		IMPLEMENTATION-SPECIFIC DESCRIPTION (OPEN MP)\n//====================================================================================================100\n\n// This is the OpenMP version of Myocyte code.\n\n// The original single-threaded code was written in MATLAB and used MATLAB ode45 ODE solver. In the process of accelerating this code, we arrived with the \n// intermediate versions that used single-threaded Sundials CVODE solver which evaluated model parallelized with OpenMP at each time step. In order to convert entire \n// solver to OpenMP code (to remove some of the operational overheads such as thread launches in OpenMP) we used a simpler solver, from Mathematics Source \n// Library, and tailored it to our needs. The parallelism in the cardiac myocyte model is on a very fine-grained level, close to that of ILP, therefore it is very hard to exploit \n// as DLP or TLB in OpenMP code. We were able to divide the model into 4 individual groups that run in parallel. However, even that is not enough work to compensate \n// for some of the OpenMP thread launch overheads, which resulted in performance worse than that of single-threaded C code. Speedup in this code could \n// be achieved only if a customizable accelerator such as FPGA was used for evaluation of the model itself. We also approached the application from another angle and \n// allowed it to run several concurrent simulations, thus turning it into an embarrassingly parallel problem. This version of the code is also useful for scientists who want to \n// run the same simulation with different sets of input parameters. OpenMP version of this code provides constant speedup of about 3.64x regardless of the number of \n// concurrent simulations.\n\n// Speedup numbers reported in the description of this application were obtained on the machine with: Intel Quad Core CPU, 4GB of RAM, Nvidia GTX280 GPU.  \n\n// 1) When running with parallelization inside each simulation instance (value of 3rd command line parameter equal to 0), performance is bad because:\n// a) thread launch overhead\n// b) small amount of work for each forked thread\n// 2) When running with parallelization across simulation instances, code gets continues speedup with the increasing number of simulation insances which saturates\n//     around 4 instances on Quad Core CPU (roughly corresponding to the number of multiprocessorsXprocessors in GTX280), with the speedup of around 3.5x compared\n//     to serial C version of code, as expected.\n\n// The following are the command parameters to the application:\n// 1) Simulation time interval which is the number of miliseconds to simulate. Needs to be integer > 0\n// 2) Number of instances of simulation to run. Needs to be integer > 0.\n// 3) Method of parallelization. Need to be 0 for parallelization inside each simulation instance, or 1 for parallelization across instances.\n// 4) Number of threads to use. Needs to be integer > 0.\n// Example:\n// a.out 100 100 1 4\n\n//====================================================================================================100\n//	DEFINE / INCLUDE\n//====================================================================================================100\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n\n#include <omp.h>\n\n#include ""define.c""\n#include ""ecc.c""\n#include ""cam.c""\n#include ""fin.c""\n#include ""master.c""\n#include ""embedded_fehlberg_7_8.c""\n#include ""solver.c""\n\n#include ""file.c""\n#include ""timer.c""\n\n//====================================================================================================100\n//	MAIN FUNCTION\n//====================================================================================================100\n\nint main(int argc, char *argv []){\n\n	//================================================================================80\n	//		VARIABLES\n	//================================================================================80\n\n	//============================================================60\n	//		TIME\n	//============================================================60\n\n	long long time0;\n	long long time1;\n	long long time2;\n	long long time3;\n	long long time4;\n	long long time5;\n\n	time0 = get_time();\n\n	//============================================================60\n	//		COUNTERS\n	//============================================================60\n\n	long long memory;\n	int i,j;\n	int status;\n	int mode;\n\n	//============================================================60\n	//		SOLVER PARAMETERS\n	//============================================================60\n\n	long workload;\n	long xmin;\n	long xmax;\n	fp h;\n	fp tolerance;\n\n	//============================================================60\n	//		DATA\n	//============================================================60\n\n	fp*** y;\n	fp** x;\n	fp** params;\n\n	//============================================================60\n	//		OPENMP\n	//============================================================60\n\n	int threads;\n\n	//================================================================================80\n	// 	GET INPUT PARAMETERS\n	//================================================================================80\n\n	//============================================================60\n	//		CHECK NUMBER OF ARGUMENTS\n	//============================================================60\n\n	if(argc!=5){\n		printf(""ERROR: %d is the incorrect number of arguments, the number of arguments must be 4\n"", argc-1);\n		return 0;\n	}\n\n	//============================================================60\n	//		GET AND CHECK PARTICULAR ARGUMENTS\n	//============================================================60\n\n	else{\n\n		//========================================40\n		//		SPAN\n		//========================================40\n\n		xmax = atoi(argv[1]);\n		if(xmax<0){\n			printf(""ERROR: %d is the incorrect end of simulation interval, use numbers > 0\n"", xmax);\n			return 0;\n		}\n\n		//========================================40\n		//		WORKLOAD\n		//========================================40\n\n		workload = atoi(argv[2]);\n		if(workload<0){\n			printf(""ERROR: %d is the incorrect number of instances of simulation, use numbers > 0\n"", workload);\n			return 0;\n		}\n\n		//========================================40\n		//		MODE\n		//========================================40\n\n		mode = 0;\n		mode = atoi(argv[3]);\n		if(mode != 0 && mode != 1){\n			printf(""ERROR: %d is the incorrect mode, it should be omitted or equal to 0 or 1\n"", mode);\n			return 0;\n		}\n\n		//========================================40\n		//		THREADS\n		//========================================40\n\n		threads = atoi(argv[4]);\n		if(threads<0){\n			printf(""ERROR: %d is the incorrect number of threads, use numbers > 0\n"", threads);\n			return 0;\n		}\n		omp_set_num_threads(threads);\n\n	}\n\n	time1 = get_time();\n\n	//================================================================================80\n	// 	ALLOCATE MEMORY\n	//================================================================================80\n\n	//============================================================60\n	//		MEMORY CHECK\n	//============================================================60\n\n	memory = workload*(xmax+1)*EQUATIONS*4;\n	if(memory>1000000000){\n		printf(""ERROR: trying to allocate more than 1.0GB of memory, decrease workload and span parameters or change memory parameter\n"");\n		return 0;\n	}\n\n	//============================================================60\n	// 	ALLOCATE ARRAYS\n	//============================================================60\n\n	y = (fp ***) malloc(workload* sizeof(fp **));\n	for(i=0; i<workload; i++){\n		y[i] = (fp**)malloc((1+xmax)*sizeof(fp*));\n		for(j=0; j<(1+xmax); j++){\n			y[i][j]= (fp *) malloc(EQUATIONS* sizeof(fp));\n		}\n	}\n\n	x = (fp **) malloc(workload * sizeof(fp *));\n	for (i= 0; i<workload; i++){\n		x[i]= (fp *)malloc((1+xmax) *sizeof(fp));\n	}\n\n	params = (fp **) malloc(workload * sizeof(fp *));\n	for (i= 0; i<workload; i++){\n		params[i]= (fp *)malloc(PARAMETERS * sizeof(fp));\n	}\n\n	time2 = get_time();\n\n	//================================================================================80\n	// 	INITIAL VALUES\n	//================================================================================80\n\n	// y\n	for(i=0; i<workload; i++){\n		read(	""../../data/myocyte/y.txt"",\n					y[i][0],\n					91,\n					1,\n					0);\n	}\n\n	// params\n	for(i=0; i<workload; i++){\n		read(	""../../data/myocyte/params.txt"",\n					params[i],\n					16,\n					1,\n					0);\n	}\n\n	time3 = get_time();\n\n	//================================================================================80\n	//	EXECUTION\n	//================================================================================80\n\n	if(mode == 0){\n\n		for(i=0; i<workload; i++){\n\n			status = solver(	y[i],\n										x[i],\n										xmax,\n										params[i],\n										mode);\n\n			// if(status !=0){\n				// printf(""STATUS: %d\n"", status);\n			// }\n\n		}\n\n	}\n	else{\n\n		#pragma omp parallel for private(i, status) shared(y, x, xmax, params, mode)\n		for(i=0; i<workload; i++){\n\n			status = solver(	y[i],\n										x[i],\n										xmax,\n										params[i],\n										mode);\n\n			// if(status !=0){\n				// printf(""STATUS: %d\n"", status);\n			// }\n\n		}\n\n	}\n\n	// // print results\n	// int k;\n	// for(i=0; i<workload; i++){\n		// printf(""WORKLOAD %d:\n"", i);\n		// for(j=0; j<(xmax+1); j++){\n			// printf(""\tTIME %d:\n"", j);\n			// for(k=0; k<EQUATIONS; k++){\n				// printf(""\t\ty[%d][%d][%d]=%13.10f\n"", i, j, k, y[i][j][k]);\n			// }\n		// }\n	// }\n\n	time4 = get_time();\n\n	//================================================================================80\n	//	DEALLOCATION\n	//================================================================================80\n\n	// y values\n	for (i= 0; i< workload; i++){\n		for (j= 0; j< (1+xmax); j++){\n			free(y[i][j]);\n		}\n		free(y[i]);\n	}\n	free(y);\n\n	// x values\n	for (i= 0; i< workload; i++){\n		free(x[i]);\n	}\n	free(x);\n\n	// parameters\n	for (i= 0; i< workload; i++){\n		free(params[i]);\n	}\n	free(params);\n\n	time5= get_time();\n\n	//================================================================================80\n	//		DISPLAY TIMING\n	//================================================================================80\n\n	printf(""Time spent in different stages of the application:\n"");\n	printf(""%.12f s, %.12f % : SETUP VARIABLES, READ COMMAND LINE ARGUMENTS\n"", 	(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time5-time0) * 100);\n	printf(""%.12f s, %.12f % : ALLOCATE MEMORY\n"", 														(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time5-time0) * 100);\n	printf(""%.12f s, %.12f % : READ DATA FROM FILES\n"", 												(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time5-time0) * 100);\n	printf(""%.12f s, %.12f % : RUN COMPUTATION\n"", 														(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time5-time0) * 100);\n	printf(""%.12f s, %.12f % : FREE MEMORY\n"", 																(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time5-time0) * 100);\n	printf(""Total time:\n"");\n	printf(""%.12f s\n"", 																											(float) (time5-time0) / 1000000);\n\n//====================================================================================================100\n//	END OF FILE\n//====================================================================================================100\n\n}\n"
myocyte/timer.c,"#include <stdlib.h>\n#include <sys/time.h>\n\n // Returns the current system time in microseconds\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n"
myocyte/cam.c,"//=====================================================================\n//	MAIN FUNCTION\n//=====================================================================\nfp cam(fp timeinst,\n			fp *initvalu,\n			int initvalu_offset,\n			fp *parameter,\n			int parameter_offset,\n			fp *finavalu,\n			fp Ca){\n\n	//=====================================================================\n	//	VARIABLES\n	//=====================================================================\n\n	// output\n	fp JCa;\n\n	// input data and output data variable references\n	int offset_1;\n	int offset_2;\n	int offset_3;\n	int offset_4;\n	int offset_5;\n	int offset_6;\n	int offset_7;\n	int offset_8;\n	int offset_9;\n	int offset_10;\n	int offset_11;\n	int offset_12;\n	int offset_13;\n	int offset_14;\n	int offset_15;\n\n	// parameter variable references\n	int parameter_offset_1;\n	int parameter_offset_2;\n	int parameter_offset_3;\n	int parameter_offset_4;\n	int parameter_offset_5;\n\n	// decoding input initial values\n	fp CaM;\n	fp Ca2CaM;\n	fp Ca4CaM;\n	fp CaMB;\n	fp Ca2CaMB;\n	fp Ca4CaMB;           \n	fp Pb2;\n	fp Pb;\n	fp Pt;\n	fp Pt2;\n	fp Pa;                            \n	fp Ca4CaN;\n	fp CaMCa4CaN;\n	fp Ca2CaMCa4CaN;\n	fp Ca4CaMCa4CaN;\n\n	// decoding input parameters\n	fp CaMtot;\n	fp Btot;\n	fp CaMKIItot;\n	fp CaNtot;\n	fp PP1tot;\n\n	// constants\n	fp K;																			//\n	fp Mg;																			//\n\n	// Ca/CaM parameters\n	fp Kd02;																		// [uM^2]\n	fp Kd24;																		// [uM^2]\n	fp k20;																			// [s^-1]      \n	fp k02;																			// [uM^-2 s^-1]\n	fp k42;																			// [s^-1]      \n	fp k24;																			// [uM^-2 s^-1]\n\n	// CaM buffering (B) parameters\n	fp k0Boff;																		// [s^-1] \n	fp k0Bon;																		// [uM^-1 s^-1] kon = koff/Kd\n	fp k2Boff;																		// [s^-1] \n	fp k2Bon;																		// [uM^-1 s^-1]\n	fp k4Boff;																		// [s^-1]\n	fp k4Bon;																		// [uM^-1 s^-1]\n\n	// using thermodynamic constraints\n	fp k20B;																		// [s^-1] thermo constraint on loop 1\n	fp k02B;																		// [uM^-2 s^-1] \n	fp k42B;																		// [s^-1] thermo constraint on loop 2\n	fp k24B;																		// [uM^-2 s^-1]\n\n	// Wi Wa Wt Wp\n	fp kbi;																			// [s^-1] (Ca4CaM dissocation from Wb)\n	fp kib;																			// [uM^-1 s^-1]\n	fp kpp1;																		// [s^-1] (PP1-dep dephosphorylation rates)\n	fp Kmpp1;																		// [uM]\n	fp kib2;\n	fp kb2i;\n	fp kb24;\n	fp kb42;\n	fp kta;																			// [s^-1] (Ca4CaM dissociation from Wt)\n	fp kat;																			// [uM^-1 s^-1] (Ca4CaM reassociation with Wa)\n	fp kt42;\n	fp kt24;\n	fp kat2;\n	fp kt2a;\n\n	// CaN parameters\n	fp kcanCaoff;																	// [s^-1] \n	fp kcanCaon;																	// [uM^-1 s^-1] \n	fp kcanCaM4on;																	// [uM^-1 s^-1]\n	fp kcanCaM4off;																	// [s^-1]\n	fp kcanCaM2on;\n	fp kcanCaM2off;\n	fp kcanCaM0on;\n	fp kcanCaM0off;\n	fp k02can;\n	fp k20can;\n	fp k24can;\n	fp k42can;\n\n	// CaM Reaction fluxes\n	fp rcn02;\n	fp rcn24;\n\n	// CaM buffer fluxes\n	fp B;\n	fp rcn02B;\n	fp rcn24B;\n	fp rcn0B;\n	fp rcn2B;\n	fp rcn4B;\n\n	// CaN reaction fluxes \n	fp Ca2CaN;\n	fp rcnCa4CaN;\n	fp rcn02CaN; \n	fp rcn24CaN;\n	fp rcn0CaN;\n	fp rcn2CaN;\n	fp rcn4CaN;\n\n	// CaMKII reaction fluxes\n	fp Pix;\n	fp rcnCKib2;\n	fp rcnCKb2b;\n	fp rcnCKib;\n	fp T;\n	fp kbt;\n	fp rcnCKbt;\n	fp rcnCKtt2;\n	fp rcnCKta;\n	fp rcnCKt2a;\n	fp rcnCKt2b2;\n	fp rcnCKai;\n\n	// CaM equations\n	fp dCaM;\n	fp dCa2CaM;\n	fp dCa4CaM;\n	fp dCaMB;\n	fp dCa2CaMB;\n	fp dCa4CaMB;\n\n	// CaMKII equations\n	fp dPb2;																		// Pb2\n	fp dPb;																			// Pb\n	fp dPt;																			// Pt\n	fp dPt2;																		// Pt2\n	fp dPa;																			// Pa\n\n	// CaN equations\n	fp dCa4CaN;																		// Ca4CaN\n	fp dCaMCa4CaN;																	// CaMCa4CaN\n	fp dCa2CaMCa4CaN;																// Ca2CaMCa4CaN\n	fp dCa4CaMCa4CaN;																// Ca4CaMCa4CaN\n\n	//=====================================================================\n	//	COMPUTATION\n	//=====================================================================\n\n	// input data and output data variable references\n	offset_1  = initvalu_offset;\n	offset_2  = initvalu_offset+1;\n	offset_3  = initvalu_offset+2;\n	offset_4  = initvalu_offset+3;\n	offset_5  = initvalu_offset+4;\n	offset_6  = initvalu_offset+5;\n	offset_7  = initvalu_offset+6;\n	offset_8  = initvalu_offset+7;\n	offset_9  = initvalu_offset+8;\n	offset_10 = initvalu_offset+9;\n	offset_11 = initvalu_offset+10;\n	offset_12 = initvalu_offset+11;\n	offset_13 = initvalu_offset+12;\n	offset_14 = initvalu_offset+13;\n	offset_15 = initvalu_offset+14;\n	\n	// input parameters variable references\n	parameter_offset_1  = parameter_offset;\n	parameter_offset_2  = parameter_offset+1;\n	parameter_offset_3  = parameter_offset+2;\n	parameter_offset_4  = parameter_offset+3;\n	parameter_offset_5  = parameter_offset+4;\n\n	// decoding input array\n	CaM				= initvalu[offset_1];\n	Ca2CaM			= initvalu[offset_2];\n	Ca4CaM			= initvalu[offset_3];\n	CaMB			= initvalu[offset_4];\n	Ca2CaMB			= initvalu[offset_5];\n	Ca4CaMB			= initvalu[offset_6];           \n	Pb2				= initvalu[offset_7];\n	Pb				= initvalu[offset_8];\n	Pt				= initvalu[offset_9];\n	Pt2				= initvalu[offset_10];\n	Pa				= initvalu[offset_11];                            \n	Ca4CaN			= initvalu[offset_12];\n	CaMCa4CaN		= initvalu[offset_13];\n	Ca2CaMCa4CaN	= initvalu[offset_14];\n	Ca4CaMCa4CaN	= initvalu[offset_15];\n\n	// decoding input parameters\n	CaMtot			= parameter[parameter_offset_1];\n	Btot			= parameter[parameter_offset_2];\n	CaMKIItot		= parameter[parameter_offset_3];\n	CaNtot			= parameter[parameter_offset_4];\n	PP1tot			= parameter[parameter_offset_5];\n\n	// values [CONSTANTS FOR ALL THREADS]\n	K = 135;																			//\n	Mg = 1;																				//\n\n	// Ca/CaM parameters\n	if (Mg <= 1){\n		Kd02 = 0.0025*(1+K/0.94-Mg/0.012)*(1+K/8.1+Mg/0.022);							// [uM^2]\n		Kd24 = 0.128*(1+K/0.64+Mg/0.0014)*(1+K/13.0-Mg/0.153);							// [uM^2]\n	}\n	else{\n		Kd02 = 0.0025*(1+K/0.94-1/0.012+(Mg-1)/0.060)*(1+K/8.1+1/0.022+(Mg-1)/0.068);   // [uM^2]\n		Kd24 = 0.128*(1+K/0.64+1/0.0014+(Mg-1)/0.005)*(1+K/13.0-1/0.153+(Mg-1)/0.150);  // [uM^2]\n	}\n	k20 = 10;																			// [s^-1]      \n	k02 = k20/Kd02;																		// [uM^-2 s^-1]\n	k42 = 500;																			// [s^-1]      \n	k24 = k42/Kd24;																		// [uM^-2 s^-1]\n\n	// CaM buffering (B) parameters\n	k0Boff = 0.0014;																	// [s^-1] \n	k0Bon = k0Boff/0.2;																	// [uM^-1 s^-1] kon = koff/Kd\n	k2Boff = k0Boff/100;																// [s^-1] \n	k2Bon = k0Bon;																		// [uM^-1 s^-1]\n	k4Boff = k2Boff;																	// [s^-1]\n	k4Bon = k0Bon;																		// [uM^-1 s^-1]\n\n	// using thermodynamic constraints\n	k20B = k20/100;																		// [s^-1] thermo constraint on loop 1\n	k02B = k02;																			// [uM^-2 s^-1] \n	k42B = k42;																			// [s^-1] thermo constraint on loop 2\n	k24B = k24;																			// [uM^-2 s^-1]\n\n	// Wi Wa Wt Wp\n	kbi = 2.2;																			// [s^-1] (Ca4CaM dissocation from Wb)\n	kib = kbi/33.5e-3;																	// [uM^-1 s^-1]\n	kpp1 = 1.72;																		// [s^-1] (PP1-dep dephosphorylation rates)\n	Kmpp1 = 11.5;																		// [uM]\n	kib2 = kib;\n	kb2i = kib2*5;\n	kb24 = k24;\n	kb42 = k42*33.5e-3/5;\n	kta = kbi/1000;																		// [s^-1] (Ca4CaM dissociation from Wt)\n	kat = kib;																			// [uM^-1 s^-1] (Ca4CaM reassociation with Wa)\n	kt42 = k42*33.5e-6/5;\n	kt24 = k24;\n	kat2 = kib;\n	kt2a = kib*5;\n\n	// CaN parameters\n	kcanCaoff = 1;																		// [s^-1] \n	kcanCaon = kcanCaoff/0.5;															// [uM^-1 s^-1] \n	kcanCaM4on = 46;																	// [uM^-1 s^-1]\n	kcanCaM4off = 0.0013;																// [s^-1]\n	kcanCaM2on = kcanCaM4on;\n	kcanCaM2off = 2508*kcanCaM4off;\n	kcanCaM0on = kcanCaM4on;\n	kcanCaM0off = 165*kcanCaM2off;\n	k02can = k02;\n	k20can = k20/165;\n	k24can = k24;\n	k42can = k20/2508;\n\n	// CaM Reaction fluxes\n	rcn02 = k02*pow(Ca,2)*CaM - k20*Ca2CaM;\n	rcn24 = k24*pow(Ca,2)*Ca2CaM - k42*Ca4CaM;\n	\n	// CaM buffer fluxes\n	B = Btot - CaMB - Ca2CaMB - Ca4CaMB;\n	rcn02B = k02B*pow(Ca,2)*CaMB - k20B*Ca2CaMB;\n	rcn24B = k24B*pow(Ca,2)*Ca2CaMB - k42B*Ca4CaMB;\n	rcn0B = k0Bon*CaM*B - k0Boff*CaMB;\n	rcn2B = k2Bon*Ca2CaM*B - k2Boff*Ca2CaMB;\n	rcn4B = k4Bon*Ca4CaM*B - k4Boff*Ca4CaMB;\n	\n	// CaN reaction fluxes \n	Ca2CaN = CaNtot - Ca4CaN - CaMCa4CaN - Ca2CaMCa4CaN - Ca4CaMCa4CaN;\n	rcnCa4CaN = kcanCaon*pow(Ca,2)*Ca2CaN - kcanCaoff*Ca4CaN;\n	rcn02CaN = k02can*pow(Ca,2)*CaMCa4CaN - k20can*Ca2CaMCa4CaN; \n	rcn24CaN = k24can*pow(Ca,2)*Ca2CaMCa4CaN - k42can*Ca4CaMCa4CaN;\n	rcn0CaN = kcanCaM0on*CaM*Ca4CaN - kcanCaM0off*CaMCa4CaN;\n	rcn2CaN = kcanCaM2on*Ca2CaM*Ca4CaN - kcanCaM2off*Ca2CaMCa4CaN;\n	rcn4CaN = kcanCaM4on*Ca4CaM*Ca4CaN - kcanCaM4off*Ca4CaMCa4CaN;\n\n	// CaMKII reaction fluxes\n	Pix = 1 - Pb2 - Pb - Pt - Pt2 - Pa;\n	rcnCKib2 = kib2*Ca2CaM*Pix - kb2i*Pb2;\n	rcnCKb2b = kb24*pow(Ca,2)*Pb2 - kb42*Pb;\n	rcnCKib = kib*Ca4CaM*Pix - kbi*Pb;\n	T = Pb + Pt + Pt2 + Pa;\n	kbt = 0.055*T + 0.0074*pow(T,2) + 0.015*pow(T,3);\n	rcnCKbt = kbt*Pb - kpp1*PP1tot*Pt/(Kmpp1+CaMKIItot*Pt);\n	rcnCKtt2 = kt42*Pt - kt24*pow(Ca,2)*Pt2;\n	rcnCKta = kta*Pt - kat*Ca4CaM*Pa;\n	rcnCKt2a = kt2a*Pt2 - kat2*Ca2CaM*Pa;\n	rcnCKt2b2 = kpp1*PP1tot*Pt2/(Kmpp1+CaMKIItot*Pt2);\n	rcnCKai = kpp1*PP1tot*Pa/(Kmpp1+CaMKIItot*Pa);\n\n	// CaM equations\n	dCaM = 1e-3*(-rcn02 - rcn0B - rcn0CaN);\n	dCa2CaM = 1e-3*(rcn02 - rcn24 - rcn2B - rcn2CaN + CaMKIItot*(-rcnCKib2 + rcnCKt2a) );\n	dCa4CaM = 1e-3*(rcn24 - rcn4B - rcn4CaN + CaMKIItot*(-rcnCKib+rcnCKta) );\n	dCaMB = 1e-3*(rcn0B-rcn02B);\n	dCa2CaMB = 1e-3*(rcn02B + rcn2B - rcn24B);\n	dCa4CaMB = 1e-3*(rcn24B + rcn4B);\n\n	// CaMKII equations\n	dPb2 = 1e-3*(rcnCKib2 - rcnCKb2b + rcnCKt2b2);										// Pb2\n	dPb = 1e-3*(rcnCKib + rcnCKb2b - rcnCKbt);											// Pb\n	dPt = 1e-3*(rcnCKbt-rcnCKta-rcnCKtt2);												// Pt\n	dPt2 = 1e-3*(rcnCKtt2-rcnCKt2a-rcnCKt2b2);											// Pt2\n	dPa = 1e-3*(rcnCKta+rcnCKt2a-rcnCKai);												// Pa\n\n	// CaN equations\n	dCa4CaN = 1e-3*(rcnCa4CaN - rcn0CaN - rcn2CaN - rcn4CaN);							// Ca4CaN\n	dCaMCa4CaN = 1e-3*(rcn0CaN - rcn02CaN);												// CaMCa4CaN\n	dCa2CaMCa4CaN = 1e-3*(rcn2CaN+rcn02CaN-rcn24CaN);									// Ca2CaMCa4CaN\n	dCa4CaMCa4CaN = 1e-3*(rcn4CaN+rcn24CaN);											// Ca4CaMCa4CaN\n\n	// encode output array\n	finavalu[offset_1] = dCaM;\n	finavalu[offset_2] = dCa2CaM;\n	finavalu[offset_3] = dCa4CaM;\n	finavalu[offset_4] = dCaMB;\n	finavalu[offset_5] = dCa2CaMB;\n	finavalu[offset_6] = dCa4CaMB;\n	finavalu[offset_7] = dPb2;\n	finavalu[offset_8] = dPb;\n	finavalu[offset_9] = dPt;\n	finavalu[offset_10] = dPt2;\n	finavalu[offset_11] = dPa;\n	finavalu[offset_12] = dCa4CaN;\n	finavalu[offset_13] = dCaMCa4CaN;\n	finavalu[offset_14] = dCa2CaMCa4CaN;\n	finavalu[offset_15] = dCa4CaMCa4CaN;\n\n	// write to global variables for adjusting Ca buffering in EC coupling model\n	JCa = 1e-3*(2*CaMKIItot*(rcnCKtt2-rcnCKb2b) - 2*(rcn02+rcn24+rcn02B+rcn24B+rcnCa4CaN+rcn02CaN+rcn24CaN)); // [uM/msec]\n\n	// return\n	return JCa;\n\n}\n"
myocyte/embedded_fehlberg_7_8.c,"////////////////////////////////////////////////////////////////////////////////\n// File: embedded_fehlberg_7_8.c                                              //\n// Routines:                                                                  //\n//    Embedded_Fehlberg_7_8                                                   //\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//                                                                            //\n//  Description:                                                              //\n//     The Runge-Kutta-Fehlberg method is an adaptive procedure for approxi-  //\n//     mating the solution of the differential equation y'(x) = f(x,y) with   //\n//     initial condition y(x0) = c.  This implementation evaluates f(x,y)     //\n//     thirteen times per step using embedded seventh order and eight order   //\n//     Runge-Kutta estimates to estimate the not only the solution but also   //\n//     the error.                                                             //\n//     The next step size is then calculated using the preassigned tolerance  //\n//     and error estimate.                                                    //\n//     For step i+1,                                                          //\n//        y[i+1] = y[i] +  h * (41/840 * k1 + 34/105 * finavalu_temp[5] + 9/35 * finavalu_temp[6]         //\n//                        + 9/35 * finavalu_temp[7] + 9/280 * finavalu_temp[8] + 9/280 finavalu_temp[9] + 41/840 finavalu_temp[10] ) //\n//     where                                                                  //\n//     k1 = f( x[i],y[i] ),                                                   //\n//     finavalu_temp[1] = f( x[i]+2h/27, y[i] + 2h*k1/27),                                  //\n//     finavalu_temp[2] = f( x[i]+h/9, y[i]+h/36*( k1 + 3 finavalu_temp[1]) ),                            //\n//     finavalu_temp[3] = f( x[i]+h/6, y[i]+h/24*( k1 + 3 finavalu_temp[2]) ),                            //\n//     finavalu_temp[4] = f( x[i]+5h/12, y[i]+h/48*(20 k1 - 75 finavalu_temp[2] + 75 finavalu_temp[3])),                //\n//     finavalu_temp[5] = f( x[i]+h/2, y[i]+h/20*( k1 + 5 finavalu_temp[3] + 4 finavalu_temp[4] ) ),                    //\n//     finavalu_temp[6] = f( x[i]+5h/6, y[i]+h/108*( -25 k1 + 125 finavalu_temp[3] - 260 finavalu_temp[4] + 250 finavalu_temp[5] ) ), //\n//     finavalu_temp[7] = f( x[i]+h/6, y[i]+h*( 31/300 k1 + 61/225 finavalu_temp[4] - 2/9 finavalu_temp[5]              //\n//                                                            + 13/900 finavalu_temp[6]) )  //\n//     finavalu_temp[8] = f( x[i]+2h/3, y[i]+h*( 2 k1 - 53/6 finavalu_temp[3] + 704/45 finavalu_temp[4] - 107/9 finavalu_temp[5]      //\n//                                                      + 67/90 finavalu_temp[6] + 3 finavalu_temp[7]) ), //\n//     finavalu_temp[9] = f( x[i]+h/3, y[i]+h*( -91/108 k1 + 23/108 finavalu_temp[3] - 976/135 finavalu_temp[4]        //\n//                             + 311/54 finavalu_temp[5] - 19/60 finavalu_temp[6] + 17/6 finavalu_temp[7] - 1/12 finavalu_temp[8]) ), //\n//     finavalu_temp[10] = f( x[i]+h, y[i]+h*( 2383/4100 k1 - 341/164 finavalu_temp[3] + 4496/1025 finavalu_temp[4]     //\n//          - 301/82 finavalu_temp[5] + 2133/4100 finavalu_temp[6] + 45/82 finavalu_temp[7] + 45/164 finavalu_temp[8] + 18/41 finavalu_temp[9]) )  //\n//     finavalu_temp[11] = f( x[i], y[i]+h*( 3/205 k1 - 6/41 finavalu_temp[5] - 3/205 finavalu_temp[6] - 3/41 finavalu_temp[7]        //\n//                                                   + 3/41 finavalu_temp[8] + 6/41 finavalu_temp[9]) )  //\n//     finavalu_temp[12] = f( x[i]+h, y[i]+h*( -1777/4100 k1 - 341/164 finavalu_temp[3] + 4496/1025 finavalu_temp[4]    //\n//                      - 289/82 finavalu_temp[5] + 2193/4100 finavalu_temp[6] + 51/82 finavalu_temp[7] + 33/164 finavalu_temp[8] +   //\n//                                                        12/41 finavalu_temp[9] + finavalu_temp[11]) )  //\n//     x[i+1] = x[i] + h.                                                     //\n//                                                                            //\n//     The error is estimated to be                                           //\n//        err = -41/840 * h * ( k1 + finavalu_temp[10] - finavalu_temp[11] - finavalu_temp[12])                         //\n//     The step size h is then scaled by the scale factor                     //\n//         scale = 0.8 * | epsilon * y[i] / [err * (xmax - x[0])] | ^ 1/7     //\n//     The scale factor is further constrained 0.125 < scale < 4.0.           //\n//     The new step size is h := scale * h.                                   //\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//  static fp Runge_Kutta(fp (*f)(fp,fp), fp *y,          //\n//                                                       fp x0, fp h) //\n//                                                                            //\n//  Description:                                                              //\n//     This routine uses Fehlberg's embedded 7th and 8th order methods to     //\n//     approximate the solution of the differential equation y'=f(x,y) with   //\n//     the initial condition y = y[0] at x = x0.  The value at x + h is       //\n//     returned in y[1].  The function returns err / h ( the absolute error   //\n//     per step size ).                                                       //\n//                                                                            //\n//  Arguments:                                                                //\n//     fp *f  Pointer to the function which returns the slope at (x,y) of //\n//                integral curve of the differential equation y' = f(x,y)     //\n//                which passes through the point (x0,y[0]).                   //\n//     fp y[] On input y[0] is the initial value of y at x, on output     //\n//                y[1] is the solution at x + h.                              //\n//     fp x   Initial value of x.                                         //\n//     fp h   Step size                                                   //\n//                                                                            //\n//  Return Values:                                                            //\n//     This routine returns the err / h.  The solution of y(x) at x + h is    //\n//     returned in y[1].                                                      //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//		PARTICULAR SOLVER FUNCTION\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\nstatic fp embedded_fehlberg_7_8(	fp timeinst,\n															fp h,\n															fp* initvalu,\n															fp* finavalu,\n															fp* error,\n															fp* parameter,\n															int mode) {\n\n	// printf(""initvalu[0] = %f\n"", initvalu[0]);\n	// printf(""initvalu[10] = %f\n"", initvalu[10]);\n	// printf(""initvalu[50] = %f\n"", initvalu[50]);\n	// printf(""initvalu[90] = %f\n"", initvalu[90]);\n\n	// printf(""finavalu[0] = %f\n"", finavalu[0]);\n	// printf(""finavalu[10] = %f\n"", finavalu[10]);\n	// printf(""finavalu[50] = %f\n"", finavalu[50]);\n	// printf(""finavalu[90] = %f\n"", finavalu[90]);\n\n	//======================================================================================================================================================\n	//	VARIABLES\n	//======================================================================================================================================================\n\n	static const fp c_1_11 = 41.0 / 840.0;\n	static const fp c6 = 34.0 / 105.0;\n	static const fp c_7_8= 9.0 / 35.0;\n	static const fp c_9_10 = 9.0 / 280.0;\n\n	static const fp a2 = 2.0 / 27.0;\n	static const fp a3 = 1.0 / 9.0;\n	static const fp a4 = 1.0 / 6.0;\n	static const fp a5 = 5.0 / 12.0;\n	static const fp a6 = 1.0 / 2.0;\n	static const fp a7 = 5.0 / 6.0;\n	static const fp a8 = 1.0 / 6.0;\n	static const fp a9 = 2.0 / 3.0;\n	static const fp a10 = 1.0 / 3.0;\n\n	static const fp b31 = 1.0 / 36.0;\n	static const fp b32 = 3.0 / 36.0;\n	static const fp b41 = 1.0 / 24.0;\n	static const fp b43 = 3.0 / 24.0;\n	static const fp b51 = 20.0 / 48.0;\n	static const fp b53 = -75.0 / 48.0;\n	static const fp b54 = 75.0 / 48.0;\n	static const fp b61 = 1.0 / 20.0;\n	static const fp b64 = 5.0 / 20.0;\n	static const fp b65 = 4.0 / 20.0;\n	static const fp b71 = -25.0 / 108.0;\n	static const fp b74 =  125.0 / 108.0;\n	static const fp b75 = -260.0 / 108.0;\n	static const fp b76 =  250.0 / 108.0;\n	static const fp b81 = 31.0/300.0;\n	static const fp b85 = 61.0/225.0;\n	static const fp b86 = -2.0/9.0;\n	static const fp b87 = 13.0/900.0;\n	static const fp b91 = 2.0;\n	static const fp b94 = -53.0/6.0;\n	static const fp b95 = 704.0 / 45.0;\n	static const fp b96 = -107.0 / 9.0;\n	static const fp b97 = 67.0 / 90.0;\n	static const fp b98 = 3.0;\n	static const fp b10_1 = -91.0 / 108.0;\n	static const fp b10_4 = 23.0 / 108.0;\n	static const fp b10_5 = -976.0 / 135.0;\n	static const fp b10_6 = 311.0 / 54.0;\n	static const fp b10_7 = -19.0 / 60.0;\n	static const fp b10_8 = 17.0 / 6.0;\n	static const fp b10_9 = -1.0 / 12.0;\n	static const fp b11_1 = 2383.0 / 4100.0;\n	static const fp b11_4 = -341.0 / 164.0;\n	static const fp b11_5 = 4496.0 / 1025.0;\n	static const fp b11_6 = -301.0 / 82.0;\n	static const fp b11_7 = 2133.0 / 4100.0;\n	static const fp b11_8 = 45.0 / 82.0;\n	static const fp b11_9 = 45.0 / 164.0;\n	static const fp b11_10 = 18.0 / 41.0;\n	static const fp b12_1 = 3.0 / 205.0;\n	static const fp b12_6 = - 6.0 / 41.0;\n	static const fp b12_7 = - 3.0 / 205.0;\n	static const fp b12_8 = - 3.0 / 41.0;\n	static const fp b12_9 = 3.0 / 41.0;\n	static const fp b12_10 = 6.0 / 41.0;\n	static const fp b13_1 = -1777.0 / 4100.0;\n	static const fp b13_4 = -341.0 / 164.0;\n	static const fp b13_5 = 4496.0 / 1025.0;\n	static const fp b13_6 = -289.0 / 82.0;\n	static const fp b13_7 = 2193.0 / 4100.0;\n	static const fp b13_8 = 51.0 / 82.0;\n	static const fp b13_9 = 33.0 / 164.0;\n	static const fp b13_10 = 12.0 / 41.0;\n\n	static const fp err_factor  = -41.0 / 840.0;\n\n	fp h2_7 = a2 * h;\n\n	fp timeinst_temp;\n	fp* initvalu_temp;\n	fp** finavalu_temp;\n\n	int i;\n\n	//======================================================================================================================================================\n	//		TEMPORARY STORAGE ALLOCATION\n	//======================================================================================================================================================\n\n	initvalu_temp= (fp *) malloc(EQUATIONS* sizeof(fp));\n\n	finavalu_temp= (fp **) malloc(13* sizeof(fp *));\n	for (i= 0; i<13; i++){\n		finavalu_temp[i]= (fp *) malloc(EQUATIONS* sizeof(fp));\n	}\n\n	//======================================================================================================================================================\n	//		EVALUATIONS\n	//======================================================================================================================================================\n\n	//===================================================================================================\n	//		1\n	//===================================================================================================\n\n	timeinst_temp = timeinst;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] ;\n		// printf(""initvalu[%d] = %f\n"", i, initvalu[i]);\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[0],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[0][%d] = %f\n"", i, finavalu_temp[0][i]);\n	// }\n\n	//===================================================================================================\n	//		2\n	//===================================================================================================\n\n	timeinst_temp = timeinst+h2_7;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h2_7 * (finavalu_temp[0][i]);\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[1],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[1][%d] = %f\n"", i, finavalu_temp[1][i]);\n	// }\n\n	//===================================================================================================\n	//		3\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a3*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b31*finavalu_temp[0][i] + b32*finavalu_temp[1][i]);\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[2],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[2][%d] = %f\n"", i, finavalu_temp[2][i]);\n	// }\n\n	//===================================================================================================\n	//		4\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a4*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b41*finavalu_temp[0][i] + b43*finavalu_temp[2][i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[3],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[3][%d] = %f\n"", i, finavalu_temp[3][i]);\n	// }\n\n	//===================================================================================================\n	//		5\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a5*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b51*finavalu_temp[0][i] + b53*finavalu_temp[2][i] + b54*finavalu_temp[3][i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[4],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[4][%d] = %f\n"", i, finavalu_temp[4][i]);\n	// }\n\n	//===================================================================================================\n	//		6\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a6*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b61*finavalu_temp[0][i] + b64*finavalu_temp[3][i] + b65*finavalu_temp[4][i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[5],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[5][%d] = %f\n"", i, finavalu_temp[5][i]);\n	// }\n\n	//===================================================================================================\n	//		7\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a7*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b71*finavalu_temp[0][i] + b74*finavalu_temp[3][i] + b75*finavalu_temp[4][i] + b76*finavalu_temp[5][i]);\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[6],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[6][%d] = %f\n"", i, finavalu_temp[6][i]);\n	// }\n\n	//===================================================================================================\n	//		8\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a8*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b81*finavalu_temp[0][i] + b85*finavalu_temp[4][i] + b86*finavalu_temp[5][i] + b87*finavalu_temp[6][i]);\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[7],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[7][%d] = %f\n"", i, finavalu_temp[7][i]);\n	// }\n\n	//===================================================================================================\n	//		9\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a9*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b91*finavalu_temp[0][i] + b94*finavalu_temp[3][i] + b95*finavalu_temp[4][i] + b96*finavalu_temp[5][i] + b97*finavalu_temp[6][i]+ b98*finavalu_temp[7][i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[8],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[8][%d] = %f\n"", i, finavalu_temp[8][i]);\n	// }\n\n	//===================================================================================================\n	//		10\n	//===================================================================================================\n\n	timeinst_temp = timeinst+a10*h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b10_1*finavalu_temp[0][i] + b10_4*finavalu_temp[3][i] + b10_5*finavalu_temp[4][i] + b10_6*finavalu_temp[5][i] + b10_7*finavalu_temp[6][i] + b10_8*finavalu_temp[7][i] + b10_9*finavalu_temp[8] [i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[9],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[9][%d] = %f\n"", i, finavalu_temp[9][i]);\n	// }\n\n	//===================================================================================================\n	//		11\n	//===================================================================================================\n\n	timeinst_temp = timeinst+h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b11_1*finavalu_temp[0][i] + b11_4*finavalu_temp[3][i] + b11_5*finavalu_temp[4][i] + b11_6*finavalu_temp[5][i] + b11_7*finavalu_temp[6][i] + b11_8*finavalu_temp[7][i] + b11_9*finavalu_temp[8][i]+ b11_10 * finavalu_temp[9][i]);\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[10],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[10][%d] = %f\n"", i, finavalu_temp[10][i]);\n	// }\n\n	//===================================================================================================\n	//		12\n	//===================================================================================================\n\n	timeinst_temp = timeinst;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b12_1*finavalu_temp[0][i] + b12_6*finavalu_temp[5][i] + b12_7*finavalu_temp[6][i] + b12_8*finavalu_temp[7][i] + b12_9*finavalu_temp[8][i] + b12_10 * finavalu_temp[9][i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[11],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[11][%d] = %f\n"", i, finavalu_temp[11][i]);\n	// }\n\n	//===================================================================================================\n	//		13\n	//===================================================================================================\n\n	timeinst_temp = timeinst+h;\n	for(i=0; i<EQUATIONS; i++){\n		initvalu_temp[i] = initvalu[i] + h * ( b13_1*finavalu_temp[0][i] + b13_4*finavalu_temp[3][i] + b13_5*finavalu_temp[4][i] + b13_6*finavalu_temp[5][i] + b13_7*finavalu_temp[6][i] + b13_8*finavalu_temp[7][i] + b13_9*finavalu_temp[8][i] + b13_10*finavalu_temp[9][i] + finavalu_temp[11][i]) ;\n	}\n\n	master(	timeinst_temp,\n					initvalu_temp,\n					parameter,\n					finavalu_temp[12],\n					mode);\n\n	// for(i=0; i<EQUATIONS; i++){\n		// printf(""finavalu_temp[12][%d] = %f\n"", i, finavalu_temp[12][i]);\n	// }\n\n	//======================================================================================================================================================\n	//		FINAL VALUE\n	//======================================================================================================================================================\n\n	for(i=0; i<EQUATIONS; i++){\n		finavalu[i]= initvalu[i] +  h * (c_1_11 * (finavalu_temp[0][i] + finavalu_temp[10][i])  + c6 * finavalu_temp[5][i] + c_7_8 * (finavalu_temp[6][i] + finavalu_temp[7][i]) + c_9_10 * (finavalu_temp[8][i] + finavalu_temp[9][i]) );\n		// printf(""finavalu_temp[0][%d] = %f\n"", i, finavalu_temp[0][i]);\n		// printf(""finavalu_temp[10][%d] = %f\n"", i, finavalu_temp[10][i]);\n		// printf(""finavalu_temp[5][%d] = %f\n"", i, finavalu_temp[5][i]);\n		// printf(""finavalu_temp[6][%d] = %f\n"", i, finavalu_temp[6][i]);\n		// printf(""finavalu_temp[7][%d] = %f\n"", i, finavalu_temp[7][i]);\n		// printf(""finavalu_temp[8][%d] = %f\n"", i, finavalu_temp[8][i]);\n		// printf(""finavalu_temp[9][%d] = %f\n"", i, finavalu_temp[9][i]);\n		// printf(""finavalu[%d] = %f\n"", i, finavalu[i]);\n	}\n\n	//======================================================================================================================================================\n	//		RETURN\n	//======================================================================================================================================================\n\n	for(i=0; i<EQUATIONS; i++){\n		error[i] = fabs(err_factor * (finavalu_temp[0][i] + finavalu_temp[10][i] - finavalu_temp[11][i] - finavalu_temp[12][i]));\n		// printf(""Error[%d] = %f\n"", i, error[i]);\n	}\n\n	//======================================================================================================================================================\n	//		DEALLOCATION\n	//======================================================================================================================================================\n\n	free(initvalu_temp);\n	free(finavalu_temp);\n\n}\n"
myocyte/master.c,"//=====================================================================\n//	MAIN FUNCTION\n//=====================================================================\n\nvoid master(fp timeinst,\n					fp* initvalu,\n					fp* parameter,\n					fp* finavalu,\n					int mode){\n\n	//=====================================================================\n	//	VARIABLES\n	//=====================================================================\n\n	// counters\n	int i;\n\n	// intermediate output on host\n	fp JCaDyad;\n	fp JCaSL;\n	fp JCaCyt;\n\n	// offset pointers\n	int initvalu_offset_batch;															//\n	int initvalu_offset_ecc;																// 46 points\n	int parameter_offset_ecc;\n	int initvalu_offset_Dyad;															// 15 points\n	int parameter_offset_Dyad;\n	int initvalu_offset_SL;																// 15 points\n	int parameter_offset_SL;\n	int initvalu_offset_Cyt;																// 15 poitns\n	int parameter_offset_Cyt;\n\n	// module parameters\n	fp CaDyad;																					// from ECC model, *** Converting from [mM] to [uM] ***\n	fp CaSL;																						// from ECC model, *** Converting from [mM] to [uM] ***\n	fp CaCyt;																					// from ECC model, *** Converting from [mM] to [uM] ***\n\n		// thread counters\n		int th_id, nthreads;\n		int th_count[4];\n		int temp;\n\n	//=====================================================================\n	//	KERNELS FOR 1 WORKLOAD - PARALLEL\n	//=====================================================================\n\n	nthreads = omp_get_max_threads();\n\n	if(mode == 0){\n\n		// partition workload between threads\n		temp = 0;\n		for(i=0; i<4; i++){													// do for all 4 pieces of work\n			if(temp>=nthreads){											// limit according to number of threads\n				temp = 0;\n			}\n			th_count[i] = temp;												// assign thread to piece of work\n			temp = temp +1;\n		}\n\n		// run pieces of work in parallel\n		#pragma omp parallel private(th_id)\n		{\n\n			if (th_id == th_count[1]) {\n\n				// ecc function\n				initvalu_offset_ecc = 0;												// 46 points\n				parameter_offset_ecc = 0;\n				ecc(						timeinst,\n											initvalu,\n											initvalu_offset_ecc,\n											parameter,\n											parameter_offset_ecc,\n											finavalu);\n\n			}\n\n			if (th_id == th_count[2]) {\n\n				// cam function for Dyad\n				initvalu_offset_Dyad = 46;											// 15 points\n				parameter_offset_Dyad = 1;\n				CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n				JCaDyad = cam(timeinst,\n											initvalu,\n											initvalu_offset_Dyad,\n											parameter,\n											parameter_offset_Dyad,\n											finavalu,\n											CaDyad);\n\n			}\n\n			if (th_id == th_count[3]) {\n\n				// cam function for SL\n				initvalu_offset_SL = 61;											// 15 points\n				parameter_offset_SL = 6;\n				CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n				JCaSL = cam(		timeinst,\n											initvalu,\n											initvalu_offset_SL,\n											parameter,\n											parameter_offset_SL,\n											finavalu,\n											CaSL);\n\n			}\n\n			if (th_id == th_count[4]) {\n\n				// cam function for Cyt\n				initvalu_offset_Cyt = 76;												// 15 poitns\n				parameter_offset_Cyt = 11;\n				CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n				JCaCyt = cam(	timeinst,\n											initvalu,\n											initvalu_offset_Cyt,\n											parameter,\n											parameter_offset_Cyt,\n											finavalu,\n											CaCyt);\n\n			}\n\n		}\n\n	}\n\n	//=====================================================================\n	//	KERNELS FOR MANY WORKLOAD - SERIAL\n	//=====================================================================\n\n	else{\n\n		// ecc function\n		initvalu_offset_ecc = 0;												// 46 points\n		parameter_offset_ecc = 0;\n		ecc(						timeinst,\n									initvalu,\n									initvalu_offset_ecc,\n									parameter,\n									parameter_offset_ecc,\n									finavalu);\n\n		// cam function for Dyad\n		initvalu_offset_Dyad = 46;											// 15 points\n		parameter_offset_Dyad = 1;\n		CaDyad = initvalu[35]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n		JCaDyad = cam(timeinst,\n									initvalu,\n									initvalu_offset_Dyad,\n									parameter,\n									parameter_offset_Dyad,\n									finavalu,\n									CaDyad);\n\n		// cam function for SL\n		initvalu_offset_SL = 61;											// 15 points\n		parameter_offset_SL = 6;\n		CaSL = initvalu[36]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n		JCaSL = cam(		timeinst,\n									initvalu,\n									initvalu_offset_SL,\n									parameter,\n									parameter_offset_SL,\n									finavalu,\n									CaSL);\n\n		// cam function for Cyt\n		initvalu_offset_Cyt = 76;												// 15 poitns\n		parameter_offset_Cyt = 11;\n		CaCyt = initvalu[37]*1e3;											// from ECC model, *** Converting from [mM] to [uM] ***\n		JCaCyt = cam(	timeinst,\n									initvalu,\n									initvalu_offset_Cyt,\n									parameter,\n									parameter_offset_Cyt,\n									finavalu,\n									CaCyt);\n\n	}\n\n	//=====================================================================\n	//	FINAL KERNEL\n	//=====================================================================\n\n	// final adjustments\n	fin(						initvalu,\n								initvalu_offset_ecc,\n								initvalu_offset_Dyad,\n								initvalu_offset_SL,\n								initvalu_offset_Cyt,\n								parameter,\n								finavalu,\n								JCaDyad,\n								JCaSL,\n								JCaCyt);\n\n	//=====================================================================\n	//	COMPENSATION FOR NANs and INFs\n	//=====================================================================\n\n	// make sure function does not return NANs and INFs\n	for(i=0; i<EQUATIONS; i++){\n		if (isnan(finavalu[i]) == 1){ \n			finavalu[i] = 0.0001;												// for NAN set rate of change to 0.0001\n		}\n		else if (isinf(finavalu[i]) == 1){ \n			finavalu[i] = 0.0001;												// for INF set rate of change to 0.0001\n		}\n	}\n\n}\n"
myocyte/ecc.c,"//=====================================================================\n//	MAIN FUNCTION\n//=====================================================================\nvoid ecc(	fp timeinst,\n				fp *initvalu,\n				int initvalu_offset,\n				fp *parameter,\n				int parameter_offset,\n				fp *finavalu){\n\n	//=====================================================================\n	//	VARIABLES\n	//=====================================================================\n\n	// initial data and output data variable references\n	int offset_1;\n	int offset_2;\n	int offset_3;\n	int offset_4;\n	int offset_5;\n	int offset_6;\n	int offset_7;\n	int offset_8;\n	int offset_9;\n	int offset_10;\n	int offset_11;\n	int offset_12;\n	int offset_13;\n	int offset_14;\n	int offset_15;\n	int offset_16;\n	int offset_17;\n	int offset_18;\n	int offset_19;\n	int offset_20;\n	int offset_21;\n	int offset_22;\n	int offset_23;\n	int offset_24;\n	int offset_25;\n	int offset_26;\n	int offset_27;\n	int offset_28;\n	int offset_29;\n	int offset_30;\n	int offset_31;\n	int offset_32;\n	int offset_33;\n	int offset_34;\n	int offset_35;\n	int offset_36;\n	int offset_37;\n	int offset_38;\n	int offset_39;\n	int offset_40;\n	int offset_41;\n	int offset_42;\n	int offset_43;\n	int offset_44;\n	int offset_45;\n	int offset_46;\n\n	// initial data variable references\n	int parameter_offset_1;\n\n	// decoded input initial data			// GET VARIABLES FROM MEMORY AND SAVE LOCALLY !!!!!!!!!!!!!!!!!!\n	fp initvalu_1;\n	fp initvalu_2;\n	fp initvalu_3;\n	fp initvalu_4;\n	fp initvalu_5;\n	fp initvalu_6;\n	fp initvalu_7;\n	fp initvalu_8;\n	fp initvalu_9;\n	fp initvalu_10;\n	fp initvalu_11;\n	fp initvalu_12;\n	fp initvalu_13;\n	fp initvalu_14;\n	fp initvalu_15;\n	fp initvalu_16;\n	fp initvalu_17;\n	fp initvalu_18;\n	fp initvalu_19;\n	fp initvalu_20;\n	fp initvalu_21;\n	fp initvalu_22;\n	fp initvalu_23;\n	fp initvalu_24;\n	fp initvalu_25;\n	fp initvalu_26;\n	fp initvalu_27;\n	fp initvalu_28;\n	fp initvalu_29;\n	fp initvalu_30;\n	fp initvalu_31;\n	fp initvalu_32;\n	fp initvalu_33;\n	fp initvalu_34;\n	fp initvalu_35;\n	fp initvalu_36;\n	fp initvalu_37;\n	fp initvalu_38;\n	fp initvalu_39;\n	fp initvalu_40;\n	fp initvalu_41;\n	fp initvalu_42;\n	fp initvalu_43;\n	fp initvalu_44;\n	fp initvalu_45;\n	fp initvalu_46;\n\n	// decoded input parameters\n	fp parameter_1;\n\n	// matlab constants undefined in c\n	fp pi;\n\n	// Constants\n	fp R;																			// [J/kmol*K]  \n	fp Frdy;																		// [C/mol]  \n	fp Temp;																		// [K] 310\n	fp FoRT;																		//\n	fp Cmem;																		// [F] membrane capacitance\n	fp Qpow;\n\n	// Cell geometry\n	fp cellLength;																	// cell length [um]\n	fp cellRadius;																	// cell radius [um]\n	fp junctionLength;																// junc length [um]\n	fp junctionRadius;																// junc radius [um]\n	fp distSLcyto;																	// dist. SL to cytosol [um]\n	fp distJuncSL;																	// dist. junc to SL [um]\n	fp DcaJuncSL;																	// Dca junc to SL [cm^2/sec]\n	fp DcaSLcyto;																	// Dca SL to cyto [cm^2/sec]\n	fp DnaJuncSL;																	// Dna junc to SL [cm^2/sec]\n	fp DnaSLcyto;																	// Dna SL to cyto [cm^2/sec] \n	fp Vcell;																		// [L]\n	fp Vmyo; \n	fp Vsr; \n	fp Vsl; \n	fp Vjunc; \n	fp SAjunc;																		// [um^2]\n	fp SAsl;																		// [um^2]\n	fp J_ca_juncsl;																	// [L/msec]\n	fp J_ca_slmyo;																	// [L/msec]\n	fp J_na_juncsl;																	// [L/msec] \n	fp J_na_slmyo;																	// [L/msec] \n\n	// Fractional currents in compartments\n	fp Fjunc;   \n	fp Fsl;\n	fp Fjunc_CaL; \n	fp Fsl_CaL;\n\n	// Fixed ion concentrations     \n	fp Cli;																			// Intracellular Cl  [mM]\n	fp Clo;																			// Extracellular Cl  [mM]\n	fp Ko;																			// Extracellular K   [mM]\n	fp Nao;																			// Extracellular Na  [mM]\n	fp Cao;																			// Extracellular Ca  [mM]\n	fp Mgi;																			// Intracellular Mg  [mM]\n\n	// Nernst Potentials\n	fp ena_junc;																	// [mV]\n	fp ena_sl;																		// [mV]\n	fp ek;																			// [mV]\n	fp eca_junc;																	// [mV]\n	fp eca_sl;																		// [mV]\n	fp ecl;																			// [mV]\n\n	// Na transport parameters\n	fp GNa;																			// [mS/uF]\n	fp GNaB;																		// [mS/uF] \n	fp IbarNaK;																		// [uA/uF]\n	fp KmNaip;																		// [mM]\n	fp KmKo;																		// [mM]\n	fp Q10NaK;  \n	fp Q10KmNai;\n\n	// K current parameters\n	fp pNaK;      \n	fp GtoSlow;																		// [mS/uF] \n	fp GtoFast;																		// [mS/uF] \n	fp gkp;\n\n	// Cl current parameters\n	fp GClCa;																		// [mS/uF]\n	fp GClB;																		// [mS/uF]\n	fp KdClCa;																		// [mM]																// [mM]\n\n	// I_Ca parameters\n	fp pNa;																			// [cm/sec]\n	fp pCa;																			// [cm/sec]\n	fp pK;																			// [cm/sec]\n	fp KmCa;																		// [mM]\n	fp Q10CaL;       \n\n	// Ca transport parameters\n	fp IbarNCX;																		// [uA/uF]\n	fp KmCai;																		// [mM]\n	fp KmCao;																		// [mM]\n	fp KmNai;																		// [mM]\n	fp KmNao;																		// [mM]\n	fp ksat;																			// [none]  \n	fp nu;																			// [none]\n	fp Kdact;																		// [mM] \n	fp Q10NCX;																		// [none]\n	fp IbarSLCaP;																	// [uA/uF]\n	fp KmPCa;																		// [mM] \n	fp GCaB;																		// [uA/uF] \n	fp Q10SLCaP;																	// [none]																	// [none]\n\n	// SR flux parameters\n	fp Q10SRCaP;																	// [none]\n	fp Vmax_SRCaP;																	// [mM/msec] (mmol/L cytosol/msec)\n	fp Kmf;																			// [mM]\n	fp Kmr;																			// [mM]L cytosol\n	fp hillSRCaP;																	// [mM]\n	fp ks;																			// [1/ms]      \n	fp koCa;																		// [mM^-2 1/ms]      \n	fp kom;																			// [1/ms]     \n	fp kiCa;																		// [1/mM/ms]\n	fp kim;																			// [1/ms]\n	fp ec50SR;																		// [mM]\n\n	// Buffering parameters\n	fp Bmax_Naj;																	// [mM] \n	fp Bmax_Nasl;																	// [mM]\n	fp koff_na;																		// [1/ms]\n	fp kon_na;																		// [1/mM/ms]\n	fp Bmax_TnClow;																	// [mM], TnC low affinity\n	fp koff_tncl;																	// [1/ms] \n	fp kon_tncl;																	// [1/mM/ms]\n	fp Bmax_TnChigh;																// [mM], TnC high affinity \n	fp koff_tnchca;																	// [1/ms] \n	fp kon_tnchca;																	// [1/mM/ms]\n	fp koff_tnchmg;																	// [1/ms] \n	fp kon_tnchmg;																	// [1/mM/ms]\n	fp Bmax_CaM;																	// [mM], CaM buffering\n	fp koff_cam;																	// [1/ms] \n	fp kon_cam;																		// [1/mM/ms]\n	fp Bmax_myosin;																	// [mM], Myosin buffering\n	fp koff_myoca;																	// [1/ms]\n	fp kon_myoca;																	// [1/mM/ms]\n	fp koff_myomg;																	// [1/ms]\n	fp kon_myomg;																	// [1/mM/ms]\n	fp Bmax_SR;																		// [mM] \n	fp koff_sr;																		// [1/ms]\n	fp kon_sr;																		// [1/mM/ms]\n	fp Bmax_SLlowsl;																// [mM], SL buffering\n	fp Bmax_SLlowj;																	// [mM]    \n	fp koff_sll;																	// [1/ms]\n	fp kon_sll;																		// [1/mM/ms]\n	fp Bmax_SLhighsl;																// [mM] \n	fp Bmax_SLhighj;																// [mM] \n	fp koff_slh;																	// [1/ms]\n	fp kon_slh;																		// [1/mM/ms]\n	fp Bmax_Csqn;																	// 140e-3*Vmyo/Vsr; [mM] \n	fp koff_csqn;																	// [1/ms] \n	fp kon_csqn;																	// [1/mM/ms] \n\n	// I_Na: Fast Na Current\n	fp am;\n	fp bm;\n	fp ah;\n	fp bh;\n	fp aj;\n	fp bj;\n	fp I_Na_junc;\n	fp I_Na_sl;\n	fp I_Na;\n\n	// I_nabk: Na Background Current\n	fp I_nabk_junc;\n	fp I_nabk_sl;\n	fp I_nabk;\n\n	// I_nak: Na/K Pump Current\n	fp sigma;\n	fp fnak;\n	fp I_nak_junc;\n	fp I_nak_sl;\n	fp I_nak;\n\n	// I_kr: Rapidly Activating K Current\n	fp gkr;\n	fp xrss;\n	fp tauxr;\n	fp rkr;\n	fp I_kr;\n\n	// I_ks: Slowly Activating K Current\n	fp pcaks_junc; \n	fp pcaks_sl;  \n	fp gks_junc;\n	fp gks_sl; \n	fp eks;	\n	fp xsss;\n	fp tauxs; \n	fp I_ks_junc;\n	fp I_ks_sl;\n	fp I_ks;\n\n	// I_kp: Plateau K current\n	fp kp_kp;\n	fp I_kp_junc;\n	fp I_kp_sl;\n	fp I_kp;\n\n	// I_to: Transient Outward K Current (slow and fast components)\n	fp xtoss;\n	fp ytoss;\n	fp rtoss;\n	fp tauxtos;\n	fp tauytos;\n	fp taurtos; \n	fp I_tos;	\n\n	//\n	fp tauxtof;\n	fp tauytof;\n	fp I_tof;\n	fp I_to;\n\n	// I_ki: Time-Independent K Current\n	fp aki;\n	fp bki;\n	fp kiss;\n	fp I_ki;\n\n	// I_ClCa: Ca-activated Cl Current, I_Clbk: background Cl Current\n	fp I_ClCa_junc;\n	fp I_ClCa_sl;\n	fp I_ClCa;\n	fp I_Clbk;\n\n	// I_Ca: L-type Calcium Current\n	fp dss;\n	fp taud;\n	fp fss;\n	fp tauf;\n\n	//\n	fp ibarca_j;\n	fp ibarca_sl;\n	fp ibark;\n	fp ibarna_j;\n	fp ibarna_sl;\n	fp I_Ca_junc;\n	fp I_Ca_sl;\n	fp I_Ca;\n	fp I_CaK;\n	fp I_CaNa_junc;\n	fp I_CaNa_sl;\n	fp I_CaNa;\n	fp I_Catot;\n\n	// I_ncx: Na/Ca Exchanger flux\n	fp Ka_junc;\n	fp Ka_sl;\n	fp s1_junc;\n	fp s1_sl;\n	fp s2_junc;\n	fp s3_junc;\n	fp s2_sl;\n	fp s3_sl;\n	fp I_ncx_junc;\n	fp I_ncx_sl;\n	fp I_ncx;\n\n	// I_pca: Sarcolemmal Ca Pump Current\n	fp I_pca_junc;\n	fp I_pca_sl;\n	fp I_pca;\n\n	// I_cabk: Ca Background Current\n	fp I_cabk_junc;\n	fp I_cabk_sl;\n	fp I_cabk;\n	\n	// SR fluxes: Calcium Release, SR Ca pump, SR Ca leak														\n	fp MaxSR;\n	fp MinSR;\n	fp kCaSR;\n	fp koSRCa;\n	fp kiSRCa;\n	fp RI;\n	fp J_SRCarel;																	// [mM/ms]\n	fp J_serca;\n	fp J_SRleak;																		//   [mM/ms]\n\n	// Cytosolic Ca Buffers\n	fp J_CaB_cytosol;\n\n	// Junctional and SL Ca Buffers\n	fp J_CaB_junction;\n	fp J_CaB_sl;\n\n	// SR Ca Concentrations\n	fp oneovervsr;\n\n	// Sodium Concentrations\n	fp I_Na_tot_junc;																// [uA/uF]\n	fp I_Na_tot_sl;																	// [uA/uF]\n	fp oneovervsl;\n\n	// Potassium Concentration\n	fp I_K_tot;\n\n	// Calcium Concentrations\n	fp I_Ca_tot_junc;																// [uA/uF]\n	fp I_Ca_tot_sl;																	// [uA/uF]\n	fp junc_sl;\n	fp sl_junc;\n	fp sl_myo;\n	fp myo_sl;\n\n	//	Simulation type													\n	int state;																			// 0-none; 1-pace; 2-vclamp\n	fp I_app;\n	fp V_hold;\n	fp V_test;\n	fp V_clamp;\n	fp R_clamp;\n	\n	//	Membrane Potential\n	fp I_Na_tot;																		// [uA/uF]\n	fp I_Cl_tot;																		// [uA/uF]\n	fp I_Ca_tot;\n	fp I_tot;\n\n	//=====================================================================\n	//	EXECUTION\n	//=====================================================================\n\n	// variable references\n	offset_1  = initvalu_offset;\n	offset_2  = initvalu_offset+1;\n	offset_3  = initvalu_offset+2;\n	offset_4  = initvalu_offset+3;\n	offset_5  = initvalu_offset+4;\n	offset_6  = initvalu_offset+5;\n	offset_7  = initvalu_offset+6;\n	offset_8  = initvalu_offset+7;\n	offset_9  = initvalu_offset+8;\n	offset_10 = initvalu_offset+9;\n	offset_11 = initvalu_offset+10;\n	offset_12 = initvalu_offset+11;\n	offset_13 = initvalu_offset+12;\n	offset_14 = initvalu_offset+13;\n	offset_15 = initvalu_offset+14;\n	offset_16 = initvalu_offset+15;\n	offset_17 = initvalu_offset+16;\n	offset_18 = initvalu_offset+17;\n	offset_19 = initvalu_offset+18;\n	offset_20 = initvalu_offset+19;\n	offset_21 = initvalu_offset+20;\n	offset_22 = initvalu_offset+21;\n	offset_23 = initvalu_offset+22;\n	offset_24 = initvalu_offset+23;\n	offset_25 = initvalu_offset+24;\n	offset_26 = initvalu_offset+25;\n	offset_27 = initvalu_offset+26;\n	offset_28 = initvalu_offset+27;\n	offset_29 = initvalu_offset+28;\n	offset_30 = initvalu_offset+29;\n	offset_31 = initvalu_offset+30;\n	offset_32 = initvalu_offset+31;\n	offset_33 = initvalu_offset+32;\n	offset_34 = initvalu_offset+33;\n	offset_35 = initvalu_offset+34;\n	offset_36 = initvalu_offset+35;\n	offset_37 = initvalu_offset+36;\n	offset_38 = initvalu_offset+37;\n	offset_39 = initvalu_offset+38;\n	offset_40 = initvalu_offset+39;\n	offset_41 = initvalu_offset+40;\n	offset_42 = initvalu_offset+41;\n	offset_43 = initvalu_offset+42;\n	offset_44 = initvalu_offset+43;\n	offset_45 = initvalu_offset+44;\n	offset_46 = initvalu_offset+45;\n	\n	// variable references\n	parameter_offset_1  = parameter_offset;\n\n	// decoded input initial data\n	initvalu_1  = initvalu[offset_1 ];\n	initvalu_2  = initvalu[offset_2 ];\n	initvalu_3  = initvalu[offset_3 ];\n	initvalu_4  = initvalu[offset_4 ];\n	initvalu_5  = initvalu[offset_5 ];\n	initvalu_6  = initvalu[offset_6 ];\n	initvalu_7  = initvalu[offset_7 ];\n	initvalu_8  = initvalu[offset_8 ];\n	initvalu_9  = initvalu[offset_9 ];\n	initvalu_10 = initvalu[offset_10];\n	initvalu_11 = initvalu[offset_11];\n	initvalu_12 = initvalu[offset_12];\n	initvalu_13 = initvalu[offset_13];\n	initvalu_14 = initvalu[offset_14];\n	initvalu_15 = initvalu[offset_15];\n	initvalu_16 = initvalu[offset_16];\n	initvalu_17 = initvalu[offset_17];\n	initvalu_18 = initvalu[offset_18];\n	initvalu_19 = initvalu[offset_19];\n	initvalu_20 = initvalu[offset_20];\n	initvalu_21 = initvalu[offset_21];\n	initvalu_22 = initvalu[offset_22];\n	initvalu_23 = initvalu[offset_23];\n	initvalu_24 = initvalu[offset_24];\n	initvalu_25 = initvalu[offset_25];\n	initvalu_26 = initvalu[offset_26];\n	initvalu_27 = initvalu[offset_27];\n	initvalu_28 = initvalu[offset_28];\n	initvalu_29 = initvalu[offset_29];\n	initvalu_30 = initvalu[offset_30];\n	initvalu_31 = initvalu[offset_31];\n	initvalu_32 = initvalu[offset_32];\n	initvalu_33 = initvalu[offset_33];\n	initvalu_34 = initvalu[offset_34];\n	initvalu_35 = initvalu[offset_35];\n	initvalu_36 = initvalu[offset_36];\n	initvalu_37 = initvalu[offset_37];\n	initvalu_38 = initvalu[offset_38];\n	initvalu_39 = initvalu[offset_39];\n	initvalu_40 = initvalu[offset_40];\n	initvalu_41 = initvalu[offset_41];\n	initvalu_42 = initvalu[offset_42];\n	initvalu_43 = initvalu[offset_43];\n	initvalu_44 = initvalu[offset_44];\n	initvalu_45 = initvalu[offset_45];\n	initvalu_46 = initvalu[offset_46];\n\n	// decoded input parameters\n	parameter_1 = parameter[parameter_offset_1];\n\n	// matlab constants undefined in c\n	pi = 3.1416;\n\n	// Constants\n	R = 8314;																			// [J/kmol*K]  \n	Frdy = 96485;																		// [C/mol]  \n	Temp = 310;																			// [K] 310\n	FoRT = Frdy/R/Temp;																	//\n	Cmem = 1.3810e-10;																	// [F] membrane capacitance\n	Qpow = (Temp-310)/10;\n\n	// Cell geometry\n	cellLength = 100;																	// cell length [um]\n	cellRadius = 10.25;																	// cell radius [um]\n	junctionLength = 160e-3;															// junc length [um]\n	junctionRadius = 15e-3;																// junc radius [um]\n	distSLcyto = 0.45;																	// dist. SL to cytosol [um]\n	distJuncSL = 0.5;																	// dist. junc to SL [um]\n	DcaJuncSL = 1.64e-6;																// Dca junc to SL [cm^2/sec]\n	DcaSLcyto = 1.22e-6;																// Dca SL to cyto [cm^2/sec]\n	DnaJuncSL = 1.09e-5;																// Dna junc to SL [cm^2/sec]\n	DnaSLcyto = 1.79e-5;																// Dna SL to cyto [cm^2/sec] \n	Vcell = pi*pow(cellRadius,2)*cellLength*1e-15;											// [L]\n	Vmyo = 0.65*Vcell; \n	Vsr = 0.035*Vcell; \n	Vsl = 0.02*Vcell; \n	Vjunc = 0.0539*0.01*Vcell; \n	SAjunc = 20150*pi*2*junctionLength*junctionRadius;									// [um^2]\n	SAsl = pi*2*cellRadius*cellLength;													// [um^2]\n	J_ca_juncsl = 1/1.2134e12;															// [L/msec]\n	J_ca_slmyo = 1/2.68510e11;															// [L/msec]\n	J_na_juncsl = 1/(1.6382e12/3*100);													// [L/msec] \n	J_na_slmyo = 1/(1.8308e10/3*100);													// [L/msec] \n\n	// Fractional currents in compartments\n	Fjunc = 0.11;   \n	Fsl = 1-Fjunc;\n	Fjunc_CaL = 0.9; \n	Fsl_CaL = 1-Fjunc_CaL;\n\n	// Fixed ion concentrations     \n	Cli = 15;																			// Intracellular Cl  [mM]\n	Clo = 150;																			// Extracellular Cl  [mM]\n	Ko = 5.4;																			// Extracellular K   [mM]\n	Nao = 140;																			// Extracellular Na  [mM]\n	Cao = 1.8;																			// Extracellular Ca  [mM]\n	Mgi = 1;																			// Intracellular Mg  [mM]\n\n	// Nernst Potentials\n	ena_junc = (1/FoRT)*log(Nao/initvalu_32);													// [mV]\n	ena_sl = (1/FoRT)*log(Nao/initvalu_33);													// [mV]\n	ek = (1/FoRT)*log(Ko/initvalu_35);														// [mV]\n	eca_junc = (1/FoRT/2)*log(Cao/initvalu_36);												// [mV]\n	eca_sl = (1/FoRT/2)*log(Cao/initvalu_37);													// [mV]\n	ecl = (1/FoRT)*log(Cli/Clo);														// [mV]\n\n	// Na transport parameters\n	GNa =  16.0;																		// [mS/uF]\n	GNaB = 0.297e-3;																	// [mS/uF] \n	IbarNaK = 1.90719;																	// [uA/uF]\n	KmNaip = 11;																		// [mM]\n	KmKo = 1.5;																			// [mM]\n	Q10NaK = 1.63;  \n	Q10KmNai = 1.39;\n\n	// K current parameters\n	pNaK = 0.01833;      \n	GtoSlow = 0.06;																		// [mS/uF] \n	GtoFast = 0.02;																		// [mS/uF] \n	gkp = 0.001;\n\n	// Cl current parameters\n	GClCa = 0.109625;																	// [mS/uF]\n	GClB = 9e-3;																		// [mS/uF]\n	KdClCa = 100e-3;																	// [mM]\n\n	// I_Ca parameters\n	pNa = 1.5e-8;																		// [cm/sec]\n	pCa = 5.4e-4;																		// [cm/sec]\n	pK = 2.7e-7;																		// [cm/sec]\n	KmCa = 0.6e-3;																		// [mM]\n	Q10CaL = 1.8;       \n\n	// Ca transport parameters\n	IbarNCX = 9.0;																		// [uA/uF]\n	KmCai = 3.59e-3;																	// [mM]\n	KmCao = 1.3;																		// [mM]\n	KmNai = 12.29;																		// [mM]\n	KmNao = 87.5;																		// [mM]\n	ksat = 0.27;																		// [none]  \n	nu = 0.35;																			// [none]\n	Kdact = 0.256e-3;																	// [mM] \n	Q10NCX = 1.57;																		// [none]\n	IbarSLCaP = 0.0673;																	// [uA/uF]\n	KmPCa = 0.5e-3;																		// [mM] \n	GCaB = 2.513e-4;																	// [uA/uF] \n	Q10SLCaP = 2.35;																	// [none]\n\n	// SR flux parameters\n	Q10SRCaP = 2.6;																		// [none]\n	Vmax_SRCaP = 2.86e-4;																// [mM/msec] (mmol/L cytosol/msec)\n	Kmf = 0.246e-3;																		// [mM]\n	Kmr = 1.7;																			// [mM]L cytosol\n	hillSRCaP = 1.787;																	// [mM]\n	ks = 25;																			// [1/ms]      \n	koCa = 10;																			// [mM^-2 1/ms]      \n	kom = 0.06;																			// [1/ms]     \n	kiCa = 0.5;																			// [1/mM/ms]\n	kim = 0.005;																		// [1/ms]\n	ec50SR = 0.45;																		// [mM]\n\n	// Buffering parameters\n	Bmax_Naj = 7.561;																	// [mM] \n	Bmax_Nasl = 1.65;																	// [mM]\n	koff_na = 1e-3;																		// [1/ms]\n	kon_na = 0.1e-3;																	// [1/mM/ms]\n	Bmax_TnClow = 70e-3;																// [mM], TnC low affinity\n	koff_tncl = 19.6e-3;																// [1/ms] \n	kon_tncl = 32.7;																	// [1/mM/ms]\n	Bmax_TnChigh = 140e-3;																// [mM], TnC high affinity \n	koff_tnchca = 0.032e-3;																// [1/ms] \n	kon_tnchca = 2.37;																	// [1/mM/ms]\n	koff_tnchmg = 3.33e-3;																// [1/ms] \n	kon_tnchmg = 3e-3;																	// [1/mM/ms]\n	Bmax_CaM = 24e-3;																	// [mM], CaM buffering\n	koff_cam = 238e-3;																	// [1/ms] \n	kon_cam = 34;																		// [1/mM/ms]\n	Bmax_myosin = 140e-3;																// [mM], Myosin buffering\n	koff_myoca = 0.46e-3;																// [1/ms]\n	kon_myoca = 13.8;																	// [1/mM/ms]\n	koff_myomg = 0.057e-3;																// [1/ms]\n	kon_myomg = 0.0157;																	// [1/mM/ms]\n	Bmax_SR = 19*0.9e-3;																	// [mM] \n	koff_sr = 60e-3;																	// [1/ms]\n	kon_sr = 100;																		// [1/mM/ms]\n	Bmax_SLlowsl = 37.38e-3*Vmyo/Vsl;													// [mM], SL buffering\n	Bmax_SLlowj = 4.62e-3*Vmyo/Vjunc*0.1;												// [mM]    \n	koff_sll = 1300e-3;																	// [1/ms]\n	kon_sll = 100;																		// [1/mM/ms]\n	Bmax_SLhighsl = 13.35e-3*Vmyo/Vsl;													// [mM] \n	Bmax_SLhighj = 1.65e-3*Vmyo/Vjunc*0.1;												// [mM] \n	koff_slh = 30e-3;																	// [1/ms]\n	kon_slh = 100;																		// [1/mM/ms]\n	Bmax_Csqn = 2.7;																	// 140e-3*Vmyo/Vsr; [mM] \n	koff_csqn = 65;																		// [1/ms] \n	kon_csqn = 100;																		// [1/mM/ms] \n\n	// I_Na: Fast Na Current\n	am = 0.32*(initvalu_39+47.13)/(1-exp(-0.1*(initvalu_39+47.13)));\n	bm = 0.08*exp(-initvalu_39/11);\n	if(initvalu_39 >= -40){\n		ah = 0; aj = 0;\n		bh = 1/(0.13*(1+exp(-(initvalu_39+10.66)/11.1)));\n		bj = 0.3*exp(-2.535e-7*initvalu_39)/(1+exp(-0.1*(initvalu_39+32)));\n	}\n	else{\n		ah = 0.135*exp((80+initvalu_39)/-6.8);\n		bh = 3.56*exp(0.079*initvalu_39)+3.1e5*exp(0.35*initvalu_39);\n		aj = (-127140*exp(0.2444*initvalu_39)-3.474e-5*exp(-0.04391*initvalu_39))*(initvalu_39+37.78)/(1+exp(0.311*(initvalu_39+79.23)));\n		bj = 0.1212*exp(-0.01052*initvalu_39)/(1+exp(-0.1378*(initvalu_39+40.14)));\n	}\n	finavalu[offset_1] = am*(1-initvalu_1)-bm*initvalu_1;\n	finavalu[offset_2] = ah*(1-initvalu_2)-bh*initvalu_2;\n	finavalu[offset_3] = aj*(1-initvalu_3)-bj*initvalu_3;\n	I_Na_junc = Fjunc*GNa*pow(initvalu_1,3)*initvalu_2*initvalu_3*(initvalu_39-ena_junc);\n	I_Na_sl = Fsl*GNa*pow(initvalu_1,3)*initvalu_2*initvalu_3*(initvalu_39-ena_sl);\n	I_Na = I_Na_junc+I_Na_sl;\n\n	// I_nabk: Na Background Current\n	I_nabk_junc = Fjunc*GNaB*(initvalu_39-ena_junc);\n	I_nabk_sl = Fsl*GNaB*(initvalu_39-ena_sl);\n	I_nabk = I_nabk_junc+I_nabk_sl;\n\n	// I_nak: Na/K Pump Current\n	sigma = (exp(Nao/67.3)-1)/7;\n	fnak = 1/(1+0.1245*exp(-0.1*initvalu_39*FoRT)+0.0365*sigma*exp(-initvalu_39*FoRT));\n	I_nak_junc = Fjunc*IbarNaK*fnak*Ko /(1+pow((KmNaip/initvalu_32),4)) /(Ko+KmKo);\n	I_nak_sl = Fsl*IbarNaK*fnak*Ko /(1+pow((KmNaip/initvalu_33),4)) /(Ko+KmKo);\n	I_nak = I_nak_junc+I_nak_sl;\n\n	// I_kr: Rapidly Activating K Current\n	gkr = 0.03*sqrt(Ko/5.4);\n	xrss = 1/(1+exp(-(initvalu_39+50)/7.5));\n	tauxr = 1/(0.00138*(initvalu_39+7)/(1-exp(-0.123*(initvalu_39+7)))+6.1e-4*(initvalu_39+10)/(exp(0.145*(initvalu_39+10))-1));\n	finavalu[offset_12] = (xrss-initvalu_12)/tauxr;\n	rkr = 1/(1+exp((initvalu_39+33)/22.4));\n	I_kr = gkr*initvalu_12*rkr*(initvalu_39-ek);\n\n	// I_ks: Slowly Activating K Current\n	pcaks_junc = -log10(initvalu_36)+3.0; \n	pcaks_sl = -log10(initvalu_37)+3.0;  \n	gks_junc = 0.07*(0.057 +0.19/(1+ exp((-7.2+pcaks_junc)/0.6)));\n	gks_sl = 0.07*(0.057 +0.19/(1+ exp((-7.2+pcaks_sl)/0.6))); \n	eks = (1/FoRT)*log((Ko+pNaK*Nao)/(initvalu_35+pNaK*initvalu_34));	\n	xsss = 1/(1+exp(-(initvalu_39-1.5)/16.7));\n	tauxs = 1/(7.19e-5*(initvalu_39+30)/(1-exp(-0.148*(initvalu_39+30)))+1.31e-4*(initvalu_39+30)/(exp(0.0687*(initvalu_39+30))-1)); \n	finavalu[offset_13] = (xsss-initvalu_13)/tauxs;\n	I_ks_junc = Fjunc*gks_junc*pow(initvalu_12,2)*(initvalu_39-eks);\n	I_ks_sl = Fsl*gks_sl*pow(initvalu_13,2)*(initvalu_39-eks);\n	I_ks = I_ks_junc+I_ks_sl;\n\n	// I_kp: Plateau K current\n	kp_kp = 1/(1+exp(7.488-initvalu_39/5.98));\n	I_kp_junc = Fjunc*gkp*kp_kp*(initvalu_39-ek);\n	I_kp_sl = Fsl*gkp*kp_kp*(initvalu_39-ek);\n	I_kp = I_kp_junc+I_kp_sl;\n\n	// I_to: Transient Outward K Current (slow and fast components)\n	xtoss = 1/(1+exp(-(initvalu_39+3.0)/15));\n	ytoss = 1/(1+exp((initvalu_39+33.5)/10));\n	rtoss = 1/(1+exp((initvalu_39+33.5)/10));\n	tauxtos = 9/(1+exp((initvalu_39+3.0)/15))+0.5;\n	tauytos = 3e3/(1+exp((initvalu_39+60.0)/10))+30;\n	taurtos = 2800/(1+exp((initvalu_39+60.0)/10))+220; \n	finavalu[offset_8] = (xtoss-initvalu_8)/tauxtos;\n	finavalu[offset_9] = (ytoss-initvalu_9)/tauytos;\n	finavalu[offset_40]= (rtoss-initvalu_40)/taurtos; \n	I_tos = GtoSlow*initvalu_8*(initvalu_9+0.5*initvalu_40)*(initvalu_39-ek);									// [uA/uF]\n\n	//\n	tauxtof = 3.5*exp(-initvalu_39*initvalu_39/30/30)+1.5;\n	tauytof = 20.0/(1+exp((initvalu_39+33.5)/10))+20.0;\n	finavalu[offset_10] = (xtoss-initvalu_10)/tauxtof;\n	finavalu[offset_11] = (ytoss-initvalu_11)/tauytof;\n	I_tof = GtoFast*initvalu_10*initvalu_11*(initvalu_39-ek);\n	I_to = I_tos + I_tof;\n\n	// I_ki: Time-Independent K Current\n	aki = 1.02/(1+exp(0.2385*(initvalu_39-ek-59.215)));\n	bki =(0.49124*exp(0.08032*(initvalu_39+5.476-ek)) + exp(0.06175*(initvalu_39-ek-594.31))) /(1 + exp(-0.5143*(initvalu_39-ek+4.753)));\n	kiss = aki/(aki+bki);\n	I_ki = 0.9*sqrt(Ko/5.4)*kiss*(initvalu_39-ek);\n\n	// I_ClCa: Ca-activated Cl Current, I_Clbk: background Cl Current\n	I_ClCa_junc = Fjunc*GClCa/(1+KdClCa/initvalu_36)*(initvalu_39-ecl);\n	I_ClCa_sl = Fsl*GClCa/(1+KdClCa/initvalu_37)*(initvalu_39-ecl);\n	I_ClCa = I_ClCa_junc+I_ClCa_sl;\n	I_Clbk = GClB*(initvalu_39-ecl);\n\n	// I_Ca: L-type Calcium Current\n	dss = 1/(1+exp(-(initvalu_39+14.5)/6.0));\n	taud = dss*(1-exp(-(initvalu_39+14.5)/6.0))/(0.035*(initvalu_39+14.5));\n	fss = 1/(1+exp((initvalu_39+35.06)/3.6))+0.6/(1+exp((50-initvalu_39)/20));\n	tauf = 1/(0.0197*exp(-pow(0.0337*(initvalu_39+14.5),2))+0.02);\n	finavalu[offset_4] = (dss-initvalu_4)/taud;\n	finavalu[offset_5] = (fss-initvalu_5)/tauf;\n	finavalu[offset_6] = 1.7*initvalu_36*(1-initvalu_6)-11.9e-3*initvalu_6;											// fCa_junc  \n	finavalu[offset_7] = 1.7*initvalu_37*(1-initvalu_7)-11.9e-3*initvalu_7;											// fCa_sl\n\n	//\n	ibarca_j = pCa*4*(initvalu_39*Frdy*FoRT) * (0.341*initvalu_36*exp(2*initvalu_39*FoRT)-0.341*Cao) /(exp(2*initvalu_39*FoRT)-1);\n	ibarca_sl = pCa*4*(initvalu_39*Frdy*FoRT) * (0.341*initvalu_37*exp(2*initvalu_39*FoRT)-0.341*Cao) /(exp(2*initvalu_39*FoRT)-1);\n	ibark = pK*(initvalu_39*Frdy*FoRT)*(0.75*initvalu_35*exp(initvalu_39*FoRT)-0.75*Ko) /(exp(initvalu_39*FoRT)-1);\n	ibarna_j = pNa*(initvalu_39*Frdy*FoRT) *(0.75*initvalu_32*exp(initvalu_39*FoRT)-0.75*Nao)  /(exp(initvalu_39*FoRT)-1);\n	ibarna_sl = pNa*(initvalu_39*Frdy*FoRT) *(0.75*initvalu_33*exp(initvalu_39*FoRT)-0.75*Nao)  /(exp(initvalu_39*FoRT)-1);\n	I_Ca_junc = (Fjunc_CaL*ibarca_j*initvalu_4*initvalu_5*(1-initvalu_6)*pow(Q10CaL,Qpow))*0.45;\n	I_Ca_sl = (Fsl_CaL*ibarca_sl*initvalu_4*initvalu_5*(1-initvalu_7)*pow(Q10CaL,Qpow))*0.45;\n	I_Ca = I_Ca_junc+I_Ca_sl;\n	finavalu[offset_43]=-I_Ca*Cmem/(Vmyo*2*Frdy)*1e3;\n	I_CaK = (ibark*initvalu_4*initvalu_5*(Fjunc_CaL*(1-initvalu_6)+Fsl_CaL*(1-initvalu_7))*pow(Q10CaL,Qpow))*0.45;\n	I_CaNa_junc = (Fjunc_CaL*ibarna_j*initvalu_4*initvalu_5*(1-initvalu_6)*pow(Q10CaL,Qpow))*0.45;\n	I_CaNa_sl = (Fsl_CaL*ibarna_sl*initvalu_4*initvalu_5*(1-initvalu_7)*pow(Q10CaL,Qpow))*0.45;\n	I_CaNa = I_CaNa_junc+I_CaNa_sl;\n	I_Catot = I_Ca+I_CaK+I_CaNa;\n\n	// I_ncx: Na/Ca Exchanger flux\n	Ka_junc = 1/(1+pow((Kdact/initvalu_36),3));\n	Ka_sl = 1/(1+pow((Kdact/initvalu_37),3));\n	s1_junc = exp(nu*initvalu_39*FoRT)*pow(initvalu_32,3)*Cao;\n	s1_sl = exp(nu*initvalu_39*FoRT)*pow(initvalu_33,3)*Cao;\n	s2_junc = exp((nu-1)*initvalu_39*FoRT)*pow(Nao,3)*initvalu_36;\n	s3_junc = (KmCai*pow(Nao,3)*(1+pow((initvalu_32/KmNai),3))+pow(KmNao,3)*initvalu_36+ pow(KmNai,3)*Cao*(1+initvalu_36/KmCai)+KmCao*pow(initvalu_32,3)+pow(initvalu_32,3)*Cao+pow(Nao,3)*initvalu_36)*(1+ksat*exp((nu-1)*initvalu_39*FoRT));\n	s2_sl = exp((nu-1)*initvalu_39*FoRT)*pow(Nao,3)*initvalu_37;\n	s3_sl = (KmCai*pow(Nao,3)*(1+pow((initvalu_33/KmNai),3)) + pow(KmNao,3)*initvalu_37+pow(KmNai,3)*Cao*(1+initvalu_37/KmCai)+KmCao*pow(initvalu_33,3)+pow(initvalu_33,3)*Cao+pow(Nao,3)*initvalu_37)*(1+ksat*exp((nu-1)*initvalu_39*FoRT));\n	I_ncx_junc = Fjunc*IbarNCX*pow(Q10NCX,Qpow)*Ka_junc*(s1_junc-s2_junc)/s3_junc;\n	I_ncx_sl = Fsl*IbarNCX*pow(Q10NCX,Qpow)*Ka_sl*(s1_sl-s2_sl)/s3_sl;\n	I_ncx = I_ncx_junc+I_ncx_sl;\n	finavalu[offset_45]=2*I_ncx*Cmem/(Vmyo*2*Frdy)*1e3;\n\n	// I_pca: Sarcolemmal Ca Pump Current\n	I_pca_junc = 	Fjunc * \n					pow(Q10SLCaP,Qpow) * \n					IbarSLCaP * \n					pow(initvalu_36,1.6) /\n					(pow(KmPCa,1.6) + pow(initvalu_36,1.6));\n	I_pca_sl = 	Fsl * \n				pow(Q10SLCaP,Qpow) * \n				IbarSLCaP * \n				pow(initvalu_37,1.6) / \n				(pow(KmPCa,1.6) + pow(initvalu_37,1.6));\n	I_pca = I_pca_junc+I_pca_sl;\n	finavalu[offset_44]=-I_pca*Cmem/(Vmyo*2*Frdy)*1e3;\n\n	// I_cabk: Ca Background Current\n	I_cabk_junc = Fjunc*GCaB*(initvalu_39-eca_junc);\n	I_cabk_sl = Fsl*GCaB*(initvalu_39-eca_sl);\n	I_cabk = I_cabk_junc+I_cabk_sl;\n	finavalu[offset_46]=-I_cabk*Cmem/(Vmyo*2*Frdy)*1e3;\n	\n	// SR fluxes: Calcium Release, SR Ca pump, SR Ca leak														\n	MaxSR = 15; \n	MinSR = 1;\n	kCaSR = MaxSR - (MaxSR-MinSR)/(1+pow(ec50SR/initvalu_31,2.5));\n	koSRCa = koCa/kCaSR;\n	kiSRCa = kiCa*kCaSR;\n	RI = 1-initvalu_14-initvalu_15-initvalu_16;\n	finavalu[offset_14] = (kim*RI-kiSRCa*initvalu_36*initvalu_14)-(koSRCa*pow(initvalu_36,2)*initvalu_14-kom*initvalu_15);			// R\n	finavalu[offset_15] = (koSRCa*pow(initvalu_36,2)*initvalu_14-kom*initvalu_15)-(kiSRCa*initvalu_36*initvalu_15-kim*initvalu_16);			// O\n	finavalu[offset_16] = (kiSRCa*initvalu_36*initvalu_15-kim*initvalu_16)-(kom*initvalu_16-koSRCa*pow(initvalu_36,2)*RI);			// I\n	J_SRCarel = ks*initvalu_15*(initvalu_31-initvalu_36);													// [mM/ms]\n	J_serca = pow(Q10SRCaP,Qpow)*Vmax_SRCaP*(pow((initvalu_38/Kmf),hillSRCaP)-pow((initvalu_31/Kmr),hillSRCaP))\n										 /(1+pow((initvalu_38/Kmf),hillSRCaP)+pow((initvalu_31/Kmr),hillSRCaP));\n	J_SRleak = 5.348e-6*(initvalu_31-initvalu_36);													//   [mM/ms]\n\n	// Sodium and Calcium Buffering														\n	finavalu[offset_17] = kon_na*initvalu_32*(Bmax_Naj-initvalu_17)-koff_na*initvalu_17;								// NaBj      [mM/ms]\n	finavalu[offset_18] = kon_na*initvalu_33*(Bmax_Nasl-initvalu_18)-koff_na*initvalu_18;							// NaBsl     [mM/ms]\n\n	// Cytosolic Ca Buffers\n	finavalu[offset_19] = kon_tncl*initvalu_38*(Bmax_TnClow-initvalu_19)-koff_tncl*initvalu_19;						// TnCL      [mM/ms]\n	finavalu[offset_20] = kon_tnchca*initvalu_38*(Bmax_TnChigh-initvalu_20-initvalu_21)-koff_tnchca*initvalu_20;			// TnCHc     [mM/ms]\n	finavalu[offset_21] = kon_tnchmg*Mgi*(Bmax_TnChigh-initvalu_20-initvalu_21)-koff_tnchmg*initvalu_21;				// TnCHm     [mM/ms]\n	finavalu[offset_22] = 0;																		// CaM       [mM/ms]\n	finavalu[offset_23] = kon_myoca*initvalu_38*(Bmax_myosin-initvalu_23-initvalu_24)-koff_myoca*initvalu_23;				// Myosin_ca [mM/ms]\n	finavalu[offset_24] = kon_myomg*Mgi*(Bmax_myosin-initvalu_23-initvalu_24)-koff_myomg*initvalu_24;				// Myosin_mg [mM/ms]\n	finavalu[offset_25] = kon_sr*initvalu_38*(Bmax_SR-initvalu_25)-koff_sr*initvalu_25;								// SRB       [mM/ms]\n	J_CaB_cytosol = finavalu[offset_19] + finavalu[offset_20] + finavalu[offset_21] + finavalu[offset_22] + finavalu[offset_23] + finavalu[offset_24] + finavalu[offset_25];\n\n	// Junctional and SL Ca Buffers\n	finavalu[offset_26] = kon_sll*initvalu_36*(Bmax_SLlowj-initvalu_26)-koff_sll*initvalu_26;						// SLLj      [mM/ms]\n	finavalu[offset_27] = kon_sll*initvalu_37*(Bmax_SLlowsl-initvalu_27)-koff_sll*initvalu_27;						// SLLsl     [mM/ms]\n	finavalu[offset_28] = kon_slh*initvalu_36*(Bmax_SLhighj-initvalu_28)-koff_slh*initvalu_28;						// SLHj      [mM/ms]\n	finavalu[offset_29] = kon_slh*initvalu_37*(Bmax_SLhighsl-initvalu_29)-koff_slh*initvalu_29;						// SLHsl     [mM/ms]\n	J_CaB_junction = finavalu[offset_26]+finavalu[offset_28];\n	J_CaB_sl = finavalu[offset_27]+finavalu[offset_29];\n\n	// SR Ca Concentrations\n	finavalu[offset_30] = kon_csqn*initvalu_31*(Bmax_Csqn-initvalu_30)-koff_csqn*initvalu_30;						// Csqn      [mM/ms]\n	oneovervsr = 1/Vsr;\n	finavalu[offset_31] = J_serca*Vmyo*oneovervsr-(J_SRleak*Vmyo*oneovervsr+J_SRCarel)-finavalu[offset_30];   // Ca_sr     [mM/ms] %Ratio 3 leak current\n\n	// Sodium Concentrations\n	I_Na_tot_junc = I_Na_junc+I_nabk_junc+3*I_ncx_junc+3*I_nak_junc+I_CaNa_junc;		// [uA/uF]\n	I_Na_tot_sl = I_Na_sl+I_nabk_sl+3*I_ncx_sl+3*I_nak_sl+I_CaNa_sl;					// [uA/uF]\n	finavalu[offset_32] = -I_Na_tot_junc*Cmem/(Vjunc*Frdy)+J_na_juncsl/Vjunc*(initvalu_33-initvalu_32)-finavalu[offset_17];\n	oneovervsl = 1/Vsl;\n	finavalu[offset_33] = -I_Na_tot_sl*Cmem*oneovervsl/Frdy+J_na_juncsl*oneovervsl*(initvalu_32-initvalu_33)+J_na_slmyo*oneovervsl*(initvalu_34-initvalu_33)-finavalu[offset_18];\n	finavalu[offset_34] = J_na_slmyo/Vmyo*(initvalu_33-initvalu_34);											// [mM/msec] \n\n	// Potassium Concentration\n	I_K_tot = I_to+I_kr+I_ks+I_ki-2*I_nak+I_CaK+I_kp;									// [uA/uF]\n	finavalu[offset_35] = 0;															// [mM/msec]\n\n	// Calcium Concentrations\n	I_Ca_tot_junc = I_Ca_junc+I_cabk_junc+I_pca_junc-2*I_ncx_junc;						// [uA/uF]\n	I_Ca_tot_sl = I_Ca_sl+I_cabk_sl+I_pca_sl-2*I_ncx_sl;								// [uA/uF]\n	finavalu[offset_36] = -I_Ca_tot_junc*Cmem/(Vjunc*2*Frdy)+J_ca_juncsl/Vjunc*(initvalu_37-initvalu_36)\n	         - J_CaB_junction+(J_SRCarel)*Vsr/Vjunc+J_SRleak*Vmyo/Vjunc;				// Ca_j\n	finavalu[offset_37] = -I_Ca_tot_sl*Cmem/(Vsl*2*Frdy)+J_ca_juncsl/Vsl*(initvalu_36-initvalu_37)\n	         + J_ca_slmyo/Vsl*(initvalu_38-initvalu_37)-J_CaB_sl;									// Ca_sl\n	finavalu[offset_38] = -J_serca-J_CaB_cytosol +J_ca_slmyo/Vmyo*(initvalu_37-initvalu_38);\n	junc_sl=J_ca_juncsl/Vsl*(initvalu_36-initvalu_37);\n	sl_junc=J_ca_juncsl/Vjunc*(initvalu_37-initvalu_36);\n	sl_myo=J_ca_slmyo/Vsl*(initvalu_38-initvalu_37);\n	myo_sl=J_ca_slmyo/Vmyo*(initvalu_37-initvalu_38);\n\n	// Simulation type													\n	state = 1;																			\n	switch(state){\n		case 0:\n			I_app = 0;\n			break;\n		case 1:																			// pace w/ current injection at cycleLength 'cycleLength'\n			if(fmod(timeinst,parameter_1) <= 5){\n				I_app = 9.5;\n			}\n			else{\n				I_app = 0.0;\n			}\n			break;\n		case 2:     \n			V_hold = -55;\n			V_test = 0;\n			if(timeinst>0.5 & timeinst<200.5){\n				V_clamp = V_test;\n			}\n			else{\n				V_clamp = V_hold;\n			}\n			R_clamp = 0.04;\n			I_app = (V_clamp-initvalu_39)/R_clamp;\n			break;\n	} \n\n	// Membrane Potential												\n	I_Na_tot = I_Na_tot_junc + I_Na_tot_sl;												// [uA/uF]\n	I_Cl_tot = I_ClCa+I_Clbk;															// [uA/uF]\n	I_Ca_tot = I_Ca_tot_junc+I_Ca_tot_sl;\n	I_tot = I_Na_tot+I_Cl_tot+I_Ca_tot+I_K_tot;\n	finavalu[offset_39] = -(I_tot-I_app);\n\n	// Set unused output values to 0 (MATLAB does it by default)\n	finavalu[offset_41] = 0;\n	finavalu[offset_42] = 0;\n\n}\n"
myocyte/define.c,//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	DEFINE / INCLUDE\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\n#define fp float\n\n#define EQUATIONS 91\n#define PARAMETERS 16\n
myocyte/fin.c,"//=====================================================================\n//	MAIN FUNCTION\n//=====================================================================\nvoid fin(	fp *initvalu,\n				int initvalu_offset_ecc,\n				int initvalu_offset_Dyad,\n				int initvalu_offset_SL,\n				int initvalu_offset_Cyt,\n				fp *parameter,\n				fp *finavalu,\n				fp JCaDyad,\n				fp JCaSL,\n				fp JCaCyt){\n\n//=====================================================================\n//	VARIABLES\n//=====================================================================\n\n	// decoded input parameters\n	fp BtotDyad;																		//\n	fp CaMKIItotDyad;																	//\n\n	// compute variables\n	fp Vmyo;																			// [L]\n	fp Vdyad;																			// [L]\n	fp VSL;																				// [L]\n	fp kDyadSL;																			// [L/msec]\n	fp kSLmyo;																			// [L/msec]\n	fp k0Boff;																			// [s^-1] \n	fp k0Bon;																			// [uM^-1 s^-1] kon = koff/Kd\n	fp k2Boff;																			// [s^-1] \n	fp k2Bon;																			// [uM^-1 s^-1]\n	fp k4Boff;																			// [s^-1]\n	fp k4Bon;																			// [uM^-1 s^-1]\n	fp CaMtotDyad;\n	fp Bdyad;																			// [uM dyad]\n	fp J_cam_dyadSL;																	// [uM/msec dyad]\n	fp J_ca2cam_dyadSL;																	// [uM/msec dyad]\n	fp J_ca4cam_dyadSL;																	// [uM/msec dyad]\n	fp J_cam_SLmyo;																		// [umol/msec]\n	fp J_ca2cam_SLmyo;																	// [umol/msec]\n	fp J_ca4cam_SLmyo;																	// [umol/msec]\n\n//=====================================================================\n//	COMPUTATION\n//=====================================================================\n\n	// decoded input parameters\n	BtotDyad      = parameter[2];														//\n	CaMKIItotDyad = parameter[3];														//\n\n	// set variables\n	Vmyo = 2.1454e-11;																	// [L]\n	Vdyad = 1.7790e-14;																	// [L]\n	VSL = 6.6013e-13;																	// [L]\n	kDyadSL = 3.6363e-16;																// [L/msec]\n	kSLmyo = 8.587e-15;																	// [L/msec]\n	k0Boff = 0.0014;																	// [s^-1] \n	k0Bon = k0Boff/0.2;																	// [uM^-1 s^-1] kon = koff/Kd\n	k2Boff = k0Boff/100;																// [s^-1] \n	k2Bon = k0Bon;																		// [uM^-1 s^-1]\n	k4Boff = k2Boff;																	// [s^-1]\n	k4Bon = k0Bon;																		// [uM^-1 s^-1]\n\n	// ADJUST ECC incorporate Ca buffering from CaM, convert JCaCyt from uM/msec to mM/msec\n	finavalu[initvalu_offset_ecc+35] = finavalu[initvalu_offset_ecc+35] + 1e-3*JCaDyad;\n	finavalu[initvalu_offset_ecc+36] = finavalu[initvalu_offset_ecc+36] + 1e-3*JCaSL;\n	finavalu[initvalu_offset_ecc+37] = finavalu[initvalu_offset_ecc+37] + 1e-3*JCaCyt; \n\n	// incorporate CaM diffusion between compartments\n	CaMtotDyad = initvalu[initvalu_offset_Dyad+0]\n			   + initvalu[initvalu_offset_Dyad+1]\n			   + initvalu[initvalu_offset_Dyad+2]\n			   + initvalu[initvalu_offset_Dyad+3]\n			   + initvalu[initvalu_offset_Dyad+4]\n			   + initvalu[initvalu_offset_Dyad+5]\n			   + CaMKIItotDyad * (  initvalu[initvalu_offset_Dyad+6]\n								  + initvalu[initvalu_offset_Dyad+7]\n								  + initvalu[initvalu_offset_Dyad+8]\n								  + initvalu[initvalu_offset_Dyad+9])\n			   + initvalu[initvalu_offset_Dyad+12]\n			   + initvalu[initvalu_offset_Dyad+13]\n			   + initvalu[initvalu_offset_Dyad+14];\n	Bdyad = BtotDyad - CaMtotDyad;																				// [uM dyad]\n	J_cam_dyadSL = 1e-3 * (  k0Boff*initvalu[initvalu_offset_Dyad+0] - k0Bon*Bdyad*initvalu[initvalu_offset_SL+0]);			// [uM/msec dyad]\n	J_ca2cam_dyadSL = 1e-3 * (  k2Boff*initvalu[initvalu_offset_Dyad+1] - k2Bon*Bdyad*initvalu[initvalu_offset_SL+1]);		// [uM/msec dyad]\n	J_ca4cam_dyadSL = 1e-3 * (  k2Boff*initvalu[initvalu_offset_Dyad+2] - k4Bon*Bdyad*initvalu[initvalu_offset_SL+2]);		// [uM/msec dyad]\n	\n	J_cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+0] - initvalu[initvalu_offset_Cyt+0]);								// [umol/msec]\n	J_ca2cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+1] - initvalu[initvalu_offset_Cyt+1]);							// [umol/msec]\n	J_ca4cam_SLmyo = kSLmyo * (  initvalu[initvalu_offset_SL+2] - initvalu[initvalu_offset_Cyt+2]);							// [umol/msec]\n	\n	// ADJUST CAM Dyad \n	finavalu[initvalu_offset_Dyad+0] = finavalu[initvalu_offset_Dyad+0] - J_cam_dyadSL;\n	finavalu[initvalu_offset_Dyad+1] = finavalu[initvalu_offset_Dyad+1] - J_ca2cam_dyadSL;\n	finavalu[initvalu_offset_Dyad+2] = finavalu[initvalu_offset_Dyad+2] - J_ca4cam_dyadSL;\n	\n	// ADJUST CAM Sl\n	finavalu[initvalu_offset_SL+0] = finavalu[initvalu_offset_SL+0] + J_cam_dyadSL*Vdyad/VSL - J_cam_SLmyo/VSL;\n	finavalu[initvalu_offset_SL+1] = finavalu[initvalu_offset_SL+1] + J_ca2cam_dyadSL*Vdyad/VSL - J_ca2cam_SLmyo/VSL;\n	finavalu[initvalu_offset_SL+2] = finavalu[initvalu_offset_SL+2] + J_ca4cam_dyadSL*Vdyad/VSL - J_ca4cam_SLmyo/VSL;\n\n	// ADJUST CAM Cyt \n	finavalu[initvalu_offset_Cyt+0] = finavalu[initvalu_offset_Cyt+0] + J_cam_SLmyo/Vmyo;\n	finavalu[initvalu_offset_Cyt+1] = finavalu[initvalu_offset_Cyt+1] + J_ca2cam_SLmyo/Vmyo;\n	finavalu[initvalu_offset_Cyt+2] = finavalu[initvalu_offset_Cyt+2] + J_ca4cam_SLmyo/Vmyo;\n\n}\n"
myocyte/file.c,"//========================================================================================================================\n//	INCLUDE/DEFINE\n//========================================================================================================================\n\n// #include <stdlib.h>\n// #include <string.h>\n#include <stdio.h>\n// #include <math.h>\n// #include <time.h>\n// #include <sys/types.h>\n// #include <dirent.h>\n// #include <errno.h>\n\n//========================================================================================================================\n//	WRITE FUNCTION\n//========================================================================================================================\n\nvoid write(	char* filename,\n					fp* input, \n					int data_rows, \n					int data_cols, \n					int major,\n					int data_range){\n\n	//=====================================================================\n	//	VARIABLES\n	//=====================================================================\n\n	FILE* fid;\n	int i, j;\n\n	//=====================================================================\n	//	CREATE/OPEN FILE FOR WRITING\n	//=====================================================================\n\n	fid = fopen(filename, ""w"");\n	if( fid == NULL ){\n		printf( ""The file was not created/opened for writing\n"" );\n		return;\n	}\n\n	//=====================================================================\n	//	WRITE VALUES TO THE FILE\n	//=====================================================================\n\n	// if matrix is saved row major in memory (C)\n	if(major==0){\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fprintf(fid, ""%f "", (fp)input[i*data_cols+j]);\n			}\n			fprintf(fid, ""\n"");\n		}\n	}\n	// if matrix is saved column major in memory (MATLAB)\n	else{\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fprintf(fid, ""%f "", (fp)input[j*data_rows+i]);\n			}\n			fprintf(fid, ""\n"");\n		}\n	}\n\n	//=====================================================================\n	//	CLOSE FILE\n	//=====================================================================\n\n	fclose(fid);\n\n}\n\n//========================================================================================================================\n//	READ FUNCTION\n//========================================================================================================================\n\nvoid read(	char* filename,\n					fp* input,\n					int data_rows, \n					int data_cols,\n					int major){\n\n	//=====================================================================\n	//	VARIABLES\n	//=====================================================================\n\n	FILE* fid;\n	int i, j;\n	char c;\n	fp temp;\n\n	//=====================================================================\n	//	OPEN FILE FOR READING\n	//=====================================================================\n\n	fid = fopen(filename, ""r"");\n	if( fid == NULL ){\n		printf( ""The file was not opened for reading\n"" );\n		return;\n	}\n\n	//=====================================================================\n	//	READ VALUES FROM THE FILE\n	//=====================================================================\n\n	if(major==0){																// if matrix is saved row major in memory (C)\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fscanf(fid, ""%f"", &temp);\n				input[i*data_cols+j] = (fp)temp;\n			}\n		}\n	}\n	else{																				// if matrix is saved column major in memory (MATLAB)\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fscanf(fid, ""%f"", &temp);\n				input[j*data_rows+i] = (fp)temp;\n			}\n		}\n	}\n\n	//=====================================================================\n	//	CLOSE FILE\n	//=====================================================================\n\n	fclose(fid);\n\n}\n"
myocyte/solver.c,"////////////////////////////////////////////////////////////////////////////////\n// int solver( fp (*f)(fp, fp), fp y[],        //\n//       fp x, fp h, fp xmax, fp *h_next, fp tolerance )  //\n//                                                                            //\n//  Description:                                                              //\n//     This function solves the differential equation y'=f(x,y) with the      //\n//     initial condition y(x) = y[0].  The value at xmax is returned in y[1]. //\n//     The function returns 0 if successful or -1 if it fails.                //\n//                                                                            //\n//  Arguments:                                                                //\n//     fp *f  Pointer to the function which returns the slope at (x,y) of //\n//                integral curve of the differential equation y' = f(x,y)     //\n//                which passes through the point (x0,y0) corresponding to the //\n//                initial condition y(x0) = y0.                               //\n//     fp y[] On input y[0] is the initial value of y at x, on output     //\n//                y[1] is the solution at xmax.                               //\n//     fp x   The initial value of x.                                     //\n//     fp h   Initial step size.                                          //\n//     fp xmax The endpoint of x.                                         //\n//     fp *h_next   A pointer to the estimated step size for successive   //\n//                      calls to solver.                       //\n//     fp tolerance The tolerance of y(xmax), i.e. a solution is sought   //\n//                so that the relative error < tolerance.                     //\n//                                                                            //\n//  Return Values:                                                            //\n//     0   The solution of y' = f(x,y) from x to xmax is stored y[1] and      //\n//         h_next has the value to the next size to try.                      //\n//    -1   The solution of y' = f(x,y) from x to xmax failed.                 //\n//    -2   Failed because either xmax < x or the step size h <= 0.            //\n//    -3   Memory limit allocated for results was reached                                //\n////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////\n//	Summary of changes by Lukasz G. Szafaryn:\n\n//	1) The original code was obtained from: Mathematics Source Library (http://mymathlib.webtrellis.net/index.html)\n// 2) This solver and particular solving algorithm used with it (embedded_fehlberg_7_8) were adapted to work with a set of equations, not just one like in original version.\n\n//	3) In order for solver to provide deterministic number of steps (needed for particular amount of memore previousely allocated for results), every next step is incremented by 1 time unit (h_init).\n//	4) Function assumes that time interval starts at 0 (xmin) and ends at integer value (xmax) specified by the uses as a parameter on command line.\n// 5) The appropriate amount of memory is previousely allocated for that range (y).\n\n//	5) This setup in 3) - 5) allows solver to adjust the step ony from current time instance to current time instance + 0.9. The next time instance is current time instance + 1;\n\n//	6) Solver also takes parameters (params) that it then passes to the equations.\n\n//	7) The original solver cannot handle cases when equations return NAN and INF values due to discontinuities and /0. That is why equations provided by user need to make sure that no NAN and INF are returned.\n\n//	Last update: 15 DEC 09\n////////////////////////////////////////////////////////////////////////////////\n\n//======================================================================================================================================================\n//======================================================================================================================================================\n//		INCLUDE\n//======================================================================================================================================================\n//======================================================================================================================================================\n\n#include <math.h>\n\n#define max(x,y) ( (x) < (y) ? (y) : (x) )\n#define min(x,y) ( (x) < (y) ? (x) : (y) )\n\n#define ATTEMPTS 12\n#define MIN_SCALE_FACTOR 0.125\n#define MAX_SCALE_FACTOR 4.0\n\n//======================================================================================================================================================\n//======================================================================================================================================================\n//		SOLVER FUNCTION\n//======================================================================================================================================================\n//======================================================================================================================================================\n\nint solver(	fp** y,\n					fp* x,\n					int xmax,\n					fp* params,\n					int mode) {\n\n	//========================================================================================================================\n	//	VARIABLES\n	//========================================================================================================================\n\n	// solver parameters\n	fp err_exponent;\n	fp last_interval;\n	int error;\n	int outside;\n	fp h;\n	fp h_init;\n	fp tolerance;\n	int xmin;\n\n	// memory\n	fp scale_min;\n	fp scale_fina;\n	fp* err= (fp *) malloc(EQUATIONS* sizeof(fp));\n	fp* scale= (fp *) malloc(EQUATIONS* sizeof(fp));\n	fp* yy= (fp *) malloc(EQUATIONS* sizeof(fp));\n\n	// counters\n	int i, j, k;\n\n	//========================================================================================================================\n	//		INITIAL SETUP\n	//========================================================================================================================\n\n	// solver parameters\n	err_exponent = 1.0 / 7.0;\n	last_interval = 0;\n	h_init = 1;\n	h = h_init;\n	xmin = 0;\n	tolerance = 10 / (fp)(xmax-xmin);\n\n	// save value for initial time instance\n	x[0] = 0;\n\n	//========================================================================================================================\n	//		CHECKING\n	//========================================================================================================================\n\n	// Verify that the step size is positive and that the upper endpoint of integration is greater than the initial enpoint.               //\n	if (xmax < xmin || h <= 0.0){\n		return -2;\n	}\n\n	// If the upper endpoint of the independent variable agrees with the initial value of the independent variable.  Set the value of the dependent variable and return success. //\n	if (xmax == xmin){\n		return 0; \n	}\n\n	// Insure that the step size h is not larger than the length of the integration interval.                                            //\n	if (h > (xmax - xmin) ) { \n		h = (fp)xmax - (fp)xmin; \n		last_interval = 1;\n	}\n\n	//========================================================================================================================\n	//		SOLVING\n	//========================================================================================================================\n\n	for(k=1; k<=xmax; k++) {											// start after initial value\n\n		x[k] = k-1;\n		h = h_init;\n\n		//==========================================================================================\n		//		REINITIALIZE VARIABLES\n		//==========================================================================================\n\n		scale_fina = 1.0;\n\n		//==========================================================================================\n		//		MAKE ATTEMPTS TO MINIMIZE ERROR\n		//==========================================================================================\n\n		// make attempts to minimize error\n		for (j = 0; j < ATTEMPTS; j++) {\n\n			//============================================================\n			//		REINITIALIZE VARIABLES\n			//============================================================\n\n			error = 0;\n			outside = 0;\n			scale_min = MAX_SCALE_FACTOR;\n\n			//============================================================\n			//		EVALUATE ALL EQUATIONS\n			//============================================================\n\n			embedded_fehlberg_7_8(	x[k],\n														h,\n														y[k-1],\n														y[k],\n														err,\n														params,\n														mode);\n\n			//============================================================\n			//		IF THERE WAS NO ERROR FOR ANY OF EQUATIONS, SET SCALE AND LEAVE THE LOOP\n			//============================================================\n\n			for(i=0; i<EQUATIONS; i++){\n				if(err[i] > 0){\n					error = 1;\n				}\n			}\n			if (error != 1) {\n				scale_fina = MAX_SCALE_FACTOR; \n				break;\n			}\n\n			//============================================================\n			//		FIGURE OUT SCALE AS THE MINIMUM OF COMPONENT SCALES\n			//============================================================\n\n			for(i=0; i<EQUATIONS; i++){\n				if(y[k-1][i] == 0.0){\n					yy[i] = tolerance;\n				}\n				else{\n					yy[i] = fabs(y[k-1][i]);\n				}\n				scale[i] = 0.8 * pow( tolerance * yy[i] / err[i] , err_exponent );\n				if(scale[i]<scale_min){\n					scale_min = scale[i];\n				}\n			}\n			scale_fina = min( max(scale_min,MIN_SCALE_FACTOR), MAX_SCALE_FACTOR);\n\n			//============================================================\n			//		IF WITHIN TOLERANCE, FINISH ATTEMPTS...\n			//============================================================\n\n			for(i=0; i<EQUATIONS; i++){\n				if ( err[i] > ( tolerance * yy[i] ) ){\n					outside = 1;\n				}\n			}\n			if (outside == 0){\n				break;\n			}\n\n			//============================================================\n			//		...OTHERWISE, ADJUST STEP FOR NEXT ATTEMPT\n			//============================================================\n\n			// scale next step in a default way\n			h = h * scale_fina;\n\n			// limit step to 0.9, because when it gets close to 1, it no longer makes sense, as 1 is already the next time instance (added to original algorithm)\n			if (h >= 0.9) {\n				h = 0.9;\n			}\n\n			// if instance+step exceeds range limit, limit to that range\n			if ( x[k] + h > (fp)xmax ){\n				h = (fp)xmax - x[k];\n			}\n\n			// if getting closer to range limit, decrease step\n			else if ( x[k] + h + 0.5 * h > (fp)xmax ){\n				h = 0.5 * h;\n			}\n\n		}\n\n		//==========================================================================================\n		//		SAVE TIME INSTANCE THAT SOLVER ENDED UP USING\n		//==========================================================================================\n\n		x[k] = x[k] + h;\n\n		//==========================================================================================\n		//		IF MAXIMUM NUMBER OF ATTEMPTS REACHED AND CANNOT GIVE SOLUTION, EXIT PROGRAM WITH ERROR\n		//==========================================================================================\n\n		if ( j >= ATTEMPTS ) {\n			return -1; \n		}\n\n	}\n\n	//========================================================================================================================\n	//		FREE MEMORY\n	//========================================================================================================================\n\n	free(err);\n	free(scale);\n	free(yy);\n\n	//========================================================================================================================\n	//		FINAL RETURN\n	//========================================================================================================================\n\n	return 0;\n\n//======================================================================================================================================================\n//======================================================================================================================================================\n//		END OF SOLVER FUNCTION\n//======================================================================================================================================================\n//======================================================================================================================================================\n\n} \n"
bfs/bfs.cpp,"#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <stdlib.h>\n#include <omp.h>\n//#define NUM_THREAD 4\n#define OPEN\n\n\nFILE *fp;\n\n//Structure to hold a node information\nstruct Node\n{\n	int starting;\n	int no_of_edges;\n};\n\nvoid BFSGraph(int argc, char** argv);\n\nvoid Usage(int argc, char**argv){\n\nfprintf(stderr,""Usage: %s <num_threads> <input_file>\n"", argv[0]);\n\n}\n////////////////////////////////////////////////////////////////////////////////\n// Main Program\n////////////////////////////////////////////////////////////////////////////////\nint main( int argc, char** argv) \n{\n	BFSGraph( argc, argv);\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//Apply BFS on a Graph using CUDA\n////////////////////////////////////////////////////////////////////////////////\nvoid BFSGraph( int argc, char** argv) \n{\n        int no_of_nodes = 0;\n        int edge_list_size = 0;\n        char *input_f;\n	int	 num_omp_threads;\n	\n	if(argc!=3){\n	Usage(argc, argv);\n	exit(0);\n	}\n    \n	num_omp_threads = atoi(argv[1]);\n	input_f = argv[2];\n	\n	printf(""Reading File\n"");\n	//Read in Graph from a file\n	fp = fopen(input_f,""r"");\n	if(!fp)\n	{\n		printf(""Error Reading graph file\n"");\n		return;\n	}\n\n	int source = 0;\n\n	fscanf(fp,""%d"",&no_of_nodes);\n   \n	// allocate host memory\n	Node* h_graph_nodes = (Node*) malloc(sizeof(Node)*no_of_nodes);\n	bool *h_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);\n	bool *h_updating_graph_mask = (bool*) malloc(sizeof(bool)*no_of_nodes);\n	bool *h_graph_visited = (bool*) malloc(sizeof(bool)*no_of_nodes);\n\n	int start, edgeno;   \n	// initalize the memory\n	for( unsigned int i = 0; i < no_of_nodes; i++) \n	{\n		fscanf(fp,""%d %d"",&start,&edgeno);\n		h_graph_nodes[i].starting = start;\n		h_graph_nodes[i].no_of_edges = edgeno;\n		h_graph_mask[i]=false;\n		h_updating_graph_mask[i]=false;\n		h_graph_visited[i]=false;\n	}\n\n	//read the source node from the file\n	fscanf(fp,""%d"",&source);\n	// source=0; //tesing code line\n\n	//set the source node as true in the mask\n	h_graph_mask[source]=true;\n	h_graph_visited[source]=true;\n\n	fscanf(fp,""%d"",&edge_list_size);\n\n	int id,cost;\n	int* h_graph_edges = (int*) malloc(sizeof(int)*edge_list_size);\n	for(int i=0; i < edge_list_size ; i++)\n	{\n		fscanf(fp,""%d"",&id);\n		fscanf(fp,""%d"",&cost);\n		h_graph_edges[i] = id;\n	}\n\n	if(fp)\n		fclose(fp);    \n\n\n	// allocate mem for the result on host side\n	int* h_cost = (int*) malloc( sizeof(int)*no_of_nodes);\n	for(int i=0;i<no_of_nodes;i++)\n		h_cost[i]=-1;\n	h_cost[source]=0;\n	\n	printf(""Start traversing the tree\n"");\n	\n	int k=0;\n#ifdef OPEN\n        double start_time = omp_get_wtime();\n#ifdef OMP_OFFLOAD\n#pragma omp target data map(to: no_of_nodes, h_graph_mask[0:no_of_nodes], h_graph_nodes[0:no_of_nodes], h_graph_edges[0:edge_list_size], h_graph_visited[0:no_of_nodes], h_updating_graph_mask[0:no_of_nodes]) map(h_cost[0:no_of_nodes])\n        {\n#endif \n#endif\n	bool stop;\n	do\n        {\n            //if no thread changes this value then the loop stops\n            stop=false;\n\n#ifdef OPEN\n            //omp_set_num_threads(num_omp_threads);\n    #ifdef OMP_OFFLOAD\n    #pragma omp target\n    #endif\n    #pragma omp parallel for \n#endif \n            for(int tid = 0; tid < no_of_nodes; tid++ )\n            {\n                if (h_graph_mask[tid] == true){ \n                    h_graph_mask[tid]=false;\n                    for(int i=h_graph_nodes[tid].starting; i<(h_graph_nodes[tid].no_of_edges + h_graph_nodes[tid].starting); i++)\n                    {\n                        int id = h_graph_edges[i];\n                        if(!h_graph_visited[id])\n                        {\n                            h_cost[id]=h_cost[tid]+1;\n                            h_updating_graph_mask[id]=true;\n                        }\n                    }\n                }\n            }\n\n#ifdef OPEN\n    #ifdef OMP_OFFLOAD\n    #pragma omp target map(stop)\n    #endif\n    #pragma omp parallel for\n#endif\n            for(int tid=0; tid< no_of_nodes ; tid++ )\n            {\n                if (h_updating_graph_mask[tid] == true){\n                    h_graph_mask[tid]=true;\n                    h_graph_visited[tid]=true;\n                    stop=true;\n                    h_updating_graph_mask[tid]=false;\n                }\n            }\n            k++;\n        }\n	while(stop);\n#ifdef OPEN\n        double end_time = omp_get_wtime();\n        printf(""Compute time: %lf\n"", (end_time - start_time));\n#ifdef OMP_OFFLOAD\n        }\n#endif\n#endif\n	//Store the result into a file\n	FILE *fpo = fopen(""result.txt"",""w"");\n	for(int i=0;i<no_of_nodes;i++)\n		fprintf(fpo,""%d) cost:%d\n"",i,h_cost[i]);\n	fclose(fpo);\n	printf(""Result stored in result.txt\n"");\n\n\n	// cleanup memory\n	free( h_graph_nodes);\n	free( h_graph_edges);\n	free( h_graph_mask);\n	free( h_updating_graph_mask);\n	free( h_graph_visited);\n	free( h_cost);\n\n}\n\n"
backprop/imagenet.c,"\n#include <stdio.h>\n#include <stdlib.h>\n#include ""backprop.h""\n\nextern layer_size;\n\nload(net)\nBPNN *net;\n{\n  float *units;\n  int nr, nc, imgsize, i, j, k;\n\n  nr = layer_size;\n  \n  imgsize = nr * nc;\n  units = net->input_units;\n\n  k = 1;\n  for (i = 0; i < nr; i++) {\n	  units[k] = (float) rand()/RAND_MAX ;\n	  k++;\n    }\n}\n"
backprop/facetrain.c,"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include ""backprop.h""\n#include ""omp.h""\n\nextern char *strcpy();\nextern void exit();\n\nint layer_size = 0;\n\nbackprop_face()\n{\n  BPNN *net;\n  int i;\n  float out_err, hid_err;\n  net = bpnn_create(layer_size, 16, 1); // (16, 1 can not be changed)\n  printf(""Input layer size : %d\n"", layer_size);\n  load(net);\n  //entering the training kernel, only one iteration\n  printf(""Starting training kernel\n"");\n  bpnn_train_kernel(net, &out_err, &hid_err);\n  bpnn_free(net);\n  printf(""Training done\n"");\n}\n\nint setup(argc, argv)\nint argc;\nchar *argv[];\n{\n  if(argc!=2){\n  fprintf(stderr, ""usage: backprop <num of input elements>\n"");\n  exit(0);\n  }\n\n  layer_size = atoi(argv[1]);\n  \n  int seed;\n\n  seed = 7;   \n  bpnn_initialize(seed);\n  backprop_face();\n\n  exit(0);\n}\n"
backprop/backprop.c,"/*\n ******************************************************************\n * HISTORY\n * 15-Oct-94  Jeff Shufelt (js), Carnegie Mellon University\n *	Prepared for 15-681, Fall 1994.\n * Modified by Shuai Che\n ******************************************************************\n */\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include ""backprop.h""\n#include <math.h>\n#define OPEN\n\n#define ABS(x)          (((x) > 0.0) ? (x) : (-(x)))\n\n#define fastcopy(to,from,len)\\n{\\n  register char *_to,*_from;\\n  register int _i,_l;\\n  _to = (char *)(to);\\n  _from = (char *)(from);\\n  _l = (len);\\n  for (_i = 0; _i < _l; _i++) *_to++ = *_from++;\\n}\n\n/*** Return random number between 0.0 and 1.0 ***/\nfloat drnd()\n{\n  return ((float) rand() / (float) BIGRND);\n}\n\n/*** Return random number between -1.0 and 1.0 ***/\nfloat dpn1()\n{\n  return ((drnd() * 2.0) - 1.0);\n}\n\n/*** The squashing function.  Currently, it's a sigmoid. ***/\n\nfloat squash(x)\nfloat x;\n{\n  float m;\n  //x = -x;\n  //m = 1 + x + x*x/2 + x*x*x/6 + x*x*x*x/24 + x*x*x*x*x/120;\n  //return(1.0 / (1.0 + m));\n  return (1.0 / (1.0 + exp(-x)));\n}\n\n\n/*** Allocate 1d array of floats ***/\n\nfloat *alloc_1d_dbl(n)\nint n;\n{\n  float *new;\n\n  new = (float *) malloc ((unsigned) (n * sizeof (float)));\n  if (new == NULL) {\n    printf(""ALLOC_1D_DBL: Couldn't allocate array of floats\n"");\n    return (NULL);\n  }\n  return (new);\n}\n\n\n/*** Allocate 2d array of floats ***/\n\nfloat **alloc_2d_dbl(m, n)\nint m, n;\n{\n  int i;\n  float **new;\n\n  new = (float **) malloc ((unsigned) (m * sizeof (float *)));\n  if (new == NULL) {\n    printf(""ALLOC_2D_DBL: Couldn't allocate array of dbl ptrs\n"");\n    return (NULL);\n  }\n\n  for (i = 0; i < m; i++) {\n    new[i] = alloc_1d_dbl(n);\n  }\n\n  return (new);\n}\n\n\nbpnn_randomize_weights(w, m, n)\nfloat **w;\nint m, n;\n{\n  int i, j;\n\n  for (i = 0; i <= m; i++) {\n    for (j = 0; j <= n; j++) {\n     w[i][j] = (float) rand()/RAND_MAX;\n    //  w[i][j] = dpn1();\n    }\n  }\n}\n\nbpnn_randomize_row(w, m)\nfloat *w;\nint m;\n{\n	int i;\n	for (i = 0; i <= m; i++) {\n     //w[i] = (float) rand()/RAND_MAX;\n	 w[i] = 0.1;\n    }\n}\n\n\nbpnn_zero_weights(w, m, n)\nfloat **w;\nint m, n;\n{\n  int i, j;\n\n  for (i = 0; i <= m; i++) {\n    for (j = 0; j <= n; j++) {\n      w[i][j] = 0.0;\n    }\n  }\n}\n\n\nvoid bpnn_initialize(seed)\n{\n  printf(""Random number generator seed: %d\n"", seed);\n  srand(seed);\n}\n\n\nBPNN *bpnn_internal_create(n_in, n_hidden, n_out)\nint n_in, n_hidden, n_out;\n{\n  BPNN *newnet;\n\n  newnet = (BPNN *) malloc (sizeof (BPNN));\n  if (newnet == NULL) {\n    printf(""BPNN_CREATE: Couldn't allocate neural network\n"");\n    return (NULL);\n  }\n\n  newnet->input_n = n_in;\n  newnet->hidden_n = n_hidden;\n  newnet->output_n = n_out;\n  newnet->input_units = alloc_1d_dbl(n_in + 1);\n  newnet->hidden_units = alloc_1d_dbl(n_hidden + 1);\n  newnet->output_units = alloc_1d_dbl(n_out + 1);\n\n  newnet->hidden_delta = alloc_1d_dbl(n_hidden + 1);\n  newnet->output_delta = alloc_1d_dbl(n_out + 1);\n  newnet->target = alloc_1d_dbl(n_out + 1);\n\n  newnet->input_weights = alloc_2d_dbl(n_in + 1, n_hidden + 1);\n  newnet->hidden_weights = alloc_2d_dbl(n_hidden + 1, n_out + 1);\n\n  newnet->input_prev_weights = alloc_2d_dbl(n_in + 1, n_hidden + 1);\n  newnet->hidden_prev_weights = alloc_2d_dbl(n_hidden + 1, n_out + 1);\n\n  return (newnet);\n}\n\n\nvoid bpnn_free(net)\nBPNN *net;\n{\n  int n1, n2, i;\n\n  n1 = net->input_n;\n  n2 = net->hidden_n;\n\n  free((char *) net->input_units);\n  free((char *) net->hidden_units);\n  free((char *) net->output_units);\n\n  free((char *) net->hidden_delta);\n  free((char *) net->output_delta);\n  free((char *) net->target);\n\n  for (i = 0; i <= n1; i++) {\n    free((char *) net->input_weights[i]);\n    free((char *) net->input_prev_weights[i]);\n  }\n  free((char *) net->input_weights);\n  free((char *) net->input_prev_weights);\n\n  for (i = 0; i <= n2; i++) {\n    free((char *) net->hidden_weights[i]);\n    free((char *) net->hidden_prev_weights[i]);\n  }\n  free((char *) net->hidden_weights);\n  free((char *) net->hidden_prev_weights);\n\n  free((char *) net);\n}\n\n\n/*** Creates a new fully-connected network from scratch,\n     with the given numbers of input, hidden, and output units.\n     Threshold units are automatically included.  All weights are\n     randomly initialized.\n\n     Space is also allocated for temporary storage (momentum weights,\n     error computations, etc).\n***/\n\nBPNN *bpnn_create(n_in, n_hidden, n_out)\nint n_in, n_hidden, n_out;\n{\n\n  BPNN *newnet;\n\n  newnet = bpnn_internal_create(n_in, n_hidden, n_out);\n\n#ifdef INITZERO\n  bpnn_zero_weights(newnet->input_weights, n_in, n_hidden);\n#else\n  bpnn_randomize_weights(newnet->input_weights, n_in, n_hidden);\n#endif\n  bpnn_randomize_weights(newnet->hidden_weights, n_hidden, n_out);\n  bpnn_zero_weights(newnet->input_prev_weights, n_in, n_hidden);\n  bpnn_zero_weights(newnet->hidden_prev_weights, n_hidden, n_out);\n  bpnn_randomize_row(newnet->target, n_out);\n  return (newnet);\n}\n\n\nvoid bpnn_layerforward(l1, l2, conn, n1, n2)\nfloat *l1, *l2, **conn;\nint n1, n2;\n{\n  float sum;\n  int j, k;\n\n  /*** Set up thresholding unit ***/\n  l1[0] = 1.0;\n#ifdef OPEN\n  omp_set_num_threads(NUM_THREAD);\n  #pragma omp parallel for shared(conn, n1, n2, l1) private(k, j) reduction(+: sum) schedule(static)\n#endif \n  /*** For each unit in second layer ***/\n  for (j = 1; j <= n2; j++) {\n\n    /*** Compute weighted sum of its inputs ***/\n    sum = 0.0;\n    for (k = 0; k <= n1; k++) {	\n      sum += conn[k][j] * l1[k]; \n    }\n    l2[j] = squash(sum);\n  }\n}\n\n//extern ""C""\nvoid bpnn_output_error(delta, target, output, nj, err)  \nfloat *delta, *target, *output, *err;\nint nj;\n{\n  int j;\n  float o, t, errsum;\n  errsum = 0.0;\n  for (j = 1; j <= nj; j++) {\n    o = output[j];\n    t = target[j];\n    delta[j] = o * (1.0 - o) * (t - o);\n    errsum += ABS(delta[j]);\n  }\n  *err = errsum;\n}\n\n\nvoid bpnn_hidden_error(delta_h,   \n					   nh, \n					   delta_o, \n					   no, \n					   who, \n					   hidden, \n					   err)\nfloat *delta_h, *delta_o, *hidden, **who, *err;\nint nh, no;\n{\n  int j, k;\n  float h, sum, errsum;\n\n  errsum = 0.0;\n  for (j = 1; j <= nh; j++) {\n    h = hidden[j];\n    sum = 0.0;\n    for (k = 1; k <= no; k++) {\n      sum += delta_o[k] * who[j][k];\n    }\n    delta_h[j] = h * (1.0 - h) * sum;\n    errsum += ABS(delta_h[j]);\n  }\n  *err = errsum;\n}\n\n\nvoid bpnn_adjust_weights(delta, ndelta, ly, nly, w, oldw)\nfloat *delta, *ly, **w, **oldw;\n{\n  float new_dw;\n  int k, j;\n  ly[0] = 1.0;\n  //eta = 0.3;\n  //momentum = 0.3;\n\n#ifdef OPEN\n  omp_set_num_threads(NUM_THREAD);\n  #pragma omp parallel for  \\n      shared(oldw, w, delta) \\n	  private(j, k, new_dw) \\n	  firstprivate(ndelta, nly) \n#endif \n  for (j = 1; j <= ndelta; j++) {\n    for (k = 0; k <= nly; k++) {\n      new_dw = ((ETA * delta[j] * ly[k]) + (MOMENTUM * oldw[k][j]));\n	  w[k][j] += new_dw;\n	  oldw[k][j] = new_dw;\n    }\n  }\n}\n\n\nvoid bpnn_feedforward(net)\nBPNN *net;\n{\n  int in, hid, out;\n\n  in = net->input_n;\n  hid = net->hidden_n;\n  out = net->output_n;\n\n  /*** Feed forward input activations. ***/\n  bpnn_layerforward(net->input_units, net->hidden_units,\n      net->input_weights, in, hid);\n  bpnn_layerforward(net->hidden_units, net->output_units,\n      net->hidden_weights, hid, out);\n\n}\n\n\nvoid bpnn_train(net, eo, eh)\nBPNN *net;\nfloat *eo, *eh;\n{\n  int in, hid, out;\n  float out_err, hid_err;\n\n  in = net->input_n;\n  hid = net->hidden_n;\n  out = net->output_n;\n\n  /*** Feed forward input activations. ***/\n  bpnn_layerforward(net->input_units, net->hidden_units,\n      net->input_weights, in, hid);\n  bpnn_layerforward(net->hidden_units, net->output_units,\n      net->hidden_weights, hid, out);\n\n  /*** Compute error on output and hidden units. ***/\n  bpnn_output_error(net->output_delta, net->target, net->output_units,\n      out, &out_err);\n  bpnn_hidden_error(net->hidden_delta, hid, net->output_delta, out,\n      net->hidden_weights, net->hidden_units, &hid_err);\n  *eo = out_err;\n  *eh = hid_err;\n\n  /*** Adjust input and hidden weights. ***/\n  bpnn_adjust_weights(net->output_delta, out, net->hidden_units, hid,\n      net->hidden_weights, net->hidden_prev_weights);\n  bpnn_adjust_weights(net->hidden_delta, hid, net->input_units, in,\n      net->input_weights, net->input_prev_weights);\n\n}\n\n\n\n\nvoid bpnn_save(net, filename)\nBPNN *net;\nchar *filename;\n{\n  int n1, n2, n3, i, j, memcnt;\n  float dvalue, **w;\n  char *mem;\n  ///add//\n  FILE *pFile;\n  pFile = fopen( filename, ""w+"" );\n  ///////\n  /*\n  if ((fd = creat(filename, 0644)) == -1) {\n    printf(""BPNN_SAVE: Cannot create '%s'\n"", filename);\n    return;\n  }\n  */\n\n  n1 = net->input_n;  n2 = net->hidden_n;  n3 = net->output_n;\n  printf(""Saving %dx%dx%d network to '%s'\n"", n1, n2, n3, filename);\n  //fflush(stdout);\n\n  //write(fd, (char *) &n1, sizeof(int));\n  //write(fd, (char *) &n2, sizeof(int));\n  //write(fd, (char *) &n3, sizeof(int));\n\n  fwrite( (char *) &n1 , sizeof(char), sizeof(char), pFile);\n  fwrite( (char *) &n2 , sizeof(char), sizeof(char), pFile);\n  fwrite( (char *) &n3 , sizeof(char), sizeof(char), pFile);\n\n  \n\n  memcnt = 0;\n  w = net->input_weights;\n  mem = (char *) malloc ((unsigned) ((n1+1) * (n2+1) * sizeof(float)));\n  for (i = 0; i <= n1; i++) {\n    for (j = 0; j <= n2; j++) {\n      dvalue = w[i][j];\n      fastcopy(&mem[memcnt], &dvalue, sizeof(float));\n      memcnt += sizeof(float);\n    }\n  }\n  //write(fd, mem, (n1+1) * (n2+1) * sizeof(float));\n  fwrite( mem , (unsigned)(sizeof(float)), (unsigned) ((n1+1) * (n2+1) * sizeof(float)) , pFile);\n  free(mem);\n\n  memcnt = 0;\n  w = net->hidden_weights;\n  mem = (char *) malloc ((unsigned) ((n2+1) * (n3+1) * sizeof(float)));\n  for (i = 0; i <= n2; i++) {\n    for (j = 0; j <= n3; j++) {\n      dvalue = w[i][j];\n      fastcopy(&mem[memcnt], &dvalue, sizeof(float));\n      memcnt += sizeof(float);\n    }\n  }\n  //write(fd, mem, (n2+1) * (n3+1) * sizeof(float));\n  fwrite( mem , sizeof(float), (unsigned) ((n2+1) * (n3+1) * sizeof(float)) , pFile);\n  free(mem);\n\n  fclose(pFile);\n  return;\n}\n\n\nBPNN *bpnn_read(filename)\nchar *filename;\n{\n  char *mem;\n  BPNN *new;\n  int fd, n1, n2, n3, i, j, memcnt;\n\n  if ((fd = open(filename, 0, 0644)) == -1) {\n    return (NULL);\n  }\n\n  printf(""Reading '%s'\n"", filename);  //fflush(stdout);\n\n  read(fd, (char *) &n1, sizeof(int));\n  read(fd, (char *) &n2, sizeof(int));\n  read(fd, (char *) &n3, sizeof(int));\n  new = bpnn_internal_create(n1, n2, n3);\n\n  printf(""'%s' contains a %dx%dx%d network\n"", filename, n1, n2, n3);\n  printf(""Reading input weights..."");  //fflush(stdout);\n\n  memcnt = 0;\n  mem = (char *) malloc ((unsigned) ((n1+1) * (n2+1) * sizeof(float)));\n  read(fd, mem, (n1+1) * (n2+1) * sizeof(float));\n  for (i = 0; i <= n1; i++) {\n    for (j = 0; j <= n2; j++) {\n      fastcopy(&(new->input_weights[i][j]), &mem[memcnt], sizeof(float));\n      memcnt += sizeof(float);\n    }\n  }\n  free(mem);\n\n  printf(""Done\nReading hidden weights..."");  //fflush(stdout);\n\n  memcnt = 0;\n  mem = (char *) malloc ((unsigned) ((n2+1) * (n3+1) * sizeof(float)));\n  read(fd, mem, (n2+1) * (n3+1) * sizeof(float));\n  for (i = 0; i <= n2; i++) {\n    for (j = 0; j <= n3; j++) {\n      fastcopy(&(new->hidden_weights[i][j]), &mem[memcnt], sizeof(float));\n      memcnt += sizeof(float);\n    }\n  }\n  free(mem);\n  close(fd);\n\n  printf(""Done\n"");  //fflush(stdout);\n\n  bpnn_zero_weights(new->input_prev_weights, n1, n2);\n  bpnn_zero_weights(new->hidden_prev_weights, n2, n3);\n\n  return (new);\n}\n"
backprop/backprop_kernel.c,"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <sys/time.h>\n\n#include ""backprop.h""\n\n////////////////////////////////////////////////////////////////////////////////\n\nextern void bpnn_layerforward(float *l1, float *l2, float **conn, int n1, int n2);\n\nextern void bpnn_output_error(float *delta, float *target, float *output, int nj, float *err);\n\nextern void bpnn_hidden_error(float *delta_h, int nh, float *delta_o, int no, float **who, float *hidden, float *err);\n\nextern void bpnn_adjust_weights(float *delta, int ndelta, float *ly, int nly, float **w, float **oldw);\n\n\nextern int setup(int argc, char** argv);\n\nextern float **alloc_2d_dbl(int m, int n);\n\nextern float squash(float x);\n\ndouble gettime() {\n  struct timeval t;\n  gettimeofday(&t,NULL);\n  return t.tv_sec+t.tv_usec*1e-6;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Program main\n////////////////////////////////////////////////////////////////////////////////\nint\nmain( int argc, char** argv) \n{\n	setup(argc, argv);\n}\n\n\nvoid bpnn_train_kernel(BPNN *net, float *eo, float *eh)\n{\n  int in, hid, out;\n  float out_err, hid_err;\n  \n  in = net->input_n;\n  hid = net->hidden_n;\n  out = net->output_n;   \n   \n  printf(""Performing CPU computation\n"");\n  bpnn_layerforward(net->input_units, net->hidden_units,net->input_weights, in, hid);\n  bpnn_layerforward(net->hidden_units, net->output_units, net->hidden_weights, hid, out);\n  bpnn_output_error(net->output_delta, net->target, net->output_units, out, &out_err);\n  bpnn_hidden_error(net->hidden_delta, hid, net->output_delta, out, net->hidden_weights, net->hidden_units, &hid_err);  \n  bpnn_adjust_weights(net->output_delta, out, net->hidden_units, hid, net->hidden_weights, net->hidden_prev_weights);\n  bpnn_adjust_weights(net->hidden_delta, hid, net->input_units, in, net->input_weights, net->input_prev_weights);\n\n}\n"
kmeans/kmeans_openmp/kmeans.c,"/*****************************************************************************/\n/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */\n/*By downloading, copying, installing or using the software you agree        */\n/*to this license.  If you do not agree to this license, do not download,    */\n/*install, copy or use the software.                                         */\n/*                                                                           */\n/*                                                                           */\n/*Copyright (c) 2005 Northwestern University                                 */\n/*All rights reserved.                                                       */\n\n/*Redistribution of the software in source and binary forms,                 */\n/*with or without modification, is permitted provided that the               */\n/*following conditions are met:                                              */\n/*                                                                           */\n/*1       Redistributions of source code must retain the above copyright     */\n/*        notice, this list of conditions and the following disclaimer.      */\n/*                                                                           */\n/*2       Redistributions in binary form must reproduce the above copyright   */\n/*        notice, this list of conditions and the following disclaimer in the */\n/*        documentation and/or other materials provided with the distribution.*/ \n/*                                                                            */\n/*3       Neither the name of Northwestern University nor the names of its    */\n/*        contributors may be used to endorse or promote products derived     */\n/*        from this software without specific prior written permission.       */\n/*                                                                            */\n/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */\n/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */\n/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */\n/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */\n/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */\n/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */\n/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */\n/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */\n/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */\n/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */\n/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */\n/*POSSIBILITY OF SUCH DAMAGE.                                                 */\n/******************************************************************************/\n\n/*************************************************************************/\n/**   File:         example.c                                           **/\n/**   Description:  Takes as input a file:                              **/\n/**                 ascii  file: containing 1 data point per line       **/\n/**                 binary file: first int is the number of objects     **/\n/**                              2nd int is the no. of features of each **/\n/**                              object                                 **/\n/**                 This example performs a fuzzy c-means clustering    **/\n/**                 on the data. Fuzzy clustering is performed using    **/\n/**                 min to max clusters and the clustering that gets    **/\n/**                 the best score according to a compactness and       **/\n/**                 separation criterion are returned.                  **/\n/**   Author:  Wei-keng Liao                                            **/\n/**            ECE Department Northwestern University                   **/\n/**            email: wkliao@ece.northwestern.edu                       **/\n/**                                                                     **/\n/**   Edited by: Jay Pisharath                                          **/\n/**              Northwestern University.                               **/\n/**                                                                     **/\n/**   ================================================================  **/\n/**																		**/\n/**   Edited by: Sang-Ha  Lee											**/\n/**				 University of Virginia									**/\n/**																		**/\n/**   Description:	No longer supports fuzzy c-means clustering;	 	**/\n/**					only regular k-means clustering.					**/\n/**					Simplified for main functionality: regular k-means	**/\n/**					clustering.											**/\n/**                                                                     **/\n/*************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <omp.h>\n#include ""getopt.h""\n\n#include ""kmeans.h""\n\nextern double wtime(void);\n\nint num_omp_threads = 1;\n\n/*---< usage() >------------------------------------------------------------*/\nvoid usage(char *argv0) {\n    char *help =\n        ""Usage: %s [switches] -i filename\n""\n        ""       -i filename     		: file containing data to be clustered\n""\n        ""       -b                 	: input file is in binary format\n""\n		""       -k                 	: number of clusters (default is 5) \n""\n        ""       -t threshold		: threshold value\n""\n		""       -n no. of threads	: number of threads"";\n    fprintf(stderr, help, argv0);\n    exit(-1);\n}\n\n/*---< main() >-------------------------------------------------------------*/\nint main(int argc, char **argv) {\n           int     opt;\n    extern char   *optarg;\n    extern int     optind;\n           int     nclusters=5;\n           char   *filename = 0;           \n           float  *buf;\n           float **attributes;\n           float **cluster_centres=NULL;\n           int     i, j;\n                \n           int     numAttributes;\n           int     numObjects;        \n           char    line[1024];           \n           int     isBinaryFile = 0;\n           int     nloops = 1;\n           float   threshold = 0.001;\n		   double  timing;		   \n\n	while ( (opt=getopt(argc,argv,""i:k:t:b:n:?""))!= EOF) {\n		switch (opt) {\n            case 'i': filename=optarg;\n                      break;\n            case 'b': isBinaryFile = 1;\n                      break;\n            case 't': threshold=atof(optarg);\n                      break;\n            case 'k': nclusters = atoi(optarg);\n                      break;			\n			case 'n': num_omp_threads = atoi(optarg);\n					  break;\n            case '?': usage(argv[0]);\n                      break;\n            default: usage(argv[0]);\n                      break;\n        }\n    }\n\n\n    if (filename == 0) usage(argv[0]);\n\n    numAttributes = numObjects = 0;\n\n    /* from the input file, get the numAttributes and numObjects ------------*/\n   \n    if (isBinaryFile) {\n        int infile;\n        if ((infile = open(filename, O_RDONLY, ""0600"")) == -1) {\n            fprintf(stderr, ""Error: no such file (%s)\n"", filename);\n            exit(1);\n        }\n        read(infile, &numObjects,    sizeof(int));\n        read(infile, &numAttributes, sizeof(int));\n   \n\n        /* allocate space for attributes[] and read attributes of all objects */\n        buf           = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        attributes    = (float**)malloc(numObjects*             sizeof(float*));\n        attributes[0] = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        for (i=1; i<numObjects; i++)\n            attributes[i] = attributes[i-1] + numAttributes;\n\n        read(infile, buf, numObjects*numAttributes*sizeof(float));\n\n        close(infile);\n    }\n    else {\n        FILE *infile;\n        if ((infile = fopen(filename, ""r"")) == NULL) {\n            fprintf(stderr, ""Error: no such file (%s)\n"", filename);\n            exit(1);\n        }\n        while (fgets(line, 1024, infile) != NULL)\n            if (strtok(line, "" \t\n"") != 0)\n                numObjects++;\n        rewind(infile);\n        while (fgets(line, 1024, infile) != NULL) {\n            if (strtok(line, "" \t\n"") != 0) {\n                /* ignore the id (first attribute): numAttributes = 1; */\n                while (strtok(NULL, "" ,\t\n"") != NULL) numAttributes++;\n                break;\n            }\n        }\n     \n\n        /* allocate space for attributes[] and read attributes of all objects */\n        buf           = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        attributes    = (float**)malloc(numObjects*             sizeof(float*));\n        attributes[0] = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        for (i=1; i<numObjects; i++)\n            attributes[i] = attributes[i-1] + numAttributes;\n        rewind(infile);\n        i = 0;\n        while (fgets(line, 1024, infile) != NULL) {\n            if (strtok(line, "" \t\n"") == NULL) continue; \n            for (j=0; j<numAttributes; j++) {\n                buf[i] = atof(strtok(NULL, "" ,\t\n""));\n                i++;\n            }\n        }\n        fclose(infile);\n    }     \n	printf(""I/O completed\n"");	\n\n	memcpy(attributes[0], buf, numObjects*numAttributes*sizeof(float));\n\n	timing = omp_get_wtime();\n    for (i=0; i<nloops; i++) {\n        \n        cluster_centres = NULL;\n        cluster(numObjects,\n                numAttributes,\n                attributes,           /* [numObjects][numAttributes] */                \n                nclusters,\n                threshold,\n                &cluster_centres   \n               );\n     \n    }\n    timing = omp_get_wtime() - timing;\n	\n\n	printf(""number of Clusters %d\n"",nclusters); \n	printf(""number of Attributes %d\n\n"",numAttributes); \n  /*  	printf(""Cluster Centers Output\n""); \n	printf(""The first number is cluster number and the following data is arribute value\n"");\n	printf(""=============================================================================\n\n"");\n	\n    for (i=0; i< nclusters; i++) {\n		printf(""%d: "", i);\n        for (j=0; j<numAttributes; j++)\n            printf(""%.2f "", cluster_centres[i][j]);\n        printf(""\n\n"");\n    }\n*/\n	printf(""Time for process: %f\n"", timing);\n\n    free(attributes);\n    free(cluster_centres[0]);\n    free(cluster_centres);\n    free(buf);\n    return(0);\n}\n\n"
kmeans/kmeans_openmp/getopt.c,"/* Getopt for GNU.\n   NOTE: getopt is now part of the C library, so if you don't know what\n   ""Keep this file name-space clean"" means, talk to drepper@gnu.org\n   before changing it!\n   Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001\n        Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, write to the Free\n   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n   02111-1307 USA.  */\n\n/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.\n   Ditto for AIX 3.2 and <stdlib.h>.  */\n#ifndef _NO_PROTO\n# define _NO_PROTO\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#if !defined __STDC__ || !__STDC__\n/* This is a separate conditional since some stdc systems\n   reject `defined (const)'.  */\n# ifndef const\n#  define const\n# endif\n#endif\n\n#include <stdio.h>\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#define GETOPT_INTERFACE_VERSION 2\n#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2\n# include <gnu-versions.h>\n# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION\n#  define ELIDE_CODE\n# endif\n#endif\n\n#ifndef ELIDE_CODE\n\n\n/* This needs to come after some library #include\n   to get __GNU_LIBRARY__ defined.  */\n#ifdef  __GNU_LIBRARY__\n/* Don't include stdlib.h for non-GNU C libraries because some of them\n   contain conflicting prototypes for getopt.  */\n# include <stdlib.h>\n# include <unistd.h>\n#endif  /* GNU C library.  */\n\n#ifdef VMS\n# include <unixlib.h>\n# if HAVE_STRING_H - 0\n#  include <string.h>\n# endif\n#endif\n\n#ifndef _\n/* This is for other GNU distributions with internationalized messages.  */\n# if (HAVE_LIBINTL_H && ENABLE_NLS) || defined _LIBC\n#  include <libintl.h>\n#  ifndef _\n#   define _(msgid)     gettext (msgid)\n#  endif\n# else\n#  define _(msgid)      (msgid)\n# endif\n# if defined _LIBC && defined USE_IN_LIBIO\n#  include <wchar.h>\n# endif\n#endif\n\n/* This version of `getopt' appears to the caller like standard Unix `getopt'\n   but it behaves differently for the user, since it allows the user\n   to intersperse the options with the other arguments.\n\n   As `getopt' works, it permutes the elements of ARGV so that,\n   when it is done, all the options precede everything else.  Thus\n   all application programs are extended to handle flexible argument order.\n\n   Setting the environment variable POSIXLY_CORRECT disables permutation.\n   Then the behavior is completely standard.\n\n   GNU application programs can use a third alternative mode in which\n   they can distinguish the relative order of options and other arguments.  */\n\n#include ""getopt.h""\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nchar *optarg;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns -1, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\n/* 1003.2 says this must be 1 before any call.  */\nint optind = 1;\n\n/* Formerly, initialization of getopt depended on optind==0, which\n   causes problems with re-calling getopt as programs generally don't\n   know that. */\n\nint __getopt_initialized;\n\n/* The next char to be scanned in the option-element\n   in which the last option character we returned was found.\n   This allows us to pick up the scan where we left off.\n\n   If this is zero, or a null string, it means resume the scan\n   by advancing to the next ARGV-element.  */\n\nstatic char *nextchar;\n\n/* Callers store zero here to inhibit the error message\n   for unrecognized options.  */\n\nint opterr = 1;\n\n/* Set to an option character which was unrecognized.\n   This must be initialized on some systems to avoid linking in the\n   system's own getopt implementation.  */\n\nint optopt = '?';\n\n/* Describe how to deal with options that follow non-option ARGV-elements.\n\n   If the caller did not specify anything,\n   the default is REQUIRE_ORDER if the environment variable\n   POSIXLY_CORRECT is defined, PERMUTE otherwise.\n\n   REQUIRE_ORDER means don't recognize them as options;\n   stop option processing when the first non-option is seen.\n   This is what Unix does.\n   This mode of operation is selected by either setting the environment\n   variable POSIXLY_CORRECT, or using `+' as the first character\n   of the list of option characters.\n\n   PERMUTE is the default.  We permute the contents of ARGV as we scan,\n   so that eventually all the non-options are at the end.  This allows options\n   to be given in any order, even with programs that were not written to\n   expect this.\n\n   RETURN_IN_ORDER is an option available to programs that were written\n   to expect options and other ARGV-elements in any order and that care about\n   the ordering of the two.  We describe each non-option ARGV-element\n   as if it were the argument of an option with character code 1.\n   Using `-' as the first character of the list of option characters\n   selects this mode of operation.\n\n   The special argument `--' forces an end of option-scanning regardless\n   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */\n\nstatic enum\n{\n  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n} ordering;\n\n/* Value of POSIXLY_CORRECT environment variable.  */\nstatic char *posixly_correct;\n\n#ifdef  __GNU_LIBRARY__\n/* We want to avoid inclusion of string.h with non-GNU libraries\n   because there are many ways it can cause trouble.\n   On some systems, it contains special magic macros that don't work\n   in GCC.  */\n# include <string.h>\n# define my_index       strchr\n#else\n\n//# if HAVE_STRING_H || WIN32 /* Pete Wilson mod 7/28/02 */\n#  include <string.h>\n//# else\n//#  include <strings.h>\n//# endif\n\n/* Avoid depending on library functions or files\n   whose names are inconsistent.  */\n\n#ifndef getenv\nextern char *getenv ();\n#endif\n\nstatic char *\nmy_index (str, chr)\n     const char *str;\n     int chr;\n{\n  while (*str)\n    {\n      if (*str == chr)\n        return (char *) str;\n      str++;\n    }\n  return 0;\n}\n\n/* If using GCC, we can safely declare strlen this way.\n   If not using GCC, it is ok not to declare it.  */\n#ifdef __GNUC__\n/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.\n   That was relevant to code that was here before.  */\n# if (!defined __STDC__ || !__STDC__) && !defined strlen\n/* gcc with -traditional declares the built-in strlen to return int,\n   and has done so at least since version 2.4.5. -- rms.  */\nextern int strlen (const char *);\n# endif /* not __STDC__ */\n#endif /* __GNUC__ */\n\n#endif /* not __GNU_LIBRARY__ */\n\n/* Handle permutation of arguments.  */\n\n/* Describe the part of ARGV that contains non-options that have\n   been skipped.  `first_nonopt' is the index in ARGV of the first of them;\n   `last_nonopt' is the index after the last of them.  */\n\nstatic int first_nonopt;\nstatic int last_nonopt;\n\n#ifdef _LIBC\n/* Stored original parameters.\n   XXX This is no good solution.  We should rather copy the args so\n   that we can compare them later.  But we must not use malloc(3).  */\nextern int __libc_argc;\nextern char **__libc_argv;\n\n/* Bash 2.0 gives us an environment variable containing flags\n   indicating ARGV elements that should not be considered arguments.  */\n\n# ifdef USE_NONOPTION_FLAGS\n/* Defined in getopt_init.c  */\nextern char *__getopt_nonoption_flags;\n\nstatic int nonoption_flags_max_len;\nstatic int nonoption_flags_len;\n# endif\n\n# ifdef USE_NONOPTION_FLAGS\n#  define SWAP_FLAGS(ch1, ch2) \\n  if (nonoption_flags_len > 0)                                                \\n    {                                                                         \\n      char __tmp = __getopt_nonoption_flags[ch1];                             \\n      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];          \\n      __getopt_nonoption_flags[ch2] = __tmp;                                  \\n    }\n# else\n#  define SWAP_FLAGS(ch1, ch2)\n# endif\n#else   /* !_LIBC */\n# define SWAP_FLAGS(ch1, ch2)\n#endif  /* _LIBC */\n\n/* Exchange two adjacent subsequences of ARGV.\n   One subsequence is elements [first_nonopt,last_nonopt)\n   which contains all the non-options that have been skipped so far.\n   The other is elements [last_nonopt,optind), which contains all\n   the options processed since those non-options were skipped.\n\n   `first_nonopt' and `last_nonopt' are relocated so that they describe\n   the new indices of the non-options in ARGV after they are moved.  */\n\n#if defined __STDC__ && __STDC__\nstatic void exchange (char **);\n#endif\n\nstatic void\nexchange (argv)\n     char **argv;\n{\n  int bottom = first_nonopt;\n  int middle = last_nonopt;\n  int top = optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the `__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        nonoption_flags_len = nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             nonoption_flags_max_len),\n                  '\0', top + 1 - nonoption_flags_max_len);\n          nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  first_nonopt += (optind - last_nonopt);\n  last_nonopt = optind;\n}\n\n/* Initialize the internal data when the first call is made.  */\n\n#if defined __STDC__ && __STDC__\nstatic const char *_getopt_initialize (int, char *const *, const char *);\n#endif\nstatic const char *\n_getopt_initialize (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  first_nonopt = last_nonopt = optind;\n\n  nextchar = NULL;\n\n  posixly_correct = getenv (""POSIXLY_CORRECT"");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct != NULL)\n    ordering = REQUIRE_ORDER;\n  else\n    ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (posixly_correct == NULL\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\0')\n            nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = nonoption_flags_max_len = strlen (orig_str);\n              if (nonoption_flags_max_len < argc)\n                nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\0', nonoption_flags_max_len - len);\n            }\n        }\n      nonoption_flags_len = nonoption_flags_max_len;\n    }\n  else\n    nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}\n\n/* Scan elements of ARGV (whose length is ARGC) for option characters\n   given in OPTSTRING.\n\n   If an element of ARGV starts with '-', and is not exactly ""-"" or ""--"",\n   then it is an option element.  The characters of this element\n   (aside from the initial '-') are option characters.  If `getopt'\n   is called repeatedly, it returns successively each of the option characters\n   from each of the option elements.\n\n   If `getopt' finds another option character, it returns that character,\n   updating `optind' and `nextchar' so that the next call to `getopt' can\n   resume the scan with the following option character or ARGV-element.\n\n   If there are no more option characters, `getopt' returns -1.\n   Then `optind' is the index in ARGV of the first ARGV-element\n   that is not an option.  (The ARGV-elements have been permuted\n   so that those that are not options now come last.)\n\n   OPTSTRING is a string containing the legitimate option characters.\n   If an option character is seen that is not listed in OPTSTRING,\n   return '?' after printing an error message.  If you set `opterr' to\n   zero, the error message is suppressed but we still return '?'.\n\n   If a char in OPTSTRING is followed by a colon, that means it wants an arg,\n   so the following text in the same ARGV-element, or the text of the following\n   ARGV-element, is returned in `optarg'.  Two colons mean an option that\n   wants an optional arg; if there is text in the current ARGV-element,\n   it is returned in `optarg', otherwise `optarg' is set to zero.\n\n   If OPTSTRING starts with `-' or `+', it requests different methods of\n   handling the non-option ARGV-elements.\n   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.\n\n   Long-named options begin with `--' instead of `-'.\n   Their names may be abbreviated as long as the abbreviation is unique\n   or is an exact match for some defined option.  If they have an\n   argument, it follows the option name in the same ARGV-element, separated\n   from the option name by a `=', or else the in next ARGV-element.\n   When `getopt' finds a long-named option, it returns 0 if that option's\n   `flag' field is nonzero, the value of the option's `val' field\n   if the `flag' field is zero.\n\n   The elements of ARGV aren't really const, because we permute them.\n   But we pretend they're const in the prototype to be compatible\n   with other systems.\n\n   LONGOPTS is a vector of `struct option' terminated by an\n   element containing a name which is zero.\n\n   LONGIND returns the index in LONGOPT of the long-named option found.\n   It is only valid when a long-named option has been found by the most\n   recent call.\n\n   If LONG_ONLY is nonzero, '-' as well as '--' can introduce\n   long-named options.  */\n\nint\n_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n     const struct option *longopts;\n     int *longind;\n     int long_only;\n{\n  int print_errors = opterr;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  if (argc < 1)\n    return -1;\n\n  optarg = NULL;\n\n  if (optind == 0 || !__getopt_initialized)\n    {\n      if (optind == 0)\n        optind = 1;     /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring);\n      __getopt_initialized = 1;\n    }\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'       \\n                      || (optind < nonoption_flags_len                        \\n                          && __getopt_nonoption_flags[optind] == '1'))\n#else\n# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')\n#endif\n\n  if (nextchar == NULL || *nextchar == '\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT and LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (last_nonopt > optind)\n        last_nonopt = optind;\n      if (first_nonopt > optind)\n        first_nonopt = optind;\n\n      if (ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (first_nonopt != last_nonopt && last_nonopt != optind)\n            exchange ((char **) argv);\n          else if (last_nonopt != optind)\n            first_nonopt = optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (optind < argc && NONOPTION_P)\n            optind++;\n          last_nonopt = optind;\n        }\n\n      /* The special ARGV-element `--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (optind != argc && !strcmp (argv[optind], ""--""))\n        {\n          optind++;\n\n          if (first_nonopt != last_nonopt && last_nonopt != optind)\n            exchange ((char **) argv);\n          else if (first_nonopt == last_nonopt)\n            first_nonopt = optind;\n          last_nonopt = argc;\n\n          optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (first_nonopt != last_nonopt)\n            optind = first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (ordering == REQUIRE_ORDER)\n            return -1;\n          optarg = argv[optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      nextchar = (argv[optind] + 1\n                  + (longopts != NULL && argv[optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form ""-f"", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option ""fubar"" and\n     the ARGV-element is ""-fu"", do consider that an abbreviation of\n     the long option, just like ""--fu"", and not ""-f"" with arg ""u"".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[optind][1] == '-'\n          || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))\n    {\n      char *nameend;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, nextchar, nameend - nextchar))\n          {\n            if ((unsigned int) (nameend - nextchar)\n                == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              /* Second or later nonexact match found.  */\n              ambig = 1;\n          }\n\n      if (ambig && !exact)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n\n              __asprintf (&buf, _(""%s: option `%s' is ambiguous\n""),\n                          argv[0], argv[optind]);\n\n              if (_IO_fwide (stderr, 0) > 0)\n                __fwprintf (stderr, L""%s"", buf);\n              else\n                fputs (buf, stderr);\n\n              free (buf);\n#else\n              fprintf (stderr, _(""%s: option `%s' is ambiguous\n""),\n                       argv[0], argv[optind]);\n#endif\n            }\n          nextchar += strlen (nextchar);\n          optind++;\n          optopt = 0;\n          return '?';\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n#endif\n\n                      if (argv[optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          __asprintf (&buf, _(""\\n%s: option `--%s' doesn't allow an argument\n""),\n                                      argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(""\\n%s: option `--%s' doesn't allow an argument\n""),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          __asprintf (&buf, _(""\\n%s: option `%c%s' doesn't allow an argument\n""),\n                                      argv[0], argv[optind - 1][0],\n                                      pfound->name);\n#else\n                          fprintf (stderr, _(""\\n%s: option `%c%s' doesn't allow an argument\n""),\n                                   argv[0], argv[optind - 1][0], pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (_IO_fwide (stderr, 0) > 0)\n                        __fwprintf (stderr, L""%s"", buf);\n                      else\n                        fputs (buf, stderr);\n\n                      free (buf);\n#endif\n                    }\n\n                  nextchar += strlen (nextchar);\n\n                  optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (optind < argc)\n                optarg = argv[optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      __asprintf (&buf,\n                                  _(""%s: option `%s' requires an argument\n""),\n                                  argv[0], argv[optind - 1]);\n\n                      if (_IO_fwide (stderr, 0) > 0)\n                        __fwprintf (stderr, L""%s"", buf);\n                      else\n                        fputs (buf, stderr);\n\n                      free (buf);\n#else\n                      fprintf (stderr,\n                               _(""%s: option `%s' requires an argument\n""),\n                               argv[0], argv[optind - 1]);\n#endif\n                    }\n                  nextchar += strlen (nextchar);\n                  optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          nextchar += strlen (nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[optind][1] == '-'\n          || my_index (optstring, *nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n#endif\n\n              if (argv[optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  __asprintf (&buf, _(""%s: unrecognized option `--%s'\n""),\n                              argv[0], nextchar);\n#else\n                  fprintf (stderr, _(""%s: unrecognized option `--%s'\n""),\n                           argv[0], nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  __asprintf (&buf, _(""%s: unrecognized option `%c%s'\n""),\n                              argv[0], argv[optind][0], nextchar);\n#else\n                  fprintf (stderr, _(""%s: unrecognized option `%c%s'\n""),\n                           argv[0], argv[optind][0], nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (_IO_fwide (stderr, 0) > 0)\n                __fwprintf (stderr, L""%s"", buf);\n              else\n                fputs (buf, stderr);\n\n              free (buf);\n#endif\n            }\n          nextchar = (char *) """";\n          optind++;\n          optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *nextchar++;\n    char *temp = my_index (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*nextchar == '\0')\n      ++optind;\n\n    if (temp == NULL || c == ':')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n#endif\n\n            if (posixly_correct)\n              {\n                /* 1003.2 specifies the format of this message.  */\n#if defined _LIBC && defined USE_IN_LIBIO\n                __asprintf (&buf, _(""%s: illegal option -- %c\n""),\n                            argv[0], c);\n#else\n                fprintf (stderr, _(""%s: illegal option -- %c\n""), argv[0], c);\n#endif\n              }\n            else\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                __asprintf (&buf, _(""%s: invalid option -- %c\n""),\n                            argv[0], c);\n#else\n                fprintf (stderr, _(""%s: invalid option -- %c\n""), argv[0], c);\n#endif\n              }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (_IO_fwide (stderr, 0) > 0)\n              __fwprintf (stderr, L""%s"", buf);\n            else\n              fputs (buf, stderr);\n\n            free (buf);\n#endif\n          }\n        optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        /* This is an option that requires an argument.  */\n        if (*nextchar != '\0')\n          {\n            optarg = nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            optind++;\n          }\n        else if (optind == argc)\n          {\n            if (print_errors)\n              {\n                /* 1003.2 specifies the format of this message.  */\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                __asprintf (&buf, _(""%s: option requires an argument -- %c\n""),\n                            argv[0], c);\n\n                if (_IO_fwide (stderr, 0) > 0)\n                  __fwprintf (stderr, L""%s"", buf);\n                else\n                  fputs (buf, stderr);\n\n                free (buf);\n#else\n                fprintf (stderr, _(""%s: option requires an argument -- %c\n""),\n                         argv[0], c);\n#endif\n              }\n            optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented `optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          optarg = argv[optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, nextchar, nameend - nextchar))\n            {\n              if ((unsigned int) (nameend - nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                __asprintf (&buf, _(""%s: option `-W %s' is ambiguous\n""),\n                            argv[0], argv[optind]);\n\n                if (_IO_fwide (stderr, 0) > 0)\n                  __fwprintf (stderr, L""%s"", buf);\n                else\n                  fputs (buf, stderr);\n\n                free (buf);\n#else\n                fprintf (stderr, _(""%s: option `-W %s' is ambiguous\n""),\n                         argv[0], argv[optind]);\n#endif\n              }\n            nextchar += strlen (nextchar);\n            optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        __asprintf (&buf, _(""\\n%s: option `-W %s' doesn't allow an argument\n""),\n                                    argv[0], pfound->name);\n\n                        if (_IO_fwide (stderr, 0) > 0)\n                          __fwprintf (stderr, L""%s"", buf);\n                        else\n                          fputs (buf, stderr);\n\n                        free (buf);\n#else\n                        fprintf (stderr, _(""\\n%s: option `-W %s' doesn't allow an argument\n""),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    nextchar += strlen (nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (optind < argc)\n                  optarg = argv[optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        __asprintf (&buf, _(""\\n%s: option `%s' requires an argument\n""),\n                                    argv[0], argv[optind - 1]);\n\n                        if (_IO_fwide (stderr, 0) > 0)\n                          __fwprintf (stderr, L""%s"", buf);\n                        else\n                          fputs (buf, stderr);\n\n                        free (buf);\n#else\n                        fprintf (stderr,\n                                 _(""%s: option `%s' requires an argument\n""),\n                                 argv[0], argv[optind - 1]);\n#endif\n                      }\n                    nextchar += strlen (nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            nextchar += strlen (nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n          nextchar = NULL;\n          return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*nextchar != '\0')\n              {\n                optarg = nextchar;\n                optind++;\n              }\n            else\n              optarg = NULL;\n            nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*nextchar != '\0')\n              {\n                optarg = nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                optind++;\n              }\n            else if (optind == argc)\n              {\n                if (print_errors)\n                  {\n                    /* 1003.2 specifies the format of this message.  */\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    __asprintf (&buf,\n                                _(""%s: option requires an argument -- %c\n""),\n                                argv[0], c);\n\n                    if (_IO_fwide (stderr, 0) > 0)\n                      __fwprintf (stderr, L""%s"", buf);\n                    else\n                      fputs (buf, stderr);\n\n                    free (buf);\n#else\n                    fprintf (stderr,\n                             _(""%s: option requires an argument -- %c\n""),\n                             argv[0], c);\n#endif\n                  }\n                optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented `optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              optarg = argv[optind++];\n            nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}\n\nint\ngetopt (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0);\n}\n\n#endif  /* Not ELIDE_CODE.  */\n\n\n/* Compile with -DTEST to make an executable for use in testing\n   the above definition of `getopt'.  */"
kmeans/kmeans_openmp/cluster.c,"/*****************************************************************************/\n/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */\n/*By downloading, copying, installing or using the software you agree        */\n/*to this license.  If you do not agree to this license, do not download,    */\n/*install, copy or use the software.                                         */\n/*                                                                           */\n/*                                                                           */\n/*Copyright (c) 2005 Northwestern University                                 */\n/*All rights reserved.                                                       */\n\n/*Redistribution of the software in source and binary forms,                 */\n/*with or without modification, is permitted provided that the               */\n/*following conditions are met:                                              */\n/*                                                                           */\n/*1       Redistributions of source code must retain the above copyright     */\n/*        notice, this list of conditions and the following disclaimer.      */\n/*                                                                           */\n/*2       Redistributions in binary form must reproduce the above copyright   */\n/*        notice, this list of conditions and the following disclaimer in the */\n/*        documentation and/or other materials provided with the distribution.*/ \n/*                                                                            */\n/*3       Neither the name of Northwestern University nor the names of its    */\n/*        contributors may be used to endorse or promote products derived     */\n/*        from this software without specific prior written permission.       */\n/*                                                                            */\n/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */\n/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */\n/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */\n/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */\n/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */\n/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */\n/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */\n/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */\n/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */\n/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */\n/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */\n/*POSSIBILITY OF SUCH DAMAGE.                                                 */\n/******************************************************************************/\n/*************************************************************************/\n/**   File:         cluster.c                                           **/\n/**   Description:  Takes as input a file, containing 1 data point per  **/\n/**                 per line, and performs a fuzzy c-means clustering   **/\n/**                 on the data. Fuzzy clustering is performed using    **/\n/**                 min to max clusters and the clustering that gets    **/\n/**                 the best score according to a compactness and       **/\n/**                 separation criterion are returned.                  **/\n/**   Author:  Brendan McCane                                           **/\n/**            James Cook University of North Queensland.               **/\n/**            Australia. email: mccane@cs.jcu.edu.au                   **/\n/**                                                                     **/\n/**   Edited by: Jay Pisharath, Wei-keng Liao                           **/\n/**              Northwestern University.                               **/\n/**                                                                     **/\n/**   ================================================================  **/\n/**																		**/\n/**   Edited by: Sang-Ha  Lee											**/\n/**				 University of Virginia									**/\n/**																		**/\n/**   Description:	No longer supports fuzzy c-means clustering;	 	**/\n/**					only regular k-means clustering.					**/\n/**					Simplified for main functionality: regular k-means	**/\n/**					clustering.											**/\n/**                                                                     **/\n/*************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <omp.h>\n\n#include ""kmeans.h""\n\n\n/*---< cluster() >-----------------------------------------------------------*/\nint cluster(int      numObjects,      /* number of input objects */\n            int      numAttributes,   /* size of attribute of each object */\n            float  **attributes,      /* [numObjects][numAttributes] */            \n            int      nclusters,\n            float    threshold,       /* in:   */\n            float ***cluster_centres /* out: [best_nclusters][numAttributes] */\n    \n            )\n{\n    int    *membership;\n    float **tmp_cluster_centres;\n\n    membership = (int*) malloc(numObjects * sizeof(int));\n   \n    srand(7);\n	/* perform regular Kmeans */\n    tmp_cluster_centres = kmeans_clustering(attributes,\n                                            numAttributes,\n                                            numObjects,\n                                            nclusters,\n                                            threshold,\n                                            membership);      \n	\n    if (*cluster_centres) {\n		free((*cluster_centres)[0]);\n        free(*cluster_centres);\n    }\n    *cluster_centres = tmp_cluster_centres;\n\n   \n	free(membership);\n\n    return 0;\n}\n\n"
kmeans/kmeans_openmp/kmeans_clustering.c,"/*****************************************************************************/\n/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */\n/*By downloading, copying, installing or using the software you agree        */\n/*to this license.  If you do not agree to this license, do not download,    */\n/*install, copy or use the software.                                         */\n/*                                                                           */\n/*                                                                           */\n/*Copyright (c) 2005 Northwestern University                                 */\n/*All rights reserved.                                                       */\n\n/*Redistribution of the software in source and binary forms,                 */\n/*with or without modification, is permitted provided that the               */\n/*following conditions are met:                                              */\n/*                                                                           */\n/*1       Redistributions of source code must retain the above copyright     */\n/*        notice, this list of conditions and the following disclaimer.      */\n/*                                                                           */\n/*2       Redistributions in binary form must reproduce the above copyright   */\n/*        notice, this list of conditions and the following disclaimer in the */\n/*        documentation and/or other materials provided with the distribution.*/ \n/*                                                                            */\n/*3       Neither the name of Northwestern University nor the names of its    */\n/*        contributors may be used to endorse or promote products derived     */\n/*        from this software without specific prior written permission.       */\n/*                                                                            */\n/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */\n/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */\n/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */\n/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */\n/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */\n/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */\n/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */\n/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */\n/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */\n/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */\n/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */\n/*POSSIBILITY OF SUCH DAMAGE.                                                 */\n/******************************************************************************/\n/*************************************************************************/\n/**   File:         kmeans_clustering.c                                 **/\n/**   Description:  Implementation of regular k-means clustering        **/\n/**                 algorithm                                           **/\n/**   Author:  Wei-keng Liao                                            **/\n/**            ECE Department, Northwestern University                  **/\n/**            email: wkliao@ece.northwestern.edu                       **/\n/**                                                                     **/\n/**   Edited by: Jay Pisharath                                          **/\n/**              Northwestern University.                               **/\n/**                                                                     **/\n/**   ================================================================  **/\n/**																		**/\n/**   Edited by: Sang-Ha  Lee											**/\n/**				 University of Virginia									**/\n/**																		**/\n/**   Description:	No longer supports fuzzy c-means clustering;	 	**/\n/**					only regular k-means clustering.					**/\n/**					Simplified for main functionality: regular k-means	**/\n/**					clustering.											**/\n/**                                                                     **/\n/*************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n\n#define RANDOM_MAX 2147483647\n\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\n\nextern double wtime(void);\nextern int num_omp_threads;\n\nint find_nearest_point(float  *pt,          /* [nfeatures] */\n                       int     nfeatures,\n                       float **pts,         /* [npts][nfeatures] */\n                       int     npts)\n{\n    int index, i;\n    float min_dist=FLT_MAX;\n\n    /* find the cluster center id with min distance to pt */\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);  /* no need square root */\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n\n/*----< euclid_dist_2() >----------------------------------------------------*/\n/* multi-dimensional spatial Euclid distance square */\n__inline\nfloat euclid_dist_2(float *pt1,\n                    float *pt2,\n                    int    numdims)\n{\n    int i;\n    float ans=0.0;\n\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n\n    return(ans);\n}\n\n\n/*----< kmeans_clustering() >---------------------------------------------*/\nfloat** kmeans_clustering(float **feature,    /* in: [npoints][nfeatures] */\n                          int     nfeatures,\n                          int     npoints,\n                          int     nclusters,\n                          float   threshold,\n                          int    *membership) /* out: [npoints] */\n{\n\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;			/* [nclusters]: no. of points in each cluster */\n	float  **new_centers;				/* [nclusters][nfeatures] */\n	float  **clusters;					/* out: [nclusters][nfeatures] */\n    float    delta;\n        \n    double   timing;\n\n	int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n\n    nthreads = num_omp_threads; \n\n    /* allocate space for returning variable clusters[] */\n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n\n    /* randomly pick cluster centers */\n    for (i=0; i<nclusters; i++) {\n        //n = (int)rand() % npoints;\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n		n++;\n    }\n\n    for (i=0; i<npoints; i++)\n		membership[i] = -1;\n\n    /* need to initialize new_centers_len and new_centers[0] to all 0 */\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n\n\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n		partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n\n	partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n\n	for (i=0; i<nthreads; i++)\n	{\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n	}\n	printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n		omp_set_num_threads(num_omp_threads);\n		#pragma omp parallel \\n                shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();				\n            #pragma omp for \\n                        private(i,j,index) \\n                        firstprivate(npoints,nclusters,nfeatures) \\n                        schedule(static) \\n                        reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n	        /* find the index of nestest cluster centers */					\n	        index = find_nearest_point(feature[i],\n		             nfeatures,\n		             clusters,\n		             nclusters);				\n	        /* if membership changes, increase delta by 1 */\n	        if (membership[i] != index) delta += 1.0;\n\n	        /* assign the membership to object i */\n	        membership[i] = index;\n				\n	        /* update new cluster centers : sum of all objects located\n		       within */\n	        partial_new_centers_len[tid][index]++;				\n	        for (j=0; j<nfeatures; j++)\n		       partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        } /* end of #pragma omp parallel */\n\n        /* let the main thread perform the array reduction */\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i] = 0.0;\n                for (k=0; k<nfeatures; k++) {\n                    new_centers[i][k] += partial_new_centers[j][i][k];\n                    partial_new_centers[j][i][k] = 0.0;\n                }\n            }\n        }    \n\n		/* replace old cluster centers with new_centers */\n		for (i=0; i<nclusters; i++) {\n            for (j=0; j<nfeatures; j++) {\n                if (new_centers_len[i] > 0)\n					clusters[i][j] = new_centers[i][j] / new_centers_len[i];\n				new_centers[i][j] = 0.0;   /* set back to 0 */\n			}\n			new_centers_len[i] = 0;   /* set back to 0 */\n		}\n        \n    } while (delta > threshold && loop++ < 500);\n\n    \n    free(new_centers[0]);\n    free(new_centers);\n    free(new_centers_len);\n\n    return clusters;\n}\n\n"
kmeans/kmeans_serial/kmeans.c,"/*****************************************************************************/\n/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */\n/*By downloading, copying, installing or using the software you agree        */\n/*to this license.  If you do not agree to this license, do not download,    */\n/*install, copy or use the software.                                         */\n/*                                                                           */\n/*                                                                           */\n/*Copyright (c) 2005 Northwestern University                                 */\n/*All rights reserved.                                                       */\n\n/*Redistribution of the software in source and binary forms,                 */\n/*with or without modification, is permitted provided that the               */\n/*following conditions are met:                                              */\n/*                                                                           */\n/*1       Redistributions of source code must retain the above copyright     */\n/*        notice, this list of conditions and the following disclaimer.      */\n/*                                                                           */\n/*2       Redistributions in binary form must reproduce the above copyright   */\n/*        notice, this list of conditions and the following disclaimer in the */\n/*        documentation and/or other materials provided with the distribution.*/ \n/*                                                                            */\n/*3       Neither the name of Northwestern University nor the names of its    */\n/*        contributors may be used to endorse or promote products derived     */\n/*        from this software without specific prior written permission.       */\n/*                                                                            */\n/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */\n/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */\n/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */\n/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */\n/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */\n/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */\n/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */\n/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */\n/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */\n/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */\n/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */\n/*POSSIBILITY OF SUCH DAMAGE.                                                 */\n/******************************************************************************/\n/*************************************************************************/\n/**   File:         example.c                                           **/\n/**   Description:  Takes as input a file:                              **/\n/**                 ascii  file: containing 1 data point per line       **/\n/**                 binary file: first int is the number of objects     **/\n/**                              2nd int is the no. of features of each **/\n/**                              object                                 **/\n/**                 This example performs a fuzzy c-means clustering    **/\n/**                 on the data. Fuzzy clustering is performed using    **/\n/**                 min to max clusters and the clustering that gets    **/\n/**                 the best score according to a compactness and       **/\n/**                 separation criterion are returned.                  **/\n/**   Author:  Wei-keng Liao                                            **/\n/**            ECE Department Northwestern University                   **/\n/**            email: wkliao@ece.northwestern.edu                       **/\n/**                                                                     **/\n/**   Edited by: Jay Pisharath                                          **/\n/**              Northwestern University.                               **/\n/**                                                                     **/\n/**   ================================================================  **/\n/**																		**/\n/**   Edited by: Sang-Ha  Lee											**/\n/**				 University of Virginia									**/\n/**																		**/\n/**   Description:	No longer supports fuzzy c-means clustering;	 	**/\n/**					only regular k-means clustering.					**/\n/**					Simplified for main functionality: regular k-means	**/\n/**					clustering.											**/\n/**                                                                     **/\n/*************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <omp.h>\n#include ""getopt.h""\n\n#include ""kmeans.h""\n\nextern double wtime(void);\n\n/*---< usage() >------------------------------------------------------------*/\nvoid usage(char *argv0) {\n    char *help =\n        ""Usage: %s [switches] -i filename\n""\n        ""       -i filename     :  file containing data to be clustered\n""\n        ""       -b                 :input file is in binary format\n""\n		""       -k                 : number of clusters (default is 8) \n""\n        ""       -t threshold    : threshold value\n"";\n    fprintf(stderr, help, argv0);\n    exit(-1);\n}\n\n/*---< main() >-------------------------------------------------------------*/\nint main(int argc, char **argv) {\n           int     opt;\n    extern char   *optarg;\n    extern int     optind;\n           int     nclusters=5;\n           char   *filename = 0;           \n           float  *buf;\n           float **attributes;\n           float **cluster_centres=NULL;\n           int     i, j;           \n		   \n           int     numAttributes;\n           int     numObjects;           \n           char    line[1024];\n           int     isBinaryFile = 0;\n           int     nloops;\n           float   threshold = 0.001;\n		   double  timing;\n\n\n\n	while ( (opt=getopt(argc,argv,""i:k:t:b""))!= EOF) {\n        switch (opt) {\n            case 'i': filename=optarg;\n                      break;\n            case 'b': isBinaryFile = 1;\n                      break;\n            case 't': threshold=atof(optarg);\n                      break;\n            case 'k': nclusters = atoi(optarg);\n                      break;\n            case '?': usage(argv[0]);\n                      break;\n            default: usage(argv[0]);\n                      break;\n        }\n    }\n\n    if (filename == 0) usage(argv[0]);\n\n    numAttributes = numObjects = 0;\n\n    /* from the input file, get the numAttributes and numObjects ------------*/\n   \n    if (isBinaryFile) {\n        int infile;\n        if ((infile = open(filename, O_RDONLY, ""0600"")) == -1) {\n            fprintf(stderr, ""Error: no such file (%s)\n"", filename);\n            exit(1);\n        }\n        read(infile, &numObjects,    sizeof(int));\n        read(infile, &numAttributes, sizeof(int));\n   \n\n        /* allocate space for attributes[] and read attributes of all objects */\n        buf           = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        attributes    = (float**)malloc(numObjects*             sizeof(float*));\n        attributes[0] = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        for (i=1; i<numObjects; i++)\n            attributes[i] = attributes[i-1] + numAttributes;\n\n        read(infile, buf, numObjects*numAttributes*sizeof(float));\n\n        close(infile);\n    }\n    else {\n        FILE *infile;\n        if ((infile = fopen(filename, ""r"")) == NULL) {\n            fprintf(stderr, ""Error: no such file (%s)\n"", filename);\n            exit(1);\n        }\n        while (fgets(line, 1024, infile) != NULL)\n            if (strtok(line, "" \t\n"") != 0)\n                numObjects++;\n        rewind(infile);\n        while (fgets(line, 1024, infile) != NULL) {\n            if (strtok(line, "" \t\n"") != 0) {\n                /* ignore the id (first attribute): numAttributes = 1; */\n                while (strtok(NULL, "" ,\t\n"") != NULL) numAttributes++;\n                break;\n            }\n        }\n     \n\n        /* allocate space for attributes[] and read attributes of all objects */\n        buf           = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        attributes    = (float**)malloc(numObjects*             sizeof(float*));\n        attributes[0] = (float*) malloc(numObjects*numAttributes*sizeof(float));\n        for (i=1; i<numObjects; i++)\n            attributes[i] = attributes[i-1] + numAttributes;\n        rewind(infile);\n        i = 0;\n        while (fgets(line, 1024, infile) != NULL) {\n            if (strtok(line, "" \t\n"") == NULL) continue; \n            for (j=0; j<numAttributes; j++) {\n                buf[i] = atof(strtok(NULL, "" ,\t\n""));\n                i++;\n            }\n        }\n        fclose(infile);\n    }\n  \n    nloops = 1;	\n	printf(""I/O completed\n"");\n\n	memcpy(attributes[0], buf, numObjects*numAttributes*sizeof(float));\n\n	timing = omp_get_wtime();\n    for (i=0; i<nloops; i++) {\n        		\n        cluster_centres = NULL;\n        cluster(numObjects,\n                numAttributes,\n                attributes,           /* [numObjects][numAttributes] */\n                nclusters,\n                threshold,\n                &cluster_centres   \n               );\n\n     \n    }\n    timing = omp_get_wtime() - timing;\n\n	printf(""number of Clusters %d\n"",nclusters); \n	printf(""number of Attributes %d\n\n"",numAttributes); \n    /*printf(""Cluster Centers Output\n""); \n	printf(""The first number is cluster number and the following data is arribute value\n"");\n	printf(""=============================================================================\n\n"");\n	\n    for (i=0; i<nclusters; i++) {\n		printf(""%d: "", i);\n        for (j=0; j<numAttributes; j++)\n            printf(""%f "", cluster_centres[i][j]);\n        printf(""\n\n"");\n    }*/\n	printf(""Time for process: %f\n"", timing);\n\n    free(attributes);\n    free(cluster_centres[0]);\n    free(cluster_centres);\n    free(buf);\n    return(0);\n}\n\n"
kmeans/kmeans_serial/getopt.c,"/* Getopt for GNU.\n   NOTE: getopt is now part of the C library, so if you don't know what\n   ""Keep this file name-space clean"" means, talk to drepper@gnu.org\n   before changing it!\n   Copyright (C) 1987,88,89,90,91,92,93,94,95,96,98,99,2000,2001\n        Free Software Foundation, Inc.\n   This file is part of the GNU C Library.\n\n   The GNU C Library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 2.1 of the License, or (at your option) any later version.\n\n   The GNU C Library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with the GNU C Library; if not, write to the Free\n   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n   02111-1307 USA.  */\n\n/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.\n   Ditto for AIX 3.2 and <stdlib.h>.  */\n#ifndef _NO_PROTO\n# define _NO_PROTO\n#endif\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n\n#if !defined __STDC__ || !__STDC__\n/* This is a separate conditional since some stdc systems\n   reject `defined (const)'.  */\n# ifndef const\n#  define const\n# endif\n#endif\n\n#include <stdio.h>\n\n/* Comment out all this code if we are using the GNU C Library, and are not\n   actually compiling the library itself.  This code is part of the GNU C\n   Library, but also included in many other GNU distributions.  Compiling\n   and linking in this code is a waste when using the GNU C library\n   (especially if it is a shared library).  Rather than having every GNU\n   program understand `configure --with-gnu-libc' and omit the object files,\n   it is simpler to just do this in the source for each such file.  */\n\n#define GETOPT_INTERFACE_VERSION 2\n#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2\n# include <gnu-versions.h>\n# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION\n#  define ELIDE_CODE\n# endif\n#endif\n\n#ifndef ELIDE_CODE\n\n\n/* This needs to come after some library #include\n   to get __GNU_LIBRARY__ defined.  */\n#ifdef  __GNU_LIBRARY__\n/* Don't include stdlib.h for non-GNU C libraries because some of them\n   contain conflicting prototypes for getopt.  */\n# include <stdlib.h>\n# include <unistd.h>\n#endif  /* GNU C library.  */\n\n#ifdef VMS\n# include <unixlib.h>\n# if HAVE_STRING_H - 0\n#  include <string.h>\n# endif\n#endif\n\n#ifndef _\n/* This is for other GNU distributions with internationalized messages.  */\n# if (HAVE_LIBINTL_H && ENABLE_NLS) || defined _LIBC\n#  include <libintl.h>\n#  ifndef _\n#   define _(msgid)     gettext (msgid)\n#  endif\n# else\n#  define _(msgid)      (msgid)\n# endif\n# if defined _LIBC && defined USE_IN_LIBIO\n#  include <wchar.h>\n# endif\n#endif\n\n/* This version of `getopt' appears to the caller like standard Unix `getopt'\n   but it behaves differently for the user, since it allows the user\n   to intersperse the options with the other arguments.\n\n   As `getopt' works, it permutes the elements of ARGV so that,\n   when it is done, all the options precede everything else.  Thus\n   all application programs are extended to handle flexible argument order.\n\n   Setting the environment variable POSIXLY_CORRECT disables permutation.\n   Then the behavior is completely standard.\n\n   GNU application programs can use a third alternative mode in which\n   they can distinguish the relative order of options and other arguments.  */\n\n#include ""getopt.h""\n\n/* For communication from `getopt' to the caller.\n   When `getopt' finds an option that takes an argument,\n   the argument value is returned here.\n   Also, when `ordering' is RETURN_IN_ORDER,\n   each non-option ARGV-element is returned here.  */\n\nchar *optarg;\n\n/* Index in ARGV of the next element to be scanned.\n   This is used for communication to and from the caller\n   and for communication between successive calls to `getopt'.\n\n   On entry to `getopt', zero means this is the first call; initialize.\n\n   When `getopt' returns -1, this is the index of the first of the\n   non-option elements that the caller should itself scan.\n\n   Otherwise, `optind' communicates from one call to the next\n   how much of ARGV has been scanned so far.  */\n\n/* 1003.2 says this must be 1 before any call.  */\nint optind = 1;\n\n/* Formerly, initialization of getopt depended on optind==0, which\n   causes problems with re-calling getopt as programs generally don't\n   know that. */\n\nint __getopt_initialized;\n\n/* The next char to be scanned in the option-element\n   in which the last option character we returned was found.\n   This allows us to pick up the scan where we left off.\n\n   If this is zero, or a null string, it means resume the scan\n   by advancing to the next ARGV-element.  */\n\nstatic char *nextchar;\n\n/* Callers store zero here to inhibit the error message\n   for unrecognized options.  */\n\nint opterr = 1;\n\n/* Set to an option character which was unrecognized.\n   This must be initialized on some systems to avoid linking in the\n   system's own getopt implementation.  */\n\nint optopt = '?';\n\n/* Describe how to deal with options that follow non-option ARGV-elements.\n\n   If the caller did not specify anything,\n   the default is REQUIRE_ORDER if the environment variable\n   POSIXLY_CORRECT is defined, PERMUTE otherwise.\n\n   REQUIRE_ORDER means don't recognize them as options;\n   stop option processing when the first non-option is seen.\n   This is what Unix does.\n   This mode of operation is selected by either setting the environment\n   variable POSIXLY_CORRECT, or using `+' as the first character\n   of the list of option characters.\n\n   PERMUTE is the default.  We permute the contents of ARGV as we scan,\n   so that eventually all the non-options are at the end.  This allows options\n   to be given in any order, even with programs that were not written to\n   expect this.\n\n   RETURN_IN_ORDER is an option available to programs that were written\n   to expect options and other ARGV-elements in any order and that care about\n   the ordering of the two.  We describe each non-option ARGV-element\n   as if it were the argument of an option with character code 1.\n   Using `-' as the first character of the list of option characters\n   selects this mode of operation.\n\n   The special argument `--' forces an end of option-scanning regardless\n   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only\n   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */\n\nstatic enum\n{\n  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER\n} ordering;\n\n/* Value of POSIXLY_CORRECT environment variable.  */\nstatic char *posixly_correct;\n\n#ifdef  __GNU_LIBRARY__\n/* We want to avoid inclusion of string.h with non-GNU libraries\n   because there are many ways it can cause trouble.\n   On some systems, it contains special magic macros that don't work\n   in GCC.  */\n# include <string.h>\n# define my_index       strchr\n#else\n\n//# if HAVE_STRING_H || WIN32 /* Pete Wilson mod 7/28/02 */\n#  include <string.h>\n//# else\n//#  include <strings.h>\n//# endif\n\n/* Avoid depending on library functions or files\n   whose names are inconsistent.  */\n\n#ifndef getenv\nextern char *getenv ();\n#endif\n\nstatic char *\nmy_index (str, chr)\n     const char *str;\n     int chr;\n{\n  while (*str)\n    {\n      if (*str == chr)\n        return (char *) str;\n      str++;\n    }\n  return 0;\n}\n\n/* If using GCC, we can safely declare strlen this way.\n   If not using GCC, it is ok not to declare it.  */\n#ifdef __GNUC__\n/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.\n   That was relevant to code that was here before.  */\n# if (!defined __STDC__ || !__STDC__) && !defined strlen\n/* gcc with -traditional declares the built-in strlen to return int,\n   and has done so at least since version 2.4.5. -- rms.  */\nextern int strlen (const char *);\n# endif /* not __STDC__ */\n#endif /* __GNUC__ */\n\n#endif /* not __GNU_LIBRARY__ */\n\n/* Handle permutation of arguments.  */\n\n/* Describe the part of ARGV that contains non-options that have\n   been skipped.  `first_nonopt' is the index in ARGV of the first of them;\n   `last_nonopt' is the index after the last of them.  */\n\nstatic int first_nonopt;\nstatic int last_nonopt;\n\n#ifdef _LIBC\n/* Stored original parameters.\n   XXX This is no good solution.  We should rather copy the args so\n   that we can compare them later.  But we must not use malloc(3).  */\nextern int __libc_argc;\nextern char **__libc_argv;\n\n/* Bash 2.0 gives us an environment variable containing flags\n   indicating ARGV elements that should not be considered arguments.  */\n\n# ifdef USE_NONOPTION_FLAGS\n/* Defined in getopt_init.c  */\nextern char *__getopt_nonoption_flags;\n\nstatic int nonoption_flags_max_len;\nstatic int nonoption_flags_len;\n# endif\n\n# ifdef USE_NONOPTION_FLAGS\n#  define SWAP_FLAGS(ch1, ch2) \\n  if (nonoption_flags_len > 0)                                                \\n    {                                                                         \\n      char __tmp = __getopt_nonoption_flags[ch1];                             \\n      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];          \\n      __getopt_nonoption_flags[ch2] = __tmp;                                  \\n    }\n# else\n#  define SWAP_FLAGS(ch1, ch2)\n# endif\n#else   /* !_LIBC */\n# define SWAP_FLAGS(ch1, ch2)\n#endif  /* _LIBC */\n\n/* Exchange two adjacent subsequences of ARGV.\n   One subsequence is elements [first_nonopt,last_nonopt)\n   which contains all the non-options that have been skipped so far.\n   The other is elements [last_nonopt,optind), which contains all\n   the options processed since those non-options were skipped.\n\n   `first_nonopt' and `last_nonopt' are relocated so that they describe\n   the new indices of the non-options in ARGV after they are moved.  */\n\n#if defined __STDC__ && __STDC__\nstatic void exchange (char **);\n#endif\n\nstatic void\nexchange (argv)\n     char **argv;\n{\n  int bottom = first_nonopt;\n  int middle = last_nonopt;\n  int top = optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the `__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        nonoption_flags_len = nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             nonoption_flags_max_len),\n                  '\0', top + 1 - nonoption_flags_max_len);\n          nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  first_nonopt += (optind - last_nonopt);\n  last_nonopt = optind;\n}\n\n/* Initialize the internal data when the first call is made.  */\n\n#if defined __STDC__ && __STDC__\nstatic const char *_getopt_initialize (int, char *const *, const char *);\n#endif\nstatic const char *\n_getopt_initialize (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  first_nonopt = last_nonopt = optind;\n\n  nextchar = NULL;\n\n  posixly_correct = getenv (""POSIXLY_CORRECT"");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (posixly_correct != NULL)\n    ordering = REQUIRE_ORDER;\n  else\n    ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (posixly_correct == NULL\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\0')\n            nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = nonoption_flags_max_len = strlen (orig_str);\n              if (nonoption_flags_max_len < argc)\n                nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\0', nonoption_flags_max_len - len);\n            }\n        }\n      nonoption_flags_len = nonoption_flags_max_len;\n    }\n  else\n    nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}\n\n/* Scan elements of ARGV (whose length is ARGC) for option characters\n   given in OPTSTRING.\n\n   If an element of ARGV starts with '-', and is not exactly ""-"" or ""--"",\n   then it is an option element.  The characters of this element\n   (aside from the initial '-') are option characters.  If `getopt'\n   is called repeatedly, it returns successively each of the option characters\n   from each of the option elements.\n\n   If `getopt' finds another option character, it returns that character,\n   updating `optind' and `nextchar' so that the next call to `getopt' can\n   resume the scan with the following option character or ARGV-element.\n\n   If there are no more option characters, `getopt' returns -1.\n   Then `optind' is the index in ARGV of the first ARGV-element\n   that is not an option.  (The ARGV-elements have been permuted\n   so that those that are not options now come last.)\n\n   OPTSTRING is a string containing the legitimate option characters.\n   If an option character is seen that is not listed in OPTSTRING,\n   return '?' after printing an error message.  If you set `opterr' to\n   zero, the error message is suppressed but we still return '?'.\n\n   If a char in OPTSTRING is followed by a colon, that means it wants an arg,\n   so the following text in the same ARGV-element, or the text of the following\n   ARGV-element, is returned in `optarg'.  Two colons mean an option that\n   wants an optional arg; if there is text in the current ARGV-element,\n   it is returned in `optarg', otherwise `optarg' is set to zero.\n\n   If OPTSTRING starts with `-' or `+', it requests different methods of\n   handling the non-option ARGV-elements.\n   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.\n\n   Long-named options begin with `--' instead of `-'.\n   Their names may be abbreviated as long as the abbreviation is unique\n   or is an exact match for some defined option.  If they have an\n   argument, it follows the option name in the same ARGV-element, separated\n   from the option name by a `=', or else the in next ARGV-element.\n   When `getopt' finds a long-named option, it returns 0 if that option's\n   `flag' field is nonzero, the value of the option's `val' field\n   if the `flag' field is zero.\n\n   The elements of ARGV aren't really const, because we permute them.\n   But we pretend they're const in the prototype to be compatible\n   with other systems.\n\n   LONGOPTS is a vector of `struct option' terminated by an\n   element containing a name which is zero.\n\n   LONGIND returns the index in LONGOPT of the long-named option found.\n   It is only valid when a long-named option has been found by the most\n   recent call.\n\n   If LONG_ONLY is nonzero, '-' as well as '--' can introduce\n   long-named options.  */\n\nint\n_getopt_internal (argc, argv, optstring, longopts, longind, long_only)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n     const struct option *longopts;\n     int *longind;\n     int long_only;\n{\n  int print_errors = opterr;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  if (argc < 1)\n    return -1;\n\n  optarg = NULL;\n\n  if (optind == 0 || !__getopt_initialized)\n    {\n      if (optind == 0)\n        optind = 1;     /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring);\n      __getopt_initialized = 1;\n    }\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'       \\n                      || (optind < nonoption_flags_len                        \\n                          && __getopt_nonoption_flags[optind] == '1'))\n#else\n# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')\n#endif\n\n  if (nextchar == NULL || *nextchar == '\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT and LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (last_nonopt > optind)\n        last_nonopt = optind;\n      if (first_nonopt > optind)\n        first_nonopt = optind;\n\n      if (ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (first_nonopt != last_nonopt && last_nonopt != optind)\n            exchange ((char **) argv);\n          else if (last_nonopt != optind)\n            first_nonopt = optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (optind < argc && NONOPTION_P)\n            optind++;\n          last_nonopt = optind;\n        }\n\n      /* The special ARGV-element `--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (optind != argc && !strcmp (argv[optind], ""--""))\n        {\n          optind++;\n\n          if (first_nonopt != last_nonopt && last_nonopt != optind)\n            exchange ((char **) argv);\n          else if (first_nonopt == last_nonopt)\n            first_nonopt = optind;\n          last_nonopt = argc;\n\n          optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (first_nonopt != last_nonopt)\n            optind = first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (ordering == REQUIRE_ORDER)\n            return -1;\n          optarg = argv[optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      nextchar = (argv[optind] + 1\n                  + (longopts != NULL && argv[optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form ""-f"", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option ""fubar"" and\n     the ARGV-element is ""-fu"", do consider that an abbreviation of\n     the long option, just like ""--fu"", and not ""-f"" with arg ""u"".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[optind][1] == '-'\n          || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))\n    {\n      char *nameend;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      int exact = 0;\n      int ambig = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, nextchar, nameend - nextchar))\n          {\n            if ((unsigned int) (nameend - nextchar)\n                == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              /* Second or later nonexact match found.  */\n              ambig = 1;\n          }\n\n      if (ambig && !exact)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n\n              __asprintf (&buf, _(""%s: option `%s' is ambiguous\n""),\n                          argv[0], argv[optind]);\n\n              if (_IO_fwide (stderr, 0) > 0)\n                __fwprintf (stderr, L""%s"", buf);\n              else\n                fputs (buf, stderr);\n\n              free (buf);\n#else\n              fprintf (stderr, _(""%s: option `%s' is ambiguous\n""),\n                       argv[0], argv[optind]);\n#endif\n            }\n          nextchar += strlen (nextchar);\n          optind++;\n          optopt = 0;\n          return '?';\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n#endif\n\n                      if (argv[optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          __asprintf (&buf, _(""\\n%s: option `--%s' doesn't allow an argument\n""),\n                                      argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(""\\n%s: option `--%s' doesn't allow an argument\n""),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          __asprintf (&buf, _(""\\n%s: option `%c%s' doesn't allow an argument\n""),\n                                      argv[0], argv[optind - 1][0],\n                                      pfound->name);\n#else\n                          fprintf (stderr, _(""\\n%s: option `%c%s' doesn't allow an argument\n""),\n                                   argv[0], argv[optind - 1][0], pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (_IO_fwide (stderr, 0) > 0)\n                        __fwprintf (stderr, L""%s"", buf);\n                      else\n                        fputs (buf, stderr);\n\n                      free (buf);\n#endif\n                    }\n\n                  nextchar += strlen (nextchar);\n\n                  optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (optind < argc)\n                optarg = argv[optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      __asprintf (&buf,\n                                  _(""%s: option `%s' requires an argument\n""),\n                                  argv[0], argv[optind - 1]);\n\n                      if (_IO_fwide (stderr, 0) > 0)\n                        __fwprintf (stderr, L""%s"", buf);\n                      else\n                        fputs (buf, stderr);\n\n                      free (buf);\n#else\n                      fprintf (stderr,\n                               _(""%s: option `%s' requires an argument\n""),\n                               argv[0], argv[optind - 1]);\n#endif\n                    }\n                  nextchar += strlen (nextchar);\n                  optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          nextchar += strlen (nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[optind][1] == '-'\n          || my_index (optstring, *nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n#endif\n\n              if (argv[optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  __asprintf (&buf, _(""%s: unrecognized option `--%s'\n""),\n                              argv[0], nextchar);\n#else\n                  fprintf (stderr, _(""%s: unrecognized option `--%s'\n""),\n                           argv[0], nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  __asprintf (&buf, _(""%s: unrecognized option `%c%s'\n""),\n                              argv[0], argv[optind][0], nextchar);\n#else\n                  fprintf (stderr, _(""%s: unrecognized option `%c%s'\n""),\n                           argv[0], argv[optind][0], nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (_IO_fwide (stderr, 0) > 0)\n                __fwprintf (stderr, L""%s"", buf);\n              else\n                fputs (buf, stderr);\n\n              free (buf);\n#endif\n            }\n          nextchar = (char *) """";\n          optind++;\n          optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *nextchar++;\n    char *temp = my_index (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*nextchar == '\0')\n      ++optind;\n\n    if (temp == NULL || c == ':')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n#endif\n\n            if (posixly_correct)\n              {\n                /* 1003.2 specifies the format of this message.  */\n#if defined _LIBC && defined USE_IN_LIBIO\n                __asprintf (&buf, _(""%s: illegal option -- %c\n""),\n                            argv[0], c);\n#else\n                fprintf (stderr, _(""%s: illegal option -- %c\n""), argv[0], c);\n#endif\n              }\n            else\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                __asprintf (&buf, _(""%s: invalid option -- %c\n""),\n                            argv[0], c);\n#else\n                fprintf (stderr, _(""%s: invalid option -- %c\n""), argv[0], c);\n#endif\n              }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (_IO_fwide (stderr, 0) > 0)\n              __fwprintf (stderr, L""%s"", buf);\n            else\n              fputs (buf, stderr);\n\n            free (buf);\n#endif\n          }\n        optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        /* This is an option that requires an argument.  */\n        if (*nextchar != '\0')\n          {\n            optarg = nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            optind++;\n          }\n        else if (optind == argc)\n          {\n            if (print_errors)\n              {\n                /* 1003.2 specifies the format of this message.  */\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                __asprintf (&buf, _(""%s: option requires an argument -- %c\n""),\n                            argv[0], c);\n\n                if (_IO_fwide (stderr, 0) > 0)\n                  __fwprintf (stderr, L""%s"", buf);\n                else\n                  fputs (buf, stderr);\n\n                free (buf);\n#else\n                fprintf (stderr, _(""%s: option requires an argument -- %c\n""),\n                         argv[0], c);\n#endif\n              }\n            optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented `optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          optarg = argv[optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, nextchar, nameend - nextchar))\n            {\n              if ((unsigned int) (nameend - nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                __asprintf (&buf, _(""%s: option `-W %s' is ambiguous\n""),\n                            argv[0], argv[optind]);\n\n                if (_IO_fwide (stderr, 0) > 0)\n                  __fwprintf (stderr, L""%s"", buf);\n                else\n                  fputs (buf, stderr);\n\n                free (buf);\n#else\n                fprintf (stderr, _(""%s: option `-W %s' is ambiguous\n""),\n                         argv[0], argv[optind]);\n#endif\n              }\n            nextchar += strlen (nextchar);\n            optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        __asprintf (&buf, _(""\\n%s: option `-W %s' doesn't allow an argument\n""),\n                                    argv[0], pfound->name);\n\n                        if (_IO_fwide (stderr, 0) > 0)\n                          __fwprintf (stderr, L""%s"", buf);\n                        else\n                          fputs (buf, stderr);\n\n                        free (buf);\n#else\n                        fprintf (stderr, _(""\\n%s: option `-W %s' doesn't allow an argument\n""),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    nextchar += strlen (nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (optind < argc)\n                  optarg = argv[optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        __asprintf (&buf, _(""\\n%s: option `%s' requires an argument\n""),\n                                    argv[0], argv[optind - 1]);\n\n                        if (_IO_fwide (stderr, 0) > 0)\n                          __fwprintf (stderr, L""%s"", buf);\n                        else\n                          fputs (buf, stderr);\n\n                        free (buf);\n#else\n                        fprintf (stderr,\n                                 _(""%s: option `%s' requires an argument\n""),\n                                 argv[0], argv[optind - 1]);\n#endif\n                      }\n                    nextchar += strlen (nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            nextchar += strlen (nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n          nextchar = NULL;\n          return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*nextchar != '\0')\n              {\n                optarg = nextchar;\n                optind++;\n              }\n            else\n              optarg = NULL;\n            nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*nextchar != '\0')\n              {\n                optarg = nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                optind++;\n              }\n            else if (optind == argc)\n              {\n                if (print_errors)\n                  {\n                    /* 1003.2 specifies the format of this message.  */\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    __asprintf (&buf,\n                                _(""%s: option requires an argument -- %c\n""),\n                                argv[0], c);\n\n                    if (_IO_fwide (stderr, 0) > 0)\n                      __fwprintf (stderr, L""%s"", buf);\n                    else\n                      fputs (buf, stderr);\n\n                    free (buf);\n#else\n                    fprintf (stderr,\n                             _(""%s: option requires an argument -- %c\n""),\n                             argv[0], c);\n#endif\n                  }\n                optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented `optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              optarg = argv[optind++];\n            nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}\n\nint\ngetopt (argc, argv, optstring)\n     int argc;\n     char *const *argv;\n     const char *optstring;\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0);\n}\n\n#endif  /* Not ELIDE_CODE.  */\n\n\n/* Compile with -DTEST to make an executable for use in testing\n   the above definition of `getopt'.  */"
kmeans/kmeans_serial/cluster.c,"/*****************************************************************************/\n/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */\n/*By downloading, copying, installing or using the software you agree        */\n/*to this license.  If you do not agree to this license, do not download,    */\n/*install, copy or use the software.                                         */\n/*                                                                           */\n/*                                                                           */\n/*Copyright (c) 2005 Northwestern University                                 */\n/*All rights reserved.                                                       */\n\n/*Redistribution of the software in source and binary forms,                 */\n/*with or without modification, is permitted provided that the               */\n/*following conditions are met:                                              */\n/*                                                                           */\n/*1       Redistributions of source code must retain the above copyright     */\n/*        notice, this list of conditions and the following disclaimer.      */\n/*                                                                           */\n/*2       Redistributions in binary form must reproduce the above copyright   */\n/*        notice, this list of conditions and the following disclaimer in the */\n/*        documentation and/or other materials provided with the distribution.*/ \n/*                                                                            */\n/*3       Neither the name of Northwestern University nor the names of its    */\n/*        contributors may be used to endorse or promote products derived     */\n/*        from this software without specific prior written permission.       */\n/*                                                                            */\n/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */\n/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */\n/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */\n/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */\n/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */\n/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */\n/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */\n/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */\n/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */\n/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */\n/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */\n/*POSSIBILITY OF SUCH DAMAGE.                                                 */\n/******************************************************************************/\n/*************************************************************************/\n/**   File:         cluster.c                                           **/\n/**   Description:  Takes as input a file, containing 1 data point per  **/\n/**                 per line, and performs a fuzzy c-means clustering   **/\n/**                 on the data. Fuzzy clustering is performed using    **/\n/**                 min to max clusters and the clustering that gets    **/\n/**                 the best score according to a compactness and       **/\n/**                 separation criterion are returned.                  **/\n/**   Author:  Brendan McCane                                           **/\n/**            James Cook University of North Queensland.               **/\n/**            Australia. email: mccane@cs.jcu.edu.au                   **/\n/**                                                                     **/\n/**   Edited by: Jay Pisharath, Wei-keng Liao                           **/\n/**              Northwestern University.                               **/\n/**                                                                     **/\n/**   ================================================================  **/\n/**																		**/\n/**   Edited by: Sang-Ha  Lee											**/\n/**				 University of Virginia									**/\n/**																		**/\n/**   Description:	No longer supports fuzzy c-means clustering;	 	**/\n/**					only regular k-means clustering.					**/\n/**					Simplified for main functionality: regular k-means	**/\n/**					clustering.											**/\n/**                                                                     **/\n/*************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <math.h>\n#include <float.h>\n#include <omp.h>\n\n#include ""kmeans.h""\n\n/*---< cluster() >-----------------------------------------------------------*/\nint cluster(int      numObjects,      /* number of input objects */\n            int      numAttributes,   /* size of attribute of each object */\n            float  **attributes,      /* [numObjects][numAttributes] */\n            int      num_nclusters,\n            float    threshold,       /* in:   */\n            float ***cluster_centres /* out: [best_nclusters][numAttributes] */\n    \n            )\n{\n    int     nclusters;\n    int    *membership;\n    float **tmp_cluster_centres;\n\n    membership = (int*) malloc(numObjects * sizeof(int));\n\n    nclusters=num_nclusters;\n\n    srand(7);\n	\n    tmp_cluster_centres = kmeans_clustering(attributes,\n                                            numAttributes,\n                                            numObjects,\n                                            nclusters,\n                                            threshold,\n                                            membership);\n\n    if (*cluster_centres) {\n		free((*cluster_centres)[0]);\n        free(*cluster_centres);\n	}\n	*cluster_centres = tmp_cluster_centres;\n\n   \n    free(membership);\n\n    return 0;\n}\n\n"
kmeans/kmeans_serial/kmeans_clustering.c,"/*****************************************************************************/\n/*IMPORTANT:  READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.         */\n/*By downloading, copying, installing or using the software you agree        */\n/*to this license.  If you do not agree to this license, do not download,    */\n/*install, copy or use the software.                                         */\n/*                                                                           */\n/*                                                                           */\n/*Copyright (c) 2005 Northwestern University                                 */\n/*All rights reserved.                                                       */\n\n/*Redistribution of the software in source and binary forms,                 */\n/*with or without modification, is permitted provided that the               */\n/*following conditions are met:                                              */\n/*                                                                           */\n/*1       Redistributions of source code must retain the above copyright     */\n/*        notice, this list of conditions and the following disclaimer.      */\n/*                                                                           */\n/*2       Redistributions in binary form must reproduce the above copyright   */\n/*        notice, this list of conditions and the following disclaimer in the */\n/*        documentation and/or other materials provided with the distribution.*/ \n/*                                                                            */\n/*3       Neither the name of Northwestern University nor the names of its    */\n/*        contributors may be used to endorse or promote products derived     */\n/*        from this software without specific prior written permission.       */\n/*                                                                            */\n/*THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS    */\n/*IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED      */\n/*TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NON-INFRINGEMENT AND         */\n/*FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL          */\n/*NORTHWESTERN UNIVERSITY OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,       */\n/*INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES          */\n/*(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR          */\n/*SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)          */\n/*HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,         */\n/*STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN    */\n/*ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE             */\n/*POSSIBILITY OF SUCH DAMAGE.                                                 */\n/******************************************************************************/\n/*************************************************************************/\n/**   File:         kmeans_clustering.c                                 **/\n/**   Description:  Implementation of regular k-means clustering        **/\n/**                 algorithm                                           **/\n/**   Author:  Wei-keng Liao                                            **/\n/**            ECE Department, Northwestern University                  **/\n/**            email: wkliao@ece.northwestern.edu                       **/\n/**                                                                     **/\n/**   Edited by: Jay Pisharath                                          **/\n/**              Northwestern University.                               **/\n/**                                                                     **/\n/**   ================================================================  **/\n/**																		**/\n/**   Edited by: Sang-Ha  Lee											**/\n/**				 University of Virginia									**/\n/**																		**/\n/**   Description:	No longer supports fuzzy c-means clustering;	 	**/\n/**					only regular k-means clustering.					**/\n/**					Simplified for main functionality: regular k-means	**/\n/**					clustering.											**/\n/**                                                                     **/\n/*************************************************************************/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n\n#define RANDOM_MAX 2147483647\n\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\n\nextern double wtime(void);\n\nint find_nearest_point(float  *pt,          /* [nfeatures] */\n                       int     nfeatures,\n                       float **pts,         /* [npts][nfeatures] */\n                       int     npts)\n{\n    int index, i;\n    float min_dist=FLT_MAX;\n\n    /* find the cluster center id with min distance to pt */\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);  /* no need square root */\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n\n/*----< euclid_dist_2() >----------------------------------------------------*/\n/* multi-dimensional spatial Euclid distance square */\n__inline\nfloat euclid_dist_2(float *pt1,\n                    float *pt2,\n                    int    numdims)\n{\n    int i;\n    float ans=0.0;\n\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n\n    return(ans);\n}\n\n\n/*----< kmeans_clustering() >---------------------------------------------*/\nfloat** kmeans_clustering(float **feature,    /* in: [npoints][nfeatures] */\n                          int     nfeatures,\n                          int     npoints,\n                          int     nclusters,\n                          float   threshold,\n                          int    *membership) /* out: [npoints] */\n{\n\n    int      i, j, n=0, index, loop=0;\n    int     *new_centers_len; /* [nclusters]: no. of points in each cluster */\n    float    delta;\n    float  **clusters;   /* out: [nclusters][nfeatures] */\n    float  **new_centers;     /* [nclusters][nfeatures] */\n  \n\n    /* allocate space for returning variable clusters[] */\n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n\n    /* randomly pick cluster centers */\n    for (i=0; i<nclusters; i++) {\n        //n = (int)rand() % npoints;\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n		n++;\n    }\n\n    for (i=0; i<npoints; i++)\n		membership[i] = -1;\n\n    /* need to initialize new_centers_len and new_centers[0] to all 0 */\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n \n  \n    do {\n		\n        delta = 0.0;\n\n        for (i=0; i<npoints; i++) {\n	        /* find the index of nestest cluster centers */\n	        index = find_nearest_point(feature[i], nfeatures, clusters, nclusters);\n	        /* if membership changes, increase delta by 1 */\n	        if (membership[i] != index) delta += 1.0;\n\n	        /* assign the membership to object i */\n	        membership[i] = index;\n\n	        /* update new cluster centers : sum of objects located within */\n	        new_centers_len[index]++;\n	        for (j=0; j<nfeatures; j++)          \n				new_centers[index][j] += feature[i][j];\n        }\n      \n\n	/* replace old cluster centers with new_centers */\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nfeatures; j++) {\n                if (new_centers_len[i] > 0)\n					clusters[i][j] = new_centers[i][j] / new_centers_len[i];\n				new_centers[i][j] = 0.0;   /* set back to 0 */\n			}\n			new_centers_len[i] = 0;   /* set back to 0 */\n		}\n            \n        //delta /= npoints;\n    } while (delta > threshold);\n\n  \n    free(new_centers[0]);\n    free(new_centers);\n    free(new_centers_len);\n\n    return clusters;\n}\n\n"
heartwall/main.c,"//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	DEFINE / INCLUDE\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n\n#include <avilib.h>\n#include <avimod.h>\n#include <omp.h>\n\n#include ""define.c""\n#include ""kernel.c""\n\n\n//===============================================================================================================================================================================================================200\n//	WRITE DATA FUNCTION\n//===============================================================================================================================================================================================================200\n\nvoid write_data(	char* filename,\n			int frameNo,\n			int frames_processed,\n			int endoPoints,\n			int* input_a,\n			int* input_b,\n			int epiPoints,\n			int* input_2a,\n			int* input_2b){\n\n	//================================================================================80\n	//	VARIABLES\n	//================================================================================80\n\n	FILE* fid;\n	int i,j;\n	char c;\n\n	//================================================================================80\n	//	OPEN FILE FOR READING\n	//================================================================================80\n\n	fid = fopen(filename, ""w+"");\n	if( fid == NULL ){\n		printf( ""The file was not opened for writing\n"" );\n		return;\n	}\n\n\n	//================================================================================80\n	//	WRITE VALUES TO THE FILE\n	//================================================================================80\n      fprintf(fid, ""Total AVI Frames: %d\n"", frameNo);	\n      fprintf(fid, ""Frames Processed: %d\n"", frames_processed);	\n      fprintf(fid, ""endoPoints: %d\n"", endoPoints);\n      fprintf(fid, ""epiPoints: %d"", epiPoints);\n	for(j=0; j<frames_processed;j++)\n	  {\n	    fprintf(fid, ""\n---Frame %d---"",j);\n	    fprintf(fid, ""\n--endo--\n"",j);\n	    for(i=0; i<endoPoints; i++){\n	      fprintf(fid, ""%d\t"", input_a[j+i*frameNo]);\n	    }\n	    fprintf(fid, ""\n"");\n	    for(i=0; i<endoPoints; i++){\n	      // if(input_b[j*size+i] > 2000) input_b[j*size+i]=0;\n	      fprintf(fid, ""%d\t"", input_b[j+i*frameNo]);\n	    }\n	    fprintf(fid, ""\n--epi--\n"",j);\n	    for(i=0; i<epiPoints; i++){\n	      //if(input_2a[j*size_2+i] > 2000) input_2a[j*size_2+i]=0;\n	      fprintf(fid, ""%d\t"", input_2a[j+i*frameNo]);\n	    }\n	    fprintf(fid, ""\n"");\n	    for(i=0; i<epiPoints; i++){\n	      //if(input_2b[j*size_2+i] > 2000) input_2b[j*size_2+i]=0;\n	      fprintf(fid, ""%d\t"", input_2b[j+i*frameNo]);\n	    }\n	  }\n	// 	================================================================================80\n	//		CLOSE FILE\n		  //	================================================================================80\n\n	fclose(fid);\n\n}\n\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	MAIN FUNCTION\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\nint main(int argc, char *argv []){\n\n	//======================================================================================================================================================\n	//	VARIABLES\n	//======================================================================================================================================================\n\n	// counters\n	int i;\n	int frames_processed;\n\n	// parameters\n	public_struct public;\n	private_struct private[ALL_POINTS];\n\n	//======================================================================================================================================================\n	// 	FRAMES\n	//======================================================================================================================================================\n\n 	\n	\n	if(argc!=4){\n		printf(""ERROR: usage: heartwall <inputfile> <num of frames> <num of threads>\n"");\n		exit(1);\n	}\n	\n	char* video_file_name;\n	video_file_name = argv[1];\n	\n	avi_t* d_frames = (avi_t*)AVI_open_input_file(video_file_name, 1);														// added casting\n	if (d_frames == NULL)  {\n		   AVI_print_error((char *) ""Error with AVI_open_input_file"");\n		   return -1;\n	}\n\n	public.d_frames = d_frames;\n	public.frames = AVI_video_frames(public.d_frames);\n	public.frame_rows = AVI_video_height(public.d_frames);\n	public.frame_cols = AVI_video_width(public.d_frames);\n	public.frame_elem = public.frame_rows * public.frame_cols;\n	public.frame_mem = sizeof(fp) * public.frame_elem;\n\n	//======================================================================================================================================================\n	// 	CHECK INPUT ARGUMENTS\n	//======================================================================================================================================================\n\n	\n	frames_processed = atoi(argv[2]);\n	if(frames_processed<0 || frames_processed>public.frames){\n		printf(""ERROR: %d is an incorrect number of frames specified, select in the range of 0-%d\n"", frames_processed, public.frames);\n		return 0;\n	}\n	\n	int omp_num_threads;\n	omp_num_threads = atoi(argv[3]);\n	if (omp_num_threads <=0){\n	   printf (""num of threads must be a positive integer"");\n	   return 0;\n	}\n	\n	printf(""num of threads: %d\n"", omp_num_threads);\n	\n	//======================================================================================================================================================\n	//	INPUTS\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	ENDO POINTS\n	//====================================================================================================\n\n	public.endoPoints = ENDO_POINTS;\n	public.d_endo_mem = sizeof(int) * public.endoPoints;\n	public.d_endoRow = (int *)malloc(public.d_endo_mem);\n	public.d_endoRow[ 0] = 369;\n	public.d_endoRow[ 1] = 400;\n	public.d_endoRow[ 2] = 429;\n	public.d_endoRow[ 3] = 452;\n	public.d_endoRow[ 4] = 476;\n	public.d_endoRow[ 5] = 486;\n	public.d_endoRow[ 6] = 479;\n	public.d_endoRow[ 7] = 458;\n	public.d_endoRow[ 8] = 433;\n	public.d_endoRow[ 9] = 404;\n	public.d_endoRow[10] = 374;\n	public.d_endoRow[11] = 346;\n	public.d_endoRow[12] = 318;\n	public.d_endoRow[13] = 294;\n	public.d_endoRow[14] = 277;\n	public.d_endoRow[15] = 269;\n	public.d_endoRow[16] = 275;\n	public.d_endoRow[17] = 287;\n	public.d_endoRow[18] = 311;\n	public.d_endoRow[19] = 339;\n	public.d_endoCol = (int *)malloc(public.d_endo_mem);\n	public.d_endoCol[ 0] = 408;\n	public.d_endoCol[ 1] = 406;\n	public.d_endoCol[ 2] = 397;\n	public.d_endoCol[ 3] = 383;\n	public.d_endoCol[ 4] = 354;\n	public.d_endoCol[ 5] = 322;\n	public.d_endoCol[ 6] = 294;\n	public.d_endoCol[ 7] = 270;\n	public.d_endoCol[ 8] = 250;\n	public.d_endoCol[ 9] = 237;\n	public.d_endoCol[10] = 235;\n	public.d_endoCol[11] = 241;\n	public.d_endoCol[12] = 254;\n	public.d_endoCol[13] = 273;\n	public.d_endoCol[14] = 300;\n	public.d_endoCol[15] = 328;\n	public.d_endoCol[16] = 356;\n	public.d_endoCol[17] = 383;\n	public.d_endoCol[18] = 401;\n	public.d_endoCol[19] = 411;\n	public.d_tEndoRowLoc = (int *)malloc(public.d_endo_mem * public.frames);\n	public.d_tEndoColLoc = (int *)malloc(public.d_endo_mem * public.frames);\n\n	//====================================================================================================\n	//	EPI POINTS\n	//====================================================================================================\n\n	public.epiPoints = EPI_POINTS;\n	public.d_epi_mem = sizeof(int) * public.epiPoints;\n	public.d_epiRow = (int *)malloc(public.d_epi_mem);\n	public.d_epiRow[ 0] = 390;\n	public.d_epiRow[ 1] = 419;\n	public.d_epiRow[ 2] = 448;\n	public.d_epiRow[ 3] = 474;\n	public.d_epiRow[ 4] = 501;\n	public.d_epiRow[ 5] = 519;\n	public.d_epiRow[ 6] = 535;\n	public.d_epiRow[ 7] = 542;\n	public.d_epiRow[ 8] = 543;\n	public.d_epiRow[ 9] = 538;\n	public.d_epiRow[10] = 528;\n	public.d_epiRow[11] = 511;\n	public.d_epiRow[12] = 491;\n	public.d_epiRow[13] = 466;\n	public.d_epiRow[14] = 438;\n	public.d_epiRow[15] = 406;\n	public.d_epiRow[16] = 376;\n	public.d_epiRow[17] = 347;\n	public.d_epiRow[18] = 318;\n	public.d_epiRow[19] = 291;\n	public.d_epiRow[20] = 275;\n	public.d_epiRow[21] = 259;\n	public.d_epiRow[22] = 256;\n	public.d_epiRow[23] = 252;\n	public.d_epiRow[24] = 252;\n	public.d_epiRow[25] = 257;\n	public.d_epiRow[26] = 266;\n	public.d_epiRow[27] = 283;\n	public.d_epiRow[28] = 305;\n	public.d_epiRow[29] = 331;\n	public.d_epiRow[30] = 360;\n	public.d_epiCol = (int *)malloc(public.d_epi_mem);\n	public.d_epiCol[ 0] = 457;\n	public.d_epiCol[ 1] = 454;\n	public.d_epiCol[ 2] = 446;\n	public.d_epiCol[ 3] = 431;\n	public.d_epiCol[ 4] = 411;\n	public.d_epiCol[ 5] = 388;\n	public.d_epiCol[ 6] = 361;\n	public.d_epiCol[ 7] = 331;\n	public.d_epiCol[ 8] = 301;\n	public.d_epiCol[ 9] = 273;\n	public.d_epiCol[10] = 243;\n	public.d_epiCol[11] = 218;\n	public.d_epiCol[12] = 196;\n	public.d_epiCol[13] = 178;\n	public.d_epiCol[14] = 166;\n	public.d_epiCol[15] = 157;\n	public.d_epiCol[16] = 155;\n	public.d_epiCol[17] = 165;\n	public.d_epiCol[18] = 177;\n	public.d_epiCol[19] = 197;\n	public.d_epiCol[20] = 218;\n	public.d_epiCol[21] = 248;\n	public.d_epiCol[22] = 276;\n	public.d_epiCol[23] = 304;\n	public.d_epiCol[24] = 333;\n	public.d_epiCol[25] = 361;\n	public.d_epiCol[26] = 391;\n	public.d_epiCol[27] = 415;\n	public.d_epiCol[28] = 434;\n	public.d_epiCol[29] = 448;\n	public.d_epiCol[30] = 455;\n	public.d_tEpiRowLoc = (int *)malloc(public.d_epi_mem * public.frames);\n	public.d_tEpiColLoc = (int *)malloc(public.d_epi_mem * public.frames);\n\n	//====================================================================================================\n	//	ALL POINTS\n	//====================================================================================================\n\n	public.allPoints = ALL_POINTS;\n\n	//======================================================================================================================================================\n	//	CONSTANTS\n	//======================================================================================================================================================\n\n	public.tSize = 25;\n	public.sSize = 40;\n	public.maxMove = 10;\n	public.alpha = 0.87;\n\n	//======================================================================================================================================================\n	//	SUMS\n	//======================================================================================================================================================\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].in_partial_sum = (fp *)malloc(sizeof(fp) * 2*public.tSize+1);\n		private[i].in_sqr_partial_sum = (fp *)malloc(sizeof(fp) * 2*public.tSize+1);\n		private[i].par_max_val = (fp *)malloc(sizeof(fp) * (2*public.tSize+2*public.sSize+1));\n		private[i].par_max_coo = (int *)malloc(sizeof(int) * (2*public.tSize+2*public.sSize+1));\n	}\n\n	//======================================================================================================================================================\n	// 	INPUT 2 (SAMPLE AROUND POINT)\n	//======================================================================================================================================================\n\n	public.in2_rows = 2 * public.sSize + 1;\n	public.in2_cols = 2 * public.sSize + 1;\n	public.in2_elem = public.in2_rows * public.in2_cols;\n	public.in2_mem = sizeof(fp) * public.in2_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_in2 = (fp *)malloc(public.in2_mem);\n		private[i].d_in2_sqr = (fp *)malloc(public.in2_mem);\n	}\n\n	//======================================================================================================================================================\n	// 	INPUT (POINT TEMPLATE)\n	//======================================================================================================================================================\n\n	public.in_mod_rows = public.tSize+1+public.tSize;\n	public.in_mod_cols = public.in_mod_rows;\n	public.in_mod_elem = public.in_mod_rows * public.in_mod_cols;\n	public.in_mod_mem = sizeof(fp) * public.in_mod_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_in_mod = (fp *)malloc(public.in_mod_mem);\n		private[i].d_in_sqr = (fp *)malloc(public.in_mod_mem);\n	}\n\n	//======================================================================================================================================================\n	// 	ARRAY OF TEMPLATES FOR ALL POINTS\n	//======================================================================================================================================================\n\n	public.d_endoT = (fp *)malloc(public.in_mod_mem * public.endoPoints);\n	public.d_epiT = (fp *)malloc(public.in_mod_mem * public.epiPoints);\n\n	//======================================================================================================================================================\n	// 	SETUP private POINTERS TO ROWS, COLS  AND TEMPLATE\n	//======================================================================================================================================================\n\n	for(i=0; i<public.endoPoints; i++){\n		private[i].point_no = i;\n		private[i].in_pointer = private[i].point_no * public.in_mod_elem;\n		private[i].d_Row = public.d_endoRow;												// original row coordinates\n		private[i].d_Col = public.d_endoCol;													// original col coordinates\n		private[i].d_tRowLoc = public.d_tEndoRowLoc;									// updated row coordinates\n		private[i].d_tColLoc = public.d_tEndoColLoc;										// updated row coordinates\n		private[i].d_T = public.d_endoT;														// templates\n	}\n\n	for(i=public.endoPoints; i<public.allPoints; i++){\n		private[i].point_no = i-public.endoPoints;\n		private[i].in_pointer = private[i].point_no * public.in_mod_elem;\n		private[i].d_Row = public.d_epiRow;\n		private[i].d_Col = public.d_epiCol;\n		private[i].d_tRowLoc = public.d_tEpiRowLoc;\n		private[i].d_tColLoc = public.d_tEpiColLoc;\n		private[i].d_T = public.d_epiT;\n	}\n\n	//======================================================================================================================================================\n	// 	CONVOLUTION\n	//======================================================================================================================================================\n\n	public.ioffset = 0;\n	public.joffset = 0;\n	public.conv_rows = public.in_mod_rows + public.in2_rows - 1;												// number of rows in I\n	public.conv_cols = public.in_mod_cols + public.in2_cols - 1;												// number of columns in I\n	public.conv_elem = public.conv_rows * public.conv_cols;												// number of elements\n	public.conv_mem = sizeof(fp) * public.conv_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_conv = (fp *)malloc(public.conv_mem);\n	}\n\n	//======================================================================================================================================================\n	// 	CUMULATIVE SUM\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	PAD ARRAY\n	//====================================================================================================\n	//====================================================================================================\n	//	VERTICAL CUMULATIVE SUM\n	//====================================================================================================\n\n	public.in2_pad_add_rows = public.in_mod_rows;\n	public.in2_pad_add_cols = public.in_mod_cols;\n	public.in2_pad_rows = public.in2_rows + 2*public.in2_pad_add_rows;\n	public.in2_pad_cols = public.in2_cols + 2*public.in2_pad_add_cols;\n	public.in2_pad_elem = public.in2_pad_rows * public.in2_pad_cols;\n	public.in2_pad_mem = sizeof(fp) * public.in2_pad_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_in2_pad = (fp *)malloc(public.in2_pad_mem);\n	}\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION\n	//====================================================================================================\n	//====================================================================================================\n	//	HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n\n	public.in2_pad_cumv_sel_rowlow = 1 + public.in_mod_rows;													// (1 to n+1)\n	public.in2_pad_cumv_sel_rowhig = public.in2_pad_rows - 1;\n	public.in2_pad_cumv_sel_collow = 1;\n	public.in2_pad_cumv_sel_colhig = public.in2_pad_cols;\n	public.in2_pad_cumv_sel2_rowlow = 1;\n	public.in2_pad_cumv_sel2_rowhig = public.in2_pad_rows - public.in_mod_rows - 1;\n	public.in2_pad_cumv_sel2_collow = 1;\n	public.in2_pad_cumv_sel2_colhig = public.in2_pad_cols;\n	public.in2_sub_rows = public.in2_pad_cumv_sel_rowhig - public.in2_pad_cumv_sel_rowlow + 1;\n	public.in2_sub_cols = public.in2_pad_cumv_sel_colhig - public.in2_pad_cumv_sel_collow + 1;\n	public.in2_sub_elem = public.in2_sub_rows * public.in2_sub_cols;\n	public.in2_sub_mem = sizeof(fp) * public.in2_sub_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_in2_sub = (fp *)malloc(public.in2_sub_mem);\n	}\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR\n	//====================================================================================================\n\n	public.in2_sub_cumh_sel_rowlow = 1;\n	public.in2_sub_cumh_sel_rowhig = public.in2_sub_rows;\n	public.in2_sub_cumh_sel_collow = 1 + public.in_mod_cols;\n	public.in2_sub_cumh_sel_colhig = public.in2_sub_cols - 1;\n	public.in2_sub_cumh_sel2_rowlow = 1;\n	public.in2_sub_cumh_sel2_rowhig = public.in2_sub_rows;\n	public.in2_sub_cumh_sel2_collow = 1;\n	public.in2_sub_cumh_sel2_colhig = public.in2_sub_cols - public.in_mod_cols - 1;\n	public.in2_sub2_sqr_rows = public.in2_sub_cumh_sel_rowhig - public.in2_sub_cumh_sel_rowlow + 1;\n	public.in2_sub2_sqr_cols = public.in2_sub_cumh_sel_colhig - public.in2_sub_cumh_sel_collow + 1;\n	public.in2_sub2_sqr_elem = public.in2_sub2_sqr_rows * public.in2_sub2_sqr_cols;\n	public.in2_sub2_sqr_mem = sizeof(fp) * public.in2_sub2_sqr_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_in2_sub2_sqr = (fp *)malloc(public.in2_sub2_sqr_mem);\n	}\n\n	//======================================================================================================================================================\n	//	CUMULATIVE SUM 2\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	PAD ARRAY\n	//====================================================================================================\n	//====================================================================================================\n	//	VERTICAL CUMULATIVE SUM\n	//====================================================================================================\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION\n	//====================================================================================================\n	//====================================================================================================\n	//	HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION\n	//====================================================================================================\n\n	//======================================================================================================================================================\n	//	TEMPLATE MASK CREATE\n	//======================================================================================================================================================\n\n	public.tMask_rows = public.in_mod_rows + (public.sSize+1+public.sSize) - 1;\n	public.tMask_cols = public.tMask_rows;\n	public.tMask_elem = public.tMask_rows * public.tMask_cols;\n	public.tMask_mem = sizeof(fp) * public.tMask_elem;\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_tMask = (fp *)malloc(public.tMask_mem);\n	}\n\n	//======================================================================================================================================================\n	//	POINT MASK INITIALIZE\n	//======================================================================================================================================================\n\n	public.mask_rows = public.maxMove;\n	public.mask_cols = public.mask_rows;\n	public.mask_elem = public.mask_rows * public.mask_cols;\n	public.mask_mem = sizeof(fp) * public.mask_elem;\n\n	//======================================================================================================================================================\n	//	MASK CONVOLUTION\n	//======================================================================================================================================================\n\n	public.mask_conv_rows = public.tMask_rows;												// number of rows in I\n	public.mask_conv_cols = public.tMask_cols;												// number of columns in I\n	public.mask_conv_elem = public.mask_conv_rows * public.mask_conv_cols;												// number of elements\n	public.mask_conv_mem = sizeof(fp) * public.mask_conv_elem;\n	public.mask_conv_ioffset = (public.mask_rows-1)/2;\n	if((public.mask_rows-1) % 2 > 0.5){\n		public.mask_conv_ioffset = public.mask_conv_ioffset + 1;\n	}\n	public.mask_conv_joffset = (public.mask_cols-1)/2;\n	if((public.mask_cols-1) % 2 > 0.5){\n		public.mask_conv_joffset = public.mask_conv_joffset + 1;\n	}\n\n	for(i=0; i<public.allPoints; i++){\n		private[i].d_mask_conv = (fp *)malloc(public.mask_conv_mem);\n	}\n\n	//======================================================================================================================================================\n	//	PRINT FRAME PROGRESS START\n	//======================================================================================================================================================\n\n	printf(""frame progress: "");\n	fflush(NULL);\n\n	//======================================================================================================================================================\n	//	KERNEL\n	//======================================================================================================================================================\n\n	for(public.frame_no=0; public.frame_no<frames_processed; public.frame_no++){\n\n	//====================================================================================================\n	//	GETTING FRAME\n	//====================================================================================================\n\n		// Extract a cropped version of the first frame from the video file\n		public.d_frame = get_frame(public.d_frames,				// pointer to video file\n													public.frame_no,				// number of frame that needs to be returned\n													0,										// cropped?\n													0,										// scaled?\n													1);									// converted\n\n	//====================================================================================================\n	//	PROCESSING\n	//====================================================================================================\n\n		omp_set_num_threads(omp_num_threads);\n		\n\n		#pragma omp parallel for\n		for(i=0; i<public.allPoints; i++){\n			kernel(	public,\n						private[i]);\n		}\n\n	//====================================================================================================\n	//	FREE MEMORY FOR FRAME\n	//====================================================================================================\n\n		// free frame after each loop iteration, since AVI library allocates memory for every frame fetched\n		free(public.d_frame);\n\n	//====================================================================================================\n	//	PRINT FRAME PROGRESS\n	//====================================================================================================\n\n		printf(""%d "", public.frame_no);\n		fflush(NULL);\n\n	}\n\n	//======================================================================================================================================================\n	//	PRINT FRAME PROGRESS END\n	//======================================================================================================================================================\n\n	printf(""\n"");\n	fflush(NULL);\n\n	//======================================================================================================================================================\n	//	DEALLOCATION\n	//======================================================================================================================================================\n\n	//==================================================50\n	//	DUMP DATA TO FILE\n	//==================================================50\n#ifdef OUTPUT\n	write_data(	""result.txt"",\n			public.frames,\n			frames_processed,		\n				public.endoPoints,\n				public.d_tEndoRowLoc,\n				public.d_tEndoColLoc,\n				public.epiPoints,\n				public.d_tEpiRowLoc,\n				public.d_tEpiColLoc);\n\n#endif\n\n\n\n	//====================================================================================================\n	//	COMMON\n	//====================================================================================================\n\n	free(public.d_endoRow);\n	free(public.d_endoCol);\n	free(public.d_tEndoRowLoc);\n	free(public.d_tEndoColLoc);\n	free(public.d_endoT);\n\n	free(public.d_epiRow);\n	free(public.d_epiCol);\n	free(public.d_tEpiRowLoc);\n	free(public.d_tEpiColLoc);\n	free(public.d_epiT);\n\n	//====================================================================================================\n	//	POINTERS\n	//====================================================================================================\n\n	for(i=0; i<public.allPoints; i++){\n		free(private[i].in_partial_sum);\n		free(private[i].in_sqr_partial_sum);\n		free(private[i].par_max_val);\n		free(private[i].par_max_coo);\n\n		free(private[i].d_in2);\n		free(private[i].d_in2_sqr);\n\n		free(private[i].d_in_mod);\n		free(private[i].d_in_sqr);\n\n		free(private[i].d_conv);\n\n		free(private[i].d_in2_pad);\n\n		free(private[i].d_in2_sub);\n\n		free(private[i].d_in2_sub2_sqr);\n\n		free(private[i].d_tMask);\n		free(private[i].d_mask_conv);\n	}\n\n}\n\n//========================================================================================================================================================================================================\n//========================================================================================================================================================================================================\n//	END OF FILE\n//========================================================================================================================================================================================================\n//========================================================================================================================================================================================================\n"
heartwall/kernel.c,"//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	KERNEL FUNCTION\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\nvoid kernel(public_struct public,\n				private_struct private){\n\n	//======================================================================================================================================================\n	//	COMMON VARIABLES\n	//======================================================================================================================================================\n\n	int ei_new;\n	fp* d_in;\n	int rot_row;\n	int rot_col;\n	int in2_rowlow;\n	int in2_collow;\n	int ic;\n	int jc;\n	int jp1;\n	int ja1, ja2;\n	int ip1;\n	int ia1, ia2;\n	int ja, jb;\n	int ia, ib;\n	fp s;\n	int i;\n	int j;\n	int row;\n	int col;\n	int ori_row;\n	int ori_col;\n	int position;\n	fp sum;\n	int pos_ori;\n	fp temp;\n	fp temp2;\n	int location;\n	int cent;\n	int tMask_row; \n	int tMask_col;\n	fp largest_value_current = 0;\n	fp largest_value = 0;\n	int largest_coordinate_current = 0;\n	int largest_coordinate = 0;\n	fp fin_max_val = 0;\n	int fin_max_coo = 0;\n	int largest_row;\n	int largest_col;\n	int offset_row;\n	int offset_col;\n	fp in_final_sum;\n	fp in_sqr_final_sum;\n	fp mean;\n	fp mean_sqr;\n	fp variance;\n	fp deviation;\n	fp denomT;\n	int pointer;\n	int ori_pointer;\n	int loc_pointer;\n	int ei_mod;\n\n	//======================================================================================================================================================\n	//	GENERATE TEMPLATE\n	//======================================================================================================================================================\n\n	// generate templates based on the first frame only\n	if(public.frame_no == 0){\n\n		// update temporary row/col coordinates\n		pointer = private.point_no*public.frames+public.frame_no;\n		private.d_tRowLoc[pointer] = private.d_Row[private.point_no];\n		private.d_tColLoc[pointer] = private.d_Col[private.point_no];\n\n		// pointers to: current frame, template for current point\n		d_in = &private.d_T[private.in_pointer];\n\n		// update template, limit the number of working threads to the size of template\n		for(col=0; col<public.in_mod_cols; col++){\n			for(row=0; row<public.in_mod_rows; row++){\n\n				// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)\n				ori_row = private.d_Row[private.point_no] - 25 + row - 1;\n				ori_col = private.d_Col[private.point_no] - 25 + col - 1;\n				ori_pointer = ori_col*public.frame_rows+ori_row;\n\n				// update template\n				d_in[col*public.in_mod_rows+row] = public.d_frame[ori_pointer];\n\n			}\n		}\n\n	}\n\n	//======================================================================================================================================================\n	//	PROCESS POINTS\n	//======================================================================================================================================================\n\n	// process points in all frames except for the first one\n	if(public.frame_no != 0){\n\n		//====================================================================================================\n		//	INPUTS\n		//====================================================================================================\n\n		//==================================================\n		//	1) SETUP POINTER TO POINT TO CURRENT FRAME FROM BATCH\n		//	2) SELECT INPUT 2 (SAMPLE AROUND POINT) FROM FRAME			SAVE IN d_in2			(NOT LINEAR IN MEMORY, SO NEED TO SAVE OUTPUT FOR LATER EASY USE)\n		//	3) SQUARE INPUT 2									SAVE IN d_in2_sqr\n		//==================================================\n\n		// pointers and variables\n		in2_rowlow = private.d_Row[private.point_no] - public.sSize;							// (1 to n+1)\n		in2_collow = private.d_Col[private.point_no] - public.sSize;\n\n		// work\n		for(col=0; col<public.in2_cols; col++){\n			for(row=0; row<public.in2_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + in2_rowlow - 1;\n			ori_col = col + in2_collow - 1;\n			temp = public.d_frame[ori_col*public.frame_rows+ori_row];\n			private.d_in2[col*public.in2_rows+row] = temp;\n			private.d_in2_sqr[col*public.in2_rows+row] = temp*temp;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET POINTER TO INPUT 1 (TEMPLATE FOR THIS POINT) IN TEMPLATE ARRAY				(LINEAR IN MEMORY, SO DONT NEED TO SAVE, JUST GET POINTER)\n		//	2) ROTATE INPUT 1									SAVE IN d_in_mod\n		//	3) SQUARE INPUT 1									SAVE IN d_in_sqr\n		//==================================================\n\n		// variables\n		d_in = &private.d_T[private.in_pointer];\n\n		// work\n		for(col=0; col<public.in_mod_cols; col++){\n			for(row=0; row<public.in_mod_rows; row++){\n\n			// rotated coordinates\n			rot_row = (public.in_mod_rows-1) - row;\n			rot_col = (public.in_mod_rows-1) - col;\n			pointer = rot_col*public.in_mod_rows+rot_row;\n\n			// execution\n			temp = d_in[pointer];\n			private.d_in_mod[col*public.in_mod_rows+row] = temp;\n			private.d_in_sqr[pointer] = temp * temp;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET SUM OF INPUT 1\n		//	2) GET SUM OF INPUT 1 SQUARED\n		//==================================================\n\n		in_final_sum = 0;\n		for(i = 0; i<public.in_mod_elem; i++){\n			in_final_sum = in_final_sum + d_in[i];\n		}\n\n		in_sqr_final_sum = 0;\n		for(i = 0; i<public.in_mod_elem; i++){\n			in_sqr_final_sum = in_sqr_final_sum + private.d_in_sqr[i];\n		}\n\n		//==================================================\n		//	3) DO STATISTICAL CALCULATIONS\n		//	4) GET DENOMINATOR T\n		//==================================================\n\n		mean = in_final_sum / public.in_mod_elem;													// gets mean (average) value of element in ROI\n		mean_sqr = mean * mean;\n		variance  = (in_sqr_final_sum / public.in_mod_elem) - mean_sqr;							// gets variance of ROI\n		deviation = sqrt(variance);																// gets standard deviation of ROI\n\n		denomT = sqrt((fp)(public.in_mod_elem-1))*deviation;\n\n		//====================================================================================================\n		//	1) CONVOLVE INPUT 2 WITH ROTATED INPUT 1					SAVE IN d_conv\n		//====================================================================================================\n\n		// work\n		for(col=1; col<=public.conv_cols; col++){\n\n			// column setup\n			j = col + public.joffset;\n			jp1 = j + 1;\n			if(public.in2_cols < jp1){\n				ja1 = jp1 - public.in2_cols;\n			}\n			else{\n				ja1 = 1;\n			}\n			if(public.in_mod_cols < j){\n				ja2 = public.in_mod_cols;\n			}\n			else{\n				ja2 = j;\n			}\n\n			for(row=1; row<=public.conv_rows; row++){\n\n				// row range setup\n				i = row + public.ioffset;\n				ip1 = i + 1;\n				\n				if(public.in2_rows < ip1){\n					ia1 = ip1 - public.in2_rows;\n				}\n				else{\n					ia1 = 1;\n				}\n				if(public.in_mod_rows < i){\n					ia2 = public.in_mod_rows;\n				}\n				else{\n					ia2 = i;\n				}\n\n				s = 0;\n\n				// getting data\n				for(ja=ja1; ja<=ja2; ja++){\n					jb = jp1 - ja;\n					for(ia=ia1; ia<=ia2; ia++){\n						ib = ip1 - ia;\n						s = s + private.d_in_mod[public.in_mod_rows*(ja-1)+ia-1] * private.d_in2[public.in2_rows*(jb-1)+ib-1];\n					}\n				}\n\n				private.d_conv[(col-1)*public.conv_rows+(row-1)] = s;\n\n		}\n	}\n		//====================================================================================================\n		//	LOCAL SUM 1\n		//====================================================================================================\n\n		//==================================================\n		//	1) PADD ARRAY										SAVE IN d_in2_pad\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_pad_cols; col++){\n			for(row=0; row<public.in2_pad_rows; row++){\n\n			// execution\n			if(	row > (public.in2_pad_add_rows-1) &&														// do if has numbers in original array\n				row < (public.in2_pad_add_rows+public.in2_rows) && \n				col > (public.in2_pad_add_cols-1) && \n				col < (public.in2_pad_add_cols+public.in2_cols)){\n				ori_row = row - public.in2_pad_add_rows;\n				ori_col = col - public.in2_pad_add_cols;\n				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2[ori_col*public.in2_rows+ori_row];\n			}\n			else{																			// do if otherwise\n				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;\n			}\n\n			}\n		}\n\n		//==================================================\n		//	1) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad\n		//==================================================\n\n		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){\n\n			// figure out column position\n			pos_ori = ei_new*public.in2_pad_rows;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){\n				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n				sum = private.d_in2_pad[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_sub_cols; col++){\n			for(row=0; row<public.in2_sub_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel_collow - 1;\n			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;\n			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// subtraction\n			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub\n		//==================================================\n\n		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){\n\n			// figure out row position\n			pos_ori = ei_new;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){\n				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;\n				sum = private.d_in2_sub[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 1\n		//	4) GET CUMULATIVE SUM 1 SQUARED						SAVE IN d_in2_sub2_sqr\n		//	5) GET NUMERATOR									SAVE IN d_conv\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_sub2_sqr_cols; col++){\n			for(row=0; row<public.in2_sub2_sqr_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel_collow - 1;\n			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;\n			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n			\n			// subtraction\n			temp2 = temp - temp2;\n\n			// squaring\n			private.d_in2_sub2_sqr[col*public.in2_sub2_sqr_rows+row] = temp2 * temp2; \n\n			// numerator\n			private.d_conv[col*public.in2_sub2_sqr_rows+row] = private.d_conv[col*public.in2_sub2_sqr_rows+row] - temp2 * in_final_sum / public.in_mod_elem;\n\n			}\n		}\n\n		//====================================================================================================\n		//	LOCAL SUM 2\n		//====================================================================================================\n\n		//==================================================\n		//	1) PAD ARRAY										SAVE IN d_in2_pad\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_pad_cols; col++){\n			for(row=0; row<public.in2_pad_rows; row++){\n\n			// execution\n			if(	row > (public.in2_pad_add_rows-1) &&													// do if has numbers in original array\n				row < (public.in2_pad_add_rows+public.in2_rows) && \n				col > (public.in2_pad_add_cols-1) && \n				col < (public.in2_pad_add_cols+public.in2_cols)){\n				ori_row = row - public.in2_pad_add_rows;\n				ori_col = col - public.in2_pad_add_cols;\n				private.d_in2_pad[col*public.in2_pad_rows+row] = private.d_in2_sqr[ori_col*public.in2_rows+ori_row];\n			}\n			else{																							// do if otherwise\n				private.d_in2_pad[col*public.in2_pad_rows+row] = 0;\n			}\n\n			}\n		}\n\n		//==================================================\n		//	2) GET VERTICAL CUMULATIVE SUM						SAVE IN d_in2_pad\n		//==================================================\n\n		//work\n		for(ei_new = 0; ei_new < public.in2_pad_cols; ei_new++){\n\n			// figure out column position\n			pos_ori = ei_new*public.in2_pad_rows;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_pad_rows; position = position + 1){\n				private.d_in2_pad[position] = private.d_in2_pad[position] + sum;\n				sum = private.d_in2_pad[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM VERTICAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS						SAVE IN d_in2_sub\n		//==================================================\n\n		// work\n		for(col=0; col<public.in2_sub_cols; col++){\n			for(row=0; row<public.in2_sub_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel_collow - 1;\n			temp = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_pad_cumv_sel2_rowlow - 1;\n			ori_col = col + public.in2_pad_cumv_sel2_collow - 1;\n			temp2 = private.d_in2_pad[ori_col*public.in2_pad_rows+ori_row];\n\n			// subtract\n			private.d_in2_sub[col*public.in2_sub_rows+row] = temp - temp2;\n\n			}\n		}\n\n		//==================================================\n		//	1) GET HORIZONTAL CUMULATIVE SUM						SAVE IN d_in2_sub\n		//==================================================\n\n		for(ei_new = 0; ei_new < public.in2_sub_rows; ei_new++){\n\n			// figure out row position\n			pos_ori = ei_new;\n\n			// loop through all rows\n			sum = 0;\n			for(position = pos_ori; position < pos_ori+public.in2_sub_elem; position = position + public.in2_sub_rows){\n				private.d_in2_sub[position] = private.d_in2_sub[position] + sum;\n				sum = private.d_in2_sub[position];\n			}\n\n		}\n\n		//==================================================\n		//	1) MAKE 1st SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	2) MAKE 2nd SELECTION FROM HORIZONTAL CUMULATIVE SUM\n		//	3) SUBTRACT THE TWO SELECTIONS TO GET LOCAL SUM 2\n		//	4) GET DIFFERENTIAL LOCAL SUM\n		//	5) GET DENOMINATOR A\n		//	6) GET DENOMINATOR\n		//	7) DIVIDE NUMBERATOR BY DENOMINATOR TO GET CORRELATION	SAVE IN d_conv\n		//==================================================\n\n		// work\n		for(col=0; col<public.conv_cols; col++){\n			for(row=0; row<public.conv_rows; row++){\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel_collow - 1;\n			temp = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n\n			// figure out corresponding location in old matrix and copy values to new matrix\n			ori_row = row + public.in2_sub_cumh_sel2_rowlow - 1;\n			ori_col = col + public.in2_sub_cumh_sel2_collow - 1;\n			temp2 = private.d_in2_sub[ori_col*public.in2_sub_rows+ori_row];\n\n			// subtract\n			temp2 = temp - temp2;\n\n			// diff_local_sums\n			temp2 = temp2 - (private.d_in2_sub2_sqr[col*public.conv_rows+row] / public.in_mod_elem);\n\n			// denominator A\n			if(temp2 < 0){\n				temp2 = 0;\n			}\n			temp2 = sqrt(temp2);\n\n			// denominator\n			temp2 = denomT * temp2;\n			\n			// correlation\n			private.d_conv[col*public.conv_rows+row] = private.d_conv[col*public.conv_rows+row] / temp2;\n\n			}\n		}\n\n		//====================================================================================================\n		//	TEMPLATE MASK CREATE\n		//====================================================================================================\n\n		// parameters\n		cent = public.sSize + public.tSize + 1;\n		pointer = public.frame_no-1+private.point_no*public.frames;\n		tMask_row = cent + private.d_tRowLoc[pointer] - private.d_Row[private.point_no] - 1;\n		tMask_col = cent + private.d_tColLoc[pointer] - private.d_Col[private.point_no] - 1;\n\n		//work\n		for(ei_new = 0; ei_new < public.tMask_elem; ei_new++){\n			private.d_tMask[ei_new] = 0;\n		}\n		private.d_tMask[tMask_col*public.tMask_rows + tMask_row] = 1;\n\n\n		//====================================================================================================\n		//	1) MASK CONVOLUTION\n		//	2) MULTIPLICATION\n		//====================================================================================================\n\n		// work\n		// for(col=1; col<=public.conv_cols; col++){\n		for(col=1; col<=public.mask_conv_cols; col++){\n\n			// col setup\n			j = col + public.mask_conv_joffset;\n			jp1 = j + 1;\n			if(public.mask_cols < jp1){\n				ja1 = jp1 - public.mask_cols;\n			}\n			else{\n				ja1 = 1;\n			}\n			if(public.tMask_cols < j){\n				ja2 = public.tMask_cols;\n			}\n			else{\n				ja2 = j;\n			}\n\n			// for(row=1; row<=public.conv_rows; row++){\n			for(row=1; row<=public.mask_conv_rows; row++){\n\n				// row setup\n				i = row + public.mask_conv_ioffset;\n				ip1 = i + 1;\n				\n				if(public.mask_rows < ip1){\n					ia1 = ip1 - public.mask_rows;\n				}\n				else{\n					ia1 = 1;\n				}\n				if(public.tMask_rows < i){\n					ia2 = public.tMask_rows;\n				}\n				else{\n					ia2 = i;\n				}\n\n				s = 0;\n\n				// get data\n				for(ja=ja1; ja<=ja2; ja++){\n					jb = jp1 - ja;\n					for(ia=ia1; ia<=ia2; ia++){\n						ib = ip1 - ia;\n						s = s + private.d_tMask[public.tMask_rows*(ja-1)+ia-1] * 1;\n					}\n				}\n\n				private.d_mask_conv[(col-1)*public.conv_rows+(row-1)] = private.d_conv[(col-1)*public.conv_rows+(row-1)] * s;\n\n			}\n\n		}\n\n		//====================================================================================================\n		//	MAXIMUM VALUE\n		//====================================================================================================\n\n		//==================================================\n		//	SEARCH\n		//==================================================\n\n		fin_max_val = 0;\n		fin_max_coo = 0;\n		for(i=0; i<public.mask_conv_elem; i++){\n			if(private.d_mask_conv[i]>fin_max_val){\n				fin_max_val = private.d_mask_conv[i];\n				fin_max_coo = i;\n			}\n		}\n\n		//==================================================\n		//	OFFSET\n		//==================================================\n\n		// convert coordinate to row/col form\n		largest_row = (fin_max_coo+1) % public.mask_conv_rows - 1;											// (0-n) row\n		largest_col = (fin_max_coo+1) / public.mask_conv_rows;												// (0-n) column\n		if((fin_max_coo+1) % public.mask_conv_rows == 0){\n			largest_row = public.mask_conv_rows - 1;\n			largest_col = largest_col - 1;\n		}\n\n		// calculate offset\n		largest_row = largest_row + 1;																	// compensate to match MATLAB format (1-n)\n		largest_col = largest_col + 1;																	// compensate to match MATLAB format (1-n)\n		offset_row = largest_row - public.in_mod_rows - (public.sSize - public.tSize);\n		offset_col = largest_col - public.in_mod_cols - (public.sSize - public.tSize);\n		pointer = private.point_no*public.frames+public.frame_no;\n		private.d_tRowLoc[pointer] = private.d_Row[private.point_no] + offset_row;\n		private.d_tColLoc[pointer] = private.d_Col[private.point_no] + offset_col;\n\n	}\n\n	//======================================================================================================================================================\n	//	COORDINATE AND TEMPLATE UPDATE\n	//======================================================================================================================================================\n\n	// if the last frame in the bath, update template\n	if(public.frame_no != 0 && (public.frame_no)%10 == 0){\n\n		// update coordinate\n		loc_pointer = private.point_no*public.frames+public.frame_no;\n		private.d_Row[private.point_no] = private.d_tRowLoc[loc_pointer];\n		private.d_Col[private.point_no] = private.d_tColLoc[loc_pointer];\n\n		// update template, limit the number of working threads to the size of template\n		for(col=0; col<public.in_mod_cols; col++){\n			for(row=0; row<public.in_mod_rows; row++){\n\n			// figure out row/col location in corresponding new template area in image and give to every thread (get top left corner and progress down and right)\n			ori_row = private.d_Row[private.point_no] - 25 + row - 1;\n			ori_col = private.d_Col[private.point_no] - 25 + col - 1;\n			ori_pointer = ori_col*public.frame_rows+ori_row;\n\n			// update template\n			d_in[col*public.in_mod_rows+row] = public.alpha*d_in[col*public.in_mod_rows+row] + (1.00-public.alpha)*public.d_frame[ori_pointer];\n\n			}\n		}\n\n	}\n\n}\n\n	//===============================================================================================================================================================================================================\n	//===============================================================================================================================================================================================================\n	//	END OF FUNCTION\n	//===============================================================================================================================================================================================================\n	//===============================================================================================================================================================================================================\n"
heartwall/define.c,"//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	DEFINE / INCLUDE\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\n#define fp float\n#define ENDO_POINTS 20\n#define EPI_POINTS 31\n#define ALL_POINTS 51\n\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	PUBLIC_STRUCT\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\ntypedef struct public_struct{\n\n	//======================================================================================================================================================\n	//	WHAT USED TO BE INPUTS FROM MATLAB\n	//======================================================================================================================================================\n\n	int tSize;\n	int sSize;\n	int maxMove;\n	fp alpha;\n\n	int endoPoints;\n	int d_endo_mem;\n	int* d_endoRow;\n	int* d_endoCol;\n	int* d_tEndoRowLoc;\n	int* d_tEndoColLoc;\n	fp* d_endoT;\n\n	int epiPoints;\n	int d_epi_mem;\n	int* d_epiRow;\n	int* d_epiCol;\n	int* d_tEpiRowLoc;\n	int* d_tEpiColLoc;\n	fp* d_epiT;\n\n	int allPoints;\n\n	//======================================================================================================================================================\n	//	FRAME\n	//======================================================================================================================================================\n\n	avi_t* d_frames;\n	int frames;\n	int frame_no;\n	fp* d_frame;\n	int frame_rows;\n	int frame_cols;\n	int frame_elem;\n	int frame_mem;\n\n	//======================================================================================================================================================\n	// 	INPUT 2\n	//======================================================================================================================================================\n\n	int in2_rows;\n	int in2_cols;\n	int in2_elem;\n	int in2_mem;\n\n	//======================================================================================================================================================\n	//	INPUT\n	//======================================================================================================================================================\n\n	int in_mod_rows;\n	int in_mod_cols;\n	int in_mod_elem;\n	int in_mod_mem;\n\n	//======================================================================================================================================================\n	//	CONVOLUTION\n	//======================================================================================================================================================\n\n	int ioffset;\n	int joffset;\n\n	int conv_rows;\n	int conv_cols;\n	int conv_elem;\n	int conv_mem;\n\n	//======================================================================================================================================================\n	//	CUMULATIVE SUM 1\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	PAD ARRAY\n	//====================================================================================================\n	//====================================================================================================\n	//	VERTICAL CUMULATIVE SUM\n	//====================================================================================================\n\n	int in2_pad_add_rows;\n	int in2_pad_add_cols;\n\n	int in2_pad_rows;\n	int in2_pad_cols;\n	int in2_pad_elem;\n	int in2_pad_mem;\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n	//====================================================================================================\n	//	HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n\n	int in2_pad_cumv_sel_rowlow;\n	int in2_pad_cumv_sel_rowhig;\n	int in2_pad_cumv_sel_collow;\n	int in2_pad_cumv_sel_colhig;\n\n	int in2_pad_cumv_sel2_rowlow;\n	int in2_pad_cumv_sel2_rowhig;\n	int in2_pad_cumv_sel2_collow;\n	int in2_pad_cumv_sel2_colhig;\n\n	int in2_sub_rows;\n	int in2_sub_cols;\n	int in2_sub_elem;\n	int in2_sub_mem;\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR\n	//====================================================================================================\n\n	int in2_sub_cumh_sel_rowlow;\n	int in2_sub_cumh_sel_rowhig;\n	int in2_sub_cumh_sel_collow;\n	int in2_sub_cumh_sel_colhig;\n\n	int in2_sub_cumh_sel2_rowlow;\n	int in2_sub_cumh_sel2_rowhig;\n	int in2_sub_cumh_sel2_collow;\n	int in2_sub_cumh_sel2_colhig;\n\n	int in2_sub2_sqr_rows;\n	int in2_sub2_sqr_cols;\n	int in2_sub2_sqr_elem;\n	int in2_sub2_sqr_mem;\n\n	//======================================================================================================================================================\n	//	CUMULATIVE SUM 2\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	PAD ARRAY\n	//====================================================================================================\n	//====================================================================================================\n	//	VERTICAL CUMULATIVE SUM\n	//====================================================================================================\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION\n	//====================================================================================================\n	//====================================================================================================\n	//	HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION\n	//====================================================================================================\n\n	//======================================================================================================================================================\n	//	TEMPLATE MASK CREATE\n	//======================================================================================================================================================\n\n	int tMask_rows;\n	int tMask_cols;\n	int tMask_elem;\n	int tMask_mem;\n\n	//======================================================================================================================================================\n	//	POINT MASK INITIALIZE\n	//======================================================================================================================================================\n\n	int mask_rows;\n	int mask_cols;\n	int mask_elem;\n	int mask_mem;\n\n	//======================================================================================================================================================\n	//	MASK CONVOLUTION\n	//======================================================================================================================================================\n\n	int mask_conv_rows;\n	int mask_conv_cols;\n	int mask_conv_elem;\n	int mask_conv_mem;\n	int mask_conv_ioffset;\n	int mask_conv_joffset;\n\n}public_struct;\n\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	PRIVATE_STRUCT\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n\ntypedef struct private_struct{\n\n	//======================================================================================================================================================\n	//	POINT-SPECIFIC\n	//======================================================================================================================================================\n\n	int point_no;\n	int in_pointer;\n\n	int* d_Row;\n	int* d_Col;\n	int* d_tRowLoc;\n	int* d_tColLoc;\n	fp* d_T;\n\n	//======================================================================================================================================================\n	// 	INPUT 2\n	//======================================================================================================================================================\n\n	fp* d_in2;\n	fp* d_in2_sqr;\n\n	//======================================================================================================================================================\n	//	INPUT\n	//======================================================================================================================================================\n\n	fp* d_in_mod;\n	fp* d_in_sqr;\n\n	//======================================================================================================================================================\n	//	CONVOLUTION\n	//======================================================================================================================================================\n\n	fp* d_conv;\n\n	//======================================================================================================================================================\n	//	CUMULATIVE SUM 1\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	PAD ARRAY\n	//====================================================================================================\n	//====================================================================================================\n	//	VERTICAL CUMULATIVE SUM\n	//====================================================================================================\n\n	fp* d_in2_pad;\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n	//====================================================================================================\n	//	HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n\n	fp* d_in2_sub;\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, SQUARE, NUMERATOR\n	//====================================================================================================\n\n	fp* d_in2_sub2_sqr;\n\n	//======================================================================================================================================================\n	//	CUMULATIVE SUM 2\n	//======================================================================================================================================================\n\n	//====================================================================================================\n	//	PAD ARRAY\n	//====================================================================================================\n	//====================================================================================================\n	//	VERTICAL CUMULATIVE SUM\n	//====================================================================================================\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION\n	//====================================================================================================\n	//====================================================================================================\n	//	HORIZONTAL CUMULATIVE SUM\n	//====================================================================================================\n\n	//====================================================================================================\n	//	SELECTION, SELECTION 2, SUBTRACTION, DIFFERENTIAL LOCAL SUM, DENOMINATOR A, DENOMINATOR, CORRELATION\n	//====================================================================================================\n\n	//======================================================================================================================================================\n	//	TEMPLATE MASK CREATE\n	//======================================================================================================================================================\n\n	fp* d_tMask;\n\n	//======================================================================================================================================================\n	//	POINT MASK INITIALIZE\n	//======================================================================================================================================================\n\n	//======================================================================================================================================================\n	//	MASK CONVOLUTION\n	//======================================================================================================================================================\n\n	fp* d_mask_conv;\n\n	//======================================================================================================================================================\n	//	SUM\n	//======================================================================================================================================================\n\n	fp* in_partial_sum;\n	fp* in_sqr_partial_sum;\n	fp* par_max_val;\n	int* par_max_coo;\n\n} private_struct;\n\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n//	END OF STRUCTURE\n//===============================================================================================================================================================================================================\n//===============================================================================================================================================================================================================\n"
heartwall/AVI/avimod.c,"// #ifdef __cplusplus\n// extern ""C"" {\n// #endif\n\n//===============================================================================================================================================================================================================\n//	DEFINE / INCLUDE\n//===============================================================================================================================================================================================================\n#include ""avimod.h""\n\n//===============================================================================================================================================================================================================\n//	FUNCTIONS\n//===============================================================================================================================================================================================================\n\n// Flips the specified image and crops it to the specified dimensions\n// If scaled == true, all values are scaled to the range [0.0, 1.0\nfp* chop_flip_image(	char *image, \n								int height, \n								int width, \n								int cropped,\n								int scaled,\n								int converted) {\n\n	// fixed dimensions for cropping or not cropping, square vertices starting from initial point in top left corner going down and right\n	int top;\n	int bottom;\n	int left;\n	int right;\n	if(cropped==1){\n		top = 0;\n		bottom = 0;\n		left = 0;\n		right = 0;\n	}\n	else{\n		top = 0;\n		bottom = height - 1;\n		left = 0;\n		right = width - 1;\n	}\n\n	// dimensions of new cropped image\n	int height_new = bottom - top + 1;\n	int width_new = right - left + 1;\n\n	// counters\n	int i, j;\n\n	// allocate memory for cropped/flipped frame\n	fp* result = (fp *) malloc(height_new * width_new * sizeof(fp));\n\n	// crop/flip and scale frame\n	fp temp;\n	if (scaled) {\n		fp scale = 1.0 / 255.0;\n		for(i = 0; i <height_new; i++){				// rows\n			for(j = 0; j <width_new; j++){			// colums\n				temp = (fp) image[((height - 1 - (i + top)) * width) + (j + left)] * scale;\n				if(temp<0){\n					result[i*width_new+j] = temp + 256;\n				}\n				else{\n					result[i*width_new+j] = temp;\n				}\n			}\n		}\n	} else {\n		for(i = 0; i <height_new; i++){				// rows\n			for(j = 0; j <width_new; j++){			// colums\n				temp = (fp) image[((height - 1 - (i + top)) * width) + (j + left)] ;\n				if(temp<0){\n					result[i*width_new+j] = temp + 256;\n				}\n				else{\n					result[i*width_new+j] = temp;\n				}\n			}\n		}\n	}\n\n// convert storage method (from row-major to column-major)\n	fp* result_converted = (fp *) malloc(height_new * width_new * sizeof(fp));\n	if(converted==1){\n		for(i = 0; i <width_new; i++){				// rows\n			for(j = 0; j <height_new; j++){			// colums\n				result_converted[i*height_new+j] = result[j*width_new+i];\n			}\n		}\n	}\n	else{\n		result_converted = result;\n	}\n	free(result);\n\n	// return\n	return result_converted;\n}\n\n// Returns the specified frame from the specified video file\n// If cropped == true, the frame is cropped to pre-determined dimensions\n//  (hardcoded to the boundaries of the blood vessel in the test video)\n// If scaled == true, all values are scaled to the range [0.0, 1.0]\nfp* get_frame(	avi_t* cell_file, \n						int frame_num, \n						int cropped, \n						int scaled,\n						int converted) {\n\n	// variable\n	int dummy;\n	int width = AVI_video_width(cell_file);\n	int height = AVI_video_height(cell_file);\n	int status;\n\n	// There are 600 frames in this file (i.e. frame_num = 600 causes an error)\n	AVI_set_video_position(cell_file, frame_num);\n\n	//Read in the frame from the AVI\n	char* image_buf = (char*) malloc(width * height * sizeof(char));\n	status = AVI_read_frame(cell_file, image_buf, &dummy);\n	if(status == -1) {\n		AVI_print_error((char*) ""Error with AVI_read_frame"");\n		exit(-1);\n	}\n\n	// The image is read in upside-down, so we need to flip it\n	fp* image_chopped;\n	image_chopped = chop_flip_image(	image_buf, \n														height, \n														width, \n														cropped,\n														scaled,\n														converted);\n\n	// free image buffer\n	free(image_buf);\n\n	// return\n	return image_chopped;\n\n} \n\n// #ifdef __cplusplus\n// }\n// #endif\n"
heartwall/AVI/avilib.c,"#ifdef __cplusplus\nextern ""C"" {\n#endif\n\n/*\n *  avilib.c\n *\n *  Copyright (C) Thomas streich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas streich \n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de> \n *\n *  This file is part of transcode, a linux video stream processing tool\n *      \n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *   \n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *   \n *  You should have received a copy of the GNU General Public License\n *  along with GNU Make; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. \n *\n */\n\n#include ""avilib.h""\n//#include <time.h>\n\n#define INFO_LIST\n\n/* The following variable indicates the kind of error */\n\nlong AVI_errno;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n#ifndef PACKAGE\n	#define PACKAGE ""my""\n	#define VERSION ""0.00""\n#endif\n\n#ifndef O_BINARY\n	/* win32 wants a binary flag to open(); this sets it to null\n	   on platforms that don't have it. */\n	#define O_BINARY 0\n#endif\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic size_t avi_read(int fd, char *buf, size_t len)\n{\n   size_t n = 0;\n   size_t r = 0;\n\n   while (r < len) {\n      n = read (fd, buf + r, len - r);\n\n      if (n <= 0)\n	  return r;\n      r += n;\n   }\n\n   return r;\n}\n\nstatic size_t avi_write (int fd, char *buf, size_t len)\n{\n   size_t n = 0;\n   size_t r = 0;\n\n   while (r < len) {\n      n = write (fd, buf + r, len - r);\n      if (n < 0)\n         return n;\n      \n      r += n;\n   }\n   return r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, int n)\n{\n   dst[0] = (n    )&0xff;\n   dst[1] = (n>> 8)&0xff;\n   dst[2] = (n>>16)&0xff;\n   dst[3] = (n>>24)&0xff;\n}\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic unsigned long str2ulong(unsigned char *str)\n{\n   return ( str[0] | (str[1]<<8) | (str[2]<<16) | (str[3]<<24) );\n}\nstatic unsigned long str2ushort(unsigned char *str)\n{\n   return ( str[0] | (str[1]<<8) );\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n   int s;\n   s = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n   //   if(s==0) s=1; /* avoid possible zero divisions */\n   if(s<4) s=4; /* avoid possible zero divisions */ \n   return s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, int length)\n{\n   unsigned char c[8];\n\n   /* Copy tag and length int c, so that we need only 1 write system call\n      for these two values */\n\n   memcpy(c,tag,4);\n   long2str(c+4,length);\n\n   /* Output tag, length and data, restore previous position\n      if the write fails */\n\n   length = PAD_EVEN(length);\n\n   if( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n       avi_write(AVI->fdes,(char *)data,length) != length )\n   {\n      lseek(AVI->fdes,AVI->pos,SEEK_SET);\n      AVI_errno = AVI_ERR_WRITE;\n      return -1;\n   }\n\n   /* Update file position */\n\n   AVI->pos += 8 + length;\n\n   //fprintf(stderr, ""pos=%lu %s\n"", AVI->pos, tag);\n\n   return 0;\n}\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, long flags, unsigned long pos, unsigned long len)\n{\n   void *ptr;\n\n   if(AVI->n_idx>=AVI->max_idx) {\n     ptr = realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n     \n     if(ptr == 0) {\n       AVI_errno = AVI_ERR_NO_MEM;\n       return -1;\n     }\n     AVI->max_idx += 4096;\n     AVI->idx = (unsigned char((*)[16]) ) ptr;\n   }\n   \n   /* Add index entry */\n\n   //   fprintf(stderr, ""INDEX %s %ld %lu %lu\n"", tag, flags, pos, len);\n\n   memcpy(AVI->idx[AVI->n_idx],tag,4);\n   long2str(AVI->idx[AVI->n_idx]+ 4,flags);\n   long2str(AVI->idx[AVI->n_idx]+ 8, pos);\n   long2str(AVI->idx[AVI->n_idx]+12, len);\n   \n   /* Update counter */\n\n   AVI->n_idx++;\n\n   if(len>AVI->max_len) AVI->max_len=len;\n\n   return 0;\n}\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\navi_t* AVI_open_output_file(char * filename)\n{\n   avi_t *AVI;\n   int i;\n\n   int mask = 0;\n   \n   unsigned char AVI_header[HEADERBYTES];\n\n   /* Allocate the avi_t struct and zero it */\n\n   AVI = (avi_t *) malloc(sizeof(avi_t));\n   if(AVI==0)\n   {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n   }\n   memset((void *)AVI,0,sizeof(avi_t));\n\n   /* Since Linux needs a long time when deleting big files,\n      we do not truncate the file when we open it.\n      Instead it is truncated when the AVI file is closed */\n\n  /* mask = umask (0);\n   umask (mask);*/\n\n   AVI->fdes = open(filename, O_RDWR|O_CREAT|O_BINARY, 0644 &~ mask);\n   if (AVI->fdes < 0)\n   {\n      AVI_errno = AVI_ERR_OPEN;\n      free(AVI);\n      return 0;\n   }\n\n   /* Write out HEADERBYTES bytes, the header will go here\n      when we are finished with writing */\n\n   for (i=0;i<HEADERBYTES;i++) AVI_header[i] = 0;\n   i = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n   if (i != HEADERBYTES)\n   {\n      close(AVI->fdes);\n      AVI_errno = AVI_ERR_WRITE;\n      free(AVI);\n      return 0;\n   }\n\n   AVI->pos  = HEADERBYTES;\n   AVI->mode = AVI_MODE_WRITE; /* open for writing */\n\n   //init\n   AVI->anum = 0;\n   AVI->aptr = 0;\n\n   return AVI;\n}\n\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n   /* may only be called if file is open for writing */\n\n   if(AVI->mode==AVI_MODE_READ) return;\n\n   AVI->width  = width;\n   AVI->height = height;\n   AVI->fps    = fps;\n   \n   if(strncmp(compressor, ""RGB"", 3)==0) {\n     memset(AVI->compressor, 0, 4);\n   } else {\n     memcpy(AVI->compressor,compressor,4);\n   }     \n   \n   AVI->compressor[4] = 0;\n\n   avi_update_header(AVI);\n}\n\nvoid AVI_set_audio(avi_t *AVI, int channels, long rate, int bits, int format, long mp3rate)\n{\n   /* may only be called if file is open for writing */\n\n   if(AVI->mode==AVI_MODE_READ) return;\n\n   //inc audio tracks\n   AVI->aptr=AVI->anum;\n   ++AVI->anum;\n\n   if(AVI->anum > AVI_MAX_TRACKS) {\n     fprintf(stderr, ""error - only %d audio tracks supported\n"", AVI_MAX_TRACKS);\n     exit(1);\n   }\n\n   AVI->track[AVI->aptr].a_chans = channels;\n   AVI->track[AVI->aptr].a_rate  = rate;\n   AVI->track[AVI->aptr].a_bits  = bits;\n   AVI->track[AVI->aptr].a_fmt   = format;\n   AVI->track[AVI->aptr].mp3rate = mp3rate;\n\n   avi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); nhb += 4\n\n#define OUTLONG(n) \\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb,n); nhb += 4\n\n#define OUTSHRT(n) \\n   if(nhb<=HEADERBYTES-2) { \\n      AVI_header[nhb  ] = (n   )&0xff; \\n      AVI_header[nhb+1] = (n>>8)&0xff; \\n   } \\n   nhb += 2\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n   int njunk, sampsize, hasIndex, ms_per_frame, frate, flag;\n   int movi_len, hdrl_start, strl_start, j;\n   unsigned char AVI_header[HEADERBYTES];\n   long nhb;\n\n   //assume max size\n   movi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n   //assume index will be written\n   hasIndex=1;\n\n   if(AVI->fps < 0.001) {\n     frate=0;\n     ms_per_frame=0;\n   } else {\n     frate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n     ms_per_frame=(int) (1000000/AVI->fps + 0.5);\n   }\n\n   /* Prepare the file header */\n\n   nhb = 0;\n\n   /* The RIFF header */\n\n   OUT4CC (""RIFF"");\n   OUTLONG(movi_len);    // assume max size\n   OUT4CC (""AVI "");\n\n   /* Start the header list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   hdrl_start = nhb;  /* Store start position */\n   OUT4CC (""hdrl"");\n\n   /* The main AVI header */\n\n   /* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n   OUT4CC (""avih"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUTLONG(ms_per_frame);       /* Microseconds per frame */\n   //ThOe ->0 \n   //   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n   OUTLONG(0);\n   OUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n                                /* Other sources call it 'reserved' */\n   flag = AVIF_ISINTERLEAVED;\n   if(hasIndex) flag |= AVIF_HASINDEX;\n   if(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n   OUTLONG(flag);               /* Flags */\n   OUTLONG(0);                  // no frames yet\n   OUTLONG(0);                  /* InitialFrames */\n\n   OUTLONG(AVI->anum+1);\n\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n                                /* MS calls the following 'reserved': */\n   OUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n   OUTLONG(0);                  /* DataRate:   Data rate of playback     */\n   OUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n   OUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n   /* Start the video stream list ---------------------------------- */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   strl_start = nhb;  /* Store start position */\n   OUT4CC (""strl"");\n\n   /* The video stream header */\n\n   OUT4CC (""strh"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUT4CC (""vids"");             /* Type */\n   OUT4CC (AVI->compressor);    /* Handler */\n   OUTLONG(0);                  /* Flags */\n   OUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n   OUTLONG(0);                  /* InitialFrames */\n   OUTLONG(FRAME_RATE_SCALE);              /* Scale */\n   OUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n   OUTLONG(0);                  /* Start */\n   OUTLONG(0);                  // no frames yet\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(-1);                 /* Quality */\n   OUTLONG(0);                  /* SampleSize */\n   OUTLONG(0);                  /* Frame */\n   OUTLONG(0);                  /* Frame */\n   //   OUTLONG(0);                  /* Frame */\n   //OUTLONG(0);                  /* Frame */\n\n   /* The video stream format */\n\n   OUT4CC (""strf"");\n   OUTLONG(40);                 /* # of bytes to follow */\n   OUTLONG(40);                 /* Size */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n   OUTSHRT(1); OUTSHRT(24);     /* Planes, Count */\n   OUT4CC (AVI->compressor);    /* Compression */\n   // ThOe (*3)\n   OUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n   OUTLONG(0);                  /* XPelsPerMeter */\n   OUTLONG(0);                  /* YPelsPerMeter */\n   OUTLONG(0);                  /* ClrUsed: Number of colors used */\n   OUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n   /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n   long2str(AVI_header+strl_start-4,nhb-strl_start);\n\n   \n   /* Start the audio stream list ---------------------------------- */\n   \n   for(j=0; j<AVI->anum; ++j) {\n       \n       sampsize = avi_sampsize(AVI, j);\n   \n       OUT4CC (""LIST"");\n       OUTLONG(0);        /* Length of list in bytes, don't know yet */\n       strl_start = nhb;  /* Store start position */\n       OUT4CC (""strl"");\n       \n       /* The audio stream header */\n       \n       OUT4CC (""strh"");\n       OUTLONG(56);            /* # of bytes to follow */\n       OUT4CC (""auds"");\n       \n       // -----------\n       // ThOe\n       OUTLONG(0);             /* Format (Optionally) */\n       // -----------\n       \n       OUTLONG(0);             /* Flags */\n       OUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n       OUTLONG(0);             /* InitialFrames */\n       \n       // ThOe /4\n       OUTLONG(sampsize/4);      /* Scale */\n       OUTLONG(1000*AVI->track[j].mp3rate/8);\n       OUTLONG(0);             /* Start */\n       OUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n       OUTLONG(0);             /* SuggestedBufferSize */\n       OUTLONG(-1);            /* Quality */\n       \n       // ThOe /4\n       OUTLONG(sampsize/4);    /* SampleSize */\n       \n       OUTLONG(0);             /* Frame */\n       OUTLONG(0);             /* Frame */\n       //       OUTLONG(0);             /* Frame */\n       //OUTLONG(0);             /* Frame */\n       \n       /* The audio stream format */\n       \n       OUT4CC (""strf"");\n       OUTLONG(16);                   /* # of bytes to follow */\n       OUTSHRT(AVI->track[j].a_fmt);           /* Format */\n       OUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n       OUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n       // ThOe\n       OUTLONG(1000*AVI->track[j].mp3rate/8);\n       //ThOe (/4)\n       \n       OUTSHRT(sampsize/4);           /* BlockAlign */\n       \n       \n       OUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n       \n       /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n       \n       long2str(AVI_header+strl_start-4,nhb-strl_start);\n   }\n   \n   /* Finish header list */\n   \n   long2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n   \n   \n   /* Calculate the needed amount of junk bytes, output junk */\n   \n   njunk = HEADERBYTES - nhb - 8 - 12;\n   \n   /* Safety first: if njunk <= 0, somebody has played with\n      HEADERBYTES without knowing what (s)he did.\n      This is a fatal error */\n   \n   if(njunk<=0)\n     {\n       fprintf(stderr,""AVI_close_output_file: # of header bytes too small\n"");\n       exit(1);\n     }\n   \n   OUT4CC (""JUNK"");\n   OUTLONG(njunk);\n   memset(AVI_header+nhb,0,njunk);\n   \n   //11/14/01 added id string \n\n   if(njunk > strlen(id_str)+8) {\n     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);\n     memcpy(AVI_header+nhb, id_str, strlen(id_str));\n   }\n   \n   nhb += njunk;\n\n   /* Start the movi list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(movi_len); /* Length of list in bytes */\n   OUT4CC (""movi"");\n\n   /* Output the header, truncate the file to the number of bytes\n      actually written, report an error if someting goes wrong */\n\n   if ( lseek(AVI->fdes,0,SEEK_SET)<0 ||\n        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n	lseek(AVI->fdes,AVI->pos,SEEK_SET)<0)\n     {\n       AVI_errno = AVI_ERR_CLOSE;\n       return -1;\n     }\n\n   return 0;\n}\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\n   int ret, njunk, sampsize, hasIndex, ms_per_frame, frate, idxerror, flag;\n   unsigned long movi_len;\n   int hdrl_start, strl_start, j;\n   unsigned char AVI_header[HEADERBYTES];\n   long nhb;\n\n#ifdef INFO_LIST\n   long info_len;\n//   time_t calptr;\n#endif\n\n   /* Calculate length of movi list */\n\n   movi_len = AVI->pos - HEADERBYTES + 4;\n\n   /* Try to ouput the index entries. This may fail e.g. if no space\n      is left on device. We will report this as an error, but we still\n      try to write the header correctly (so that the file still may be\n      readable in the most cases */\n\n   idxerror = 0;\n   //   fprintf(stderr, ""pos=%lu, index_len=%ld             \n"", AVI->pos, AVI->n_idx*16);\n   ret = avi_add_chunk(AVI, (unsigned char *)""idx1"", (unsigned char *)((void*)AVI->idx), AVI->n_idx*16);\n   hasIndex = (ret==0);\n   //fprintf(stderr, ""pos=%lu, index_len=%d\n"", AVI->pos, hasIndex);\n\n   if(ret) {\n     idxerror = 1;\n     AVI_errno = AVI_ERR_WRITE_INDEX;\n   }\n   \n   /* Calculate Microseconds per frame */\n\n   if(AVI->fps < 0.001) {\n     frate=0;\n     ms_per_frame=0;\n   } else {\n     frate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n     ms_per_frame=(int) (1000000/AVI->fps + 0.5);\n   }\n\n   /* Prepare the file header */\n\n   nhb = 0;\n\n   /* The RIFF header */\n\n   OUT4CC (""RIFF"");\n   OUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n   OUT4CC (""AVI "");\n\n   /* Start the header list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   hdrl_start = nhb;  /* Store start position */\n   OUT4CC (""hdrl"");\n\n   /* The main AVI header */\n\n   /* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n   OUT4CC (""avih"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUTLONG(ms_per_frame);       /* Microseconds per frame */\n   //ThOe ->0 \n   //   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n   OUTLONG(0);\n   OUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n                                /* Other sources call it 'reserved' */\n   flag = AVIF_ISINTERLEAVED;\n   if(hasIndex) flag |= AVIF_HASINDEX;\n   if(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n   OUTLONG(flag);               /* Flags */\n   OUTLONG(AVI->video_frames);  /* TotalFrames */\n   OUTLONG(0);                  /* InitialFrames */\n\n   OUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n                                /* MS calls the following 'reserved': */\n   OUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n   OUTLONG(0);                  /* DataRate:   Data rate of playback     */\n   OUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n   OUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n   /* Start the video stream list ---------------------------------- */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   strl_start = nhb;  /* Store start position */\n   OUT4CC (""strl"");\n\n   /* The video stream header */\n\n   OUT4CC (""strh"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUT4CC (""vids"");             /* Type */\n   OUT4CC (AVI->compressor);    /* Handler */\n   OUTLONG(0);                  /* Flags */\n   OUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n   OUTLONG(0);                  /* InitialFrames */\n   OUTLONG(FRAME_RATE_SCALE);              /* Scale */\n   OUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n   OUTLONG(0);                  /* Start */\n   OUTLONG(AVI->video_frames);  /* Length */\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(-1);                 /* Quality */\n   OUTLONG(0);                  /* SampleSize */\n   OUTLONG(0);                  /* Frame */\n   OUTLONG(0);                  /* Frame */\n   //   OUTLONG(0);                  /* Frame */\n   //OUTLONG(0);                  /* Frame */\n\n   /* The video stream format */\n\n   OUT4CC (""strf"");\n   OUTLONG(40);                 /* # of bytes to follow */\n   OUTLONG(40);                 /* Size */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n   OUTSHRT(1); OUTSHRT(24);     /* Planes, Count */\n   OUT4CC (AVI->compressor);    /* Compression */\n   // ThOe (*3)\n   OUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n   OUTLONG(0);                  /* XPelsPerMeter */\n   OUTLONG(0);                  /* YPelsPerMeter */\n   OUTLONG(0);                  /* ClrUsed: Number of colors used */\n   OUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n   /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n   long2str(AVI_header+strl_start-4,nhb-strl_start);\n\n   /* Start the audio stream list ---------------------------------- */\n\n   for(j=0; j<AVI->anum; ++j) {\n     \n     //if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n       {\n	   \n	 sampsize = avi_sampsize(AVI, j);\n	   \n	 OUT4CC (""LIST"");\n	 OUTLONG(0);        /* Length of list in bytes, don't know yet */\n	 strl_start = nhb;  /* Store start position */\n	 OUT4CC (""strl"");\n	   \n	 /* The audio stream header */\n	 \n	 OUT4CC (""strh"");\n	 OUTLONG(56);            /* # of bytes to follow */\n	 OUT4CC (""auds"");\n	 \n	 // -----------\n	 // ThOe\n	 OUTLONG(0);             /* Format (Optionally) */\n	   // -----------\n	   \n	 OUTLONG(0);             /* Flags */\n	 OUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n	 OUTLONG(0);             /* InitialFrames */\n	   \n	 // ThOe /4\n	 OUTLONG(sampsize/4);      /* Scale */\n	 OUTLONG(1000*AVI->track[j].mp3rate/8);\n	 OUTLONG(0);             /* Start */\n	 OUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n	 OUTLONG(0);             /* SuggestedBufferSize */\n	 OUTLONG(-1);            /* Quality */\n	   \n	 // ThOe /4\n	 OUTLONG(sampsize/4);    /* SampleSize */\n	   \n	 OUTLONG(0);             /* Frame */\n	 OUTLONG(0);             /* Frame */\n	 //	 OUTLONG(0);             /* Frame */\n	 //OUTLONG(0);             /* Frame */\n	   \n	 /* The audio stream format */\n	 \n	 OUT4CC (""strf"");\n	 OUTLONG(16);                   /* # of bytes to follow */\n	 OUTSHRT(AVI->track[j].a_fmt);           /* Format */\n	 OUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n	 OUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n	 // ThOe\n	 OUTLONG(1000*AVI->track[j].mp3rate/8);\n	 //ThOe (/4)\n	 \n	 OUTSHRT(sampsize/4);           /* BlockAlign */\n	 \n	 \n	 OUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n	 \n	 /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n       }\n       long2str(AVI_header+strl_start-4,nhb-strl_start);\n   }\n   \n   /* Finish header list */\n   \n   long2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n   // add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n   OUT4CC (""LIST"");\n   \n   //FIXME\n   info_len = MAX_INFO_STRLEN + 12;\n   OUTLONG(info_len);\n   OUT4CC (""INFO"");\n\n//   OUT4CC (""INAM"");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   sprintf(id_str, ""\t"");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, strlen(id_str));\n//   nhb += MAX_INFO_STRLEN;\n\n   OUT4CC (""ISFT"");\n   OUTLONG(MAX_INFO_STRLEN);\n\n   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);\n   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n   memcpy(AVI_header+nhb, id_str, strlen(id_str));\n   nhb += MAX_INFO_STRLEN;\n\n//   OUT4CC (""ICMT"");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL); \n//   sprintf(id_str, ""\t%s %s"", ctime(&calptr), """");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n   // ----------------------------\n   \n   /* Calculate the needed amount of junk bytes, output junk */\n   \n   njunk = HEADERBYTES - nhb - 8 - 12;\n   \n   /* Safety first: if njunk <= 0, somebody has played with\n      HEADERBYTES without knowing what (s)he did.\n      This is a fatal error */\n   \n   if(njunk<=0)\n   {\n      fprintf(stderr,""AVI_close_output_file: # of header bytes too small\n"");\n      exit(1);\n   }\n\n   OUT4CC (""JUNK"");\n   OUTLONG(njunk);\n   memset(AVI_header+nhb,0,njunk);\n   \n   nhb += njunk;\n\n   /* Start the movi list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(movi_len); /* Length of list in bytes */\n   OUT4CC (""movi"");\n\n   /* Output the header, truncate the file to the number of bytes\n      actually written, report an error if someting goes wrong */\n\n   if ( lseek(AVI->fdes,0,SEEK_SET)<0 ||\n        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES \n        //|| ftruncate(AVI->fdes,AVI->pos)<0 \n        )\n   {\n      AVI_errno = AVI_ERR_CLOSE;\n      return -1;\n   }\n\n   if(idxerror) return -1;\n\n   return 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned long length, int audio, int keyframe)\n{\n   int n;\n\n   unsigned char astr[5];\n\n   /* Check for maximum file length */\n   \n   if ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n     AVI_errno = AVI_ERR_SIZELIM;\n     return -1;\n   }\n   \n   /* Add index entry */\n\n   //set tag for current audio track\n   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);\n\n   if(audio)\n     n = avi_add_index_entry(AVI,astr,0x00,AVI->pos,length);\n   else\n     n = avi_add_index_entry(AVI,(unsigned char *) ""00db"",((keyframe)?0x10:0x0),AVI->pos,length);\n   \n   if(n) return -1;\n   \n   /* Output tag and data */\n   \n   if(audio)\n     n = avi_add_chunk(AVI,(unsigned char *) astr, (unsigned char *)data,length);\n   else\n     n = avi_add_chunk(AVI,(unsigned char *)""00db"",(unsigned char *)data,length);\n   \n   if (n) return -1;\n   \n   return 0;\n}\n\nint AVI_write_frame(avi_t *AVI, char *data, long bytes, int keyframe)\n{\n  unsigned long pos;\n  \n  if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  \n  pos = AVI->pos;\n\n  if(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n   \n  AVI->last_pos = pos;\n  AVI->last_len = bytes;\n  AVI->video_frames++;\n  return 0;\n}\n\nint AVI_dup_frame(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   if(AVI->last_pos==0) return 0; /* No previous real frame */\n   if(avi_add_index_entry(AVI,(unsigned char *)""00db"",0x10,AVI->last_pos,AVI->last_len)) return -1;\n   AVI->video_frames++;\n   AVI->must_use_index = 1;\n   return 0;\n}\n\nint AVI_write_audio(avi_t *AVI, char *data, long bytes)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   if( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n   AVI->track[AVI->aptr].audio_bytes += bytes;\n   return 0;\n}\n\n\nint AVI_append_audio(avi_t *AVI, char *data, long bytes)\n{\n\n  long i, length, pos;\n  unsigned char c[4];\n\n  if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  \n  // update last index entry:\n  \n  --AVI->n_idx;\n  length = str2ulong(AVI->idx[AVI->n_idx]+12);\n  pos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n  //update;\n  long2str(AVI->idx[AVI->n_idx]+12,length+bytes);   \n\n  ++AVI->n_idx;\n\n  AVI->track[AVI->aptr].audio_bytes += bytes;\n\n  //update chunk header\n  lseek(AVI->fdes, pos+4, SEEK_SET);\n  long2str(c, length+bytes);     \n  avi_write(AVI->fdes,(char *) c, 4);\n\n  lseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n  i=PAD_EVEN(length + bytes);\n\n  bytes = i - length;\n  avi_write(AVI->fdes, data, bytes);\n  AVI->pos = pos + 8 + i;\n\n  return 0;\n}\n\n\nlong AVI_bytes_remain(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) return 0;\n\n   return ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nlong AVI_bytes_written(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) return 0;\n\n   return (AVI->pos + 8 + 16*AVI->n_idx);\n}\n\nint AVI_set_audio_track(avi_t *AVI, int track)\n{\n  \n  if(track < 0 || track + 1 > AVI->anum) return(-1);\n\n  //this info is not written to file anyway\n  AVI->aptr=track;\n  return 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n    return(AVI->aptr);\n}\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nint AVI_close(avi_t *AVI)\n{\n   int ret;\n\n   /* If the file was open for writing, the header and index still have\n      to be written */\n\n   if(AVI->mode == AVI_MODE_WRITE)\n      ret = avi_close_output_file(AVI);\n   else\n      ret = 0;\n\n   /* Even if there happened an error, we first clean up */\n\n   close(AVI->fdes);\n   if(AVI->idx) free(AVI->idx);\n   if(AVI->video_index) free(AVI->video_index);\n   //FIXME\n   //if(AVI->audio_index) free(AVI->audio_index);\n   free(AVI);\n\n   return ret;\n}\n\n\n#define ERR_EXIT(x) \\n{ \\n   AVI_close(AVI); \\n   AVI_errno = x; \\n   return 0; \\n}\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n  avi_t *AVI=NULL;\n  \n  /* Create avi_t structure */\n  \n  AVI = (avi_t *) malloc(sizeof(avi_t));\n  if(AVI==NULL)\n    {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n    }\n  memset((void *)AVI,0,sizeof(avi_t));\n  \n  AVI->mode = AVI_MODE_READ; /* open for reading */\n  \n  /* Open the file */\n  \n  AVI->fdes = open(filename,O_RDONLY|O_BINARY);\n  if(AVI->fdes < 0)\n    {\n      AVI_errno = AVI_ERR_OPEN;\n      free(AVI);\n      return 0;\n    }\n  \n  avi_parse_input_file(AVI, getIndex);\n\n  AVI->aptr=0; //reset  \n\n  return AVI;\n}\n\navi_t *AVI_open_fd(int fd, int getIndex)\n{\n  avi_t *AVI=NULL;\n  \n  /* Create avi_t structure */\n  \n  AVI = (avi_t *) malloc(sizeof(avi_t));\n  if(AVI==NULL)\n    {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n    }\n  memset((void *)AVI,0,sizeof(avi_t));\n  \n  AVI->mode = AVI_MODE_READ; /* open for reading */\n  \n  // file alread open\n  AVI->fdes = fd;\n  \n  avi_parse_input_file(AVI, getIndex);\n\n  AVI->aptr=0; //reset\n  \n  return AVI;\n}\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n  long i, n, rate, scale, idx_type;\n  unsigned char *hdrl_data;\n  long header_offset=0, hdrl_len=0;\n  long nvi, nai[AVI_MAX_TRACKS], ioff;\n  long tot[AVI_MAX_TRACKS];\n  int j;\n  int lasttag = 0;\n  int vids_strh_seen = 0;\n  int vids_strf_seen = 0;\n  int auds_strh_seen = 0;\n  //  int auds_strf_seen = 0;\n  int num_stream = 0;\n  char data[256];\n  \n  /* Read first 12 bytes and check that this is an AVI file */\n\n   if( avi_read(AVI->fdes,data,12) != 12 ) ERR_EXIT(AVI_ERR_READ)\n\n   if( strncasecmp(data  ,""RIFF"",4) !=0 ||\n       strncasecmp(data+8,""AVI "",4) !=0 ) ERR_EXIT(AVI_ERR_NO_AVI)\n\n   /* Go through the AVI file and extract the header list,\n      the start position of the 'movi' list and an optionally\n      present idx1 tag */\n\n   hdrl_data = 0;\n\n   while(1)\n   {\n      if( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\n      n = str2ulong((unsigned char *) data+4);\n      n = PAD_EVEN(n);\n\n      if(strncasecmp(data,""LIST"",4) == 0)\n      {\n         if( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n         n -= 4;\n         if(strncasecmp(data,""hdrl"",4) == 0)\n         {\n            hdrl_len = n;\n            hdrl_data = (unsigned char *) malloc(n);\n            if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n				 \n	    // offset of header\n	    \n	    header_offset = lseek(AVI->fdes,0,SEEK_CUR);\n				 \n            if( avi_read(AVI->fdes,(char *)hdrl_data,n) != n ) ERR_EXIT(AVI_ERR_READ)\n         }\n         else if(strncasecmp(data,""movi"",4) == 0)\n         {\n            AVI->movi_start = lseek(AVI->fdes,0,SEEK_CUR);\n            lseek(AVI->fdes,n,SEEK_CUR);\n         }\n         else\n            lseek(AVI->fdes,n,SEEK_CUR);\n      }\n      else if(strncasecmp(data,""idx1"",4) == 0)\n      {\n         /* n must be a multiple of 16, but the reading does not\n            break if this is not the case */\n\n         AVI->n_idx = AVI->max_idx = n/16;\n         AVI->idx = (unsigned  char((*)[16]) ) malloc(n);\n         if(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n         if(avi_read(AVI->fdes, (char *) AVI->idx, n) != n ) ERR_EXIT(AVI_ERR_READ)\n      }\n      else\n         lseek(AVI->fdes,n,SEEK_CUR);\n   }\n\n   if(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n   if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n   /* Interpret the header list */\n\n   for(i=0;i<hdrl_len;)\n   {\n      /* List tags are completly ignored */\n\n      if(strncasecmp((char *) hdrl_data+i, ""LIST"",4)==0) { i+= 12; continue; }\n\n      n = str2ulong(hdrl_data+i+4);\n      n = PAD_EVEN(n);\n\n      /* Interpret the tag and its args */\n\n      if(strncasecmp((char *)hdrl_data+i,""strh"",4)==0)\n      {\n         i += 8;\n         if(strncasecmp((char *)hdrl_data+i,""vids"",4) == 0 && !vids_strh_seen)\n         {\n            memcpy(AVI->compressor,hdrl_data+i+4,4);\n            AVI->compressor[4] = 0;\n\n	    // ThOe\n	    AVI->v_codech_off = header_offset + i+4;\n\n            scale = str2ulong((unsigned char *)hdrl_data+i+20);\n            rate  = str2ulong(hdrl_data+i+24);\n            if(scale!=0) AVI->fps = (double)rate/(double)scale;\n            AVI->video_frames = str2ulong(hdrl_data+i+32);\n            AVI->video_strn = num_stream;\n	    AVI->max_len = 0;\n            vids_strh_seen = 1;\n            lasttag = 1; /* vids */\n         }\n         else if (strncasecmp ((char *) hdrl_data+i,""auds"",4) ==0 && ! auds_strh_seen)\n         {\n\n	   //inc audio tracks\n	   AVI->aptr=AVI->anum;\n	   ++AVI->anum;\n	   \n	   if(AVI->anum > AVI_MAX_TRACKS) {\n	     fprintf(stderr, ""error - only %d audio tracks supported\n"", AVI_MAX_TRACKS);\n	     return(-1);\n	   }\n	   \n	   AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n	   AVI->track[AVI->aptr].audio_strn = num_stream;\n	   //	   auds_strh_seen = 1;\n	   lasttag = 2; /* auds */\n	   \n	   // ThOe\n	   AVI->track[AVI->aptr].a_codech_off = header_offset + i;\n	   \n         }\n         else\n            lasttag = 0;\n         num_stream++;\n      }\n      else if(strncasecmp((char *) hdrl_data+i,""strf"",4)==0)\n      {\n         i += 8;\n         if(lasttag == 1)\n         {\n            AVI->width  = str2ulong(hdrl_data+i+4);\n            AVI->height = str2ulong(hdrl_data+i+8);\n            vids_strf_seen = 1;\n	    //ThOe\n	    AVI->v_codecf_off = header_offset + i+16;\n\n	    memcpy(AVI->compressor2, hdrl_data+i+16, 4);\n            AVI->compressor2[4] = 0;\n\n         }\n         else if(lasttag == 2)\n         {\n            AVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n	    //ThOe\n	    AVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n	    \n            AVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n            AVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n	    //ThOe: read mp3bitrate\n	    AVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n	    //:ThOe\n            AVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n	    //            auds_strf_seen = 1;\n         }\n         lasttag = 0;\n      }\n      else\n      {\n         i += 8;\n         lasttag = 0;\n      }\n\n      i += n;\n   }\n\n   free(hdrl_data);\n\n   if(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n   AVI->video_tag[0] = AVI->video_strn/10 + '0';\n   AVI->video_tag[1] = AVI->video_strn%10 + '0';\n   AVI->video_tag[2] = 'd';\n   AVI->video_tag[3] = 'b';\n\n   /* Audio tag is set to ""99wb"" if no audio present */\n   if(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n   for(j=0; j<AVI->anum; ++j) {\n     AVI->track[j].audio_tag[0] = (j+1)/10 + '0';\n     AVI->track[j].audio_tag[1] = (j+1)%10 + '0';\n     AVI->track[j].audio_tag[2] = 'w';\n     AVI->track[j].audio_tag[3] = 'b';\n   }\n\n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n   /* get index if wanted */\n\n   if(!getIndex) return(0);\n\n   /* if the file has an idx1, check if this is relative\n      to the start of the file or to the start of the movi list */\n\n   idx_type = 0;\n\n   if(AVI->idx)\n   {\n      long pos, len;\n\n      /* Search the first videoframe in the idx1 and look where\n         it is in the file */\n\n      for(i=0;i<AVI->n_idx;i++)\n         if( strncasecmp((char *) AVI->idx[i],(char *) AVI->video_tag,3)==0 ) break;\n      if(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n      pos = str2ulong(AVI->idx[i]+ 8);\n      len = str2ulong(AVI->idx[i]+12);\n\n      lseek(AVI->fdes,pos,SEEK_SET);\n      if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n      if( strncasecmp((char *)data,(char *)AVI->idx[i],4)==0 && \n      str2ulong((unsigned char *)data+4)==len )\n      {\n         idx_type = 1; /* Index from start of file */\n      }\n      else\n      {\n         lseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n         if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n         if( strncasecmp((char *)data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n         {\n            idx_type = 2; /* Index from start of movi list */\n         }\n      }\n      /* idx_type remains 0 if neither of the two tests above succeeds */\n   }\n\n   if(idx_type == 0)\n   {\n      /* we must search through the file to get the index */\n\n      lseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n      AVI->n_idx = 0;\n\n      while(1)\n      {\n         if( avi_read(AVI->fdes,data,8) != 8 ) break;\n         n = str2ulong((unsigned char *)data+4);\n\n         /* The movi list may contain sub-lists, ignore them */\n\n         if(strncasecmp(data,""LIST"",4)==0)\n         {\n            lseek(AVI->fdes,4,SEEK_CUR);\n            continue;\n         }\n\n         /* Check if we got a tag ##db, ##dc or ##wb */\n	 \n         if( ( (data[2]=='d' || data[2]=='D') &&\n               (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n	     || ( (data[2]=='w' || data[2]=='W') &&\n		  (data[3]=='b' || data[3]=='B') ) )\n	   {\n	   avi_add_index_entry(AVI,(unsigned char *) data,0,lseek(AVI->fdes,0,SEEK_CUR)-8,n);\n         }\n	 \n         lseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n      }\n      idx_type = 1;\n   }\n\n   /* Now generate the video index and audio index arrays */\n\n   nvi = 0;\n   for(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n   for(i=0;i<AVI->n_idx;i++) {\n     \n     if(strncasecmp((char *)AVI->idx[i],(char *) AVI->video_tag,3) == 0) nvi++;\n     \n     for(j=0; j<AVI->anum; ++j) if(strncasecmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n   }\n   \n   AVI->video_frames = nvi;\n   for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n//   fprintf(stderr, ""chunks = %ld %d %s\n"", AVI->track[0].audio_chunks, AVI->anum, AVI->track[0].audio_tag);\n\n   if(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n   AVI->video_index = (video_index_entry *) malloc(nvi*sizeof(video_index_entry));\n   if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n   \n   for(j=0; j<AVI->anum; ++j) {\n       if(AVI->track[j].audio_chunks) {\n	   AVI->track[j].audio_index = (audio_index_entry *) malloc(nai[j]*sizeof(audio_index_entry));\n	   if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n       }\n   }   \n   \n   nvi = 0;\n   for(j=0; j<AVI->anum; ++j) nai[j] = tot[j] = 0;\n   \n   ioff = idx_type == 1 ? 8 : AVI->movi_start+4;\n   \n   for(i=0;i<AVI->n_idx;i++) {\n\n     //video\n     if(strncasecmp((char *)AVI->idx[i],(char *)AVI->video_tag,3) == 0) {\n       AVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n       AVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n       AVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n       nvi++;\n     }\n     \n     //audio\n     for(j=0; j<AVI->anum; ++j) {\n	 \n       if(strncasecmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n	 AVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n	 AVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n	 AVI->track[j].audio_index[nai[j]].tot = tot[j];\n	 tot[j] += AVI->track[j].audio_index[nai[j]].len;\n	 nai[j]++;\n       }\n     }\n   }\n   \n   \n   for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n   \n   /* Reposition the file */\n   \n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n   AVI->video_pos = 0;\n\n   return(0);\n}\n\nlong AVI_video_frames(avi_t *AVI)\n{\n   return AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n   return AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n   return AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n   return AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n   return AVI->compressor2;\n}\n\nlong AVI_max_video_chunk(avi_t *AVI)\n{\n   return AVI->max_len; \n}\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n    return(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_chans;\n}\n\nlong AVI_audio_mp3rate(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].mp3rate;\n}\n\nint AVI_audio_bits(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_fmt;\n}\n\nlong AVI_audio_rate(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_rate;\n}\n\nlong AVI_audio_bytes(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].audio_bytes;\n}\n\nlong AVI_audio_chunks(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].audio_chunks;\n}\n\nlong AVI_audio_codech_offset(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_codech_off;\n}\n\nlong AVI_audio_codecf_offset(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_codecf_off;\n}\n\nlong  AVI_video_codech_offset(avi_t *AVI)\n{\n    return AVI->v_codech_off;\n}\n\nlong  AVI_video_codecf_offset(avi_t *AVI)\n{\n    return AVI->v_codecf_off;\n}\n\nlong AVI_frame_size(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(frame < 0 || frame >= AVI->video_frames) return 0;\n   return(AVI->video_index[frame].len);\n}\n\nlong AVI_audio_size(avi_t *AVI, long frame)\n{\n  if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n  \n  if(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return 0;\n  return(AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nlong AVI_get_video_position(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(frame < 0 || frame >= AVI->video_frames) return 0;\n   return(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n   AVI->video_pos = 0;\n   return 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if (frame < 0 ) frame = 0;\n   AVI->video_pos = frame;\n   return 0;\n}\n\nint AVI_set_audio_bitrate(avi_t *AVI, long bitrate)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   AVI->track[AVI->aptr].mp3rate = bitrate;\n   return 0;\n}\n      \n\nlong AVI_read_frame(avi_t *AVI, char *vidbuf, int *keyframe)\n{\n   long n;\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n   if(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n   n = AVI->video_index[AVI->video_pos].len;\n   *keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n   lseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n   if (avi_read(AVI->fdes,vidbuf,n) != n)\n   {\n      AVI_errno = AVI_ERR_READ;\n      return -1;\n   }\n   AVI->video_pos++;\n   return n;\n}\n\nint AVI_set_audio_position(avi_t *AVI, long byte)\n{\n   long n0, n1, n;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(byte < 0) byte = 0;\n\n   /* Binary search in the audio chunks */\n\n   n0 = 0;\n   n1 = AVI->track[AVI->aptr].audio_chunks;\n\n   while(n0<n1-1)\n   {\n      n = (n0+n1)/2;\n      if(AVI->track[AVI->aptr].audio_index[n].tot>byte)\n         n1 = n;\n      else\n         n0 = n;\n   }\n\n   AVI->track[AVI->aptr].audio_posc = n0;\n   AVI->track[AVI->aptr].audio_posb = byte - AVI->track[AVI->aptr].audio_index[n0].tot;\n\n   return 0;\n}\n\nlong AVI_read_audio(avi_t *AVI, char *audbuf, long bytes)\n{\n   long nr, pos, left, todo;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   nr = 0; /* total number of bytes read */\n\n   while(bytes>0)\n   {\n      left = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb;\n      if(left==0)\n      {\n         if(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n         AVI->track[AVI->aptr].audio_posc++;\n         AVI->track[AVI->aptr].audio_posb = 0;\n         continue;\n      }\n      if(bytes<left)\n         todo = bytes;\n      else\n         todo = left;\n      pos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n      lseek(AVI->fdes, pos, SEEK_SET);\n      if (avi_read(AVI->fdes,audbuf+nr,todo) != todo)\n      {\n         AVI_errno = AVI_ERR_READ;\n         return -1;\n      }\n      bytes -= todo;\n      nr    += todo;\n      AVI->track[AVI->aptr].audio_posb += todo;\n   }\n\n   return nr;\n}\n\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, long max_vidbuf,\n                              char *audbuf, long max_audbuf,\n                              long *len)\n{\n\n/*\n * Return codes:\n *\n *    1 = video data read\n *    2 = audio data read\n *    0 = reached EOF\n *   -1 = video buffer too small\n *   -2 = audio buffer too small\n */\n\n   int n;\n   char data[8];\n \n   if(AVI->mode==AVI_MODE_WRITE) return 0;\n\n   while(1)\n   {\n      /* Read tag and length */\n\n      if( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n      /* if we got a list tag, ignore it */\n\n      if(strncasecmp(data,""LIST"",4) == 0)\n      {\n         lseek(AVI->fdes,4,SEEK_CUR);\n         continue;\n      }\n\n      n = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n      if(strncasecmp(data,AVI->video_tag,3) == 0)\n      {\n         *len = n;\n         AVI->video_pos++;\n         if(n>max_vidbuf)\n         {\n            lseek(AVI->fdes,n,SEEK_CUR);\n            return -1;\n         }\n         if(avi_read(AVI->fdes,vidbuf,n) != n ) return 0;\n         return 1;\n      }\n      else if(strncasecmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n      {\n         *len = n;\n         if(n>max_audbuf)\n         {\n            lseek(AVI->fdes,n,SEEK_CUR);\n            return -2;\n         }\n         if(avi_read(AVI->fdes,audbuf,n) != n ) return 0;\n         return 2;\n         break;\n      }\n      else\n         if(lseek(AVI->fdes,n,SEEK_CUR)<0)  return 0;\n   }\n}\n\n/* AVI_print_error: Print most recent error (similar to perror) */\n\nchar *(avi_errors[]) =\n{\n  /*  0 */ (char *) ""avilib - No Error"",\n  /*  1 */ (char *) ""avilib - AVI file size limit reached"",\n  /*  2 */ (char *) ""avilib - Error opening AVI file"",\n  /*  3 */ (char *) ""avilib - Error reading from AVI file"",\n  /*  4 */ (char *) ""avilib - Error writing to AVI file"",\n  /*  5 */ (char *) ""avilib - Error writing index (file may still be useable)"",\n  /*  6 */ (char *) ""avilib - Error closing AVI file"",\n  /*  7 */ (char *) ""avilib - Operation (read/write) not permitted"",\n  /*  8 */ (char *) ""avilib - Out of memory (malloc failed)"",\n  /*  9 */ (char *) ""avilib - Not an AVI file"",\n  /* 10 */ (char *) ""avilib - AVI file has no header list (corrupted?)"",\n  /* 11 */ (char *) ""avilib - AVI file has no MOVI list (corrupted?)"",\n  /* 12 */ (char *) ""avilib - AVI file has no video data"",\n  /* 13 */ (char *) ""avilib - operation needs an index"",\n  /* 14 */ (char *) ""avilib - Unkown Error""\n};\nstatic int num_avi_errors = sizeof(avi_errors)/sizeof(char*);\n\nstatic char error_string[4096];\n\nvoid AVI_print_error(char *str)\n{\n   int aerrno;\n\n   aerrno = (AVI_errno>=0 && AVI_errno<num_avi_errors) ? AVI_errno : num_avi_errors-1;\n\n   fprintf(stderr,""%s: %s\n"",str,avi_errors[aerrno]);\n\n   /* for the following errors, perror should report a more detailed reason: */\n\n   if(AVI_errno == AVI_ERR_OPEN ||\n      AVI_errno == AVI_ERR_READ ||\n      AVI_errno == AVI_ERR_WRITE ||\n      AVI_errno == AVI_ERR_WRITE_INDEX ||\n      AVI_errno == AVI_ERR_CLOSE )\n   {\n      perror(""REASON"");\n   }\n}\n\nchar *AVI_strerror()\n{\n   int aerrno;\n\n   aerrno = (AVI_errno>=0 && AVI_errno<num_avi_errors) ? AVI_errno : num_avi_errors-1;\n\n   if(AVI_errno == AVI_ERR_OPEN ||\n      AVI_errno == AVI_ERR_READ ||\n      AVI_errno == AVI_ERR_WRITE ||\n      AVI_errno == AVI_ERR_WRITE_INDEX ||\n      AVI_errno == AVI_ERR_CLOSE )\n   {\n      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));\n      return error_string;\n   }\n   else\n   {\n      return avi_errors[aerrno];\n   }\n}\n\nuint64_t AVI_max_size()\n{\n  return((uint64_t) AVI_MAX_LEN);\n}\n\n#ifdef __cplusplus\n}\n#endif\n"
leukocyte/OpenMP/detect_main.c,"#include ""find_ellipse.h""\n#include ""track_ellipse.h""\n\nint omp_num_threads = 1;\n\nint main(int argc, char ** argv) {\n\n	// Keep track of the start time of the program\n  long long program_start_time = get_time();\n	\n	// Let the user specify the number of frames to process\n	int num_frames = 1;\n	\n	if (argc !=4){\n		fprintf(stderr, ""usage: %s <num of frames> <num of threads><input file>"", argv[0]);\n		exit(1);\n	}\n	\n	if (argc > 1){\n		num_frames = atoi(argv[1]);\n		omp_num_threads = atoi(argv[2]);\n		}\n	printf(""Num of threads: %d\n"", omp_num_threads);\n	// Open video file\n	char *video_file_name;\n	video_file_name = argv[3];\n	\n	avi_t *cell_file = AVI_open_input_file(video_file_name, 1);\n	if (cell_file == NULL)	{\n		AVI_print_error(""Error with AVI_open_input_file"");\n		return -1;\n	}\n	\n	int i, j, *crow, *ccol, pair_counter = 0, x_result_len = 0, Iter = 20, ns = 4, k_count = 0, n;\n	MAT *cellx, *celly, *A;\n	double *GICOV_spots, *t, *G, *x_result, *y_result, *V, *QAX_CENTERS, *QAY_CENTERS;\n	double threshold = 1.8, radius = 10.0, delta = 3.0, dt = 0.01, b = 5.0;\n	\n	// Extract a cropped version of the first frame from the video file\n	MAT *image_chopped = get_frame(cell_file, 0, 1, 0);\n	printf(""Detecting cells in frame 0\n"");\n	\n	// Get gradient matrices in x and y directions\n	MAT *grad_x = gradient_x(image_chopped);\n	MAT *grad_y = gradient_y(image_chopped);\n	\n	m_free(image_chopped);\n	\n	// Get GICOV matrix corresponding to image gradients\n	long long GICOV_start_time = get_time();\n	MAT *gicov = ellipsematching(grad_x, grad_y);\n	\n	// Square GICOV values\n	MAT *max_gicov = m_get(gicov->m, gicov->n);\n	for (i = 0; i < gicov->m; i++) {\n		for (j = 0; j < gicov->n; j++) {\n			double val = m_get_val(gicov, i, j);\n			m_set_val(max_gicov, i, j, val * val);\n		}\n	}\n	\n	long long GICOV_end_time = get_time();\n	\n	// Dilate the GICOV matrix\n	long long dilate_start_time = get_time();\n	MAT *strel = structuring_element(12);\n	MAT *img_dilated = dilate_f(max_gicov, strel);\n	long long dilate_end_time = get_time();\n	\n	// Find possible matches for cell centers based on GICOV and record the rows/columns in which they are found\n	pair_counter = 0;\n	crow = (int *) malloc(max_gicov->m * max_gicov->n * sizeof(int));\n	ccol = (int *) malloc(max_gicov->m * max_gicov->n * sizeof(int));\n	for (i = 0; i < max_gicov->m; i++) {\n		for (j = 0; j < max_gicov->n; j++) {\n			if (!(m_get_val(max_gicov,i,j) == 0.0) && (m_get_val(img_dilated,i,j) == m_get_val(max_gicov,i,j))) {\n				crow[pair_counter] = i;\n				ccol[pair_counter] = j;\n				pair_counter++;\n			}\n		}\n	}\n	\n	GICOV_spots = (double *) malloc(sizeof(double)*pair_counter);\n	for (i = 0; i < pair_counter; i++)\n		GICOV_spots[i] = m_get_val(gicov, crow[i], ccol[i]);\n	\n	G = (double *) calloc(pair_counter, sizeof(double));\n	x_result = (double *) calloc(pair_counter, sizeof(double));\n	y_result = (double *) calloc(pair_counter, sizeof(double));\n	\n	x_result_len = 0;\n	for (i = 0; i < pair_counter; i++) {\n		if ((crow[i] > 29) && (crow[i] < BOTTOM - TOP + 39)) {\n			x_result[x_result_len] = ccol[i];\n			y_result[x_result_len] = crow[i] - 40;\n			G[x_result_len] = GICOV_spots[i];\n			x_result_len++;\n		}\n	}\n	\n	// Make an array t which holds each ""time step"" for the possible cells\n	t = (double *) malloc(sizeof(double) * 36);\n	for (i = 0; i < 36; i++) {\n		t[i] = (double)i * 2.0 * PI / 36.0;\n	}\n	\n	// Store cell boundaries (as simple circles) for all cells\n	cellx = m_get(x_result_len, 36);\n	celly = m_get(x_result_len, 36);\n	for(i = 0; i < x_result_len; i++) {\n		for(j = 0; j < 36; j++) {\n			m_set_val(cellx, i, j, x_result[i] + radius * cos(t[j]));\n			m_set_val(celly, i, j, y_result[i] + radius * sin(t[j]));\n		}\n	}\n	\n	A = TMatrix(9,4);\n\n	\n	V = (double *) malloc(sizeof(double) * pair_counter);\n	QAX_CENTERS = (double * )malloc(sizeof(double) * pair_counter);\n	QAY_CENTERS = (double *) malloc(sizeof(double) * pair_counter);\n	memset(V, 0, sizeof(double) * pair_counter);\n	memset(QAX_CENTERS, 0, sizeof(double) * pair_counter);\n	memset(QAY_CENTERS, 0, sizeof(double) * pair_counter);\n\n	// For all possible results, find the ones that are feasibly leukocytes and store their centers\n	k_count = 0;\n	for (n = 0; n < x_result_len; n++) {\n		if ((G[n] < -1 * threshold) || G[n] > threshold) {\n			MAT * x, *y;\n			VEC * x_row, * y_row;\n			x = m_get(1, 36);\n			y = m_get(1, 36);\n\n			x_row = v_get(36);\n			y_row = v_get(36);\n\n			// Get current values of possible cells from cellx/celly matrices\n			x_row = get_row(cellx, n, x_row);\n			y_row = get_row(celly, n, y_row);\n			uniformseg(x_row, y_row, x, y);\n\n			// Make sure that the possible leukocytes are not too close to the edge of the frame\n			if ((m_min(x) > b) && (m_min(y) > b) && (m_max(x) < cell_file->width - b) && (m_max(y) < cell_file->height - b)) {\n				MAT * Cx, * Cy, *Cy_temp, * Ix1, * Iy1;\n				VEC  *Xs, *Ys, *W, *Nx, *Ny, *X, *Y;\n				Cx = m_get(1, 36);\n				Cy = m_get(1, 36);\n				Cx = mmtr_mlt(A, x, Cx);\n				Cy = mmtr_mlt(A, y, Cy);\n				\n				Cy_temp = m_get(Cy->m, Cy->n);\n				\n				for (i = 0; i < 9; i++)\n					m_set_val(Cy, i, 0, m_get_val(Cy, i, 0) + 40.0);\n					\n				// Iteratively refine the snake/spline\n				for (i = 0; i < Iter; i++) {\n					int typeofcell;\n					\n					if(G[n] > 0.0) typeofcell = 0;\n					else typeofcell = 1;\n					\n					splineenergyform01(Cx, Cy, grad_x, grad_y, ns, delta, 2.0 * dt, typeofcell);\n				}\n				\n				X = getsampling(Cx, ns);\n				for (i = 0; i < Cy->m; i++)\n					m_set_val(Cy_temp, i, 0, m_get_val(Cy, i, 0) - 40.0);\n				Y = getsampling(Cy_temp, ns);\n				\n				Ix1 = linear_interp2(grad_x, X, Y);\n				Iy1 = linear_interp2(grad_x, X, Y);\n				Xs = getfdriv(Cx, ns);\n				Ys = getfdriv(Cy, ns);\n				\n				Nx = v_get(Ys->dim);\n				for (i = 0; i < Ys->dim; i++)\n					v_set_val(Nx, i, v_get_val(Ys, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n					\n				Ny = v_get(Xs->dim);\n				for (i = 0; i < Xs->dim; i++)\n					v_set_val(Ny, i, -1.0 * v_get_val(Xs, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n					\n				W = v_get(Nx->dim);\n				for (i = 0; i < Nx->dim; i++)\n					v_set_val(W, i, m_get_val(Ix1, 0, i) * v_get_val(Nx, i) + m_get_val(Iy1, 0, i) * v_get_val(Ny, i));\n					\n				V[n] = mean(W) / std_dev(W);\n				\n				//get means of X and Y values for all ""snaxels"" of the spline contour, thus finding the cell centers\n				QAX_CENTERS[k_count] = mean(X);\n				QAY_CENTERS[k_count] = mean(Y) + TOP;\n				\n				k_count++;\n				\n				// Free memory\n				v_free(W);\n				v_free(Ny);\n				v_free(Nx);\n				v_free(Ys);\n				v_free(Xs);\n				m_free(Iy1);\n				m_free(Ix1);\n				v_free(Y);\n				v_free(X);\n				m_free(Cy_temp);\n				m_free(Cy);\n				m_free(Cx);				\n			}\n			\n			// Free memory\n			v_free(y_row);\n			v_free(x_row);\n			m_free(y);\n			m_free(x);\n		}\n	}\n\n	// Free memory\n	free(V);\n	free(ccol);\n	free(crow);\n	free(GICOV_spots);\n	free(t);\n	free(G);\n	free(x_result);\n	free(y_result);\n	m_free(A);\n	m_free(celly);\n	m_free(cellx);\n	m_free(img_dilated);\n	m_free(max_gicov);\n	m_free(gicov);\n	m_free(grad_y);\n	m_free(grad_x);\n	\n	// Report the total number of cells detected\n	printf(""Cells detected: %d\n\n"", k_count);\n	\n	// Report the breakdown of the detection runtime\n	printf(""Detection runtime\n"");\n	printf(""-----------------\n"");\n	printf(""GICOV computation: %.5f seconds\n"", ((float) (GICOV_end_time - GICOV_start_time)) / (1000*1000));\n	printf(""   GICOV dilation: %.5f seconds\n"", ((float) (dilate_end_time - dilate_start_time)) / (1000*1000));\n	printf(""            Total: %.5f seconds\n"", ((float) (get_time() - program_start_time)) / (1000*1000));\n	\n	// Now that the cells have been detected in the first frame,\n	//  track the ellipses through subsequent frames\n	if (num_frames > 1) printf(""\nTracking cells across %d frames\n"", num_frames);\n	else                printf(""\nTracking cells across 1 frame\n"");\n	long long tracking_start_time = get_time();\n	int num_snaxels = 20;\n	ellipsetrack(cell_file, QAX_CENTERS, QAY_CENTERS, k_count, radius, num_snaxels, num_frames);\n	printf(""           Total: %.5f seconds\n"", ((float) (get_time() - tracking_start_time)) / (float) (1000*1000*num_frames));\n	\n	// Report total program execution time\n    printf(""\nTotal application run time: %.5f seconds\n"", ((float) (get_time() - program_start_time)) / (1000*1000));\n\n	return 0;\n}\n"
leukocyte/OpenMP/avilib.c,"/*\n *  avilib.c\n *\n *  Copyright (C) Thomas streich - June 2001\n *  multiple audio track support Copyright (C) 2002 Thomas streich \n *\n *  Original code:\n *  Copyright (C) 1999 Rainer Johanni <Rainer@Johanni.de> \n *\n *  This file is part of transcode, a linux video stream processing tool\n *      \n *  transcode is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *   \n *  transcode is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *   \n *  You should have received a copy of the GNU General Public License\n *  along with GNU Make; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. \n *\n */\n\n#include ""avilib.h""\n//#include <time.h>\n\n#define INFO_LIST\n\n/* The following variable indicates the kind of error */\n\nlong AVI_errno;\n\n#define MAX_INFO_STRLEN 64\nstatic char id_str[MAX_INFO_STRLEN];\n\n#define FRAME_RATE_SCALE 1000000\n\n#ifndef PACKAGE\n#define PACKAGE ""my""\n#define VERSION ""0.00""\n#endif\n\n#ifndef O_BINARY\n/* win32 wants a binary flag to open(); this sets it to null\n   on platforms that don't have it. */\n#define O_BINARY 0\n#endif\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for writing an AVI File                            *\n *                                                                 *\n *******************************************************************/\n\nstatic size_t avi_read(int fd, char *buf, size_t len)\n{\n   size_t n = 0;\n   size_t r = 0;\n\n   while (r < len) {\n      n = read (fd, buf + r, len - r);\n\n      if (n <= 0)\n	  return r;\n      r += n;\n   }\n\n   return r;\n}\n\nstatic size_t avi_write (int fd, char *buf, size_t len)\n{\n   size_t n = 0;\n   size_t r = 0;\n\n   while (r < len) {\n      n = write (fd, buf + r, len - r);\n      if (n < 0)\n         return n;\n      \n      r += n;\n   }\n   return r;\n}\n\n/* HEADERBYTES: The number of bytes to reserve for the header */\n\n#define HEADERBYTES 2048\n\n/* AVI_MAX_LEN: The maximum length of an AVI file, we stay a bit below\n    the 2GB limit (Remember: 2*10^9 is smaller than 2 GB) */\n\n#define AVI_MAX_LEN (UINT_MAX-(1<<20)*16-HEADERBYTES)\n\n#define PAD_EVEN(x) ( ((x)+1) & ~1 )\n\n\n/* Copy n into dst as a 4 byte, little endian number.\n   Should also work on big endian machines */\n\nstatic void long2str(unsigned char *dst, int n)\n{\n   dst[0] = (n    )&0xff;\n   dst[1] = (n>> 8)&0xff;\n   dst[2] = (n>>16)&0xff;\n   dst[3] = (n>>24)&0xff;\n}\n\n/* Convert a string of 4 or 2 bytes to a number,\n   also working on big endian machines */\n\nstatic unsigned long str2ulong(unsigned char *str)\n{\n   return ( str[0] | (str[1]<<8) | (str[2]<<16) | (str[3]<<24) );\n}\nstatic unsigned long str2ushort(unsigned char *str)\n{\n   return ( str[0] | (str[1]<<8) );\n}\n\n/* Calculate audio sample size from number of bits and number of channels.\n   This may have to be adjusted for eg. 12 bits and stereo */\n\nstatic int avi_sampsize(avi_t *AVI, int j)\n{\n   int s;\n   s = ((AVI->track[j].a_bits+7)/8)*AVI->track[j].a_chans;\n   //   if(s==0) s=1; /* avoid possible zero divisions */\n   if(s<4) s=4; /* avoid possible zero divisions */ \n   return s;\n}\n\n/* Add a chunk (=tag and data) to the AVI file,\n   returns -1 on write error, 0 on success */\n\nstatic int avi_add_chunk(avi_t *AVI, unsigned char *tag, unsigned char *data, int length)\n{\n   unsigned char c[8];\n\n   /* Copy tag and length int c, so that we need only 1 write system call\n      for these two values */\n\n   memcpy(c,tag,4);\n   long2str(c+4,length);\n\n   /* Output tag, length and data, restore previous position\n      if the write fails */\n\n   length = PAD_EVEN(length);\n\n   if( avi_write(AVI->fdes,(char *)c,8) != 8 ||\n       avi_write(AVI->fdes,(char *)data,length) != length )\n   {\n      lseek(AVI->fdes,AVI->pos,SEEK_SET);\n      AVI_errno = AVI_ERR_WRITE;\n      return -1;\n   }\n\n   /* Update file position */\n\n   AVI->pos += 8 + length;\n\n   //fprintf(stderr, ""pos=%lu %s\n"", AVI->pos, tag);\n\n   return 0;\n}\n\nstatic int avi_add_index_entry(avi_t *AVI, unsigned char *tag, long flags, unsigned long pos, unsigned long len)\n{\n   void *ptr;\n\n   if(AVI->n_idx>=AVI->max_idx) {\n     ptr = realloc((void *)AVI->idx,(AVI->max_idx+4096)*16);\n     \n     if(ptr == 0) {\n       AVI_errno = AVI_ERR_NO_MEM;\n       return -1;\n     }\n     AVI->max_idx += 4096;\n     AVI->idx = (unsigned char((*)[16]) ) ptr;\n   }\n   \n   /* Add index entry */\n\n   //   fprintf(stderr, ""INDEX %s %ld %lu %lu\n"", tag, flags, pos, len);\n\n   memcpy(AVI->idx[AVI->n_idx],tag,4);\n   long2str(AVI->idx[AVI->n_idx]+ 4,flags);\n   long2str(AVI->idx[AVI->n_idx]+ 8, pos);\n   long2str(AVI->idx[AVI->n_idx]+12, len);\n   \n   /* Update counter */\n\n   AVI->n_idx++;\n\n   if(len>AVI->max_len) AVI->max_len=len;\n\n   return 0;\n}\n\n/*\n   AVI_open_output_file: Open an AVI File and write a bunch\n                         of zero bytes as space for the header.\n\n   returns a pointer to avi_t on success, a zero pointer on error\n*/\n\navi_t* AVI_open_output_file(char * filename)\n{\n   avi_t *AVI;\n   int i;\n\n   int mask = 0;\n   \n   unsigned char AVI_header[HEADERBYTES];\n\n   /* Allocate the avi_t struct and zero it */\n\n   AVI = (avi_t *) malloc(sizeof(avi_t));\n   if(AVI==0)\n   {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n   }\n   memset((void *)AVI,0,sizeof(avi_t));\n\n   /* Since Linux needs a long time when deleting big files,\n      we do not truncate the file when we open it.\n      Instead it is truncated when the AVI file is closed */\n\n  /* mask = umask (0);\n   umask (mask);*/\n\n   AVI->fdes = open(filename, O_RDWR|O_CREAT|O_BINARY, 0644 &~ mask);\n   if (AVI->fdes < 0)\n   {\n      AVI_errno = AVI_ERR_OPEN;\n      free(AVI);\n      return 0;\n   }\n\n   /* Write out HEADERBYTES bytes, the header will go here\n      when we are finished with writing */\n\n   for (i=0;i<HEADERBYTES;i++) AVI_header[i] = 0;\n   i = avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES);\n   if (i != HEADERBYTES)\n   {\n      close(AVI->fdes);\n      AVI_errno = AVI_ERR_WRITE;\n      free(AVI);\n      return 0;\n   }\n\n   AVI->pos  = HEADERBYTES;\n   AVI->mode = AVI_MODE_WRITE; /* open for writing */\n\n   //init\n   AVI->anum = 0;\n   AVI->aptr = 0;\n\n   return AVI;\n}\n\nvoid AVI_set_video(avi_t *AVI, int width, int height, double fps, char *compressor)\n{\n   /* may only be called if file is open for writing */\n\n   if(AVI->mode==AVI_MODE_READ) return;\n\n   AVI->width  = width;\n   AVI->height = height;\n   AVI->fps    = fps;\n   \n   if(strncmp(compressor, ""RGB"", 3)==0) {\n     memset(AVI->compressor, 0, 4);\n   } else {\n     memcpy(AVI->compressor,compressor,4);\n   }     \n   \n   AVI->compressor[4] = 0;\n\n   avi_update_header(AVI);\n}\n\nvoid AVI_set_audio(avi_t *AVI, int channels, long rate, int bits, int format, long mp3rate)\n{\n   /* may only be called if file is open for writing */\n\n   if(AVI->mode==AVI_MODE_READ) return;\n\n   //inc audio tracks\n   AVI->aptr=AVI->anum;\n   ++AVI->anum;\n\n   if(AVI->anum > AVI_MAX_TRACKS) {\n     fprintf(stderr, ""error - only %d audio tracks supported\n"", AVI_MAX_TRACKS);\n     exit(1);\n   }\n\n   AVI->track[AVI->aptr].a_chans = channels;\n   AVI->track[AVI->aptr].a_rate  = rate;\n   AVI->track[AVI->aptr].a_bits  = bits;\n   AVI->track[AVI->aptr].a_fmt   = format;\n   AVI->track[AVI->aptr].mp3rate = mp3rate;\n\n   avi_update_header(AVI);\n}\n\n#define OUT4CC(s) \\n   if(nhb<=HEADERBYTES-4) memcpy(AVI_header+nhb,s,4); nhb += 4\n\n#define OUTLONG(n) \\n   if(nhb<=HEADERBYTES-4) long2str(AVI_header+nhb,n); nhb += 4\n\n#define OUTSHRT(n) \\n   if(nhb<=HEADERBYTES-2) { \\n      AVI_header[nhb  ] = (n   )&0xff; \\n      AVI_header[nhb+1] = (n>>8)&0xff; \\n   } \\n   nhb += 2\n\n\n//ThOe write preliminary AVI file header: 0 frames, max vid/aud size\nint avi_update_header(avi_t *AVI)\n{\n   int njunk, sampsize, hasIndex, ms_per_frame, frate, flag;\n   int movi_len, hdrl_start, strl_start, j;\n   unsigned char AVI_header[HEADERBYTES];\n   long nhb;\n\n   //assume max size\n   movi_len = AVI_MAX_LEN - HEADERBYTES + 4;\n\n   //assume index will be written\n   hasIndex=1;\n\n   if(AVI->fps < 0.001) {\n     frate=0;\n     ms_per_frame=0;\n   } else {\n     frate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n     ms_per_frame=(int) (1000000/AVI->fps + 0.5);\n   }\n\n   /* Prepare the file header */\n\n   nhb = 0;\n\n   /* The RIFF header */\n\n   OUT4CC (""RIFF"");\n   OUTLONG(movi_len);    // assume max size\n   OUT4CC (""AVI "");\n\n   /* Start the header list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   hdrl_start = nhb;  /* Store start position */\n   OUT4CC (""hdrl"");\n\n   /* The main AVI header */\n\n   /* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n   OUT4CC (""avih"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUTLONG(ms_per_frame);       /* Microseconds per frame */\n   //ThOe ->0 \n   //   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n   OUTLONG(0);\n   OUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n                                /* Other sources call it 'reserved' */\n   flag = AVIF_ISINTERLEAVED;\n   if(hasIndex) flag |= AVIF_HASINDEX;\n   if(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n   OUTLONG(flag);               /* Flags */\n   OUTLONG(0);                  // no frames yet\n   OUTLONG(0);                  /* InitialFrames */\n\n   OUTLONG(AVI->anum+1);\n\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n                                /* MS calls the following 'reserved': */\n   OUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n   OUTLONG(0);                  /* DataRate:   Data rate of playback     */\n   OUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n   OUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n   /* Start the video stream list ---------------------------------- */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   strl_start = nhb;  /* Store start position */\n   OUT4CC (""strl"");\n\n   /* The video stream header */\n\n   OUT4CC (""strh"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUT4CC (""vids"");             /* Type */\n   OUT4CC (AVI->compressor);    /* Handler */\n   OUTLONG(0);                  /* Flags */\n   OUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n   OUTLONG(0);                  /* InitialFrames */\n   OUTLONG(FRAME_RATE_SCALE);              /* Scale */\n   OUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n   OUTLONG(0);                  /* Start */\n   OUTLONG(0);                  // no frames yet\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(-1);                 /* Quality */\n   OUTLONG(0);                  /* SampleSize */\n   OUTLONG(0);                  /* Frame */\n   OUTLONG(0);                  /* Frame */\n   //   OUTLONG(0);                  /* Frame */\n   //OUTLONG(0);                  /* Frame */\n\n   /* The video stream format */\n\n   OUT4CC (""strf"");\n   OUTLONG(40);                 /* # of bytes to follow */\n   OUTLONG(40);                 /* Size */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n   OUTSHRT(1); OUTSHRT(24);     /* Planes, Count */\n   OUT4CC (AVI->compressor);    /* Compression */\n   // ThOe (*3)\n   OUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n   OUTLONG(0);                  /* XPelsPerMeter */\n   OUTLONG(0);                  /* YPelsPerMeter */\n   OUTLONG(0);                  /* ClrUsed: Number of colors used */\n   OUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n   /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n   long2str(AVI_header+strl_start-4,nhb-strl_start);\n\n   \n   /* Start the audio stream list ---------------------------------- */\n   \n   for(j=0; j<AVI->anum; ++j) {\n       \n       sampsize = avi_sampsize(AVI, j);\n   \n       OUT4CC (""LIST"");\n       OUTLONG(0);        /* Length of list in bytes, don't know yet */\n       strl_start = nhb;  /* Store start position */\n       OUT4CC (""strl"");\n       \n       /* The audio stream header */\n       \n       OUT4CC (""strh"");\n       OUTLONG(56);            /* # of bytes to follow */\n       OUT4CC (""auds"");\n       \n       // -----------\n       // ThOe\n       OUTLONG(0);             /* Format (Optionally) */\n       // -----------\n       \n       OUTLONG(0);             /* Flags */\n       OUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n       OUTLONG(0);             /* InitialFrames */\n       \n       // ThOe /4\n       OUTLONG(sampsize/4);      /* Scale */\n       OUTLONG(1000*AVI->track[j].mp3rate/8);\n       OUTLONG(0);             /* Start */\n       OUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n       OUTLONG(0);             /* SuggestedBufferSize */\n       OUTLONG(-1);            /* Quality */\n       \n       // ThOe /4\n       OUTLONG(sampsize/4);    /* SampleSize */\n       \n       OUTLONG(0);             /* Frame */\n       OUTLONG(0);             /* Frame */\n       //       OUTLONG(0);             /* Frame */\n       //OUTLONG(0);             /* Frame */\n       \n       /* The audio stream format */\n       \n       OUT4CC (""strf"");\n       OUTLONG(16);                   /* # of bytes to follow */\n       OUTSHRT(AVI->track[j].a_fmt);           /* Format */\n       OUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n       OUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n       // ThOe\n       OUTLONG(1000*AVI->track[j].mp3rate/8);\n       //ThOe (/4)\n       \n       OUTSHRT(sampsize/4);           /* BlockAlign */\n       \n       \n       OUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n       \n       /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n       \n       long2str(AVI_header+strl_start-4,nhb-strl_start);\n   }\n   \n   /* Finish header list */\n   \n   long2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n   \n   \n   /* Calculate the needed amount of junk bytes, output junk */\n   \n   njunk = HEADERBYTES - nhb - 8 - 12;\n   \n   /* Safety first: if njunk <= 0, somebody has played with\n      HEADERBYTES without knowing what (s)he did.\n      This is a fatal error */\n   \n   if(njunk<=0)\n     {\n       fprintf(stderr,""AVI_close_output_file: # of header bytes too small\n"");\n       exit(1);\n     }\n   \n   OUT4CC (""JUNK"");\n   OUTLONG(njunk);\n   memset(AVI_header+nhb,0,njunk);\n   \n   //11/14/01 added id string \n\n   if(njunk > strlen(id_str)+8) {\n     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);\n     memcpy(AVI_header+nhb, id_str, strlen(id_str));\n   }\n   \n   nhb += njunk;\n\n   /* Start the movi list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(movi_len); /* Length of list in bytes */\n   OUT4CC (""movi"");\n\n   /* Output the header, truncate the file to the number of bytes\n      actually written, report an error if someting goes wrong */\n\n   if ( lseek(AVI->fdes,0,SEEK_SET)<0 ||\n        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES ||\n	lseek(AVI->fdes,AVI->pos,SEEK_SET)<0)\n     {\n       AVI_errno = AVI_ERR_CLOSE;\n       return -1;\n     }\n\n   return 0;\n}\n\n/*\n  Write the header of an AVI file and close it.\n  returns 0 on success, -1 on write error.\n*/\n\nstatic int avi_close_output_file(avi_t *AVI)\n{\n\n   int ret, njunk, sampsize, hasIndex, ms_per_frame, frate, idxerror, flag;\n   unsigned long movi_len;\n   int hdrl_start, strl_start, j;\n   unsigned char AVI_header[HEADERBYTES];\n   long nhb;\n\n#ifdef INFO_LIST\n   long info_len;\n//   time_t calptr;\n#endif\n\n   /* Calculate length of movi list */\n\n   movi_len = AVI->pos - HEADERBYTES + 4;\n\n   /* Try to ouput the index entries. This may fail e.g. if no space\n      is left on device. We will report this as an error, but we still\n      try to write the header correctly (so that the file still may be\n      readable in the most cases */\n\n   idxerror = 0;\n   //   fprintf(stderr, ""pos=%lu, index_len=%ld             \n"", AVI->pos, AVI->n_idx*16);\n   ret = avi_add_chunk(AVI, (unsigned char *)""idx1"", (void*)AVI->idx, AVI->n_idx*16);\n   hasIndex = (ret==0);\n   //fprintf(stderr, ""pos=%lu, index_len=%d\n"", AVI->pos, hasIndex);\n\n   if(ret) {\n     idxerror = 1;\n     AVI_errno = AVI_ERR_WRITE_INDEX;\n   }\n   \n   /* Calculate Microseconds per frame */\n\n   if(AVI->fps < 0.001) {\n     frate=0;\n     ms_per_frame=0;\n   } else {\n     frate = (int) (FRAME_RATE_SCALE*AVI->fps + 0.5);\n     ms_per_frame=(int) (1000000/AVI->fps + 0.5);\n   }\n\n   /* Prepare the file header */\n\n   nhb = 0;\n\n   /* The RIFF header */\n\n   OUT4CC (""RIFF"");\n   OUTLONG(AVI->pos - 8);    /* # of bytes to follow */\n   OUT4CC (""AVI "");\n\n   /* Start the header list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   hdrl_start = nhb;  /* Store start position */\n   OUT4CC (""hdrl"");\n\n   /* The main AVI header */\n\n   /* The Flags in AVI File header */\n\n#define AVIF_HASINDEX           0x00000010      /* Index at end of file */\n#define AVIF_MUSTUSEINDEX       0x00000020\n#define AVIF_ISINTERLEAVED      0x00000100\n#define AVIF_TRUSTCKTYPE        0x00000800      /* Use CKType to find key frames */\n#define AVIF_WASCAPTUREFILE     0x00010000\n#define AVIF_COPYRIGHTED        0x00020000\n\n   OUT4CC (""avih"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUTLONG(ms_per_frame);       /* Microseconds per frame */\n   //ThOe ->0 \n   //   OUTLONG(10000000);           /* MaxBytesPerSec, I hope this will never be used */\n   OUTLONG(0);\n   OUTLONG(0);                  /* PaddingGranularity (whatever that might be) */\n                                /* Other sources call it 'reserved' */\n   flag = AVIF_ISINTERLEAVED;\n   if(hasIndex) flag |= AVIF_HASINDEX;\n   if(hasIndex && AVI->must_use_index) flag |= AVIF_MUSTUSEINDEX;\n   OUTLONG(flag);               /* Flags */\n   OUTLONG(AVI->video_frames);  /* TotalFrames */\n   OUTLONG(0);                  /* InitialFrames */\n\n   OUTLONG(AVI->anum+1);\n//   if (AVI->track[0].audio_bytes)\n//      { OUTLONG(2); }           /* Streams */\n//   else\n//      { OUTLONG(1); }           /* Streams */\n\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n                                /* MS calls the following 'reserved': */\n   OUTLONG(0);                  /* TimeScale:  Unit used to measure time */\n   OUTLONG(0);                  /* DataRate:   Data rate of playback     */\n   OUTLONG(0);                  /* StartTime:  Starting time of AVI data */\n   OUTLONG(0);                  /* DataLength: Size of AVI data chunk    */\n\n\n   /* Start the video stream list ---------------------------------- */\n\n   OUT4CC (""LIST"");\n   OUTLONG(0);        /* Length of list in bytes, don't know yet */\n   strl_start = nhb;  /* Store start position */\n   OUT4CC (""strl"");\n\n   /* The video stream header */\n\n   OUT4CC (""strh"");\n   OUTLONG(56);                 /* # of bytes to follow */\n   OUT4CC (""vids"");             /* Type */\n   OUT4CC (AVI->compressor);    /* Handler */\n   OUTLONG(0);                  /* Flags */\n   OUTLONG(0);                  /* Reserved, MS says: wPriority, wLanguage */\n   OUTLONG(0);                  /* InitialFrames */\n   OUTLONG(FRAME_RATE_SCALE);              /* Scale */\n   OUTLONG(frate);              /* Rate: Rate/Scale == samples/second */\n   OUTLONG(0);                  /* Start */\n   OUTLONG(AVI->video_frames);  /* Length */\n   OUTLONG(0);                  /* SuggestedBufferSize */\n   OUTLONG(-1);                 /* Quality */\n   OUTLONG(0);                  /* SampleSize */\n   OUTLONG(0);                  /* Frame */\n   OUTLONG(0);                  /* Frame */\n   //   OUTLONG(0);                  /* Frame */\n   //OUTLONG(0);                  /* Frame */\n\n   /* The video stream format */\n\n   OUT4CC (""strf"");\n   OUTLONG(40);                 /* # of bytes to follow */\n   OUTLONG(40);                 /* Size */\n   OUTLONG(AVI->width);         /* Width */\n   OUTLONG(AVI->height);        /* Height */\n   OUTSHRT(1); OUTSHRT(24);     /* Planes, Count */\n   OUT4CC (AVI->compressor);    /* Compression */\n   // ThOe (*3)\n   OUTLONG(AVI->width*AVI->height*3);  /* SizeImage (in bytes?) */\n   OUTLONG(0);                  /* XPelsPerMeter */\n   OUTLONG(0);                  /* YPelsPerMeter */\n   OUTLONG(0);                  /* ClrUsed: Number of colors used */\n   OUTLONG(0);                  /* ClrImportant: Number of colors important */\n\n   /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n\n   long2str(AVI_header+strl_start-4,nhb-strl_start);\n\n   /* Start the audio stream list ---------------------------------- */\n\n   for(j=0; j<AVI->anum; ++j) {\n     \n     //if (AVI->track[j].a_chans && AVI->track[j].audio_bytes)\n       {\n	   \n	 sampsize = avi_sampsize(AVI, j);\n	   \n	 OUT4CC (""LIST"");\n	 OUTLONG(0);        /* Length of list in bytes, don't know yet */\n	 strl_start = nhb;  /* Store start position */\n	 OUT4CC (""strl"");\n	   \n	 /* The audio stream header */\n	 \n	 OUT4CC (""strh"");\n	 OUTLONG(56);            /* # of bytes to follow */\n	 OUT4CC (""auds"");\n	 \n	 // -----------\n	 // ThOe\n	 OUTLONG(0);             /* Format (Optionally) */\n	   // -----------\n	   \n	 OUTLONG(0);             /* Flags */\n	 OUTLONG(0);             /* Reserved, MS says: wPriority, wLanguage */\n	 OUTLONG(0);             /* InitialFrames */\n	   \n	 // ThOe /4\n	 OUTLONG(sampsize/4);      /* Scale */\n	 OUTLONG(1000*AVI->track[j].mp3rate/8);\n	 OUTLONG(0);             /* Start */\n	 OUTLONG(4*AVI->track[j].audio_bytes/sampsize);   /* Length */\n	 OUTLONG(0);             /* SuggestedBufferSize */\n	 OUTLONG(-1);            /* Quality */\n	   \n	 // ThOe /4\n	 OUTLONG(sampsize/4);    /* SampleSize */\n	   \n	 OUTLONG(0);             /* Frame */\n	 OUTLONG(0);             /* Frame */\n	 //	 OUTLONG(0);             /* Frame */\n	 //OUTLONG(0);             /* Frame */\n	   \n	 /* The audio stream format */\n	 \n	 OUT4CC (""strf"");\n	 OUTLONG(16);                   /* # of bytes to follow */\n	 OUTSHRT(AVI->track[j].a_fmt);           /* Format */\n	 OUTSHRT(AVI->track[j].a_chans);         /* Number of channels */\n	 OUTLONG(AVI->track[j].a_rate);          /* SamplesPerSec */\n	 // ThOe\n	 OUTLONG(1000*AVI->track[j].mp3rate/8);\n	 //ThOe (/4)\n	 \n	 OUTSHRT(sampsize/4);           /* BlockAlign */\n	 \n	 \n	 OUTSHRT(AVI->track[j].a_bits);          /* BitsPerSample */\n	 \n	 /* Finish stream list, i.e. put number of bytes in the list to proper pos */\n       }\n       long2str(AVI_header+strl_start-4,nhb-strl_start);\n   }\n   \n   /* Finish header list */\n   \n   long2str(AVI_header+hdrl_start-4,nhb-hdrl_start);\n\n\n   // add INFO list --- (0.6.0pre4)\n\n#ifdef INFO_LIST\n   OUT4CC (""LIST"");\n   \n   //FIXME\n   info_len = MAX_INFO_STRLEN + 12;\n   OUTLONG(info_len);\n   OUT4CC (""INFO"");\n\n//   OUT4CC (""INAM"");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   sprintf(id_str, ""\t"");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, strlen(id_str));\n//   nhb += MAX_INFO_STRLEN;\n\n   OUT4CC (""ISFT"");\n   OUTLONG(MAX_INFO_STRLEN);\n\n   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);\n   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n   memcpy(AVI_header+nhb, id_str, strlen(id_str));\n   nhb += MAX_INFO_STRLEN;\n\n//   OUT4CC (""ICMT"");\n//   OUTLONG(MAX_INFO_STRLEN);\n\n//   calptr=time(NULL); \n//   sprintf(id_str, ""\t%s %s"", ctime(&calptr), """");\n//   memset(AVI_header+nhb, 0, MAX_INFO_STRLEN);\n//   memcpy(AVI_header+nhb, id_str, 25);\n//   nhb += MAX_INFO_STRLEN;\n#endif\n\n   // ----------------------------\n   \n   /* Calculate the needed amount of junk bytes, output junk */\n   \n   njunk = HEADERBYTES - nhb - 8 - 12;\n   \n   /* Safety first: if njunk <= 0, somebody has played with\n      HEADERBYTES without knowing what (s)he did.\n      This is a fatal error */\n   \n   if(njunk<=0)\n   {\n      fprintf(stderr,""AVI_close_output_file: # of header bytes too small\n"");\n      exit(1);\n   }\n\n   OUT4CC (""JUNK"");\n   OUTLONG(njunk);\n   memset(AVI_header+nhb,0,njunk);\n   \n   nhb += njunk;\n\n   /* Start the movi list */\n\n   OUT4CC (""LIST"");\n   OUTLONG(movi_len); /* Length of list in bytes */\n   OUT4CC (""movi"");\n\n   /* Output the header, truncate the file to the number of bytes\n      actually written, report an error if someting goes wrong */\n\n   if ( lseek(AVI->fdes,0,SEEK_SET)<0 ||\n        avi_write(AVI->fdes,(char *)AVI_header,HEADERBYTES)!=HEADERBYTES \n        //|| ftruncate(AVI->fdes,AVI->pos)<0 \n        )\n   {\n      AVI_errno = AVI_ERR_CLOSE;\n      return -1;\n   }\n\n   if(idxerror) return -1;\n\n   return 0;\n}\n\n/*\n   AVI_write_data:\n   Add video or audio data to the file;\n\n   Return values:\n    0    No error;\n   -1    Error, AVI_errno is set appropriatly;\n\n*/\n\nstatic int avi_write_data(avi_t *AVI, char *data, unsigned long length, int audio, int keyframe)\n{\n   int n;\n\n   unsigned char astr[5];\n\n   /* Check for maximum file length */\n   \n   if ( (AVI->pos + 8 + length + 8 + (AVI->n_idx+1)*16) > AVI_MAX_LEN ) {\n     AVI_errno = AVI_ERR_SIZELIM;\n     return -1;\n   }\n   \n   /* Add index entry */\n\n   //set tag for current audio track\n   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);\n\n   if(audio)\n     n = avi_add_index_entry(AVI,astr,0x00,AVI->pos,length);\n   else\n     n = avi_add_index_entry(AVI,(unsigned char *) ""00db"",((keyframe)?0x10:0x0),AVI->pos,length);\n   \n   if(n) return -1;\n   \n   /* Output tag and data */\n   \n   if(audio)\n     n = avi_add_chunk(AVI,(unsigned char *) astr, (unsigned char *)data,length);\n   else\n     n = avi_add_chunk(AVI,(unsigned char *)""00db"",(unsigned char *)data,length);\n   \n   if (n) return -1;\n   \n   return 0;\n}\n\nint AVI_write_frame(avi_t *AVI, char *data, long bytes, int keyframe)\n{\n  unsigned long pos;\n  \n  if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  \n  pos = AVI->pos;\n\n  if(avi_write_data(AVI,data,bytes,0,keyframe)) return -1;\n   \n  AVI->last_pos = pos;\n  AVI->last_len = bytes;\n  AVI->video_frames++;\n  return 0;\n}\n\nint AVI_dup_frame(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   if(AVI->last_pos==0) return 0; /* No previous real frame */\n   if(avi_add_index_entry(AVI,(unsigned char *)""00db"",0x10,AVI->last_pos,AVI->last_len)) return -1;\n   AVI->video_frames++;\n   AVI->must_use_index = 1;\n   return 0;\n}\n\nint AVI_write_audio(avi_t *AVI, char *data, long bytes)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   if( avi_write_data(AVI,data,bytes,1,0) ) return -1;\n   AVI->track[AVI->aptr].audio_bytes += bytes;\n   return 0;\n}\n\n\nint AVI_append_audio(avi_t *AVI, char *data, long bytes)\n{\n\n  long i, length, pos;\n  unsigned char c[4];\n\n  if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  \n  // update last index entry:\n  \n  --AVI->n_idx;\n  length = str2ulong(AVI->idx[AVI->n_idx]+12);\n  pos    = str2ulong(AVI->idx[AVI->n_idx]+8);\n\n  //update;\n  long2str(AVI->idx[AVI->n_idx]+12,length+bytes);   \n\n  ++AVI->n_idx;\n\n  AVI->track[AVI->aptr].audio_bytes += bytes;\n\n  //update chunk header\n  lseek(AVI->fdes, pos+4, SEEK_SET);\n  long2str(c, length+bytes);     \n  avi_write(AVI->fdes,(char *) c, 4);\n\n  lseek(AVI->fdes, pos+8+length, SEEK_SET);\n\n  i=PAD_EVEN(length + bytes);\n\n  bytes = i - length;\n  avi_write(AVI->fdes, data, bytes);\n  AVI->pos = pos + 8 + i;\n\n  return 0;\n}\n\n\nlong AVI_bytes_remain(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) return 0;\n\n   return ( AVI_MAX_LEN - (AVI->pos + 8 + 16*AVI->n_idx));\n}\n\nlong AVI_bytes_written(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_READ) return 0;\n\n   return (AVI->pos + 8 + 16*AVI->n_idx);\n}\n\nint AVI_set_audio_track(avi_t *AVI, int track)\n{\n  \n  if(track < 0 || track + 1 > AVI->anum) return(-1);\n\n  //this info is not written to file anyway\n  AVI->aptr=track;\n  return 0;\n}\n\nint AVI_get_audio_track(avi_t *AVI)\n{\n    return(AVI->aptr);\n}\n\n\n/*******************************************************************\n *                                                                 *\n *    Utilities for reading video and audio from an AVI File       *\n *                                                                 *\n *******************************************************************/\n\nint AVI_close(avi_t *AVI)\n{\n   int ret;\n\n   /* If the file was open for writing, the header and index still have\n      to be written */\n\n   if(AVI->mode == AVI_MODE_WRITE)\n      ret = avi_close_output_file(AVI);\n   else\n      ret = 0;\n\n   /* Even if there happened an error, we first clean up */\n\n   close(AVI->fdes);\n   if(AVI->idx) free(AVI->idx);\n   if(AVI->video_index) free(AVI->video_index);\n   //FIXME\n   //if(AVI->audio_index) free(AVI->audio_index);\n   free(AVI);\n\n   return ret;\n}\n\n\n#define ERR_EXIT(x) \\n{ \\n   AVI_close(AVI); \\n   AVI_errno = x; \\n   return 0; \\n}\n\navi_t *AVI_open_input_file(char *filename, int getIndex)\n{\n  avi_t *AVI=NULL;\n  \n  /* Create avi_t structure */\n  \n  AVI = (avi_t *) malloc(sizeof(avi_t));\n  if(AVI==NULL)\n    {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n    }\n  memset((void *)AVI,0,sizeof(avi_t));\n  \n  AVI->mode = AVI_MODE_READ; /* open for reading */\n  \n  /* Open the file */\n  \n  AVI->fdes = open(filename,O_RDONLY|O_BINARY);\n  if(AVI->fdes < 0)\n    {\n      AVI_errno = AVI_ERR_OPEN;\n      free(AVI);\n      return 0;\n    }\n  \n  avi_parse_input_file(AVI, getIndex);\n\n  AVI->aptr=0; //reset  \n\n  return AVI;\n}\n\navi_t *AVI_open_fd(int fd, int getIndex)\n{\n  avi_t *AVI=NULL;\n  \n  /* Create avi_t structure */\n  \n  AVI = (avi_t *) malloc(sizeof(avi_t));\n  if(AVI==NULL)\n    {\n      AVI_errno = AVI_ERR_NO_MEM;\n      return 0;\n    }\n  memset((void *)AVI,0,sizeof(avi_t));\n  \n  AVI->mode = AVI_MODE_READ; /* open for reading */\n  \n  // file alread open\n  AVI->fdes = fd;\n  \n  avi_parse_input_file(AVI, getIndex);\n\n  AVI->aptr=0; //reset\n  \n  return AVI;\n}\n\nint avi_parse_input_file(avi_t *AVI, int getIndex)\n{\n  long i, n, rate, scale, idx_type;\n  unsigned char *hdrl_data;\n  long header_offset=0, hdrl_len=0;\n  long nvi, nai[AVI_MAX_TRACKS], ioff;\n  long tot[AVI_MAX_TRACKS];\n  int j;\n  int lasttag = 0;\n  int vids_strh_seen = 0;\n  int vids_strf_seen = 0;\n  int auds_strh_seen = 0;\n  //  int auds_strf_seen = 0;\n  int num_stream = 0;\n  char data[256];\n  \n  /* Read first 12 bytes and check that this is an AVI file */\n\n   if( avi_read(AVI->fdes,data,12) != 12 ) ERR_EXIT(AVI_ERR_READ)\n\n   if( strncasecmp(data  ,""RIFF"",4) !=0 ||\n       strncasecmp(data+8,""AVI "",4) !=0 ) ERR_EXIT(AVI_ERR_NO_AVI)\n\n   /* Go through the AVI file and extract the header list,\n      the start position of the 'movi' list and an optionally\n      present idx1 tag */\n\n   hdrl_data = 0;\n\n   while(1)\n   {\n      if( avi_read(AVI->fdes,data,8) != 8 ) break; /* We assume it's EOF */\n\n      n = str2ulong((unsigned char *) data+4);\n      n = PAD_EVEN(n);\n\n      if(strncasecmp(data,""LIST"",4) == 0)\n      {\n         if( avi_read(AVI->fdes,data,4) != 4 ) ERR_EXIT(AVI_ERR_READ)\n         n -= 4;\n         if(strncasecmp(data,""hdrl"",4) == 0)\n         {\n            hdrl_len = n;\n            hdrl_data = (unsigned char *) malloc(n);\n            if(hdrl_data==0) ERR_EXIT(AVI_ERR_NO_MEM);\n				 \n	    // offset of header\n	    \n	    header_offset = lseek(AVI->fdes,0,SEEK_CUR);\n				 \n            if( avi_read(AVI->fdes,(char *)hdrl_data,n) != n ) ERR_EXIT(AVI_ERR_READ)\n         }\n         else if(strncasecmp(data,""movi"",4) == 0)\n         {\n            AVI->movi_start = lseek(AVI->fdes,0,SEEK_CUR);\n            lseek(AVI->fdes,n,SEEK_CUR);\n         }\n         else\n            lseek(AVI->fdes,n,SEEK_CUR);\n      }\n      else if(strncasecmp(data,""idx1"",4) == 0)\n      {\n         /* n must be a multiple of 16, but the reading does not\n            break if this is not the case */\n\n         AVI->n_idx = AVI->max_idx = n/16;\n         AVI->idx = (unsigned  char((*)[16]) ) malloc(n);\n         if(AVI->idx==0) ERR_EXIT(AVI_ERR_NO_MEM)\n         if(avi_read(AVI->fdes, (char *) AVI->idx, n) != n ) ERR_EXIT(AVI_ERR_READ)\n      }\n      else\n         lseek(AVI->fdes,n,SEEK_CUR);\n   }\n\n   if(!hdrl_data      ) ERR_EXIT(AVI_ERR_NO_HDRL)\n   if(!AVI->movi_start) ERR_EXIT(AVI_ERR_NO_MOVI)\n\n   /* Interpret the header list */\n\n   for(i=0;i<hdrl_len;)\n   {\n      /* List tags are completly ignored */\n\n      if(strncasecmp((char *) hdrl_data+i, ""LIST"",4)==0) { i+= 12; continue; }\n\n      n = str2ulong(hdrl_data+i+4);\n      n = PAD_EVEN(n);\n\n      /* Interpret the tag and its args */\n\n      if(strncasecmp((char *)hdrl_data+i,""strh"",4)==0)\n      {\n         i += 8;\n         if(strncasecmp((char *)hdrl_data+i,""vids"",4) == 0 && !vids_strh_seen)\n         {\n            memcpy(AVI->compressor,hdrl_data+i+4,4);\n            AVI->compressor[4] = 0;\n\n	    // ThOe\n	    AVI->v_codech_off = header_offset + i+4;\n\n            scale = str2ulong((unsigned char *)hdrl_data+i+20);\n            rate  = str2ulong(hdrl_data+i+24);\n            if(scale!=0) AVI->fps = (double)rate/(double)scale;\n            AVI->video_frames = str2ulong(hdrl_data+i+32);\n            AVI->video_strn = num_stream;\n	    AVI->max_len = 0;\n            vids_strh_seen = 1;\n            lasttag = 1; /* vids */\n         }\n         else if (strncasecmp ((char *) hdrl_data+i,""auds"",4) ==0 && ! auds_strh_seen)\n         {\n\n	   //inc audio tracks\n	   AVI->aptr=AVI->anum;\n	   ++AVI->anum;\n	   \n	   if(AVI->anum > AVI_MAX_TRACKS) {\n	     fprintf(stderr, ""error - only %d audio tracks supported\n"", AVI_MAX_TRACKS);\n	     return(-1);\n	   }\n	   \n	   AVI->track[AVI->aptr].audio_bytes = str2ulong(hdrl_data+i+32)*avi_sampsize(AVI, 0);\n	   AVI->track[AVI->aptr].audio_strn = num_stream;\n	   //	   auds_strh_seen = 1;\n	   lasttag = 2; /* auds */\n	   \n	   // ThOe\n	   AVI->track[AVI->aptr].a_codech_off = header_offset + i;\n	   \n         }\n         else\n            lasttag = 0;\n         num_stream++;\n      }\n      else if(strncasecmp((char *) hdrl_data+i,""strf"",4)==0)\n      {\n         i += 8;\n         if(lasttag == 1)\n         {\n            AVI->width  = str2ulong(hdrl_data+i+4);\n            AVI->height = str2ulong(hdrl_data+i+8);\n            vids_strf_seen = 1;\n	    //ThOe\n	    AVI->v_codecf_off = header_offset + i+16;\n\n	    memcpy(AVI->compressor2, hdrl_data+i+16, 4);\n            AVI->compressor2[4] = 0;\n\n         }\n         else if(lasttag == 2)\n         {\n            AVI->track[AVI->aptr].a_fmt   = str2ushort(hdrl_data+i  );\n\n	    //ThOe\n	    AVI->track[AVI->aptr].a_codecf_off = header_offset + i;\n	    \n            AVI->track[AVI->aptr].a_chans = str2ushort(hdrl_data+i+2);\n            AVI->track[AVI->aptr].a_rate  = str2ulong (hdrl_data+i+4);\n	    //ThOe: read mp3bitrate\n	    AVI->track[AVI->aptr].mp3rate = 8*str2ulong(hdrl_data+i+8)/1000;\n	    //:ThOe\n            AVI->track[AVI->aptr].a_bits  = str2ushort(hdrl_data+i+14);\n	    //            auds_strf_seen = 1;\n         }\n         lasttag = 0;\n      }\n      else\n      {\n         i += 8;\n         lasttag = 0;\n      }\n\n      i += n;\n   }\n\n   free(hdrl_data);\n\n   if(!vids_strh_seen || !vids_strf_seen) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n   AVI->video_tag[0] = AVI->video_strn/10 + '0';\n   AVI->video_tag[1] = AVI->video_strn%10 + '0';\n   AVI->video_tag[2] = 'd';\n   AVI->video_tag[3] = 'b';\n\n   /* Audio tag is set to ""99wb"" if no audio present */\n   if(!AVI->track[0].a_chans) AVI->track[0].audio_strn = 99;\n\n   for(j=0; j<AVI->anum; ++j) {\n     AVI->track[j].audio_tag[0] = (j+1)/10 + '0';\n     AVI->track[j].audio_tag[1] = (j+1)%10 + '0';\n     AVI->track[j].audio_tag[2] = 'w';\n     AVI->track[j].audio_tag[3] = 'b';\n   }\n\n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n\n   /* get index if wanted */\n\n   if(!getIndex) return(0);\n\n   /* if the file has an idx1, check if this is relative\n      to the start of the file or to the start of the movi list */\n\n   idx_type = 0;\n\n   if(AVI->idx)\n   {\n      long pos, len;\n\n      /* Search the first videoframe in the idx1 and look where\n         it is in the file */\n\n      for(i=0;i<AVI->n_idx;i++)\n         if( strncasecmp((char *) AVI->idx[i],(char *) AVI->video_tag,3)==0 ) break;\n      if(i>=AVI->n_idx) ERR_EXIT(AVI_ERR_NO_VIDS)\n\n      pos = str2ulong(AVI->idx[i]+ 8);\n      len = str2ulong(AVI->idx[i]+12);\n\n      lseek(AVI->fdes,pos,SEEK_SET);\n      if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n      if( strncasecmp((char *)data,(char *)AVI->idx[i],4)==0 && \n      str2ulong((unsigned char *)data+4)==len )\n      {\n         idx_type = 1; /* Index from start of file */\n      }\n      else\n      {\n         lseek(AVI->fdes,pos+AVI->movi_start-4,SEEK_SET);\n         if(avi_read(AVI->fdes,data,8)!=8) ERR_EXIT(AVI_ERR_READ)\n         if( strncasecmp((char *)data,(char *)AVI->idx[i],4)==0 && str2ulong((unsigned char *)data+4)==len )\n         {\n            idx_type = 2; /* Index from start of movi list */\n         }\n      }\n      /* idx_type remains 0 if neither of the two tests above succeeds */\n   }\n\n   if(idx_type == 0)\n   {\n      /* we must search through the file to get the index */\n\n      lseek(AVI->fdes, AVI->movi_start, SEEK_SET);\n\n      AVI->n_idx = 0;\n\n      while(1)\n      {\n         if( avi_read(AVI->fdes,data,8) != 8 ) break;\n         n = str2ulong((unsigned char *)data+4);\n\n         /* The movi list may contain sub-lists, ignore them */\n\n         if(strncasecmp(data,""LIST"",4)==0)\n         {\n            lseek(AVI->fdes,4,SEEK_CUR);\n            continue;\n         }\n\n         /* Check if we got a tag ##db, ##dc or ##wb */\n	 \n         if( ( (data[2]=='d' || data[2]=='D') &&\n               (data[3]=='b' || data[3]=='B' || data[3]=='c' || data[3]=='C') )\n	     || ( (data[2]=='w' || data[2]=='W') &&\n		  (data[3]=='b' || data[3]=='B') ) )\n	   {\n	   avi_add_index_entry(AVI,(unsigned char *) data,0,lseek(AVI->fdes,0,SEEK_CUR)-8,n);\n         }\n	 \n         lseek(AVI->fdes,PAD_EVEN(n),SEEK_CUR);\n      }\n      idx_type = 1;\n   }\n\n   /* Now generate the video index and audio index arrays */\n\n   nvi = 0;\n   for(j=0; j<AVI->anum; ++j) nai[j] = 0;\n\n   for(i=0;i<AVI->n_idx;i++) {\n     \n     if(strncasecmp((char *)AVI->idx[i],(char *) AVI->video_tag,3) == 0) nvi++;\n     \n     for(j=0; j<AVI->anum; ++j) if(strncasecmp((char *)AVI->idx[i], AVI->track[j].audio_tag,4) == 0) nai[j]++;\n   }\n   \n   AVI->video_frames = nvi;\n   for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_chunks = nai[j];\n\n//   fprintf(stderr, ""chunks = %ld %d %s\n"", AVI->track[0].audio_chunks, AVI->anum, AVI->track[0].audio_tag);\n\n   if(AVI->video_frames==0) ERR_EXIT(AVI_ERR_NO_VIDS);\n   AVI->video_index = (video_index_entry *) malloc(nvi*sizeof(video_index_entry));\n   if(AVI->video_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n   \n   for(j=0; j<AVI->anum; ++j) {\n       if(AVI->track[j].audio_chunks) {\n	   AVI->track[j].audio_index = (audio_index_entry *) malloc(nai[j]*sizeof(audio_index_entry));\n	   if(AVI->track[j].audio_index==0) ERR_EXIT(AVI_ERR_NO_MEM);\n       }\n   }   \n   \n   nvi = 0;\n   for(j=0; j<AVI->anum; ++j) nai[j] = tot[j] = 0;\n   \n   ioff = idx_type == 1 ? 8 : AVI->movi_start+4;\n   \n   for(i=0;i<AVI->n_idx;i++) {\n\n     //video\n     if(strncasecmp((char *)AVI->idx[i],(char *)AVI->video_tag,3) == 0) {\n       AVI->video_index[nvi].key = str2ulong(AVI->idx[i]+ 4);\n       AVI->video_index[nvi].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n       AVI->video_index[nvi].len = str2ulong(AVI->idx[i]+12);\n       nvi++;\n     }\n     \n     //audio\n     for(j=0; j<AVI->anum; ++j) {\n	 \n       if(strncasecmp((char *)AVI->idx[i],AVI->track[j].audio_tag,4) == 0) {\n	 AVI->track[j].audio_index[nai[j]].pos = str2ulong(AVI->idx[i]+ 8)+ioff;\n	 AVI->track[j].audio_index[nai[j]].len = str2ulong(AVI->idx[i]+12);\n	 AVI->track[j].audio_index[nai[j]].tot = tot[j];\n	 tot[j] += AVI->track[j].audio_index[nai[j]].len;\n	 nai[j]++;\n       }\n     }\n   }\n   \n   \n   for(j=0; j<AVI->anum; ++j) AVI->track[j].audio_bytes = tot[j];\n   \n   /* Reposition the file */\n   \n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n   AVI->video_pos = 0;\n\n   return(0);\n}\n\nlong AVI_video_frames(avi_t *AVI)\n{\n   return AVI->video_frames;\n}\nint  AVI_video_width(avi_t *AVI)\n{\n   return AVI->width;\n}\nint  AVI_video_height(avi_t *AVI)\n{\n   return AVI->height;\n}\ndouble AVI_frame_rate(avi_t *AVI)\n{\n   return AVI->fps;\n}\nchar* AVI_video_compressor(avi_t *AVI)\n{\n   return AVI->compressor2;\n}\n\nlong AVI_max_video_chunk(avi_t *AVI)\n{\n   return AVI->max_len; \n}\n\nint AVI_audio_tracks(avi_t *AVI)\n{\n    return(AVI->anum);\n}\n\nint AVI_audio_channels(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_chans;\n}\n\nlong AVI_audio_mp3rate(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].mp3rate;\n}\n\nint AVI_audio_bits(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_bits;\n}\n\nint AVI_audio_format(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_fmt;\n}\n\nlong AVI_audio_rate(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_rate;\n}\n\nlong AVI_audio_bytes(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].audio_bytes;\n}\n\nlong AVI_audio_chunks(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].audio_chunks;\n}\n\nlong AVI_audio_codech_offset(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_codech_off;\n}\n\nlong AVI_audio_codecf_offset(avi_t *AVI)\n{\n   return AVI->track[AVI->aptr].a_codecf_off;\n}\n\nlong  AVI_video_codech_offset(avi_t *AVI)\n{\n    return AVI->v_codech_off;\n}\n\nlong  AVI_video_codecf_offset(avi_t *AVI)\n{\n    return AVI->v_codecf_off;\n}\n\nlong AVI_frame_size(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(frame < 0 || frame >= AVI->video_frames) return 0;\n   return(AVI->video_index[frame].len);\n}\n\nlong AVI_audio_size(avi_t *AVI, long frame)\n{\n  if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n  if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n  \n  if(frame < 0 || frame >= AVI->track[AVI->aptr].audio_chunks) return 0;\n  return(AVI->track[AVI->aptr].audio_index[frame].len);\n}\n\nlong AVI_get_video_position(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(frame < 0 || frame >= AVI->video_frames) return 0;\n   return(AVI->video_index[frame].pos);\n}\n\n\nint AVI_seek_start(avi_t *AVI)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   lseek(AVI->fdes,AVI->movi_start,SEEK_SET);\n   AVI->video_pos = 0;\n   return 0;\n}\n\nint AVI_set_video_position(avi_t *AVI, long frame)\n{\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if (frame < 0 ) frame = 0;\n   AVI->video_pos = frame;\n   return 0;\n}\n\nint AVI_set_audio_bitrate(avi_t *AVI, long bitrate)\n{\n   if(AVI->mode==AVI_MODE_READ) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n\n   AVI->track[AVI->aptr].mp3rate = bitrate;\n   return 0;\n}\n      \n\nlong AVI_read_frame(avi_t *AVI, char *vidbuf, int *keyframe)\n{\n   long n;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->video_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(AVI->video_pos < 0 || AVI->video_pos >= AVI->video_frames) return -1;\n   n = AVI->video_index[AVI->video_pos].len;\n\n   *keyframe = (AVI->video_index[AVI->video_pos].key==0x10) ? 1:0;\n\n   lseek(AVI->fdes, AVI->video_index[AVI->video_pos].pos, SEEK_SET);\n\n   if (avi_read(AVI->fdes,vidbuf,n) != n)\n   {\n      AVI_errno = AVI_ERR_READ;\n      return -1;\n   }\n\n   AVI->video_pos++;\n\n   return n;\n}\n\nint AVI_set_audio_position(avi_t *AVI, long byte)\n{\n   long n0, n1, n;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   if(byte < 0) byte = 0;\n\n   /* Binary search in the audio chunks */\n\n   n0 = 0;\n   n1 = AVI->track[AVI->aptr].audio_chunks;\n\n   while(n0<n1-1)\n   {\n      n = (n0+n1)/2;\n      if(AVI->track[AVI->aptr].audio_index[n].tot>byte)\n         n1 = n;\n      else\n         n0 = n;\n   }\n\n   AVI->track[AVI->aptr].audio_posc = n0;\n   AVI->track[AVI->aptr].audio_posb = byte - AVI->track[AVI->aptr].audio_index[n0].tot;\n\n   return 0;\n}\n\nlong AVI_read_audio(avi_t *AVI, char *audbuf, long bytes)\n{\n   long nr, pos, left, todo;\n\n   if(AVI->mode==AVI_MODE_WRITE) { AVI_errno = AVI_ERR_NOT_PERM; return -1; }\n   if(!AVI->track[AVI->aptr].audio_index)         { AVI_errno = AVI_ERR_NO_IDX;   return -1; }\n\n   nr = 0; /* total number of bytes read */\n\n   while(bytes>0)\n   {\n      left = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].len - AVI->track[AVI->aptr].audio_posb;\n      if(left==0)\n      {\n         if(AVI->track[AVI->aptr].audio_posc>=AVI->track[AVI->aptr].audio_chunks-1) return nr;\n         AVI->track[AVI->aptr].audio_posc++;\n         AVI->track[AVI->aptr].audio_posb = 0;\n         continue;\n      }\n      if(bytes<left)\n         todo = bytes;\n      else\n         todo = left;\n      pos = AVI->track[AVI->aptr].audio_index[AVI->track[AVI->aptr].audio_posc].pos + AVI->track[AVI->aptr].audio_posb;\n      lseek(AVI->fdes, pos, SEEK_SET);\n      if (avi_read(AVI->fdes,audbuf+nr,todo) != todo)\n      {\n         AVI_errno = AVI_ERR_READ;\n         return -1;\n      }\n      bytes -= todo;\n      nr    += todo;\n      AVI->track[AVI->aptr].audio_posb += todo;\n   }\n\n   return nr;\n}\n\n/* AVI_read_data: Special routine for reading the next audio or video chunk\n                  without having an index of the file. */\n\nint AVI_read_data(avi_t *AVI, char *vidbuf, long max_vidbuf,\n                              char *audbuf, long max_audbuf,\n                              long *len)\n{\n\n/*\n * Return codes:\n *\n *    1 = video data read\n *    2 = audio data read\n *    0 = reached EOF\n *   -1 = video buffer too small\n *   -2 = audio buffer too small\n */\n\n   int n;\n   char data[8];\n \n   if(AVI->mode==AVI_MODE_WRITE) return 0;\n\n   while(1)\n   {\n      /* Read tag and length */\n\n      if( avi_read(AVI->fdes,data,8) != 8 ) return 0;\n\n      /* if we got a list tag, ignore it */\n\n      if(strncasecmp(data,""LIST"",4) == 0)\n      {\n         lseek(AVI->fdes,4,SEEK_CUR);\n         continue;\n      }\n\n      n = PAD_EVEN(str2ulong((unsigned char *)data+4));\n\n      if(strncasecmp(data,AVI->video_tag,3) == 0)\n      {\n         *len = n;\n         AVI->video_pos++;\n         if(n>max_vidbuf)\n         {\n            lseek(AVI->fdes,n,SEEK_CUR);\n            return -1;\n         }\n         if(avi_read(AVI->fdes,vidbuf,n) != n ) return 0;\n         return 1;\n      }\n      else if(strncasecmp(data,AVI->track[AVI->aptr].audio_tag,4) == 0)\n      {\n         *len = n;\n         if(n>max_audbuf)\n         {\n            lseek(AVI->fdes,n,SEEK_CUR);\n            return -2;\n         }\n         if(avi_read(AVI->fdes,audbuf,n) != n ) return 0;\n         return 2;\n         break;\n      }\n      else\n         if(lseek(AVI->fdes,n,SEEK_CUR)<0)  return 0;\n   }\n}\n\n/* AVI_print_error: Print most recent error (similar to perror) */\n\nchar *(avi_errors[]) =\n{\n  /*  0 */ ""avilib - No Error"",\n  /*  1 */ ""avilib - AVI file size limit reached"",\n  /*  2 */ ""avilib - Error opening AVI file"",\n  /*  3 */ ""avilib - Error reading from AVI file"",\n  /*  4 */ ""avilib - Error writing to AVI file"",\n  /*  5 */ ""avilib - Error writing index (file may still be useable)"",\n  /*  6 */ ""avilib - Error closing AVI file"",\n  /*  7 */ ""avilib - Operation (read/write) not permitted"",\n  /*  8 */ ""avilib - Out of memory (malloc failed)"",\n  /*  9 */ ""avilib - Not an AVI file"",\n  /* 10 */ ""avilib - AVI file has no header list (corrupted?)"",\n  /* 11 */ ""avilib - AVI file has no MOVI list (corrupted?)"",\n  /* 12 */ ""avilib - AVI file has no video data"",\n  /* 13 */ ""avilib - operation needs an index"",\n  /* 14 */ ""avilib - Unkown Error""\n};\nstatic int num_avi_errors = sizeof(avi_errors)/sizeof(char*);\n\nstatic char error_string[4096];\n\nvoid AVI_print_error(char *str)\n{\n   int aerrno;\n\n   aerrno = (AVI_errno>=0 && AVI_errno<num_avi_errors) ? AVI_errno : num_avi_errors-1;\n\n   fprintf(stderr,""%s: %s\n"",str,avi_errors[aerrno]);\n\n   /* for the following errors, perror should report a more detailed reason: */\n\n   if(AVI_errno == AVI_ERR_OPEN ||\n      AVI_errno == AVI_ERR_READ ||\n      AVI_errno == AVI_ERR_WRITE ||\n      AVI_errno == AVI_ERR_WRITE_INDEX ||\n      AVI_errno == AVI_ERR_CLOSE )\n   {\n      perror(""REASON"");\n   }\n}\n\nchar *AVI_strerror()\n{\n   int aerrno;\n\n   aerrno = (AVI_errno>=0 && AVI_errno<num_avi_errors) ? AVI_errno : num_avi_errors-1;\n\n   if(AVI_errno == AVI_ERR_OPEN ||\n      AVI_errno == AVI_ERR_READ ||\n      AVI_errno == AVI_ERR_WRITE ||\n      AVI_errno == AVI_ERR_WRITE_INDEX ||\n      AVI_errno == AVI_ERR_CLOSE )\n   {\n      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));\n      return error_string;\n   }\n   else\n   {\n      return avi_errors[aerrno];\n   }\n}\n\nuint64_t AVI_max_size()\n{\n  return((uint64_t) AVI_MAX_LEN);\n}\n\n"
leukocyte/OpenMP/track_ellipse.c,"#include ""track_ellipse.h""\n\n\nvoid ellipsetrack(avi_t *video, double *xc0, double *yc0, int Nc, int R, int Np, int Nf) {\n	/*\n	% ELLIPSETRACK tracks cells in the movie specified by 'video', at\n	%  locations 'xc0'/'yc0' with radii R using an ellipse with Np discrete\n	%  points, starting at frame number one and stopping at frame number 'Nf'.\n	%\n	% INPUTS:\n	%   video.......pointer to avi video object\n	%   xc0,yc0.....initial center location (Nc entries)\n	%   Nc..........number of cells\n	%   R...........initial radius\n	%   Np..........nbr of snaxels points per snake\n	%   Nf..........nbr of frames in which to track\n	%\n	% Matlab code written by: DREW GILLIAM (based on code by GANG DONG /\n	%                                                        NILANJAN RAY)\n	% Ported to C by: MICHAEL BOYER\n	*/\n	\n	int i, j;\n	\n	// Compute angle parameter\n	double *t = (double *) malloc(sizeof(double) * Np);\n	double increment = (2.0 * PI) / (double) Np;\n	for (i = 0; i < Np; i++) {\n		t[i] =  increment * (double) i ;\n	}\n\n	// Allocate space for a snake for each cell in each frame\n	double **xc = alloc_2d_double(Nc, Nf + 1);\n	double **yc = alloc_2d_double(Nc, Nf + 1);\n	double ***r = alloc_3d_double(Nc, Np, Nf + 1);\n	double ***x = alloc_3d_double(Nc, Np, Nf + 1);\n	double ***y = alloc_3d_double(Nc, Np, Nf + 1);\n	\n	// Save the first snake for each cell\n	for (i = 0; i < Nc; i++) {\n		xc[i][0] = xc0[i];\n		yc[i][0] = yc0[i];\n		for (j = 0; j < Np; j++) {\n			r[i][j][0] = (double) R;\n		}\n	}\n	\n	// Generate ellipse points for each cell\n	for (i = 0; i < Nc; i++) {\n		for (j = 0; j < Np; j++) {\n			x[i][j][0] = xc[i][0] + (r[i][j][0] * cos(t[j]));\n			y[i][j][0] = yc[i][0] + (r[i][j][0] * sin(t[j]));\n		}\n	}\n	\n	// Keep track of the total time spent on computing\n	//  the MGVF matrix and evolving the snakes\n	long long  MGVF_time = 0;\n	long long snake_time = 0;\n	\n	\n	// Process each frame\n	int frame_num, cell_num;\n	for (frame_num = 1; frame_num <= Nf; frame_num++) {	 \n		printf(""\rProcessing frame %d / %d"", frame_num, Nf);\n		fflush(stdout);\n		\n		// Get the current video frame and its dimensions\n		MAT *I = get_frame(video, frame_num, 0, 1);\n		int Ih = I->m;\n		int Iw = I->n;\n	    \n	    // Set the current positions equal to the previous positions		\n		for (i = 0; i < Nc; i++) {\n			xc[i][frame_num] = xc[i][frame_num - 1];\n			yc[i][frame_num] = yc[i][frame_num - 1];\n			for (j = 0; j < Np; j++) {\n				r[i][j][frame_num] = r[i][j][frame_num - 1];\n			}\n		}\n		\n		// Split the work among multiple threads, if OPEN is defined\n		#ifdef OPEN\n		#pragma omp parallel for num_threads(omp_num_threads) private(i, j)\n		#endif\n		// Track each cell\n		for (cell_num = 0; cell_num < Nc; cell_num++) {\n			// Make copies of the current cell's location\n			double xci = xc[cell_num][frame_num];\n			double yci = yc[cell_num][frame_num];\n			double *ri = (double *) malloc(sizeof(double) * Np);\n			for (j = 0; j < Np; j++) {\n				ri[j] = r[cell_num][j][frame_num];\n			}\n			\n			// Add up the last ten y-values for this cell\n			//  (or fewer if there are not yet ten previous frames)\n			double ycavg = 0.0;\n			for (i = (frame_num > 10 ? frame_num - 10 : 0); i < frame_num; i++) {\n				ycavg += yc[cell_num][i];\n			}\n			// Compute the average of the last ten y-values\n			//  (this represents the expected y-location of the cell)\n			ycavg = ycavg / (double) (frame_num > 10 ? 10 : frame_num);\n			\n			// Determine the range of the subimage surrounding the current position\n			int u1 = max(xci - 4.0 * R + 0.5, 0 );\n			int u2 = min(xci + 4.0 * R + 0.5, Iw - 1);\n			int v1 = max(yci - 2.0 * R + 1.5, 0 );    \n			int v2 = min(yci + 2.0 * R + 1.5, Ih - 1);\n			\n			// Extract the subimage\n			MAT *Isub = m_get(v2 - v1 + 1, u2 - u1 + 1);\n			for (i = v1; i <= v2; i++) {\n				for (j = u1; j <= u2; j++) {\n					m_set_val(Isub, i - v1, j - u1, m_get_val(I, i, j));\n				}\n			}\n			\n	        // Compute the subimage gradient magnitude			\n			MAT *Ix = gradient_x(Isub);\n			MAT *Iy = gradient_y(Isub);\n			MAT *IE = m_get(Isub->m, Isub->n);\n			for (i = 0; i < Isub->m; i++) {\n				for (j = 0; j < Isub->n; j++) {\n					double temp_x = m_get_val(Ix, i, j);\n					double temp_y = m_get_val(Iy, i, j);\n					m_set_val(IE, i, j, sqrt((temp_x * temp_x) + (temp_y * temp_y)));\n				}\n			}\n			\n			// Compute the motion gradient vector flow (MGVF) edgemaps\n			long long MGVF_start_time = get_time();\n			MAT *IMGVF = MGVF(IE, 1, 1);\n			MGVF_time += get_time() - MGVF_start_time;\n			\n			// Determine the position of the cell in the subimage			\n			xci = xci - (double) u1;\n			yci = yci - (double) (v1 - 1);\n			ycavg = ycavg - (double) (v1 - 1);\n			\n			// Evolve the snake\n			long long snake_start_time = get_time();\n			ellipseevolve(IMGVF, &xci, &yci, ri, t, Np, (double) R, ycavg);\n			snake_time += get_time() - snake_start_time;\n			\n			// Compute the cell's new position in the full image\n			xci = xci + u1;\n			yci = yci + (v1 - 1);\n			\n			// Store the new location of the cell and the snake\n			xc[cell_num][frame_num] = xci;\n			yc[cell_num][frame_num] = yci;\n			for (j = 0; j < Np; j++) {\n				r[cell_num][j][frame_num] = ri[j];\n				x[cell_num][j][frame_num] = xc[cell_num][frame_num] + (ri[j] * cos(t[j]));\n				y[cell_num][j][frame_num] = yc[cell_num][frame_num] + (ri[j] * sin(t[j]));\n			}\n			\n			// Output the updated center of each cell\n			//printf(""%d,%f,%f\n"", cell_num, xci[cell_num], yci[cell_num]);\n			\n			// Free temporary memory\n			m_free(IMGVF);\n			free(ri);\n	    }\n\n#ifdef OUTPUT\n		if (frame_num == Nf)\n		  {\n		    FILE * pFile;\n		    pFile = fopen (""result.txt"",""w+"");\n	\n		    for (cell_num = 0; cell_num < Nc; cell_num++)		\n		      fprintf(pFile,""\n%d,%f,%f"", cell_num, xc[cell_num][Nf], yc[cell_num][Nf]);\n\n		    fclose (pFile);\n		  }\n		\n#endif\n	\n	\n		// Output a new line to visually distinguish the output from different frames\n		//printf(""\n"");\n	}\n	\n	// Free temporary memory\n	free(t);\n	free_2d_double(xc);\n	free_2d_double(yc);\n	free_3d_double(r);\n	free_3d_double(x);\n	free_3d_double(y);\n	\n	// Report average processing time per frame\n	printf(""\n\nTracking runtime (average per frame):\n"");\n	printf(""------------------------------------\n"");\n	printf(""MGVF computation: %.5f seconds\n"", ((float) (MGVF_time)) / (float) (1000*1000*Nf));\n	printf("" Snake evolution: %.5f seconds\n"", ((float) (snake_time)) / (float) (1000*1000*Nf));\n}\n\n\nMAT *MGVF(MAT *I, double vx, double vy) {\n	/*\n	% MGVF calculate the motion gradient vector flow (MGVF) \n	%  for the image 'I'\n	%\n	% Based on the algorithm in:\n	%  Motion gradient vector flow: an external force for tracking rolling \n	%   leukocytes with shape and size constrained active contours\n	%  Ray, N. and Acton, S.T.\n	%  IEEE Transactions on Medical Imaging\n	%  Volume: 23, Issue: 12, December 2004 \n	%  Pages: 1466 - 1478\n	%\n	% INPUTS\n	%   I...........image\n	%   vx,vy.......velocity vector\n	%   \n	% OUTPUT\n	%   IMGVF.......MGVF vector field as image\n	%\n	% Matlab code written by: DREW GILLIAM (based on work by GANG DONG /\n	%                                                        NILANJAN RAY)\n	% Ported to C by: MICHAEL BOYER\n	*/\n\n	// Constants\n	double converge = 0.00001;\n	double mu = 0.5;\n	double epsilon = 0.0000000001;\n	double lambda = 8.0 * mu + 1.0;\n	// Smallest positive value expressable in double-precision\n	double eps = pow(2.0, -52.0);\n	// Maximum number of iterations to compute the MGVF matrix\n	int iterations = 500;\n	\n	// Find the maximum and minimum values in I\n	int m = I->m, n = I->n, i, j;\n	double Imax = m_get_val(I, 0, 0);\n	double Imin = m_get_val(I, 0, 0);\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double temp = m_get_val(I, i, j);\n			if (temp > Imax) Imax = temp;\n			else if (temp < Imin) Imin = temp;\n		}\n	}\n	\n	// Normalize the image I\n	double scale = 1.0 / (Imax - Imin + eps);\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double old_val = m_get_val(I, i, j);\n			m_set_val(I, i, j, (old_val - Imin) * scale);\n		}\n	}\n\n	// Initialize the output matrix IMGVF with values from I\n	MAT *IMGVF = m_get(m, n);\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			m_set_val(IMGVF, i, j, m_get_val(I, i, j));\n		}\n	}\n	\n	// Precompute row and column indices for the\n	//  neighbor difference computation below\n	int *rowU = (int *) malloc(sizeof(int) * m);\n	int *rowD = (int *) malloc(sizeof(int) * m);\n	int *colL = (int *) malloc(sizeof(int) * n);\n	int *colR = (int *) malloc(sizeof(int) * n);\n	rowU[0] = 0;\n	rowD[m - 1] = m - 1;\n	for (i = 1; i < m; i++) {\n		rowU[i] = i - 1;\n		rowD[i - 1] = i;\n	}\n	colL[0] = 0;\n	colR[n - 1] = n - 1;\n	for (j = 1; j < n; j++) {\n		colL[j] = j - 1;\n		colR[j - 1] = j;\n	}\n	\n	// Allocate matrices used in the while loop below\n	MAT *U    = m_get(m, n), *D    = m_get(m, n), *L    = m_get(m, n), *R    = m_get(m, n);\n	MAT *UR   = m_get(m, n), *DR   = m_get(m, n), *UL   = m_get(m, n), *DL   = m_get(m, n);\n	MAT *UHe  = m_get(m, n), *DHe  = m_get(m, n), *LHe  = m_get(m, n), *RHe  = m_get(m, n);\n	MAT *URHe = m_get(m, n), *DRHe = m_get(m, n), *ULHe = m_get(m, n), *DLHe = m_get(m, n);\n\n	\n	// Precompute constants to avoid division in the for loops below\n	double mu_over_lambda = mu / lambda;\n	double one_over_lambda = 1.0 / lambda;\n	\n	// Compute the MGVF\n	int iter = 0;\n	double mean_diff = 1.0;\n	while ((iter < iterations) && (mean_diff > converge)) { \n	    \n	    // Compute the difference between each pixel and its eight neighbors\n		for (i = 0; i < m; i++) {\n			for (j = 0; j < n; j++) {\n				double subtrahend = m_get_val(IMGVF, i, j);\n				m_set_val(U, i, j, m_get_val(IMGVF, rowU[i], j) - subtrahend);\n				m_set_val(D, i, j, m_get_val(IMGVF, rowD[i], j) - subtrahend);\n				m_set_val(L, i, j, m_get_val(IMGVF, i, colL[j]) - subtrahend);\n				m_set_val(R, i, j, m_get_val(IMGVF, i, colR[j]) - subtrahend);\n				m_set_val(UR, i, j, m_get_val(IMGVF, rowU[i], colR[j]) - subtrahend);\n				m_set_val(DR, i, j, m_get_val(IMGVF, rowD[i], colR[j]) - subtrahend);\n				m_set_val(UL, i, j, m_get_val(IMGVF, rowU[i], colL[j]) - subtrahend);\n				m_set_val(DL, i, j, m_get_val(IMGVF, rowD[i], colL[j]) - subtrahend);\n			}\n		}\n		\n	    // Compute the regularized heaviside version of the matrices above\n		heaviside( UHe,  U, -vy,      epsilon);\n		heaviside( DHe,  D,  vy,      epsilon);\n		heaviside( LHe,  L, -vx,      epsilon);\n		heaviside( RHe,  R,  vx,      epsilon);\n		heaviside(URHe, UR,  vx - vy, epsilon);\n		heaviside(DRHe, DR,  vx + vy, epsilon);\n		heaviside(ULHe, UL, -vx - vy, epsilon);\n		heaviside(DLHe, DL,  vy - vx, epsilon);\n		\n		// Update the IMGVF matrix\n		double total_diff = 0.0;\n		for (i = 0; i < m; i++) {\n			for (j = 0; j < n; j++) {\n				// Store the old value so we can compute the difference later\n				double old_val = m_get_val(IMGVF, i, j);\n				\n				// Compute IMGVF += (mu / lambda)(UHe .*U  + DHe .*D  + LHe .*L  + RHe .*R +\n				//                                URHe.*UR + DRHe.*DR + ULHe.*UL + DLHe.*DL);\n				double vU  = m_get_val(UHe,  i, j) * m_get_val(U,  i, j);\n				double vD  = m_get_val(DHe,  i, j) * m_get_val(D,  i, j);\n				double vL  = m_get_val(LHe,  i, j) * m_get_val(L,  i, j);\n				double vR  = m_get_val(RHe,  i, j) * m_get_val(R,  i, j);\n				double vUR = m_get_val(URHe, i, j) * m_get_val(UR, i, j);\n				double vDR = m_get_val(DRHe, i, j) * m_get_val(DR, i, j);\n				double vUL = m_get_val(ULHe, i, j) * m_get_val(UL, i, j);\n				double vDL = m_get_val(DLHe, i, j) * m_get_val(DL, i, j);				\n				double vHe = old_val + mu_over_lambda * (vU + vD + vL + vR + vUR + vDR + vUL + vDL);\n				\n				// Compute IMGVF -= (1 / lambda)(I .* (IMGVF - I))\n				double vI = m_get_val(I, i, j);\n				double new_val = vHe - (one_over_lambda * vI * (vHe - vI));\n				m_set_val(IMGVF, i, j, new_val);\n				\n				// Keep track of the absolute value of the differences\n				//  between this iteration and the previous one\n				total_diff += fabs(new_val - old_val);\n			}\n		}\n		\n		// Compute the mean absolute difference between this iteration\n		//  and the previous one to check for convergence\n		mean_diff = total_diff / (double) (m * n);\n	    \n		iter++;\n	}\n	\n	// Free memory\n	free(rowU); free(rowD); free(colL); free(colR);\n	m_free(U);    m_free(D);    m_free(L);    m_free(R);\n	m_free(UR);   m_free(DR);   m_free(UL);   m_free(DL);\n	m_free(UHe);  m_free(DHe);  m_free(LHe);  m_free(RHe);\n	m_free(URHe); m_free(DRHe); m_free(ULHe); m_free(DLHe);\n\n	return IMGVF;\n}\n\n\n// Regularized version of the Heaviside step function,\n//  parameterized by a small positive number 'e'\nvoid heaviside(MAT *H, MAT *z, double v, double e) {\n	int m = z->m, n = z->n, i, j;\n	\n	// Precompute constants to avoid division in the for loops below\n	double one_over_pi = 1.0 / PI;\n	double one_over_e = 1.0 / e;\n	\n	// Compute H = (1 / pi) * atan((z * v) / e) + 0.5\n	for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double z_val = m_get_val(z, i, j) * v;\n			double H_val = one_over_pi * atan(z_val * one_over_e) + 0.5;\n			m_set_val(H, i, j, H_val);\n		}\n	}\n	\n	// A simpler, faster approximation of the Heaviside function\n	/* for (i = 0; i < m; i++) {\n		for (j = 0; j < n; j++) {\n			double z_val = m_get_val(z, i, j) * v;\n			double H_val = 0.5;\n			if (z_val < -0.0001) H_val = 0.0;\n			else if (z_val > 0.0001) H_val = 1.0;\n			m_set_val(H, i, j, H_val);\n		}\n	} */\n}\n\n\nvoid ellipseevolve(MAT *f, double *xc0, double *yc0, double *r0, double *t, int Np, double Er, double Ey) {\n	/*\n	% ELLIPSEEVOLVE evolves a parametric snake according\n	%  to some energy constraints.\n	%\n	% INPUTS:\n	%   f............potential surface\n	%   xc0,yc0......initial center position\n	%   r0,t.........initial radii & angle vectors (with Np elements each)\n	%   Np...........number of snaxel points per snake\n	%   Er...........expected radius\n	%   Ey...........expected y position\n	%\n	% OUTPUTS\n	%   xc0,yc0.......final center position\n	%   r0...........final radii\n	%\n	% Matlab code written by: DREW GILLIAM (based on work by GANG DONG /\n	%                                                        NILANJAN RAY)\n	% Ported to C by: MICHAEL BOYER\n	*/\n	\n	\n	// Constants\n	double deltax = 0.2;\n	double deltay = 0.2;\n	double deltar = 0.2; \n	double converge = 0.1;\n	double lambdaedge = 1;\n	double lambdasize = 0.2;\n	double lambdapath = 0.05;\n	int iterations = 1000;      // maximum number of iterations\n\n	int i, j;\n\n	// Initialize variables\n	double xc = *xc0;\n	double yc = *yc0;\n	double *r = (double *) malloc(sizeof(double) * Np);\n	for (i = 0; i < Np; i++) r[i] = r0[i];\n	\n	// Compute the x- and y-gradients of the MGVF matrix\n	MAT *fx = gradient_x(f);\n	MAT *fy = gradient_y(f);\n	\n	// Normalize the gradients\n	int fh = f->m, fw = f->n;\n	for (i = 0; i < fh; i++) {\n		for (j = 0; j < fw; j++) {\n			double temp_x = m_get_val(fx, i, j);\n			double temp_y = m_get_val(fy, i, j);\n			double fmag = sqrt((temp_x * temp_x) + (temp_y * temp_y));\n			m_set_val(fx, i, j, temp_x / fmag);\n			m_set_val(fy, i, j, temp_y / fmag);\n		}\n	}\n	\n	double *r_old = (double *) malloc(sizeof(double) * Np);\n	VEC *x = v_get(Np);\n	VEC *y = v_get(Np);\n	\n	\n	// Evolve the snake\n	int iter = 0;\n	double snakediff = 1.0;\n	while (iter < iterations && snakediff > converge) {\n		\n		// Save the values from the previous iteration\n		double xc_old = xc, yc_old = yc;\n		for (i = 0; i < Np; i++) {\n			r_old[i] = r[i];\n		}\n		\n		// Compute the locations of the snaxels\n		for (i = 0; i < Np; i++) {\n			v_set_val(x, i, xc + r[i] * cos(t[i]));\n			v_set_val(y, i, yc + r[i] * sin(t[i]));\n		}\n		\n		// See if any of the points in the snake are off the edge of the image\n		double min_x = v_get_val(x, 0), max_x = v_get_val(x, 0);\n		double min_y = v_get_val(y, 0), max_y = v_get_val(y, 0);\n		for (i = 1; i < Np; i++) {\n			double x_i = v_get_val(x, i);\n			if (x_i < min_x) min_x = x_i;\n			else if (x_i > max_x) max_x = x_i;\n			double y_i = v_get_val(y, i);\n			if (y_i < min_y) min_y = y_i;\n			else if (y_i > max_y) max_y = y_i;\n		}\n		if (min_x < 0.0 || max_x > (double) fw - 1.0 || min_y < 0 || max_y > (double) fh - 1.0) break;\n		\n		\n		// Compute the length of the snake		\n		double L = 0.0;\n		for (i = 0; i < Np - 1; i++) {\n			double diff_x = v_get_val(x, i + 1) - v_get_val(x, i);\n			double diff_y = v_get_val(y, i + 1) - v_get_val(y, i);\n			L += sqrt((diff_x * diff_x) + (diff_y * diff_y));\n		}\n		double diff_x = v_get_val(x, 0) - v_get_val(x, Np - 1);\n		double diff_y = v_get_val(y, 0) - v_get_val(y, Np - 1);\n		L += sqrt((diff_x * diff_x) + (diff_y * diff_y));\n		\n		// Compute the potential surface at each snaxel\n		MAT *vf  = linear_interp2(f,  x, y);\n		MAT *vfx = linear_interp2(fx, x, y);\n		MAT *vfy = linear_interp2(fy, x, y);\n		\n		// Compute the average potential surface around the snake\n		double vfmean  = sum_m(vf ) / L;\n		double vfxmean = sum_m(vfx) / L;\n		double vfymean = sum_m(vfy) / L;\n		\n		// Compute the radial potential surface		\n		int m = vf->m, n = vf->n;\n		MAT *vfr = m_get(m, n);\n		for (i = 0; i < n; i++) {\n			double vf_val  = m_get_val(vf,  0, i);\n			double vfx_val = m_get_val(vfx, 0, i);\n			double vfy_val = m_get_val(vfy, 0, i);\n			double x_val = v_get_val(x, i);\n			double y_val = v_get_val(y, i);\n			double new_val = (vf_val + vfx_val * (x_val - xc) + vfy_val * (y_val - yc) - vfmean) / L;\n			m_set_val(vfr, 0, i, new_val);\n		}		\n		\n		// Update the snake center and snaxels\n		xc =  xc + (deltax * lambdaedge * vfxmean);\n		yc = (yc + (deltay * lambdaedge * vfymean) + (deltay * lambdapath * Ey)) / (1.0 + deltay * lambdapath);\n		double r_diff = 0.0;\n		for (i = 0; i < Np; i++) {\n			r[i] = (r[i] + (deltar * lambdaedge * m_get_val(vfr, 0, i)) + (deltar * lambdasize * Er)) /\n			       (1.0 + deltar * lambdasize);\n			r_diff += fabs(r[i] - r_old[i]);\n		}\n		\n		// Test for convergence\n		snakediff = fabs(xc - xc_old) + fabs(yc - yc_old) + r_diff;\n		\n		// Free temporary matrices\n		m_free(vf);\n		m_free(vfx);\n		m_free(vfy);\n		m_free(vfr);\n	    \n		iter++;\n	}\n	\n	// Set the return values\n	*xc0 = xc;\n	*yc0 = yc;\n	for (i = 0; i < Np; i++)\n		r0[i] = r[i];\n	\n	// Free memory\n	free(r); free(r_old);\n	v_free( x); v_free( y);\n	m_free(fx); m_free(fy);\n}\n	\n\n// Returns the sum of all of the elements in the specified matrix\ndouble sum_m(MAT *matrix) {\n	if (matrix == NULL) return 0.0;	\n	\n	int i, j;\n	double sum = 0.0;\n	for (i = 0; i < matrix->m; i++)\n		for (j = 0; j < matrix->n; j++)\n			sum += m_get_val(matrix, i, j);\n	\n	return sum;\n}\n\n\n// Returns the sum of all of the elements in the specified vector\ndouble sum_v(VEC *vector) {\n	if (vector == NULL) return 0.0;	\n	\n	int i;\n	double sum = 0.0;\n	for (i = 0; i < vector->dim; i++)\n		sum += v_get_val(vector, i);\n	\n	return sum;\n}\n\n\n// Creates a zeroed x-by-y matrix of doubles\ndouble **alloc_2d_double(int x, int y) {\n	if (x < 1 || y < 1) return NULL;\n	\n	// Allocate the data and the pointers to the data\n	double *data = (double *) calloc(x * y, sizeof(double));\n	double **pointers = (double **) malloc(sizeof(double *) * x);\n	\n	// Make the pointers point to the data\n	int i;\n	for (i = 0; i < x; i++) {\n		pointers[i] = data + (i * y);\n	}\n	\n	return pointers;\n}\n\n\n// Creates a zeroed x-by-y-by-z matrix of doubles\ndouble ***alloc_3d_double(int x, int y, int z) {\n	if (x < 1 || y < 1 || z < 1) return NULL;\n	\n	// Allocate the data and the two levels of pointers\n	double *data = (double *) calloc(x * y * z, sizeof(double));\n	double **pointers_to_data = (double **) malloc(sizeof(double *) * x * y);\n	double ***pointers_to_pointers = (double ***) malloc(sizeof(double **) * x);\n	\n	// Make the pointers point to the data\n	int i;\n	for (i = 0; i < x * y; i++) pointers_to_data[i] = data + (i * z);\n	for (i = 0; i < x; i++) pointers_to_pointers[i] = pointers_to_data + (i * y);\n	\n	return pointers_to_pointers;\n}\n\n\n// Frees a 2d matrix generated by the alloc_2d_double function\nvoid free_2d_double(double **p) {\n	if (p != NULL) {\n		if (p[0] != NULL) free(p[0]);\n		free(p);\n	}\n}\n\n\n// Frees a 3d matrix generated by the alloc_3d_double function\nvoid free_3d_double(double ***p) {\n	if (p != NULL) {\n		if (p[0] != NULL) {\n			if (p[0][0] != NULL) free(p[0][0]);\n			free(p[0]);\n		}\n		free(p);\n	}\n}\n"
leukocyte/OpenMP/misc_math.c,"#include ""misc_math.h""\n#include <stdlib.h>\n#include <math.h>\n\n\n#define THRESHOLD_double 0.000001\n\ninline int double_eq(double f1, double f2)\n{\n	return fabs(f1-f2) < THRESHOLD_double;\n}\n\n//Given a matrix, return the matrix containing an approximation of the gradient matrix dM/dx\nMAT * gradient_x(MAT * input)\n{\n	int i, j;\n	MAT * result = m_get(input->m, input->n);\n\n	for(i = 0; i < result->m; i++)\n	{\n		for(j = 0; j < result->n; j++)\n		{\n			if(j==0)\n				m_set_val(result, i, j, m_get_val(input, i, j+1) - m_get_val(input, i, j));\n			else if(j==input->n-1)\n				m_set_val(result, i, j, m_get_val(input, i, j) - m_get_val(input, i, j-1));\n			else\n				m_set_val(result, i, j, (m_get_val(input, i, j+1) - m_get_val(input, i, j-1)) / 2.0);\n		}\n	}\n\n	return result;\n}\n\n//Given a matrix, return the matrix containing an approximation of the gradient matrix dM/dy\nMAT * gradient_y(MAT * input)\n{\n	int i, j;\n	MAT * result = m_get(input->m, input->n);\n	\n	for(i = 0; i < result->n; i++)\n	{\n		for(j = 0; j < result->m; j++)\n		{\n			if(j==0)\n				m_set_val(result, j, i, m_get_val(input, j+1, i) - m_get_val(input, j, i));\n			else if(j==input->m-1)\n				m_set_val(result, j, i, m_get_val(input, j, i) - m_get_val(input, j-1, i));\n			else\n				m_set_val(result, j, i, (m_get_val(input, j+1, i) - m_get_val(input, j-1, i)) / 2.0);\n		}\n	}\n	return result;\n}\n\n//Return the mean of the values in a vector\ndouble mean(VEC * in)\n{\n	double sum = 0.0;\n	int i;\n	for(i = 0; i < in->dim; i++)\n		sum+=v_get_val(in, i);\n\n	return sum/(double)in->dim;\n}\n\n//Return the standard deviation of the values in a vector\ndouble std_dev(VEC * in)\n{\n	double m = mean(in), sum =0.0;\n	int i;\n	for(i = 0; i < in->dim; i++)\n	{\n		double temp = v_get_val(in, i) - m;\n		sum+=temp*temp;\n	}\n	return sqrt(sum/(double)in->dim);\n}\n"
leukocyte/OpenMP/find_ellipse.c,"#include ""find_ellipse.h""\n#include <sys/time.h>\n\n\n// The number of sample points per ellipse\n#define NPOINTS 150\n// The expected radius (in pixels) of a cell\n#define RADIUS 10\n// The range of acceptable radii\n#define MIN_RAD RADIUS - 2\n#define MAX_RAD RADIUS * 2\n// The number of different sample ellipses to try\n#define NCIRCLES 7\n\n\nextern MAT * m_inverse(MAT * A, MAT * out);\n\n\n// Returns the current system time in microseconds\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\n\n// Returns the specified frame from the specified video file\n// If cropped == true, the frame is cropped to pre-determined dimensions\n//  (hardcoded to the boundaries of the blood vessel in the test video)\n// If scaled == true, all values are scaled to the range [0.0, 1.0]\nMAT * get_frame(avi_t *cell_file, int frame_num, int cropped, int scaled) {\n	int dummy;\n	int width = AVI_video_width(cell_file);\n	int height = AVI_video_height(cell_file);\n	unsigned char *image_buf = (unsigned char *) malloc(width * height);\n\n	// There are 600 frames in this file (i.e. frame_num = 600 causes an error)\n	AVI_set_video_position(cell_file, frame_num);\n\n	//Read in the frame from the AVI\n	if(AVI_read_frame(cell_file, (char *)image_buf, &dummy) == -1) {\n		AVI_print_error(""Error with AVI_read_frame"");\n		exit(-1);\n	}\n\n	MAT * image_chopped;\n	if (cropped) {\n		// Crop and flip image so we deal only with the interior of the vein\n		image_chopped = chop_flip_image(image_buf, height, width, TOP, BOTTOM, 0, width - 1, scaled);\n	} else {\n		// Just flip the image\n		image_chopped = chop_flip_image(image_buf, height, width, 0, height - 1, 0, width - 1, scaled);\n	}\n	\n	free(image_buf);\n	\n	return image_chopped;\n}\n\n\n// Flips the specified image and crops it to the specified dimensions\nMAT * chop_flip_image(unsigned char *image, int height, int width, int top, int bottom, int left, int right, int scaled) {\n	MAT * result = m_get(bottom - top + 1, right - left + 1);\n	int i, j;\n	if (scaled) {\n		double scale = 1.0 / 255.0;\n		for(i = 0; i <= (bottom - top); i++)\n			for(j = 0; j <= (right - left); j++)\n				//m_set_val(result, i, j, (double) image[((height - (i + top)) * width) + (j + left)] * scale);\n				  m_set_val(result, i, j, (double) image[((height - 1 - (i + top)) * width) + (j + left)] * scale);\n	} else {\n		for(i = 0; i <= (bottom - top); i++)\n			for(j = 0; j <= (right - left); j++)\n				//m_set_val(result, i, j, (double) image[((height - (i + top)) * width) + (j + left)]);\n				  m_set_val(result, i, j, (double) image[((height - 1 - (i + top)) * width) + (j + left)]);\n	}\n\n	return result;\n}\n\n\n// Given x- and y-gradients of a video frame, computes the GICOV\n//  score for each sample ellipse at every pixel in the frame\nMAT * ellipsematching(MAT * grad_x, MAT * grad_y) {\n	int i, n, k;\n	// Compute the sine and cosine of the angle to each point in each sample circle\n	//  (which are the same across all sample circles)\n	double sin_angle[NPOINTS], cos_angle[NPOINTS], theta[NPOINTS];\n	for (n = 0; n < NPOINTS; n++) {\n		theta[n] = (double) n * 2.0 * PI / (double) NPOINTS;\n		sin_angle[n] = sin(theta[n]);\n		cos_angle[n] = cos(theta[n]);\n	}\n\n	// Compute the (x,y) pixel offsets of each sample point in each sample circle\n	int tX[NCIRCLES][NPOINTS], tY[NCIRCLES][NPOINTS];\n	for (k = 0; k < NCIRCLES; k++) {\n		double rad = (double) (MIN_RAD + 2 * k); \n		for (n = 0; n < NPOINTS; n++) {\n			tX[k][n] = (int) (cos(theta[n]) * rad);\n			tY[k][n] = (int) (sin(theta[n]) * rad);\n		}\n	}\n	\n	int MaxR = MAX_RAD + 2;\n	\n	// Allocate memory for the result matrix\n	int height = grad_x->m, width = grad_x->n;\n	MAT * gicov = m_get(height, width);\n	\n	// Split the work among multiple threads, if OPEN is defined\n	#ifdef OPEN\n	#pragma omp parallel for num_threads(omp_num_threads)\n	#endif\n	// Scan from left to right, top to bottom, computing GICOV values\n	for (i = MaxR; i < width - MaxR; i++) {\n		double Grad[NPOINTS];\n		int j, k, n, x, y;\n		\n		for (j = MaxR; j < height - MaxR; j++) {\n			// Initialize the maximal GICOV score to 0\n			double max_GICOV = 0;	\n			\n			// Iterate across each stencil\n			for (k = 0; k < NCIRCLES; k++) {\n				// Iterate across each sample point in the current stencil\n				for (n = 0; n < NPOINTS; n++)	{\n					// Determine the x- and y-coordinates of the current sample point\n					y = j + tY[k][n];\n					x = i + tX[k][n];\n					\n					// Compute the combined gradient value at the current sample point\n					Grad[n] = m_get_val(grad_x, y, x) * cos_angle[n] + m_get_val(grad_y, y, x) * sin_angle[n];\n				}\n				\n				// Compute the mean gradient value across all sample points\n				double sum = 0.0;\n				for (n = 0; n < NPOINTS; n++) sum += Grad[n];\n				double mean = sum / (double)NPOINTS;\n				\n				// Compute the variance of the gradient values\n				double var = 0.0;				\n				for (n = 0; n < NPOINTS; n++)	{\n					sum = Grad[n] - mean;\n					var += sum * sum;\n				}				\n				var = var / (double) (NPOINTS - 1);\n				\n				// Keep track of the maximal GICOV value seen so far\n				if (mean * mean / var > max_GICOV) {\n					m_set_val(gicov, j, i, mean / sqrt(var));\n					max_GICOV = mean * mean / var;\n				}\n			}\n		}\n	}\n	\n	return gicov;\n}\n\n\n// Returns a circular structuring element of the specified radius\nMAT * structuring_element(int radius) {\n	MAT * result = m_get(radius*2+1, radius*2+1);\n	\n	int i, j;\n	for(i = 0; i < result->m; i++) {\n		for(j = 0; j < result->n; j++) {\n			if(sqrt((float)((i-radius)*(i-radius)+(j-radius)*(j-radius))) <= radius)\n				m_set_val(result, i, j, 1.0);\n			else\n				m_set_val(result, i, j, 0.0);\n		}\n	}\n\n	return result;\n}\n\n\n// Performs an image dilation on the specified matrix\n//  using the specified structuring element\nMAT * dilate_f(MAT * img_in, MAT * strel) {\n	MAT * dilated = m_get(img_in->m, img_in->n);\n	\n	// Find the center of the structuring element\n	int el_center_i = strel->m / 2, el_center_j = strel->n / 2, i;\n	\n	// Split the work among multiple threads, if OPEN is defined\n	#ifdef OPEN\n	#pragma omp parallel for num_threads(omp_num_threads)\n	#endif\n	// Iterate across the input matrix\n	for (i = 0; i < img_in->m; i++) {\n		int j, el_i, el_j, x, y;\n		for (j = 0; j < img_in->n; j++) {\n			double max = 0.0, temp;\n			// Iterate across the structuring element\n			for (el_i = 0; el_i < strel->m; el_i++) {\n				for (el_j = 0; el_j < strel->n; el_j++) {\n					y = i - el_center_i + el_i;\n					x = j - el_center_j + el_j;\n					// Make sure we have not gone off the edge of the matrix\n					if (y >=0 && x >= 0 && y < img_in->m && x < img_in->n && m_get_val(strel, el_i, el_j) != 0) {\n						// Determine if this is maximal value seen so far\n						temp = m_get_val(img_in, y, x);\n						if (temp > max)	max = temp;\n					}\n				}\n			}\n			// Store the maximum value found\n			m_set_val(dilated, i, j, max);\n		}\n	}\n\n	return dilated;\n}\n\n\n//M = # of sampling points in each segment\n//N = number of segment of curve\n//Get special TMatrix\nMAT * TMatrix(unsigned int N, unsigned int M)\n{\n	MAT * B = NULL, * LB = NULL, * B_TEMP = NULL, * B_TEMP_INV = NULL, * B_RET = NULL;\n	int * aindex, * bindex, * cindex, * dindex;\n	int i, j;\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n\n	B = m_get(N*M, N);\n	LB = m_get(M, N);\n\n	for(i = 0; i < N; i++)\n	{\n		m_zero(LB);\n		\n		for(j = 0; j < M; j++)\n		{\n			double s = (double)j / (double)M;\n			double a, b, c, d;\n\n			a = (-1.0*s*s*s + 3.0*s*s - 3.0*s + 1.0) / 6.0;\n			b = (3.0*s*s*s - 6.0*s*s + 4.0) / 6.0;\n			c = (-3.0*s*s*s + 3.0*s*s + 3.0*s + 1.0) / 6.0;\n			d = s*s*s / 6.0;\n\n			m_set_val(LB, j, aindex[i], a);\n			m_set_val(LB, j, bindex[i], b);\n			m_set_val(LB, j, cindex[i], c);\n			m_set_val(LB, j, dindex[i], d);\n		}\n		int m, n;\n\n		for(m = i*M; m < (i+1)*M; m++)\n			for(n = 0; n < N; n++)\n				m_set_val(B, m, n, m_get_val(LB, m%M, n));\n	}\n\n	B_TEMP = mtrm_mlt(B, B, B_TEMP);\n	B_TEMP_INV = m_inverse(B_TEMP, B_TEMP_INV);\n	B_RET = mmtr_mlt(B_TEMP_INV, B, B_RET);\n	\n	m_free(B);\n	m_free(LB);\n	m_free(B_TEMP);\n	m_free(B_TEMP_INV);\n\n	free(dindex);\n	free(cindex);\n	free(bindex);\n	free(aindex);\n\n	return B_RET;\n}\n\nvoid uniformseg(VEC * cellx_row, VEC * celly_row, MAT * x, MAT * y)\n{\n	double dx[36], dy[36], dist[36], dsum[36], perm = 0.0, uperm;\n	int i, j, index[36];\n\n	for(i = 1; i <= 36; i++)\n	{\n		dx[i%36] = v_get_val(cellx_row, i%36) - v_get_val(cellx_row, (i-1)%36);\n		dy[i%36] = v_get_val(celly_row, i%36) - v_get_val(celly_row, (i-1)%36);\n		dist[i%36] = sqrt(dx[i%36]*dx[i%36] + dy[i%36]*dy[i%36]);\n		perm+= dist[i%36];\n	}\n	uperm = perm / 36.0;\n	dsum[0] = dist[0];\n	for(i = 1; i < 36; i++)\n		dsum[i] = dsum[i-1]+dist[i];\n\n	for(i = 0; i < 36; i++)\n	{\n		double minimum=DBL_MAX, temp;\n		int min_index = 0;\n		for(j = 0; j < 36; j++)\n		{\n			temp = fabs(dsum[j]- (double)i*uperm);\n			if (temp < minimum)\n			{\n				minimum = temp;\n				min_index = j;\n			}\n		}\n		index[i] = min_index;\n	}\n\n	for(i = 0; i < 36; i++)\n	{\n		m_set_val(x, 0, i, v_get_val(cellx_row, index[i]));\n		m_set_val(y, 0, i, v_get_val(celly_row, index[i]));\n	}\n}\n\n//Get minimum element in a matrix\ndouble m_min(MAT * m)\n{\n	int i, j;\n	double minimum = DBL_MAX, temp;\n	for(i = 0; i < m->m; i++)\n	{\n		for(j = 0; j < m->n; j++)\n		{\n			temp = m_get_val(m, i, j);\n			if(temp < minimum)\n				minimum = temp;\n		}\n	}\n	return minimum;\n}\n\n//Get maximum element in a matrix\ndouble m_max(MAT * m)\n{\n	int i, j;\n	double maximum = DBL_MIN, temp;\n	for(i = 0; i < m->m; i++)\n	{\n		for(j = 0; j < m->n; j++)\n		{\n			temp = m_get_val(m, i, j);\n			if(temp > maximum)\n				maximum = temp;\n		}\n	}\n	return maximum;\n}\n\nVEC * getsampling(MAT * m, int ns)\n{\n	int N = m->n > m->m ? m-> n:m->m, M = ns;\n	int * aindex, * bindex, * cindex, * dindex;\n	int i, j;\n	VEC * retval = v_get(N*M);\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n	for(i = 0; i < N; i++)\n	{\n		for(j = 0; j < M; j++)\n		{\n			double s = (double)j / (double)M;\n			double a, b, c, d;\n\n			a = m_get_val(m, 0, aindex[i]) * (-1.0*s*s*s + 3.0*s*s - 3.0*s + 1.0);\n			b = m_get_val(m, 0, bindex[i]) * (3.0*s*s*s - 6.0*s*s + 4.0);\n			c = m_get_val(m, 0, cindex[i]) * (-3.0*s*s*s + 3.0*s*s + 3.0*s + 1.0);\n			d = m_get_val(m, 0, dindex[i]) * s*s*s;\n			v_set_val(retval, i*M+j,(a+b+c+d)/6.0);\n\n		}\n	}\n\n	free(dindex);\n	free(cindex);\n	free(bindex);\n	free(aindex);\n\n	return retval;\n}\n\nVEC * getfdriv(MAT * m, int ns)\n{\n	int N = m->n > m->m ? m-> n:m->m, M = ns;\n	int * aindex, * bindex, * cindex, * dindex;\n	int i, j;\n	VEC * retval = v_get(N*M);\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n	for(i = 0; i < N; i++)\n	{\n		for(j = 0; j < M; j++)\n		{\n			double s = (double)j / (double)M;\n			double a, b, c, d;\n\n			a = m_get_val(m, 0, aindex[i]) * (-3.0*s*s + 6.0*s - 3.0);\n			b = m_get_val(m, 0, bindex[i]) * (9.0*s*s - 12.0*s);\n			c = m_get_val(m, 0, cindex[i]) * (-9.0*s*s + 6.0*s + 3.0);\n			d = m_get_val(m, 0, dindex[i]) * (3.0 *s*s);\n			v_set_val(retval, i*M+j, (a+b+c+d)/6.0);\n\n		}\n	}\n\n	free(dindex);\n	free(cindex);\n	free(bindex);\n	free(aindex);\n\n	return retval;\n}\n\n//Performs bilinear interpolation, getting the values of m specified in the vectors X and Y\nMAT * linear_interp2(MAT * m, VEC * X, VEC * Y)\n{\n	//Kind of assumes X and Y have same len!\n\n	MAT * retval = m_get(1, X->dim);\n	double x_coord, y_coord, new_val, a, b;\n	int l, k, i;\n\n	for(i = 0; i < X->dim; i++)\n	{\n		x_coord = v_get_val(X, i);\n		y_coord = v_get_val(Y, i);\n\n		l = (int)x_coord;\n		k = (int)y_coord;\n\n		a = x_coord - (double)l;\n		b = y_coord - (double)k;\n\n		//printf(""xc: %f \t yc: %f \t i: %d \t l: %d \t k: %d \t a: %f \t b: %f\n"", x_coord, y_coord, i, l, k, a, b);\n\n		new_val = (1.0-a)*(1.0-b)*m_get_val(m, k, l) +\n				  a*(1.0-b)*m_get_val(m, k, l+1) +\n				  (1.0-a)*b*m_get_val(m, k+1, l) +\n				  a*b*m_get_val(m, k+1, l+1);\n\n		m_set_val(retval, 0, i, new_val);\n	}\n\n	return retval;\n}\n\nvoid splineenergyform01(MAT * Cx, MAT * Cy, MAT * Ix, MAT * Iy, int ns, double delta, double dt, int typeofcell)\n{\n	VEC * X, * Y, * Xs, * Ys, * Nx, * Ny, * X1, * Y1, * X2, * Y2, *	XY, * XX, * YY, * dCx, * dCy, * Ix1, * Ix2, *Iy1, *Iy2;\n	MAT * Ix1_mat, * Ix2_mat, * Iy1_mat, * Iy2_mat;\n	int i,j, N, * aindex, * bindex, * cindex, * dindex;\n\n	X = getsampling(Cx, ns);\n	Y = getsampling(Cy, ns);\n	Xs = getfdriv(Cx, ns);\n	Ys = getfdriv(Cy, ns);\n\n	Nx = v_get(Ys->dim);\n	for(i = 0; i < Nx->dim; i++)\n		v_set_val(Nx, i, v_get_val(Ys, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n\n	Ny = v_get(Xs->dim);\n	for(i = 0; i < Ny->dim; i++)\n		v_set_val(Ny, i, -1.0 * v_get_val(Xs, i) / sqrt(v_get_val(Xs, i)*v_get_val(Xs, i) + v_get_val(Ys, i)*v_get_val(Ys, i)));\n	\n	X1 = v_get(Nx->dim);\n	for(i = 0; i < X1->dim; i++)\n		v_set_val(X1, i, v_get_val(X, i) + delta*v_get_val(Nx, i));\n\n	Y1 = v_get(Ny->dim);\n	for(i = 0; i < Y1->dim; i++)\n		v_set_val(Y1, i, v_get_val(Y, i) + delta*v_get_val(Ny, i));\n\n	X2 = v_get(Nx->dim);\n	for(i = 0; i < X2->dim; i++)\n		v_set_val(X2, i, v_get_val(X, i) - delta*v_get_val(Nx, i));\n\n	Y2 = v_get(Ny->dim);\n	for(i = 0; i < Y2->dim; i++)\n		v_set_val(Y2, i, v_get_val(Y, i) + delta*v_get_val(Ny, i));\n\n	Ix1_mat = linear_interp2(Ix, X1, Y1);\n	Iy1_mat = linear_interp2(Iy, X1, Y1);\n	Ix2_mat = linear_interp2(Ix, X2, Y2);\n	Iy2_mat = linear_interp2(Iy, X2, Y2);\n\n	Ix1 = v_get(Ix1_mat->n);\n	Iy1 = v_get(Iy1_mat->n);\n	Ix2 = v_get(Ix2_mat->n);\n	Iy2 = v_get(Iy2_mat->n);\n\n	Ix1 = get_row(Ix1_mat, 0, Ix1);\n	Iy1 = get_row(Iy1_mat, 0, Iy1);\n	Ix2 = get_row(Ix2_mat, 0, Ix2);\n	Iy2 = get_row(Iy2_mat, 0, Iy2);\n\n	N = Cx->m;\n\n	//VEC * retval = v_get(N*ns);\n\n	aindex = malloc(N*sizeof(int));\n	bindex = malloc(N*sizeof(int));\n	cindex = malloc(N*sizeof(int));\n	dindex = malloc(N*sizeof(int));\n\n	for(i = 1; i < N; i++)\n		aindex[i] = i-1;\n	aindex[0] = N-1;\n\n	for(i = 0; i < N; i++)\n		bindex[i] = i;\n	\n	for(i = 0; i < N-1; i++)\n		cindex[i] = i+1;\n	cindex[N-1] = 0;\n\n	for(i = 0; i < N-2; i++)\n		dindex[i] = i+2;\n	dindex[N-2] = 0;\n	dindex[N-1] = 1;\n\n	XY = v_get(Xs->dim);\n	for(i = 0; i < Xs->dim; i++)\n		v_set_val(XY, i, v_get_val(Xs, i) * v_get_val(Ys, i));\n\n	XX = v_get(Xs->dim);\n	for(i = 0; i < Xs->dim; i++)\n		v_set_val(XX, i, v_get_val(Xs, i) * v_get_val(Xs, i));\n\n	YY = v_get(Ys->dim);\n	for(i = 0; i < Xs->dim; i++)\n		v_set_val(YY, i, v_get_val(Ys, i) * v_get_val(Ys, i));\n\n	dCx = v_get(Cx->m);\n	dCy = v_get(Cy->m);\n\n	//get control points for splines\n	for(i = 0; i < Cx->m; i++)\n	{\n		for(j = 0; j < ns; j++)\n		{\n			double s = (double)j / (double)ns;\n			double A1, A2, A3, A4, B1, B2, B3, B4, D, D_3, Tx1, Tx2, Tx3, Tx4, Ty1, Ty2, Ty3, Ty4;\n			int k;\n\n			A1 = (-1.0*(s-1.0)*(s-1.0)*(s-1.0)) / 6.0;\n			A2 = (3.0*s*s*s - 6.0*s*s + 4.0) / 6.0;\n			A3 = (-3.0*s*s*s + 3.0*s*s + 3.0*s + 1.0) / 6.0;\n			A4 = s*s*s / 6.0;\n\n			B1 = (-3.0*s*s + 6.0*s - 3.0) / 6.0;\n			B2 = (9.0*s*s - 12.0*s) / 6.0;\n			B3 = (-9.0*s*s + 6.0*s + 3.0) / 6.0;\n			B4 = 3.0*s*s / 6.0;\n\n			k = i*ns+j;\n			D = sqrt(v_get_val(Xs, k)*v_get_val(Xs, k) + v_get_val(Ys, k)*v_get_val(Ys, k));\n			D_3 = D*D*D;\n			\n			//1st control point\n			\n			Tx1 = A1 - delta * v_get_val(XY, k) * B1 / D_3;\n			Tx2 = -1.0 * delta*(B1/D - v_get_val(XX, k)*B1/D_3);\n			Tx3 = A1 + delta * v_get_val(XY, k) * B1 / D_3;\n			Tx4 = delta*(B1/D - v_get_val(XX, k)*B1/D_3);\n\n			Ty1 = delta*(B1/D - v_get_val(YY, k)*B1/D_3);\n			Ty2 = A1 + delta * v_get_val(XY, k) * B1 / D_3;\n			Ty3 = -1.0 * delta*(B1/D - v_get_val(YY, k)*B1/D_3);\n			Ty4 = A1 - delta * v_get_val(XY, k) * B1 / D_3;\n\n			v_set_val(dCx, aindex[i], v_get_val(dCx, aindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, aindex[i], v_get_val(dCy, aindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));\n		\n			//2nd control point\n\n			Tx1 = A2 - delta * v_get_val(XY, k) * B2 / D_3;\n			Tx2 = -1.0 * delta*(B2/D - v_get_val(XX, k)*B2/D_3);\n			Tx3 = A2 + delta * v_get_val(XY, k) * B2 / D_3;\n			Tx4 = delta*(B2/D - v_get_val(XX, k)*B2/D_3);\n\n			Ty1 = delta*(B2/D - v_get_val(YY, k)*B2/D_3);\n			Ty2 = A2 + delta * v_get_val(XY, k) * B2 / D_3;\n			Ty3 = -1.0 * delta*(B2/D - v_get_val(YY, k)*B2/D_3);\n			Ty4 = A2 - delta * v_get_val(XY, k) * B2 / D_3;\n\n			v_set_val(dCx, bindex[i], v_get_val(dCx, bindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, bindex[i], v_get_val(dCy, bindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));\n\n			//3nd control point\n\n			Tx1 = A3 - delta * v_get_val(XY, k) * B3 / D_3;\n			Tx2 = -1.0 * delta*(B3/D - v_get_val(XX, k)*B3/D_3);\n			Tx3 = A3 + delta * v_get_val(XY, k) * B3 / D_3;\n			Tx4 = delta*(B3/D - v_get_val(XX, k)*B3/D_3);\n\n			Ty1 = delta*(B3/D - v_get_val(YY, k)*B3/D_3);\n			Ty2 = A3 + delta * v_get_val(XY, k) * B3 / D_3;\n			Ty3 = -1.0 * delta*(B3/D - v_get_val(YY, k)*B3/D_3);\n			Ty4 = A3 - delta * v_get_val(XY, k) * B3 / D_3;\n\n			v_set_val(dCx, cindex[i], v_get_val(dCx, cindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, cindex[i], v_get_val(dCy, cindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));\n	\n			//4nd control point\n\n			Tx1 = A4 - delta * v_get_val(XY, k) * B4 / D_3;\n			Tx2 = -1.0 * delta*(B4/D - v_get_val(XX, k)*B4/D_3);\n			Tx3 = A4 + delta * v_get_val(XY, k) * B4 / D_3;\n			Tx4 = delta*(B4/D - v_get_val(XX, k)*B4/D_3);\n\n			Ty1 = delta*(B4/D - v_get_val(YY, k)*B4/D_3);\n			Ty2 = A4 + delta * v_get_val(XY, k) * B4 / D_3;\n			Ty3 = -1.0 * delta*(B4/D - v_get_val(YY, k)*B4/D_3);\n			Ty4 = A4 - delta * v_get_val(XY, k) * B4 / D_3;\n\n			v_set_val(dCx, dindex[i], v_get_val(dCx, dindex[i]) + Tx1*v_get_val(Ix1, k) + Tx2*v_get_val(Iy1,k) - Tx3*v_get_val(Ix2, k) - Tx4*v_get_val(Iy2, k));\n			v_set_val(dCy, dindex[i], v_get_val(dCy, dindex[i]) + Ty1*v_get_val(Ix1, k) + Ty2*v_get_val(Iy1,k) - Ty3*v_get_val(Ix2, k) - Ty4*v_get_val(Iy2, k));		\n		}\n	}\n\n	if(typeofcell==1)\n	{\n		for(i = 0; i < Cx->n; i++)\n			m_set_val(Cx, 0, i, m_get_val(Cx, 1, i) - dt*v_get_val(dCx, i));\n\n		for(i = 0; i < Cy->n; i++)\n			m_set_val(Cy, 0, i, m_get_val(Cy, 1, i) - dt*v_get_val(dCy, i));\n	}\n	else\n	{\n		for(i = 0; i < Cx->n; i++)\n			m_set_val(Cx, 0, i, m_get_val(Cx, 1, i) + dt*v_get_val(dCx, i));\n\n		for(i = 0; i < Cy->n; i++)\n			m_set_val(Cy, 0, i, m_get_val(Cy, 1, i) + dt*v_get_val(dCy, i));\n	}\n\n	v_free(dCy); v_free(dCx); v_free(YY); v_free(XX); v_free(XY);\n\n	free(dindex); free(cindex); free(bindex); free(aindex); \n\n	v_free(Iy2); v_free(Ix2); v_free(Iy1); v_free(Ix1); \n\n	m_free(Iy2_mat); m_free(Ix2_mat); m_free(Iy1_mat); m_free(Ix1_mat); \n\n	v_free(Y2); v_free(X2); v_free(Y1); v_free(X1); v_free(Ny); v_free(Nx); v_free(Ys); v_free(Xs); v_free(Y); v_free(X); \n}\n"
leukocyte/meschach_lib/splufctr.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Sparse LU factorisation\n	See also: sparse.[ch] etc for details about sparse matrices\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""sparse2.h""\n\n\n\n/* Macro for speedup */\n/* #define	sprow_idx2(r,c,hint)	\\n   ( ( (hint) >= 0 && (r)->elt[hint].col == (c)) ? hint : sprow_idx((r),(c)) ) */\n\n\n/* spLUfactor -- sparse LU factorisation with pivoting\n	-- uses partial pivoting and Markowitz criterion\n			|a[p][k]| >= alpha * max_i |a[i][k]|\n	-- creates fill-in as needed\n	-- in situ factorisation */\n#ifndef ANSI_C\nSPMAT	*spLUfactor(A,px,alpha)\nSPMAT	*A;\nPERM	*px;\ndouble	alpha;\n#else\nSPMAT	*spLUfactor(SPMAT *A, PERM *px, double alpha)\n#endif\n{\n	int	i, best_i, k, idx, len, best_len, m, n;\n	SPROW	*r, *r_piv, tmp_row;\n	STATIC	SPROW	*merge = (SPROW *)NULL;\n	Real	max_val, tmp;\n	STATIC VEC	*col_vals=VNULL;\n\n	if ( ! A || ! px )\n		error(E_NULL,""spLUfctr"");\n	if ( alpha <= 0.0 || alpha > 1.0 )\n		error(E_RANGE,""alpha in spLUfctr"");\n	if ( px->size <= A->m )\n		px = px_resize(px,A->m);\n	px_ident(px);\n	col_vals = v_resize(col_vals,A->m);\n	MEM_STAT_REG(col_vals,TYPE_VEC);\n\n	m = A->m;	n = A->n;\n	if ( ! A->flag_col )\n		sp_col_access(A);\n	if ( ! A->flag_diag )\n		sp_diag_access(A);\n	A->flag_col = A->flag_diag = FALSE;\n	if ( ! merge ) {\n	   merge = sprow_get(20);\n	   MEM_STAT_REG(merge,TYPE_SPROW);\n	}\n\n	for ( k = 0; k < n; k++ )\n	{\n	    /* find pivot row/element for partial pivoting */\n\n	    /* get first row with a non-zero entry in the k-th column */\n	    max_val = 0.0;\n	    for ( i = k; i < m; i++ )\n	    {\n		r = &(A->row[i]);\n		idx = sprow_idx(r,k);\n		if ( idx < 0 )\n		    tmp = 0.0;\n		else\n		    tmp = r->elt[idx].val;\n		if ( fabs(tmp) > max_val )\n		    max_val = fabs(tmp);\n		col_vals->ve[i] = tmp;\n	    }\n\n	    if ( max_val == 0.0 )\n		continue;\n\n	    best_len = n+1;	/* only if no possibilities */\n	    best_i = -1;\n	    for ( i = k; i < m; i++ )\n	    {\n		tmp = fabs(col_vals->ve[i]);\n		if ( tmp == 0.0 )\n		    continue;\n		if ( tmp >= alpha*max_val )\n		{\n		    r = &(A->row[i]);\n		    idx = sprow_idx(r,k);\n		    len = (r->len) - idx;\n		    if ( len < best_len )\n		    {\n			best_len = len;\n			best_i = i;\n		    }\n		}\n	    }\n\n	    /* swap row #best_i with row #k */\n	    MEM_COPY(&(A->row[best_i]),&tmp_row,sizeof(SPROW));\n	    MEM_COPY(&(A->row[k]),&(A->row[best_i]),sizeof(SPROW));\n	    MEM_COPY(&tmp_row,&(A->row[k]),sizeof(SPROW));\n	    /* swap col_vals entries */\n	    tmp = col_vals->ve[best_i];\n	    col_vals->ve[best_i] = col_vals->ve[k];\n	    col_vals->ve[k] = tmp;\n	    px_transp(px,k,best_i);\n\n	    r_piv = &(A->row[k]);\n	    for ( i = k+1; i < n; i++ )\n	    {\n		/* compute and set multiplier */\n		tmp = col_vals->ve[i]/col_vals->ve[k];\n		if ( tmp != 0.0 )\n		    sp_set_val(A,i,k,tmp);\n		else\n		    continue;\n\n		/* perform row operations */\n		merge->len = 0;\n		r = &(A->row[i]);\n		sprow_mltadd(r,r_piv,-tmp,k+1,merge,TYPE_SPROW);\n		idx = sprow_idx(r,k+1);\n		if ( idx < 0 )\n		    idx = -(idx+2);\n		/* see if r needs expanding */\n		if ( r->maxlen < idx + merge->len )\n		    sprow_xpd(r,idx+merge->len,TYPE_SPMAT);\n		r->len = idx+merge->len;\n		MEM_COPY((char *)(merge->elt),(char *)&(r->elt[idx]),\n			merge->len*sizeof(row_elt));\n	    }\n	}\n#ifdef	THREADSAFE\n	sprow_free(merge);	V_FREE(col_vals);\n#endif\n\n	return A;\n}\n\n/* spLUsolve -- solve A.x = b using factored matrix A from spLUfactor()\n	-- returns x\n	-- may not be in-situ */\n#ifndef ANSI_C\nVEC	*spLUsolve(A,pivot,b,x)\nSPMAT	*A;\nPERM	*pivot;\nVEC	*b, *x;\n#else\nVEC	*spLUsolve(const SPMAT *A, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	int	i, idx, len, lim;\n	Real	sum, *x_ve;\n	SPROW	*r;\n	row_elt	*elt;\n\n	if ( ! A || ! b )\n	    error(E_NULL,""spLUsolve"");\n	if ( (pivot != PNULL && A->m != pivot->size) || A->m != b->dim )\n	    error(E_SIZES,""spLUsolve"");\n	if ( ! x || x->dim != A->n )\n	    x = v_resize(x,A->n);\n\n	if ( pivot != PNULL )\n	    x = px_vec(pivot,b,x);\n	else\n	    x = v_copy(b,x);\n\n	x_ve = x->ve;\n	lim = min(A->m,A->n);\n	for ( i = 0; i < lim; i++ )\n	{\n	    sum = x_ve[i];\n	    r = &(A->row[i]);\n	    len = r->len;\n	    elt = r->elt;\n	    for ( idx = 0; idx < len && elt->col < i; idx++, elt++ )\n		sum -= elt->val*x_ve[elt->col];\n	    x_ve[i] = sum;\n	}\n\n	for ( i = lim-1; i >= 0; i-- )\n	{\n	    sum = x_ve[i];\n	    r = &(A->row[i]);\n	    len = r->len;\n	    elt = &(r->elt[len-1]);\n	    for ( idx = len-1; idx >= 0 && elt->col > i; idx--, elt-- )\n		sum -= elt->val*x_ve[elt->col];\n	    if ( idx < 0 || elt->col != i || elt->val == 0.0 )\n		error(E_SING,""spLUsolve"");\n	    x_ve[i] = sum/elt->val;\n	}\n\n	return x;\n}\n\n/* spLUTsolve -- solve A.x = b using factored matrix A from spLUfactor()\n	-- returns x\n	-- may not be in-situ */\n#ifndef ANSI_C\nVEC	*spLUTsolve(A,pivot,b,x)\nSPMAT	*A;\nPERM	*pivot;\nVEC	*b, *x;\n#else\nVEC	*spLUTsolve(SPMAT *A, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	int	i, idx, lim, rownum;\n	Real	sum, *tmp_ve;\n	/* SPROW	*r; */\n	row_elt	*elt;\n	STATIC VEC	*tmp=VNULL;\n\n	if ( ! A || ! b )\n	    error(E_NULL,""spLUTsolve"");\n	if ( (pivot != PNULL && A->m != pivot->size) || A->m != b->dim )\n	    error(E_SIZES,""spLUTsolve"");\n	tmp = v_copy(b,tmp);\n	MEM_STAT_REG(tmp,TYPE_VEC);\n\n	if ( ! A->flag_col )\n	    sp_col_access(A);\n	if ( ! A->flag_diag )\n	    sp_diag_access(A);\n\n	lim = min(A->m,A->n);\n	tmp_ve = tmp->ve;\n	/* solve U^T.tmp = b */\n	for ( i = 0; i < lim; i++ )\n	{\n	    sum = tmp_ve[i];\n	    rownum = A->start_row[i];\n	    idx    = A->start_idx[i];\n	    if ( rownum < 0 || idx < 0 )\n		error(E_SING,""spLUTsolve"");\n	    while ( rownum < i && rownum >= 0 && idx >= 0 )\n	    {\n		elt = &(A->row[rownum].elt[idx]);\n		sum -= elt->val*tmp_ve[rownum];\n		rownum = elt->nxt_row;\n		idx    = elt->nxt_idx;\n	    }\n	    if ( rownum != i )\n		error(E_SING,""spLUTsolve"");\n	    elt = &(A->row[rownum].elt[idx]);\n	    if ( elt->val == 0.0 )\n		error(E_SING,""spLUTsolve"");\n	    tmp_ve[i] = sum/elt->val;\n	}\n\n	/* now solve L^T.tmp = (old) tmp */\n	for ( i = lim-1; i >= 0; i-- )\n	{\n	    sum = tmp_ve[i];\n	    rownum = i;\n	    idx    = A->row[rownum].diag;\n	    if ( idx < 0 )\n		error(E_NULL,""spLUTsolve"");\n	    elt = &(A->row[rownum].elt[idx]);\n	    rownum = elt->nxt_row;\n	    idx    = elt->nxt_idx;\n	    while ( rownum < lim && rownum >= 0 && idx >= 0 )\n	    {\n		elt = &(A->row[rownum].elt[idx]);\n		sum -= elt->val*tmp_ve[rownum];\n		rownum = elt->nxt_row;\n		idx    = elt->nxt_idx;\n	    }\n	    tmp_ve[i] = sum;\n	}\n\n	if ( pivot != PNULL )\n	    x = pxinv_vec(pivot,tmp,x);\n	else\n	    x = v_copy(tmp,x);\n\n#ifdef	THREADSAFE\n	V_FREE(tmp);\n#endif\n\n	return x;\n}\n\n/* spILUfactor -- sparse modified incomplete LU factorisation with\n						no pivoting\n	-- all pivot entries are ensured to be >= alpha in magnitude\n	-- setting alpha = 0 gives incomplete LU factorisation\n	-- no fill-in is generated\n	-- in situ factorisation */\n#ifndef ANSI_C\nSPMAT	*spILUfactor(A,alpha)\nSPMAT	*A;\ndouble	alpha;\n#else\nSPMAT	*spILUfactor(SPMAT *A, double alpha)\n#endif\n{\n    int		i, k, idx, idx_piv, m, n, old_idx, old_idx_piv;\n    SPROW	*r, *r_piv;\n    Real	piv_val, tmp;\n    \n    /* printf(""spILUfactor: entered\n""); */\n    if ( ! A )\n	error(E_NULL,""spILUfactor"");\n    if ( alpha < 0.0 )\n	error(E_RANGE,""[alpha] in spILUfactor"");\n    \n    m = A->m;	n = A->n;\n    sp_diag_access(A);\n    sp_col_access(A);\n    \n    for ( k = 0; k < n; k++ )\n    {\n	/* printf(""spILUfactor(l.%d): checkpoint A: k = %d\n"",__LINE__,k); */\n	/* printf(""spILUfactor(l.%d): A =\n"", __LINE__); */\n	/* sp_output(A); */\n	r_piv = &(A->row[k]);\n	idx_piv = r_piv->diag;\n	if ( idx_piv < 0 )\n	{\n	    sprow_set_val(r_piv,k,alpha);\n	    idx_piv = sprow_idx(r_piv,k);\n	}\n	/* printf(""spILUfactor: checkpoint B\n""); */\n	if ( idx_piv < 0 )\n	    error(E_BOUNDS,""spILUfactor"");\n	old_idx_piv = idx_piv;\n	piv_val = r_piv->elt[idx_piv].val;\n	/* printf(""spILUfactor: checkpoint C\n""); */\n	if ( fabs(piv_val) < alpha )\n	    piv_val = ( piv_val < 0.0 ) ? -alpha : alpha;\n	if ( piv_val == 0.0 )	/* alpha == 0.0 too! */\n	    error(E_SING,""spILUfactor"");\n\n	/* go to next row with a non-zero in this column */\n	i = r_piv->elt[idx_piv].nxt_row;\n	old_idx = idx = r_piv->elt[idx_piv].nxt_idx;\n	while ( i >= k )\n	{\n	    /* printf(""spILUfactor: checkpoint D: i = %d\n"",i); */\n	    /* perform row operations */\n	    r = &(A->row[i]);\n	    /* idx = sprow_idx(r,k); */\n	    /* printf(""spLUfactor(l.%d) i = %d, idx = %d\n"",\n		   __LINE__, i, idx); */\n	    if ( idx < 0 )\n	    {\n		idx = r->elt[old_idx].nxt_idx;\n		i = r->elt[old_idx].nxt_row;\n		continue;\n	    }\n	    /* printf(""spILUfactor: checkpoint E\n""); */\n	    /* compute and set multiplier */\n	    r->elt[idx].val = tmp = r->elt[idx].val/piv_val;\n	    /* printf(""spILUfactor: piv_val = %g, multiplier = %g\n"",\n		   piv_val, tmp); */\n	    /* printf(""spLUfactor(l.%d) multiplier = %g\n"", __LINE__, tmp); */\n	    if ( tmp == 0.0 )\n	    {\n		idx = r->elt[old_idx].nxt_idx;\n		i = r->elt[old_idx].nxt_row;\n		continue;\n	    }\n	    /* idx = sprow_idx(r,k+1); */\n	    /* if ( idx < 0 )\n		idx = -(idx+2); */\n	    idx_piv++;	idx++;	/* now look beyond the multiplier entry */\n	    /* printf(""spILUfactor: checkpoint F: idx = %d, idx_piv = %d\n"",\n		   idx, idx_piv); */\n	    while ( idx_piv < r_piv->len && idx < r->len )\n	    {\n		/* printf(""spILUfactor: checkpoint G: idx = %d, idx_piv = %d\n"",\n		       idx, idx_piv); */\n		if ( r_piv->elt[idx_piv].col < r->elt[idx].col )\n		    idx_piv++;\n		else if ( r_piv->elt[idx_piv].col > r->elt[idx].col )\n		    idx++;\n		else /* column numbers match */\n		{\n		    /* printf(""spILUfactor(l.%d) subtract %g times the "",\n			   __LINE__, tmp); */\n		    /* printf(""(%d,%d) entry to the (%d,%d) entry\n"",\n			   k, r_piv->elt[idx_piv].col,\n			   i, r->elt[idx].col); */\n		    r->elt[idx].val -= tmp*r_piv->elt[idx_piv].val;\n		    idx++;	idx_piv++;\n		}\n	    }\n\n	    /* bump to next row with a non-zero in column k */\n	    /* printf(""spILUfactor(l.%d) column = %d, row[%d] =\n"",\n		   __LINE__, r->elt[old_idx].col, i); */\n	    /* sprow_foutput(stdout,r); */\n	    i = r->elt[old_idx].nxt_row;\n	    old_idx = idx = r->elt[old_idx].nxt_idx;\n	    /* printf(""spILUfactor(l.%d) i = %d, idx = %d\n"", __LINE__, i, idx); */\n	    /* and restore idx_piv to index of pivot entry */\n	    idx_piv = old_idx_piv;\n	}\n    }\n    /* printf(""spILUfactor: exiting\n""); */\n    return A;\n}\n"
leukocyte/meschach_lib/iter0.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* iter0.c  14/09/93 */\n\n/* ITERATIVE METHODS - service functions */\n\n/* functions for creating and releasing ITER structures;\n   for memory information;\n   for getting some values from an ITER variable;\n   for changing values in an ITER variable;\n   see also iter.c\n*/\n\n#include        <stdio.h>\n#include	<math.h>\n#include        ""iter.h""\n\n\nstatic char rcsid[] = ""$Id: iter0.c,v 1.3 1995/01/30 14:50:56 des Exp $"";\n\n\n/* standard functions */\n\n/* standard information */\n#ifndef ANSI_C\nvoid iter_std_info(ip,nres,res,Bres)\nITER *ip;\ndouble nres;\nVEC *res, *Bres;\n#else\nvoid iter_std_info(const ITER *ip, double nres, VEC *res, VEC *Bres)\n#endif\n{\n   if (nres >= 0.0)\n#ifndef MEX\n     printf("" %d. residual = %g\n"",ip->steps,nres);\n#else\n     mexPrintf("" %d. residual = %g\n"",ip->steps,nres);\n#endif\n   else \n#ifndef MEX\n     printf("" %d. residual = %g (WARNING !!! should be >= 0) \n"",\n	    ip->steps,nres);\n#else\n     mexPrintf("" %d. residual = %g (WARNING !!! should be >= 0) \n"",\n	       ip->steps,nres);\n#endif\n}\n\n/* standard stopping criterion */\n#ifndef ANSI_C\nint iter_std_stop_crit(ip, nres, res, Bres)\nITER *ip;\ndouble nres;\nVEC *res, *Bres;\n#else\nint iter_std_stop_crit(const ITER *ip, double nres, VEC *res, VEC *Bres)\n#endif\n{\n   /* standard stopping criterium */\n   if (nres <= ip->init_res*ip->eps) return TRUE; \n   return FALSE;\n}\n\n\n/* iter_get - create a new structure pointing to ITER */\n#ifndef ANSI_C\nITER *iter_get(lenb, lenx)\nint lenb, lenx;\n#else\nITER *iter_get(int lenb, int lenx)\n#endif\n{\n   ITER *ip;\n\n   if ((ip = NEW(ITER)) == (ITER *) NULL)\n     error(E_MEM,""iter_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ITER,0,sizeof(ITER));\n      mem_numvar(TYPE_ITER,1);\n   }\n\n   /* default values */\n   \n   ip->shared_x = FALSE;\n   ip->shared_b = FALSE;\n   ip->k = 0;\n   ip->limit = ITER_LIMIT_DEF;\n   ip->eps = ITER_EPS_DEF;\n   ip->steps = 0;\n\n   if (lenb > 0) ip->b = v_get(lenb);\n   else ip->b = (VEC *)NULL;\n\n   if (lenx > 0) ip->x = v_get(lenx);\n   else ip->x = (VEC *)NULL;\n\n   ip->Ax = (Fun_Ax) NULL;\n   ip->A_par = NULL;	\n   ip->ATx = (Fun_Ax) NULL;\n   ip->AT_par = NULL;\n   ip->Bx = (Fun_Ax) NULL;\n   ip->B_par = NULL;\n   ip->info = iter_std_info;\n   ip->stop_crit = iter_std_stop_crit;\n   ip->init_res = 0.0;\n   \n   return ip;\n}\n\n\n/* iter_free - release memory */\n#ifndef ANSI_C\nint iter_free(ip)\nITER *ip;\n#else\nint iter_free(ITER *ip)\n#endif\n{\n   if (ip == (ITER *)NULL) return -1;\n   \n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_ITER,sizeof(ITER),0);\n      mem_numvar(TYPE_ITER,-1);\n   }\n\n   if ( !ip->shared_x && ip->x != NULL ) v_free(ip->x);\n   if ( !ip->shared_b && ip->b != NULL ) v_free(ip->b);\n\n   free((char *)ip);\n\n   return 0;\n}\n\n#ifndef ANSI_C\nITER *iter_resize(ip,new_lenb,new_lenx)\nITER *ip;\nint new_lenb, new_lenx;\n#else\nITER *iter_resize(ITER *ip, int new_lenb, int new_lenx)\n#endif\n{\n   VEC *old;\n\n   if ( ip == (ITER *) NULL)\n     error(E_NULL,""iter_resize"");\n\n   old = ip->x;\n   ip->x = v_resize(ip->x,new_lenx);\n   if ( ip->shared_x && old != ip->x )\n     warning(WARN_SHARED_VEC,""iter_resize"");\n   old = ip->b;\n   ip->b = v_resize(ip->b,new_lenb);\n   if ( ip->shared_b && old != ip->b )\n     warning(WARN_SHARED_VEC,""iter_resize"");\n\n   return ip;\n}\n\n#ifndef MEX\n/* print out ip structure - for diagnostic purposes mainly */\n#ifndef ANSI_C\nvoid iter_dump(fp,ip)\nITER *ip;\nFILE *fp;\n#else\nvoid iter_dump(FILE *fp, ITER *ip)\n#endif\n{\n   if (ip == NULL) {\n      fprintf(fp,"" ITER structure: NULL\n"");\n      return;\n   }\n\n   fprintf(fp,""\n ITER structure:\n"");\n   fprintf(fp,"" ip->shared_x = %s, ip->shared_b = %s\n"",\n	   (ip->shared_x ? ""TRUE"" : ""FALSE""),\n	   (ip->shared_b ? ""TRUE"" : ""FALSE"") );\n   fprintf(fp,"" ip->k = %d, ip->limit = %d, ip->steps = %d, ip->eps = %g\n"",\n	   ip->k,ip->limit,ip->steps,ip->eps);\n   fprintf(fp,"" ip->x = 0x%p, ip->b = 0x%p\n"",ip->x,ip->b);\n   fprintf(fp,"" ip->Ax = 0x%p, ip->A_par = 0x%p\n"",ip->Ax,ip->A_par);\n   fprintf(fp,"" ip->ATx = 0x%p, ip->AT_par = 0x%p\n"",ip->ATx,ip->AT_par);\n   fprintf(fp,"" ip->Bx = 0x%p, ip->B_par = 0x%p\n"",ip->Bx,ip->B_par);\n   fprintf(fp,"" ip->info = 0x%p, ip->stop_crit = 0x%p, ip->init_res = %g\n"",\n	   ip->info,ip->stop_crit,ip->init_res);\n   fprintf(fp,""\n"");\n   \n}\n#endif\n\n/* copy the structure ip1 to ip2 preserving vectors x and b of ip2\n   (vectors x and b in ip2 are the same before and after iter_copy2)\n   if ip2 == NULL then a new structure is created with x and b being NULL\n   and other members are taken from ip1\n*/\n#ifndef ANSI_C\nITER *iter_copy2(ip1,ip2)\nITER *ip1, *ip2;\n#else\nITER *iter_copy2(ITER *ip1, ITER *ip2)\n#endif\n{\n   VEC *x, *b;\n   int shx, shb;\n\n   if (ip1 == (ITER *)NULL) \n     error(E_NULL,""iter_copy2"");\n\n   if (ip2 == (ITER *)NULL) {\n      if ((ip2 = NEW(ITER)) == (ITER *) NULL)\n	error(E_MEM,""iter_copy2"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ITER,0,sizeof(ITER));\n	 mem_numvar(TYPE_ITER,1);\n      }\n      ip2->x = ip2->b = NULL;\n      ip2->shared_x = ip2->shared_x = FALSE;\n   }\n\n   x = ip2->x;\n   b = ip2->b;\n   shb = ip2->shared_b;\n   shx = ip2->shared_x;\n   MEM_COPY(ip1,ip2,sizeof(ITER));\n   ip2->x = x;\n   ip2->b = b;\n   ip2->shared_x = shx;\n   ip2->shared_b = shb;\n\n   return ip2;\n}\n\n\n/* copy the structure ip1 to ip2 copying also the vectors x and b */\n#ifndef ANSI_C\nITER *iter_copy(ip1,ip2)\nITER *ip1, *ip2;\n#else\nITER *iter_copy(const ITER *ip1, ITER *ip2)\n#endif\n{\n   VEC *x, *b;\n\n   if (ip1 == (ITER *)NULL) \n     error(E_NULL,""iter_copy"");\n\n   if (ip2 == (ITER *)NULL) {\n      if ((ip2 = NEW(ITER)) == (ITER *) NULL)\n	error(E_MEM,""iter_copy2"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ITER,0,sizeof(ITER));\n	 mem_numvar(TYPE_ITER,1);\n      }\n   }\n\n   x = ip2->x;\n   b = ip2->b;\n\n   MEM_COPY(ip1,ip2,sizeof(ITER));\n   if (ip1->x)\n     ip2->x = v_copy(ip1->x,x);\n   if (ip1->b)\n     ip2->b = v_copy(ip1->b,b);\n\n   ip2->shared_x = ip2->shared_b = FALSE;\n\n   return ip2;\n}\n\n\n/*** functions to generate sparse matrices with random entries ***/\n\n\n/* iter_gen_sym -- generate symmetric positive definite\n   n x n matrix, \n   nrow - number of nonzero entries in a row\n   */\n#ifndef ANSI_C\nSPMAT	*iter_gen_sym(n,nrow)\nint	n, nrow;\n#else\nSPMAT	*iter_gen_sym(int n, int nrow)\n#endif\n{\n   SPMAT	*A;\n   VEC	        *u;\n   Real       s1;\n   int		i, j, k, k_max;\n   \n   if (nrow <= 1) nrow = 2;\n   /* nrow should be even */\n   if ((nrow & 1)) nrow -= 1;\n   A = sp_get(n,n,nrow);\n   u = v_get(A->m);\n   v_zero(u);\n   for ( i = 0; i < A->m; i++ )\n   {\n      k_max = ((rand() >> 8) % (nrow/2));\n      for ( k = 0; k <= k_max; k++ )\n      {\n	 j = (rand() >> 8) % A->n;\n	 s1 = mrand();\n	 sp_set_val(A,i,j,s1);\n	 sp_set_val(A,j,i,s1);\n	 u->ve[i] += fabs(s1);\n	 u->ve[j] += fabs(s1);\n      }\n   }\n   /* ensure that A is positive definite */\n   for ( i = 0; i < A->m; i++ )\n     sp_set_val(A,i,i,u->ve[i] + 1.0);\n   \n   V_FREE(u);\n   return A;\n}\n\n\n/* iter_gen_nonsym -- generate non-symmetric m x n sparse matrix, m >= n \n   nrow - number of entries in a row;\n   diag - number which is put in diagonal entries and then permuted\n   (if diag is zero then 1.0 is there)\n*/\n#ifndef ANSI_C\nSPMAT	*iter_gen_nonsym(m,n,nrow,diag)\nint	m, n, nrow;\ndouble diag;\n#else\nSPMAT	*iter_gen_nonsym(int m, int n, int nrow, double diag)\n#endif\n{\n   SPMAT	*A;\n   PERM		*px;\n   int		i, j, k, k_max;\n   Real		s1;\n   \n   if (nrow <= 1) nrow = 2;\n   if (diag == 0.0) diag = 1.0;\n   A = sp_get(m,n,nrow);\n   px = px_get(n);\n   for ( i = 0; i < A->m; i++ )\n   {\n      k_max = (rand() >> 8) % (nrow-1);\n      for ( k = 0; k <= k_max; k++ )\n      {\n	 j = (rand() >> 8) % A->n;\n	 s1 = mrand();\n	 sp_set_val(A,i,j,-s1);\n      }\n   }\n   /* to make it likely that A is nonsingular, use pivot... */\n   for ( i = 0; i < 2*A->n; i++ )\n   {\n      j = (rand() >> 8) % A->n;\n      k = (rand() >> 8) % A->n;\n      px_transp(px,j,k);\n   }\n   for ( i = 0; i < A->n; i++ )\n     sp_set_val(A,i,px->pe[i],diag);  \n   \n   PX_FREE(px);\n   return A;\n}\n\n#if ( 0 )\n/* iter_gen_nonsym -- generate non-symmetric positive definite \n   n x n sparse matrix;\n   nrow - number of entries in a row\n*/\n#ifndef ANSI_C\nSPMAT	*iter_gen_nonsym_posdef(n,nrow)\nint	n, nrow;\n#else\nSPMAT	*iter_gen_nonsym(int m, int n, int nrow, double diag)\n#endif\n{\n   SPMAT	*A;\n   PERM		*px;\n   VEC          *u;\n   int		i, j, k, k_max;\n   Real		s1;\n   \n   if (nrow <= 1) nrow = 2;\n   A = sp_get(n,n,nrow);\n   px = px_get(n);\n   u = v_get(A->m);\n   v_zero(u);\n   for ( i = 0; i < A->m; i++ )\n   {\n      k_max = (rand() >> 8) % (nrow-1);\n      for ( k = 0; k <= k_max; k++ )\n      {\n	 j = (rand() >> 8) % A->n;\n	 s1 = mrand();\n	 sp_set_val(A,i,j,-s1);\n	 u->ve[i] += fabs(s1);\n      }\n   }\n   /* ensure that A is positive definite */\n   for ( i = 0; i < A->m; i++ )\n     sp_set_val(A,i,i,u->ve[i] + 1.0);\n   \n   PX_FREE(px);\n   V_FREE(u);\n   return A;\n}\n#endif\n\n\n\n\n"
leukocyte/meschach_lib/arnoldi.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	Arnoldi method for finding eigenvalues of large non-symmetric\n		matrices\n*/\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include	""matrix2.h""\n#include	""sparse.h""\n\nstatic char rcsid[] = ""$Id: arnoldi.c,v 1.3 1994/01/13 05:45:40 des Exp $"";\n\n\n/* arnoldi -- an implementation of the Arnoldi method */\nMAT	*arnoldi(A,A_param,x0,m,h_rem,Q,H)\nVEC	*(*A)();\nvoid	*A_param;\nVEC	*x0;\nint	m;\nReal	*h_rem;\nMAT	*Q, *H;\n{\n	STATIC VEC	*v=VNULL, *u=VNULL, *r=VNULL, *s=VNULL, *tmp=VNULL;\n	int	i;\n	Real	h_val;\n\n	if ( ! A || ! Q || ! x0 )\n	    error(E_NULL,""arnoldi"");\n	if ( m <= 0 )\n	    error(E_BOUNDS,""arnoldi"");\n	if ( Q->n != x0->dim ||	Q->m != m )\n	    error(E_SIZES,""arnoldi"");\n\n	m_zero(Q);\n	H = m_resize(H,m,m);\n	m_zero(H);\n	u = v_resize(u,x0->dim);\n	v = v_resize(v,x0->dim);\n	r = v_resize(r,m);\n	s = v_resize(s,m);\n	tmp = v_resize(tmp,x0->dim);\n	MEM_STAT_REG(u,TYPE_VEC);\n	MEM_STAT_REG(v,TYPE_VEC);\n	MEM_STAT_REG(r,TYPE_VEC);\n	MEM_STAT_REG(s,TYPE_VEC);\n	MEM_STAT_REG(tmp,TYPE_VEC);\n	sv_mlt(1.0/v_norm2(x0),x0,v);\n	for ( i = 0; i < m; i++ )\n	{\n	    set_row(Q,i,v);\n	    u = (*A)(A_param,v,u);\n	    r = mv_mlt(Q,u,r);\n	    tmp = vm_mlt(Q,r,tmp);\n	    v_sub(u,tmp,u);\n	    h_val = v_norm2(u);\n	    /* if u == 0 then we have an exact subspace */\n	    if ( h_val == 0.0 )\n	    {\n		*h_rem = h_val;\n		return H;\n	    }\n	    /* iterative refinement -- ensures near orthogonality */\n	    do {\n		s = mv_mlt(Q,u,s);\n		tmp = vm_mlt(Q,s,tmp);\n		v_sub(u,tmp,u);\n		v_add(r,s,r);\n	    } while ( v_norm2(s) > 0.1*(h_val = v_norm2(u)) );\n	    /* now that u is nearly orthogonal to Q, update H */\n	    set_col(H,i,r);\n	    if ( i == m-1 )\n	    {\n		*h_rem = h_val;\n		continue;\n	    }\n	    /* H->me[i+1][i] = h_val; */\n	    m_set_val(H,i+1,i,h_val);\n	    sv_mlt(1.0/h_val,u,v);\n	}\n\n#ifdef THREADSAFE\n	V_FREE(v);	V_FREE(u);	V_FREE(r);\n	V_FREE(r);	V_FREE(s);	V_FREE(tmp);\n#endif\n	return H;\n}\n\n/* sp_arnoldi -- uses arnoldi() with an explicit representation of A */\nMAT	*sp_arnoldi(A,x0,m,h_rem,Q,H)\nSPMAT	*A;\nVEC	*x0;\nint	m;\nReal	*h_rem;\nMAT	*Q, *H;\n{	return arnoldi(sp_mv_mlt,A,x0,m,h_rem,Q,H);	}\n\n/* gmres -- generalised minimum residual algorithm of Saad & Schultz\n		SIAM J. Sci. Stat. Comp. v.7, pp.856--869 (1986)\n	-- y is overwritten with the solution */\nVEC	*gmres(A,A_param,m,Q,R,b,tol,x)\nVEC	*(*A)();\nvoid	*A_param;\nVEC	*b, *x;\nint	m;\nMAT	*Q, *R;\ndouble	tol;\n{\n    STATIC VEC	*v=VNULL, *u=VNULL, *r=VNULL, *tmp=VNULL, *rhs=VNULL;\n    STATIC VEC	*diag=VNULL, *beta=VNULL;\n    int	i;\n    Real	h_val, norm_b;\n    \n    if ( ! A || ! Q || ! b || ! R )\n	error(E_NULL,""gmres"");\n    if ( m <= 0 )\n	error(E_BOUNDS,""gmres"");\n    if ( Q->n != b->dim || Q->m != m )\n	error(E_SIZES,""gmres"");\n    \n    x = v_copy(b,x);\n    m_zero(Q);\n    R = m_resize(R,m+1,m);\n    m_zero(R);\n    u = v_resize(u,x->dim);\n    v = v_resize(v,x->dim);\n    tmp = v_resize(tmp,x->dim);\n    rhs = v_resize(rhs,m+1);\n    MEM_STAT_REG(u,TYPE_VEC);\n    MEM_STAT_REG(v,TYPE_VEC);\n    MEM_STAT_REG(r,TYPE_VEC);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n    MEM_STAT_REG(rhs,TYPE_VEC);\n    norm_b = v_norm2(x);\n    if ( norm_b == 0.0 )\n	error(E_RANGE,""gmres"");\n    sv_mlt(1.0/norm_b,x,v);\n    \n    for ( i = 0; i < m; i++ )\n    {\n	set_row(Q,i,v);\n	tracecatch(u = (*A)(A_param,v,u),""gmres"");\n	r = mv_mlt(Q,u,r);\n	tmp = vm_mlt(Q,r,tmp);\n	v_sub(u,tmp,u);\n	h_val = v_norm2(u);\n	set_col(R,i,r);\n	R->me[i+1][i] = h_val;\n	sv_mlt(1.0/h_val,u,v);\n    }\n    \n    /* use i x i submatrix of R */\n    R = m_resize(R,i+1,i);\n    rhs = v_resize(rhs,i+1);\n    v_zero(rhs);\n    rhs->ve[0] = norm_b;\n    tmp = v_resize(tmp,i);\n    diag = v_resize(diag,i+1);\n    beta = v_resize(beta,i+1);\n    MEM_STAT_REG(beta,TYPE_VEC);\n    MEM_STAT_REG(diag,TYPE_VEC);\n    QRfactor(R,diag /* ,beta */);\n    tmp = QRsolve(R,diag, /* beta, */ rhs,tmp);\n    v_resize(tmp,m);\n    vm_mlt(Q,tmp,x);\n\n#ifdef THREADSAFE\n    V_FREE(v);		V_FREE(u);	V_FREE(r);\n    V_FREE(tmp);	V_FREE(rhs);\n    V_FREE(diag);	V_FREE(beta);\n#endif\n\n    return x;\n}\n"
leukocyte/meschach_lib/norm.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	A collection of functions for computing norms: scaled and unscaled\n*/\nstatic	char	rcsid[] = ""$Id: norm.c,v 1.6 1994/01/13 05:34:35 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n\n\n/* _v_norm1 -- computes (scaled) 1-norms of vectors */\n#ifndef ANSI_C\ndouble	_v_norm1(x,scale)\nVEC	*x, *scale;\n#else\ndouble	_v_norm1(const VEC *x, const VEC *scale)\n#endif\n{\n	int	i, dim;\n	Real	s, sum;\n\n	if ( x == (VEC *)NULL )\n		error(E_NULL,""_v_norm1"");\n	dim = x->dim;\n\n	sum = 0.0;\n	if ( scale == (VEC *)NULL )\n		for ( i = 0; i < dim; i++ )\n			sum += fabs(x->ve[i]);\n	else if ( scale->dim < dim )\n		error(E_SIZES,""_v_norm1"");\n	else\n		for ( i = 0; i < dim; i++ )\n		{	s = scale->ve[i];\n			sum += ( s== 0.0 ) ? fabs(x->ve[i]) : fabs(x->ve[i]/s);\n		}\n\n	return sum;\n}\n\n/* square -- returns x^2 */\n#ifndef ANSI_C\ndouble	square(x)\ndouble	x;\n#else\ndouble	square(double x)\n#endif\n{	return x*x;	}\n\n/* cube -- returns x^3 */\n#ifndef ANSI_C\ndouble cube(x)\ndouble x;\n#else\ndouble cube(double x)\n#endif\n{  return x*x*x;   }\n\n/* _v_norm2 -- computes (scaled) 2-norm (Euclidean norm) of vectors */\n#ifndef ANSI_C\ndouble	_v_norm2(x,scale)\nVEC	*x, *scale;\n#else\ndouble	_v_norm2(const VEC *x, const VEC *scale)\n#endif\n{\n	int	i, dim;\n	Real	s, sum;\n\n	if ( x == (VEC *)NULL )\n		error(E_NULL,""_v_norm2"");\n	dim = x->dim;\n\n	sum = 0.0;\n	if ( scale == (VEC *)NULL )\n		for ( i = 0; i < dim; i++ )\n			sum += square(x->ve[i]);\n	else if ( scale->dim < dim )\n		error(E_SIZES,""_v_norm2"");\n	else\n		for ( i = 0; i < dim; i++ )\n		{	s = scale->ve[i];\n			sum += ( s== 0.0 ) ? square(x->ve[i]) :\n							square(x->ve[i]/s);\n		}\n\n	return sqrt(sum);\n}\n\n#define	max(a,b)	((a) > (b) ? (a) : (b))\n\n/* _v_norm_inf -- computes (scaled) infinity-norm (supremum norm) of vectors */\n#ifndef ANSI_C\ndouble	_v_norm_inf(x,scale)\nVEC	*x, *scale;\n#else\ndouble	_v_norm_inf(const VEC *x, const VEC *scale)\n#endif\n{\n	int	i, dim;\n	Real	s, maxval, tmp;\n\n	if ( x == (VEC *)NULL )\n		error(E_NULL,""_v_norm_inf"");\n	dim = x->dim;\n\n	maxval = 0.0;\n	if ( scale == (VEC *)NULL )\n		for ( i = 0; i < dim; i++ )\n		{	tmp = fabs(x->ve[i]);\n			maxval = max(maxval,tmp);\n		}\n	else if ( scale->dim < dim )\n		error(E_SIZES,""_v_norm_inf"");\n	else\n		for ( i = 0; i < dim; i++ )\n		{	s = scale->ve[i];\n			tmp = ( s== 0.0 ) ? fabs(x->ve[i]) : fabs(x->ve[i]/s);\n			maxval = max(maxval,tmp);\n		}\n\n	return maxval;\n}\n\n/* m_norm1 -- compute matrix 1-norm -- unscaled */\n#ifndef ANSI_C\ndouble	m_norm1(A)\nMAT	*A;\n#else\ndouble	m_norm1(const MAT *A)\n#endif\n{\n	int	i, j, m, n;\n	Real	maxval, sum;\n\n	if ( A == (MAT *)NULL )\n		error(E_NULL,""m_norm1"");\n\n	m = A->m;	n = A->n;\n	maxval = 0.0;\n\n	for ( j = 0; j < n; j++ )\n	{\n		sum = 0.0;\n		for ( i = 0; i < m; i ++ )\n			sum += fabs(A->me[i][j]);\n		maxval = max(maxval,sum);\n	}\n\n	return maxval;\n}\n\n/* m_norm_inf -- compute matrix infinity-norm -- unscaled */\n#ifndef ANSI_C\ndouble	m_norm_inf(A)\nMAT	*A;\n#else\ndouble	m_norm_inf(const MAT *A)\n#endif\n{\n	int	i, j, m, n;\n	Real	maxval, sum;\n\n	if ( A == (MAT *)NULL )\n		error(E_NULL,""m_norm_inf"");\n\n	m = A->m;	n = A->n;\n	maxval = 0.0;\n\n	for ( i = 0; i < m; i++ )\n	{\n		sum = 0.0;\n		for ( j = 0; j < n; j ++ )\n			sum += fabs(A->me[i][j]);\n		maxval = max(maxval,sum);\n	}\n\n	return maxval;\n}\n\n/* m_norm_frob -- compute matrix frobenius-norm -- unscaled */\n#ifndef ANSI_C\ndouble	m_norm_frob(A)\nMAT	*A;\n#else\ndouble	m_norm_frob(const MAT *A)\n#endif\n{\n	int	i, j, m, n;\n	Real	sum;\n\n	if ( A == (MAT *)NULL )\n		error(E_NULL,""m_norm_frob"");\n\n	m = A->m;	n = A->n;\n	sum = 0.0;\n\n	for ( i = 0; i < m; i++ )\n		for ( j = 0; j < n; j ++ )\n			sum += square(A->me[i][j]);\n\n	return sqrt(sum);\n}\n\n"
leukocyte/meschach_lib/itertort.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*  iter_tort.c  16/09/93 */\n\n/*\n  This file contains tests for the iterative part of Meschach\n*/\n\n#include	<stdio.h>\n#include	""matrix2.h""\n#include	""sparse2.h""\n#include	""iter.h""\n#include	<math.h>\n\n#define	errmesg(mesg)	printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)	printf(""# Testing %s...\n"",mesg);\n  \n  /* for iterative methods */\n  \n#if REAL == DOUBLE\n#define	EPS	1e-7\n#define KK	20\n#elif REAL == FLOAT\n#define EPS   1e-5\n#define KK	8\n#endif\n\n#define ANON  513\n#define ASYM  ANON   \n\n  \nstatic VEC *ex_sol = VNULL;\n\n/* new iter information */\nvoid iter_mod_info(ip,nres,res,Bres)\nITER *ip;\ndouble nres;\nVEC *res, *Bres;\n{\n   static VEC *tmp;\n\n   if (ip->b == VNULL) return;\n   tmp = v_resize(tmp,ip->b->dim);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n\n   if (nres >= 0.0) {\n      printf("" %d. residual = %g\n"",ip->steps,nres);\n   }\n   else \n     printf("" %d. residual = %g (WARNING !!! should be >= 0) \n"",\n	    ip->steps,nres);\n   if (ex_sol != VNULL)\n     printf(""    ||u_ex - u_approx||_2 = %g\n"",\n	    v_norm2(v_sub(ip->x,ex_sol,tmp)));\n}\n\n\n/* out = A^T*A*x */\nVEC *norm_equ(A,x,out)\nSPMAT *A;\nVEC *x, *out;\n{\n   static VEC * tmp;\n\n   tmp = v_resize(tmp,x->dim);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n   sp_mv_mlt(A,x,tmp);\n   sp_vm_mlt(A,tmp,out);\n   return out;\n\n}\n\n\n/* \n  make symmetric preconditioner for nonsymmetric matrix A;\n   B = 0.5*(A+A^T) and then B is factorized using \n   incomplete Choleski factorization\n*/\n\nSPMAT *gen_sym_precond(A)\nSPMAT *A;\n{\n   SPMAT *B;\n   SPROW *row;\n   int i,j,k;\n   Real val;\n   \n   B = sp_get(A->m,A->n,A->row[0].maxlen);\n   for (i=0; i < A->m; i++) {\n      row = &(A->row[i]);\n      for (j = 0; j < row->len; j++) {\n	k = row->elt[j].col;\n	if (i != k) {\n	   val = 0.5*(sp_get_val(A,i,k) + sp_get_val(A,k,i));\n	   sp_set_val(B,i,k,val);\n	   sp_set_val(B,k,i,val);\n	}\n	else { /* i == k */\n	  val = sp_get_val(A,i,i);\n	  sp_set_val(B,i,i,val);\n       }\n     }\n   }\n\n   spICHfactor(B);\n   return B;\n}\n\n/* Dv_mlt -- diagonal by vector multiply; the diagonal matrix is represented\n		by a vector d */\nVEC	*Dv_mlt(d, x, out)\nVEC	*d, *x, *out;\n{\n    int		i;\n\n    if ( ! d || ! x )\n	error(E_NULL,""Dv_mlt"");\n    if ( d->dim != x->dim )\n	error(E_SIZES,""Dv_mlt"");\n    out = v_resize(out,x->dim);\n\n    for ( i = 0; i < x->dim; i++ )\n	out->ve[i] = d->ve[i]*x->ve[i];\n\n    return out;\n}\n\n\n\n/************************************************/\nvoid	main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n   VEC		*x, *y, *z, *u, *v, *xn, *yn;\n   SPMAT	*A = NULL, *B = NULL;\n   SPMAT	*An = NULL, *Bn = NULL;\n   int		i, k, kk, j;\n   ITER        *ips, *ips1, *ipns, *ipns1;\n   MAT         *Q, *H, *Q1, *H1;\n   VEC         vt, vt1;\n   Real        hh;\n\n\n   mem_info_on(TRUE);\n   notice(""allocating sparse matrices"");\n   \n   printf("" dim of A = %dx%d\n"",ASYM,ASYM);\n   \n   A = iter_gen_sym(ASYM,8);   \n   B = sp_copy(A);\n   spICHfactor(B);\n   \n   u = v_get(A->n);\n   x = v_get(A->n);\n   y = v_get(A->n);\n   v = v_get(A->n);\n\n   v_rand(x);\n   sp_mv_mlt(A,x,y);\n   ex_sol = x;\n   \n   notice("" initialize ITER variables"");\n   /* ips for symmetric matrices with precondition */\n   ips = iter_get(A->m,A->n);\n\n   /*  printf("" ips:\n"");\n   iter_dump(stdout,ips);   */\n\n   ips->limit = 500;\n   ips->eps = EPS;\n   \n   iter_Ax(ips,sp_mv_mlt,A);\n   iter_Bx(ips,spCHsolve,B);\n\n   ips->b = v_copy(y,ips->b);\n   v_rand(ips->x);\n   /* test of iter_resize */\n   ips = iter_resize(ips,2*A->m,2*A->n);\n   ips = iter_resize(ips,A->m,A->n);\n\n   /*  printf("" ips:\n"");\n   iter_dump(stdout,ips); */\n   \n   /* ips1 for symmetric matrices without precondition */\n   ips1 = iter_get(0,0);\n   /*   printf("" ips1:\n"");\n   iter_dump(stdout,ips1);   */\n   ITER_FREE(ips1);\n\n   ips1 = iter_copy2(ips,ips1);\n   iter_Bx(ips1,NULL,NULL);\n   ips1->b = ips->b;\n   ips1->shared_b = TRUE;\n   /*    printf("" ips1:\n"");\n   iter_dump(stdout,ips1);   */\n\n   /* ipns for nonsymetric matrices with precondition */\n   ipns = iter_copy(ips,INULL);\n   ipns->k = KK;\n   ipns->limit = 500;\n   ipns->info = NULL;\n\n   An = iter_gen_nonsym_posdef(ANON,8);   \n   Bn = gen_sym_precond(An);\n   xn = v_get(An->n);\n   yn = v_get(An->n);\n   v_rand(xn);\n   sp_mv_mlt(An,xn,yn);\n   ipns->b = v_copy(yn,ipns->b);\n\n   iter_Ax(ipns, sp_mv_mlt,An);\n   iter_ATx(ipns, sp_vm_mlt,An);\n   iter_Bx(ipns, spCHsolve,Bn);\n\n   /*  printf("" ipns:\n"");\n   iter_dump(stdout,ipns); */\n   \n   /* ipns1 for nonsymmetric matrices without precondition */\n   ipns1 = iter_copy2(ipns,INULL);\n   ipns1->b = ipns->b;\n   ipns1->shared_b = TRUE;\n   iter_Bx(ipns1,NULL,NULL);\n\n   /*   printf("" ipns1:\n"");\n   iter_dump(stdout,ipns1);  */\n\n\n   /*******  CG  ********/\n\n   notice("" CG method without preconditioning"");\n   ips1->info = NULL;\n   mem_stat_mark(1);\n   iter_cg(ips1);\n\n   k = ips1->steps;\n   z = ips1->x;\n   printf("" cg: no. of iter.steps = %d\n"",k);\n   v_sub(z,x,u);\n   printf("" (cg:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n"",\n	  v_norm2(u),EPS);\n   \n   notice("" CG method with ICH preconditioning"");\n\n   ips->info = NULL;\n   v_zero(ips->x);  \n   iter_cg(ips);  \n\n   k = ips->steps;\n   printf("" cg: no. of iter.steps = %d\n"",k);\n   v_sub(ips->x,x,u);\n   printf("" (cg:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n"",\n	  v_norm2(u),EPS);\n   \n   V_FREE(v);\n   if ((v = iter_spcg(A,B,y,EPS,VNULL,1000,&k)) == VNULL)\n     errmesg(""CG method with precond.: NULL solution""); \n   \n   v_sub(ips->x,v,u);\n   if (v_norm2(u) >= EPS) {\n      errmesg(""CG method with precond.: different solutions"");\n      printf("" diff. = %g\n"",v_norm2(u));\n   }   \n   \n\n   mem_stat_free(1);\n   printf("" spcg: # of iter. steps = %d\n"",k);\n   v_sub(v,x,u);\n   printf("" (spcg:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(u),EPS);  \n\n\n   /***  CG FOR NORMAL EQUATION *****/\n\n   notice(""CGNE method with ICH preconditioning (nonsymmetric case)"");\n\n   /* ipns->info = iter_std_info;  */\n   ipns->info = NULL;\n   v_zero(ipns->x);\n \n   mem_stat_mark(1);\n   iter_cgne(ipns);\n\n   k = ipns->steps;\n   z = ipns->x;\n   printf("" cgne: no. of iter.steps = %d\n"",k);\n   v_sub(z,xn,u);\n   printf("" (cgne:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(u),EPS);\n\n   notice(""CGNE method without preconditioning (nonsymmetric case)"");\n\n   v_rand(u);\n   u = iter_spcgne(An,NULL,yn,EPS,u,1000,&k);\n\n   mem_stat_free(1);\n   printf("" spcgne: no. of iter.steps = %d\n"",k);\n   v_sub(u,xn,u);\n   printf("" (spcgne:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(u),EPS);\n\n   /***  CGS  *****/\n\n   notice(""CGS method with ICH preconditioning (nonsymmetric case)"");\n\n   v_zero(ipns->x);   /* new init guess == 0 */\n \n   mem_stat_mark(1);\n   ipns->info = NULL;\n   v_rand(u);\n   iter_cgs(ipns,u);\n\n   k = ipns->steps;\n   z = ipns->x;\n   printf("" cgs: no. of iter.steps = %d\n"",k);\n   v_sub(z,xn,u);\n   printf("" (cgs:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(u),EPS);\n\n   notice(""CGS method without preconditioning (nonsymmetric case)"");\n\n   v_rand(u);\n   v_rand(v);\n   v = iter_spcgs(An,NULL,yn,u,EPS,v,1000,&k);\n\n   mem_stat_free(1);\n   printf("" cgs: no. of iter.steps = %d\n"",k);\n   v_sub(v,xn,u);\n   printf("" (cgs:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(u),EPS);\n   \n\n\n   /*** LSQR ***/\n\n   notice(""LSQR method (without preconditioning)"");\n\n   v_rand(u);\n   v_free(ipns1->x);\n   ipns1->x = u;\n   ipns1->shared_x = TRUE;\n   ipns1->info = NULL;\n   mem_stat_mark(2);\n   z = iter_lsqr(ipns1);\n   \n   v_sub(xn,z,v);\n   k = ipns1->steps;\n   printf("" lsqr: # of iter. steps = %d\n"",k);\n   printf("" (lsqr:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(v),EPS);\n\n   v_rand(u);\n   u = iter_splsqr(An,yn,EPS,u,1000,&k);\n   mem_stat_free(2);\n   \n   v_sub(xn,u,v);\n   printf("" splsqr: # of iter. steps = %d\n"",k);\n   printf("" (splsqr:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n"",	\n	  v_norm2(v),EPS);\n\n\n\n   /***** GMRES ********/\n\n   notice(""GMRES method with ICH preconditioning (nonsymmetric case)"");\n\n   v_zero(ipns->x);\n/*   ipns->info = iter_std_info;  */\n   ipns->info = NULL;  \n\n   mem_stat_mark(2);\n   z = iter_gmres(ipns);\n   v_sub(xn,z,v);\n   k = ipns->steps;\n   printf("" gmres: # of iter. steps = %d\n"",k);\n   printf("" (gmres:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(v),EPS);\n\n   notice(""GMRES method without preconditioning (nonsymmetric case)"");\n   V_FREE(v);\n   v = iter_spgmres(An,NULL,yn,EPS,VNULL,10,1004,&k);\n   mem_stat_free(2);\n   \n   v_sub(xn,v,v);\n   printf("" spgmres: # of iter. steps = %d\n"",k);\n   printf("" (spgmres:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(v),EPS);\n\n\n\n   /**** MGCR *****/\n\n   notice(""MGCR method with ICH preconditioning (nonsymmetric case)"");\n\n   v_zero(ipns->x);\n   mem_stat_mark(2);\n   z = iter_mgcr(ipns);\n   v_sub(xn,z,v);\n   k = ipns->steps;\n   printf("" mgcr: # of iter. steps = %d\n"",k);\n   printf("" (mgcr:) ||u_ex - u_approx||_2 = %g  [EPS = %g]\n"",\n	  v_norm2(v),EPS);\n\n   notice(""MGCR method without  preconditioning (nonsymmetric case)"");\n   V_FREE(v);\n   v = iter_spmgcr(An,NULL,yn,EPS,VNULL,10,1004,&k);\n   mem_stat_free(2);\n   \n   v_sub(xn,v,v);\n   printf("" spmgcr: # of iter. steps = %d\n"",k);\n   printf("" (spmgcr:) ||u_ex - u_approx||_2 = %g [EPS = %g]\n"",\n	  v_norm2(v),EPS);\n\n\n   /***** ARNOLDI METHOD ********/\n\n\n   notice(""arnoldi method"");\n\n   kk = ipns1->k = KK;\n   Q = m_get(kk,x->dim);\n   Q1 = m_get(kk,x->dim);\n   H = m_get(kk,kk);\n   v_rand(u);\n   ipns1->x = u;\n   ipns1->shared_x = TRUE;\n   mem_stat_mark(3);\n   iter_arnoldi_iref(ipns1,&hh,Q,H);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt.max_dim = x->dim;\n   vt1.dim = vt1.max_dim = x->dim;\n   for (j=0; j < kk; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(An,&vt,&vt1);\n   }\n   H1 = m_get(kk,kk);\n   mmtr_mlt(Q,Q1,H1);\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (arnoldi_iref) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n   /* check Q*Q^T = I  */\n\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < kk; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (arnoldi_iref) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n   ipns1->x = u;\n   ipns1->shared_x = TRUE;\n   mem_stat_mark(3);\n   iter_arnoldi(ipns1,&hh,Q,H);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt.max_dim = x->dim;\n   vt1.dim = vt1.max_dim = x->dim;\n   for (j=0; j < kk; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(An,&vt,&vt1);\n   }\n\n   mmtr_mlt(Q,Q1,H1);\n   m_sub(H,H1,H1);\n  if (m_norm_inf(H1) > MACHEPS*x->dim)  \n     printf("" (arnoldi) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n   /* check Q*Q^T = I  */\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < kk; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (arnoldi) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n   v_rand(u);\n   mem_stat_mark(3);\n   iter_sparnoldi(An,u,kk,&hh,Q,H);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt.max_dim = x->dim;\n   vt1.dim = vt1.max_dim = x->dim;\n   for (j=0; j < kk; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(An,&vt,&vt1);\n   }\n\n   mmtr_mlt(Q,Q1,H1);\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (sparnoldi) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n   /* check Q*Q^T = I  */\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < kk; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (sparnoldi) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n\n\n   /****** LANCZOS METHOD ******/\n\n   notice(""lanczos method"");\n   kk = ipns1->k; \n   Q = m_resize(Q,kk,x->dim);\n   Q1 = m_resize(Q1,kk,x->dim);\n   H = m_resize(H,kk,kk);\n   ips1->k = kk;\n   v_rand(u);\n   v_free(ips1->x);\n   ips1->x = u;\n   ips1->shared_x = TRUE;\n\n   mem_stat_mark(3);\n   iter_lanczos(ips1,x,y,&hh,Q);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt1.dim = Q->n;\n   vt.max_dim = vt1.max_dim = Q->max_n;\n   Q1 = m_resize(Q1,Q->m,Q->n);\n   for (j=0; j < Q->m; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(A,&vt,&vt1);\n   }\n   H1 = m_resize(H1,Q->m,Q->m);\n   H = m_resize(H,Q->m,Q->m);\n   mmtr_mlt(Q,Q1,H1);\n\n   m_zero(H);\n   for (j=0; j < Q->m-1; j++) {\n      H->me[j][j] = x->ve[j];\n      H->me[j][j+1] = H->me[j+1][j] = y->ve[j];\n   }\n   H->me[Q->m-1][Q->m-1] = x->ve[Q->m-1];\n\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (lanczos) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n   /* check Q*Q^T = I  */\n\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < Q->m; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (lanczos) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n   mem_stat_mark(3);\n   v_rand(u);\n   iter_splanczos(A,kk,u,x,y,&hh,Q);\n   mem_stat_free(3);\n\n   /* check the equality:\n      Q*A*Q^T = H; */\n\n   vt.dim = vt1.dim = Q->n;\n   vt.max_dim = vt1.max_dim = Q->max_n;\n   Q1 = m_resize(Q1,Q->m,Q->n);\n   for (j=0; j < Q->m; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      sp_mv_mlt(A,&vt,&vt1);\n   }\n   H1 = m_resize(H1,Q->m,Q->m);\n   H = m_resize(H,Q->m,Q->m);\n   mmtr_mlt(Q,Q1,H1);\n   for (j=0; j < Q->m-1; j++) {\n      H->me[j][j] = x->ve[j];\n      H->me[j][j+1] = H->me[j+1][j] = y->ve[j];\n   }\n   H->me[Q->m-1][Q->m-1] = x->ve[Q->m-1];\n\n   m_sub(H,H1,H1);\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (splanczos) ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n   /* check Q*Q^T = I  */\n   mmtr_mlt(Q,Q,H1);\n   for (j=0; j < Q->m; j++)\n     H1->me[j][j] -= 1.0;\n   if (m_norm_inf(H1) > MACHEPS*x->dim)\n     printf("" (splanczos) ||Q*Q^T - I|| = %g [cf. MACHEPS = %g]\n"",\n	    m_norm_inf(H1),MACHEPS);\n\n\n\n   /***** LANCZOS2 ****/\n\n   notice(""lanczos2 method"");\n   kk = 50;  		/* # of dir. vectors */\n   ips1->k = kk;\n   v_rand(u);\n   ips1->x = u;\n   ips1->shared_x = TRUE;\n\n   for ( i = 0; i < xn->dim; i++ )\n	xn->ve[i] = i;\n   iter_Ax(ips1,Dv_mlt,xn);\n   mem_stat_mark(3);\n   iter_lanczos2(ips1,y,v);\n   mem_stat_free(3);\n\n   printf(""# Number of steps of Lanczos algorithm = %d\n"", kk);\n   printf(""# Exact eigenvalues are 0, 1, 2, ..., %d\n"",ANON-1);\n   printf(""# Extreme eigenvalues should be accurate; \n"");\n   printf(""# interior values usually are not.\n"");\n   printf(""# approx e-vals =\n"");	v_output(y);\n   printf(""# Error in estimate of bottom e-vec (Lanczos) = %g\n"",\n	  fabs(v->ve[0]));\n\n   mem_stat_mark(3);\n   v_rand(u);\n   iter_splanczos2(A,kk,u,y,v);\n   mem_stat_free(3);\n\n\n   /***** FINISHING *******/\n\n   notice(""release ITER variables"");\n   \n   M_FREE(Q);\n   M_FREE(Q1);\n   M_FREE(H);\n   M_FREE(H1);\n\n   ITER_FREE(ipns);\n   ITER_FREE(ips);\n   ITER_FREE(ipns1);\n   ITER_FREE(ips1);\n   SP_FREE(A);\n   SP_FREE(B);\n   SP_FREE(An);\n   SP_FREE(Bn);\n   \n   V_FREE(x);\n   V_FREE(y);\n   V_FREE(u);\n   V_FREE(v); \n   V_FREE(xn);\n   V_FREE(yn);\n\n   printf(""# Done testing (%s)\n"",argv[0]);\n   mem_info();\n}\n"
leukocyte/meschach_lib/zhessen.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n		File containing routines for determining Hessenberg\n	factorisations.\n\n	Complex version\n*/\n\nstatic	char	rcsid[] = ""$Id: zhessen.c,v 1.2 1995/03/27 15:47:50 des Exp $"";\n\n#include	<stdio.h>\n#include	""zmatrix.h""\n#include        ""zmatrix2.h""\n\n\n/* zHfactor -- compute Hessenberg factorisation in compact form.\n	-- factorisation performed in situ\n	-- for details of the compact form see zQRfactor.c and zmatrix2.doc */\nZMAT	*zHfactor(A, diag)\nZMAT	*A;\nZVEC	*diag;\n{\n	STATIC	ZVEC	*tmp1 = ZVNULL, *w = ZVNULL;\n	Real	beta;\n	int	k, limit;\n\n	if ( ! A || ! diag )\n		error(E_NULL,""zHfactor"");\n	if ( diag->dim < A->m - 1 )\n		error(E_SIZES,""zHfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""zHfactor"");\n	limit = A->m - 1;\n\n	tmp1 = zv_resize(tmp1,A->m);\n	w    = zv_resize(w,   A->n);\n	MEM_STAT_REG(tmp1,TYPE_ZVEC);\n	MEM_STAT_REG(w,   TYPE_ZVEC);\n\n	for ( k = 0; k < limit; k++ )\n	{\n	    zget_col(A,k,tmp1);\n	    zhhvec(tmp1,k+1,&beta,tmp1,&A->me[k+1][k]);\n	    diag->ve[k] = tmp1->ve[k+1];\n	    /* printf(""zHfactor: k = %d, beta = %g, tmp1 =\n"",k,beta);\n	    zv_output(tmp1); */\n	    \n	    _zhhtrcols(A,k+1,k+1,tmp1,beta,w);\n	    zhhtrrows(A,0  ,k+1,tmp1,beta);\n	    /* printf(""# at stage k = %d, A =\n"",k);	zm_output(A); */\n	}\n\n#ifdef	THREADSAFE\n	ZV_FREE(tmp1);	ZV_FREE(w);\n#endif\n\n	return (A);\n}\n\n/* zHQunpack -- unpack the compact representation of H and Q of a\n	Hessenberg factorisation\n	-- if either H or Q is NULL, then it is not unpacked\n	-- it can be in situ with HQ == H\n	-- returns HQ\n*/\nZMAT	*zHQunpack(HQ,diag,Q,H)\nZMAT	*HQ, *Q, *H;\nZVEC	*diag;\n{\n	int	i, j, limit;\n	Real	beta, r_ii, tmp_val;\n	STATIC	ZVEC	*tmp1 = ZVNULL, *tmp2 = ZVNULL;\n\n	if ( HQ==ZMNULL || diag==ZVNULL )\n		error(E_NULL,""zHQunpack"");\n	if ( HQ == Q || H == Q )\n	    error(E_INSITU,""zHQunpack"");\n	limit = HQ->m - 1;\n	if ( diag->dim < limit )\n		error(E_SIZES,""zHQunpack"");\n	if ( HQ->m != HQ->n )\n		error(E_SQUARE,""zHQunpack"");\n\n\n	if ( Q != ZMNULL )\n	{\n	    Q = zm_resize(Q,HQ->m,HQ->m);\n	    tmp1 = zv_resize(tmp1,H->m);\n	    tmp2 = zv_resize(tmp2,H->m);\n	    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n	    MEM_STAT_REG(tmp2,TYPE_ZVEC);\n	    \n	    for ( i = 0; i < H->m; i++ )\n	    {\n		/* tmp1 = i'th basis vector */\n		for ( j = 0; j < H->m; j++ )\n		    tmp1->ve[j].re = tmp1->ve[j].im = 0.0;\n		tmp1->ve[i].re = 1.0;\n		\n		/* apply H/h transforms in reverse order */\n		for ( j = limit-1; j >= 0; j-- )\n		{\n		    zget_col(HQ,j,tmp2);\n		    r_ii = zabs(tmp2->ve[j+1]);\n		    tmp2->ve[j+1] = diag->ve[j];\n		    tmp_val = (r_ii*zabs(diag->ve[j]));\n		    beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n		    /* printf(""zHQunpack: j = %d, beta = %g, tmp2 =\n"",\n			   j,beta);\n		    zv_output(tmp2); */\n		    zhhtrvec(tmp2,beta,j+1,tmp1,tmp1);\n		}\n		\n		/* insert into Q */\n		zset_col(Q,i,tmp1);\n	    }\n	}\n\n	if ( H != ZMNULL )\n	{\n	    H = zm_copy(HQ,zm_resize(H,HQ->m,HQ->n));\n	    \n	    limit = H->m;\n	    for ( i = 1; i < limit; i++ )\n		for ( j = 0; j < i-1; j++ )\n		    H->me[i][j].re = H->me[i][j].im = 0.0;\n	}\n\n#ifdef	THREADSAFE\n	ZV_FREE(tmp1);	ZV_FREE(tmp2);\n#endif\n\n	return HQ;\n}\n\n\n\n"
leukocyte/meschach_lib/zmatio.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n#include        <stdio.h>\n#include        <ctype.h>\n#include        ""zmatrix.h""\n\nstatic char rcsid[] = ""$Id: zmatio.c,v 1.1 1994/01/13 04:25:18 des Exp $"";\n\n\n\n/* local variables */\nstatic char line[MAXLINE];\n\n/**************************************************************************\n  Input routines\n  **************************************************************************/\n\n#ifndef ANSI_C\ncomplex	z_finput(fp)\nFILE	*fp;\n#else\ncomplex	z_finput(FILE *fp)\n#endif\n{\n    int		io_code;\n    complex	z;\n\n    skipjunk(fp);\n    if ( isatty(fileno(fp)) )\n    {\n	do {\n	    fprintf(stderr,""real and imag parts: "");\n	    if ( fgets(line,MAXLINE,fp) == NULL )\n		error(E_EOF,""z_finput"");\n#if REAL == DOUBLE\n	    io_code = sscanf(line,""%lf%lf"",&z.re,&z.im);\n#elif REAL == FLOAT\n	    io_code = sscanf(line,""%f%f"",&z.re,&z.im);\n#endif\n\n	} while ( io_code != 2 );\n    }\n    else\n#if REAL == DOUBLE\n      if ( (io_code=fscanf(fp,"" (%lf,%lf)"",&z.re,&z.im)) < 2 )\n#elif REAL == FLOAT\n      if ( (io_code=fscanf(fp,"" (%f,%f)"",&z.re,&z.im)) < 2 )\n#endif\n	    error((io_code == EOF) ? E_EOF : E_FORMAT,""z_finput"");\n\n    return z;\n}\n\n#ifndef ANSI_C\nZMAT	*zm_finput(fp,a)\nFILE    *fp;\nZMAT	*a;\n#else\nZMAT	*zm_finput(FILE *fp,ZMAT *a)\n#endif\n{\n     ZMAT        *izm_finput(),*bzm_finput();\n     \n     if ( isatty(fileno(fp)) )\n	  return izm_finput(fp,a);\n     else\n	  return bzm_finput(fp,a);\n}\n\n/* izm_finput -- interactive input of matrix */\n#ifndef ANSI_C\nZMAT     *izm_finput(fp,mat)\nFILE    *fp;\nZMAT     *mat;\n#else\nZMAT     *izm_finput(FILE *fp, ZMAT *mat)\n#endif\n{\n     char       c;\n     unsigned int      i, j, m, n, dynamic;\n     /* dynamic set to TRUE if memory allocated here */\n     \n     /* get matrix size */\n     if ( mat != ZMNULL && mat->m<MAXDIM && mat->n<MAXDIM )\n     {  m = mat->m;     n = mat->n;     dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,""ComplexMatrix: rows cols:"");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""izm_finput"");\n	  } while ( sscanf(line,""%u%u"",&m,&n)<2 || m>MAXDIM || n>MAXDIM );\n	  mat = zm_get(m,n);\n     }\n     \n     /* input elements */\n     for ( i=0; i<m; i++ )\n     {\n     redo:\n	  fprintf(stderr,""row %u:\n"",i);\n	  for ( j=0; j<n; j++ )\n	       do\n	       {\n	       redo2:\n		    fprintf(stderr,""entry (%u,%u): "",i,j);\n		    if ( !dynamic )\n			 fprintf(stderr,""old (%14.9g,%14.9g) new: "",\n				 mat->me[i][j].re,mat->me[i][j].im);\n		    if ( fgets(line,MAXLINE,fp)==NULL )\n			 error(E_INPUT,""izm_finput"");\n		    if ( (*line == 'b' || *line == 'B') && j > 0 )\n		    {   j--;    dynamic = FALSE;        goto redo2;     }\n		    if ( (*line == 'f' || *line == 'F') && j < n-1 )\n		    {   j++;    dynamic = FALSE;        goto redo2;     }\n	       } while ( *line=='\0' ||\n#if REAL == DOUBLE\n			 sscanf(line,""%lf%lf"",\n#elif REAL == FLOAT\n			sscanf(line,""%f%f"",\n#endif	\n				&mat->me[i][j].re,&mat->me[i][j].im)<1 );\n	  fprintf(stderr,""Continue: "");\n	  fscanf(fp,""%c"",&c);\n	  if ( c == 'n' || c == 'N' )\n	  {    dynamic = FALSE;                 goto redo;      }\n	  if ( (c == 'b' || c == 'B') /* && i > 0 */ )\n	  {     if ( i > 0 )\n		    i--;\n		dynamic = FALSE;        goto redo;\n	  }\n     }\n     \n     return (mat);\n}\n\n/* bzm_finput -- batch-file input of matrix */\n#ifndef ANSI_C\nZMAT     *bzm_finput(fp,mat)\nFILE    *fp;\nZMAT     *mat;\n#else\nZMAT     *bzm_finput(FILE *fp,ZMAT *mat)\n#endif\n{\n     unsigned int      i,j,m,n,dummy;\n     int        io_code;\n     \n     /* get dimension */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp,"" ComplexMatrix: %u by %u"",&m,&n)) < 2 ||\n	 m>MAXDIM || n>MAXDIM )\n	  error(io_code==EOF ? E_EOF : E_FORMAT,""bzm_finput"");\n     \n     /* allocate memory if necessary */\n     if ( mat==ZMNULL || mat->m<m || mat->n<n )\n	  mat = zm_resize(mat,m,n);\n     \n     /* get entries */\n     for ( i=0; i<m; i++ )\n     {\n	  skipjunk(fp);\n	  if ( fscanf(fp,"" row %u:"",&dummy) < 1 )\n	       error(E_FORMAT,""bzm_finput"");\n	  for ( j=0; j<n; j++ )\n	  {\n	      /* printf(""bzm_finput: j = %d\n"", j); */\n#if REAL == DOUBLE\n	      if ((io_code=fscanf(fp,"" ( %lf , %lf )"",\n#elif REAL == FLOAT\n	      if ((io_code=fscanf(fp,"" ( %f , %f )"",\n#endif\n				  &mat->me[i][j].re,&mat->me[i][j].im)) < 2 )\n		  error(io_code==EOF ? E_EOF : E_FORMAT,""bzm_finput"");\n	  }\n     }\n     \n     return (mat);\n}\n\n#ifndef ANSI_C\nZVEC     *zv_finput(fp,x)\nFILE    *fp;\nZVEC     *x;\n#else\nZVEC     *zv_finput(FILE *fp,ZVEC *x)\n#endif\n{\n     ZVEC        *izv_finput(),*bzv_finput();\n     \n     if ( isatty(fileno(fp)) )\n	  return izv_finput(fp,x);\n     else\n	  return bzv_finput(fp,x);\n}\n\n/* izv_finput -- interactive input of vector */\n#ifndef ANSI_C\nZVEC     *izv_finput(fp,vec)\nFILE    *fp;\nZVEC     *vec;\n#else\nZVEC     *izv_finput(FILE *fp,ZVEC *vec)\n#endif\n{\n     unsigned int      i,dim,dynamic;  /* dynamic set if memory allocated here */\n     \n     /* get vector dimension */\n     if ( vec != ZVNULL && vec->dim<MAXDIM )\n     {  dim = vec->dim; dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,""ComplexVector: dim: "");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""izv_finput"");\n	  } while ( sscanf(line,""%u"",&dim)<1 || dim>MAXDIM );\n	  vec = zv_get(dim);\n     }\n     \n     /* input elements */\n     for ( i=0; i<dim; i++ )\n	  do\n	  {\n	  redo:\n	       fprintf(stderr,""entry %u: "",i);\n	       if ( !dynamic )\n		    fprintf(stderr,""old (%14.9g,%14.9g) new: "",\n			    vec->ve[i].re,vec->ve[i].im);\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""izv_finput"");\n	       if ( (*line == 'b' || *line == 'B') && i > 0 )\n	       {        i--;    dynamic = FALSE;        goto redo;         }\n	       if ( (*line == 'f' || *line == 'F') && i < dim-1 )\n	       {        i++;    dynamic = FALSE;        goto redo;         }\n	  } while ( *line=='\0' ||\n#if REAL == DOUBLE\n		    sscanf(line,""%lf%lf"",\n#elif REAL == FLOAT\n		    sscanf(line,""%f%f"",\n#endif  \n			   &vec->ve[i].re,&vec->ve[i].im) < 2 );\n     \n     return (vec);\n}\n\n/* bzv_finput -- batch-file input of vector */\n#ifndef ANSI_C\nZVEC     *bzv_finput(fp,vec)\nFILE    *fp;\nZVEC    *vec;\n#else\nZVEC     *bzv_finput(FILE *fp, ZVEC *vec)\n#endif\n{\n     unsigned int      i,dim;\n     int        io_code;\n     \n     /* get dimension */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp,"" ComplexVector: dim:%u"",&dim)) < 1 ||\n	  dim>MAXDIM )\n	 error(io_code==EOF ? 7 : 6,""bzv_finput"");\n\n     \n     /* allocate memory if necessary */\n     if ( vec==ZVNULL || vec->dim<dim )\n	  vec = zv_resize(vec,dim);\n     \n     /* get entries */\n     skipjunk(fp);\n     for ( i=0; i<dim; i++ )\n#if REAL == DOUBLE\n	  if ((io_code=fscanf(fp,"" (%lf,%lf)"",\n#elif REAL == FLOAT\n          if ((io_code=fscanf(fp,"" (%f,%f)"",\n#endif\n			      &vec->ve[i].re,&vec->ve[i].im)) < 2 )\n	       error(io_code==EOF ? 7 : 6,""bzv_finput"");\n     \n     return (vec);\n}\n\n/**************************************************************************\n  Output routines\n  **************************************************************************/\nstatic const char    *zformat = "" (%14.9g, %14.9g) "";\n\n#ifndef ANSI_C\nchar	*setzformat(f_string)\nchar    *f_string;\n#else\nconst char	*setzformat(const char *f_string)\n#endif\n{\n    const char	*old_f_string;\n    old_f_string = zformat;\n    if ( f_string != (char *)NULL && *f_string != '\0' )\n	zformat = f_string;\n\n    return old_f_string;\n}\n\n#ifndef ANSI_C\nvoid	z_foutput(fp,z)\nFILE	*fp;\ncomplex	z;\n#else\nvoid	z_foutput(FILE *fp,complex z)\n#endif\n{\n    fprintf(fp,zformat,z.re,z.im);\n    putc('\n',fp);\n}\n\n#ifndef ANSI_C\nvoid    zm_foutput(fp,a)\nFILE    *fp;\nZMAT     *a;\n#else\nvoid    zm_foutput(FILE *fp,ZMAT *a)\n#endif\n{\n     unsigned int      i, j, tmp;\n     \n     if ( a == ZMNULL )\n     {  fprintf(fp,""ComplexMatrix: NULL\n"");   return;         }\n     fprintf(fp,""ComplexMatrix: %d by %d\n"",a->m,a->n);\n     if ( a->me == (complex **)NULL )\n     {  fprintf(fp,""NULL\n"");           return;         }\n     for ( i=0; i<a->m; i++ )   /* for each row... */\n     {\n	  fprintf(fp,""row %u: "",i);\n	  for ( j=0, tmp=1; j<a->n; j++, tmp++ )\n	  {             /* for each col in row... */\n	       fprintf(fp,zformat,a->me[i][j].re,a->me[i][j].im);\n	       if ( ! (tmp % 2) )       putc('\n',fp);\n	  }\n	  if ( tmp % 2 != 1 )   putc('\n',fp);\n     }\n}\n\n#ifndef ANSI_C\nvoid    zv_foutput(fp,x)\nFILE    *fp;\nZVEC     *x;\n#else\nvoid    zv_foutput(FILE *fp,ZVEC *x)\n#endif\n{\n     unsigned int      i, tmp;\n     \n     if ( x == ZVNULL )\n     {  fprintf(fp,""ComplexVector: NULL\n"");   return;         }\n     fprintf(fp,""ComplexVector: dim: %d\n"",x->dim);\n     if ( x->ve == (complex *)NULL )\n     {  fprintf(fp,""NULL\n"");   return;         }\n     for ( i=0, tmp=0; i<x->dim; i++, tmp++ )\n     {\n	  fprintf(fp,zformat,x->ve[i].re,x->ve[i].im);\n	  if ( (tmp % 2) == 1 )   putc('\n',fp);\n     }\n     if ( (tmp % 2) != 0 )        putc('\n',fp);\n}\n\n#ifndef ANSI_C\nvoid    zm_dump(fp,a)\nFILE    *fp;\nZMAT     *a;\n#else\nvoid    zm_dump(FILE *fp, ZMAT *a)\n#endif\n{\n	unsigned int   i, j, tmp;\n     \n     if ( a == ZMNULL )\n     {  fprintf(fp,""ComplexMatrix: NULL\n"");   return;         }\n     fprintf(fp,""ComplexMatrix: %d by %d @ 0x%lx\n"",a->m,a->n,(long)a);\n     fprintf(fp,""\tmax_m = %d, max_n = %d, max_size = %d\n"",\n	     a->max_m, a->max_n, a->max_size);\n     if ( a->me == (complex **)NULL )\n     {  fprintf(fp,""NULL\n"");           return;         }\n     fprintf(fp,""a->me @ 0x%lx\n"",(long)(a->me));\n     fprintf(fp,""a->base @ 0x%lx\n"",(long)(a->base));\n     for ( i=0; i<a->m; i++ )   /* for each row... */\n     {\n	  fprintf(fp,""row %u: @ 0x%lx "",i,(long)(a->me[i]));\n	  for ( j=0, tmp=1; j<a->n; j++, tmp++ )\n	  {             /* for each col in row... */\n	       fprintf(fp,zformat,a->me[i][j].re,a->me[i][j].im);\n	       if ( ! (tmp % 2) )       putc('\n',fp);\n	  }\n	  if ( tmp % 2 != 1 )   putc('\n',fp);\n     }\n}\n\n\n#ifndef ANSI_C\nvoid    zv_dump(fp,x)\nFILE    *fp;\nZVEC     *x;\n#else\nvoid    zv_dump(FILE *fp,ZVEC *x)\n#endif\n{\n     unsigned int      i, tmp;\n     \n     if ( ! x )\n     {  fprintf(fp,""ComplexVector: NULL\n"");   return;         }\n     fprintf(fp,""ComplexVector: dim: %d @ 0x%lx\n"",x->dim,(long)(x));\n     if ( ! x->ve )\n     {  fprintf(fp,""NULL\n"");   return;         }\n     fprintf(fp,""x->ve @ 0x%lx\n"",(long)(x->ve));\n     for ( i=0, tmp=0; i<x->dim; i++, tmp++ )\n     {\n	  fprintf(fp,zformat,x->ve[i].re,x->ve[i].im);\n	  if ( tmp % 2 == 1 )   putc('\n',fp);\n     }\n     if ( tmp % 2 != 0 )        putc('\n',fp);\n}\n\n"
leukocyte/meschach_lib/svd.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File containing routines for computing the SVD of matrices\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\nstatic char rcsid[] = ""$Id: svd.c,v 1.7 1995/09/08 14:45:43 des Exp $"";\n\n\n\n#define	sgn(x)	((x) >= 0 ? 1 : -1)\n#define	MAX_STACK	100\n\n/* fixsvd -- fix minor details about SVD\n	-- make singular values non-negative\n	-- sort singular values in decreasing order\n	-- variables as for bisvd()\n	-- no argument checking */\n#ifndef ANSI_C\nstatic void	fixsvd(d,U,V)\nVEC	*d;\nMAT	*U, *V;\n#else\nstatic void	fixsvd(VEC *d, MAT *U, MAT *V)\n#endif\n{\n    int		i, j, k, l, r, stack[MAX_STACK], sp;\n    Real	tmp, v;\n\n    /* make singular values non-negative */\n    for ( i = 0; i < d->dim; i++ )\n	if ( d->ve[i] < 0.0 )\n	{\n	    d->ve[i] = - d->ve[i];\n	    if ( U != MNULL )\n		for ( j = 0; j < U->m; j++ )\n		    U->me[i][j] = - U->me[i][j];\n	}\n\n    /* sort singular values */\n    /* nonrecursive implementation of quicksort due to R.Sedgewick,\n       ""Algorithms in C"", p. 122 (1990) */\n    sp = -1;\n    l = 0;	r = d->dim - 1;\n    for ( ; ; )\n    {\n	while ( r > l )\n	{\n	    /* i = partition(d->ve,l,r) */\n	    v = d->ve[r];\n\n	    i = l - 1;	    j = r;\n	    for ( ; ; )\n	    {	/* inequalities are ""backwards"" for **decreasing** order */\n		while ( d->ve[++i] > v )\n		    ;\n		while ( d->ve[--j] < v )\n		    ;\n		if ( i >= j )\n		    break;\n		/* swap entries in d->ve */\n		tmp = d->ve[i];	  d->ve[i] = d->ve[j];	d->ve[j] = tmp;\n		/* swap rows of U & V as well */\n		if ( U != MNULL )\n		    for ( k = 0; k < U->n; k++ )\n		    {\n			tmp = U->me[i][k];\n			U->me[i][k] = U->me[j][k];\n			U->me[j][k] = tmp;\n		    }\n		if ( V != MNULL )\n		    for ( k = 0; k < V->n; k++ )\n		    {\n			tmp = V->me[i][k];\n			V->me[i][k] = V->me[j][k];\n			V->me[j][k] = tmp;\n		    }\n	    }\n	    tmp = d->ve[i];    d->ve[i] = d->ve[r];    d->ve[r] = tmp;\n	    if ( U != MNULL )\n		for ( k = 0; k < U->n; k++ )\n		{\n		    tmp = U->me[i][k];\n		    U->me[i][k] = U->me[r][k];\n		    U->me[r][k] = tmp;\n		}\n	    if ( V != MNULL )\n		for ( k = 0; k < V->n; k++ )\n		{\n		    tmp = V->me[i][k];\n		    V->me[i][k] = V->me[r][k];\n		    V->me[r][k] = tmp;\n		}\n	    /* end i = partition(...) */\n	    if ( i - l > r - i )\n	    {	stack[++sp] = l;    stack[++sp] = i-1;	l = i+1;    }\n	    else\n	    {	stack[++sp] = i+1;  stack[++sp] = r;	r = i-1;    }\n	}\n	if ( sp < 0 )\n	    break;\n	r = stack[sp--];	l = stack[sp--];\n    }\n}\n\n\n/* bisvd -- svd of a bidiagonal m x n matrix represented by d (diagonal) and\n			f (super-diagonals)\n	-- returns with d set to the singular values, f zeroed\n	-- if U, V non-NULL, the orthogonal operations are accumulated\n		in U, V; if U, V == I on entry, then SVD == U^T.A.V\n		where A is initial matrix\n	-- returns d on exit */\n#ifndef ANSI_C\nVEC	*bisvd(d,f,U,V)\nVEC	*d, *f;\nMAT	*U, *V;\n#else\nVEC	*bisvd(VEC *d, VEC *f, MAT *U, MAT *V)\n#endif\n{\n	int	i, j, n;\n	int	i_min, i_max, split;\n	Real	c, s, shift, size, z;\n	Real	d_tmp, diff, t11, t12, t22, *d_ve, *f_ve;\n\n	if ( ! d || ! f )\n		error(E_NULL,""bisvd"");\n	if ( d->dim != f->dim + 1 )\n		error(E_SIZES,""bisvd"");\n	n = d->dim;\n	if ( ( U && U->n < n ) || ( V && V->m < n ) )\n		error(E_SIZES,""bisvd"");\n	if ( ( U && U->m != U->n ) || ( V && V->m != V->n ) )\n		error(E_SQUARE,""bisvd"");\n\n\n	if ( n == 1 )\n	  {\n	    if ( d->ve[0] < 0.0 )\n	      {\n		d->ve[0] = - d->ve[0];\n		if ( U != MNULL )\n		  sm_mlt(-1.0,U,U);\n	      }\n	    return d;\n	  }\n	d_ve = d->ve;	f_ve = f->ve;\n\n	size = v_norm_inf(d) + v_norm_inf(f);\n\n	i_min = 0;\n	while ( i_min < n )	/* outer while loop */\n	{\n	    /* find i_max to suit;\n		submatrix i_min..i_max should be irreducible */\n	    i_max = n - 1;\n	    for ( i = i_min; i < n - 1; i++ )\n		if ( d_ve[i] == 0.0 || f_ve[i] == 0.0 )\n		{   i_max = i;\n		    if ( f_ve[i] != 0.0 )\n		    {\n			/* have to ``chase'' f[i] element out of matrix */\n			z = f_ve[i];	f_ve[i] = 0.0;\n			for ( j = i; j < n-1 && z != 0.0; j++ )\n			{\n			    givens(d_ve[j+1],z, &c, &s);\n			    s = -s;\n			    d_ve[j+1] =  c*d_ve[j+1] - s*z;\n			    if ( j+1 < n-1 )\n			    {\n				z         = s*f_ve[j+1];\n				f_ve[j+1] = c*f_ve[j+1];\n			    }\n			    if ( U )\n				rot_rows(U,i,j+1,c,s,U);\n			}\n		    }\n		    break;\n		}\n	    if ( i_max <= i_min )\n	    {\n		i_min = i_max + 1;\n		continue;\n	    }\n	    /* printf(""bisvd: i_min = %d, i_max = %d\n"",i_min,i_max); */\n\n	    split = FALSE;\n	    while ( ! split )\n	    {\n		/* compute shift */\n		t11 = d_ve[i_max-1]*d_ve[i_max-1] +\n			(i_max > i_min+1 ? f_ve[i_max-2]*f_ve[i_max-2] : 0.0);\n		t12 = d_ve[i_max-1]*f_ve[i_max-1];\n		t22 = d_ve[i_max]*d_ve[i_max] + f_ve[i_max-1]*f_ve[i_max-1];\n		/* use e-val of [[t11,t12],[t12,t22]] matrix\n				closest to t22 */\n		diff = (t11-t22)/2;\n		shift = t22 - t12*t12/(diff +\n			sgn(diff)*sqrt(diff*diff+t12*t12));\n\n		/* initial Givens' rotation */\n		givens(d_ve[i_min]*d_ve[i_min]-shift,\n			d_ve[i_min]*f_ve[i_min], &c, &s);\n\n		/* do initial Givens' rotations */\n		d_tmp         = c*d_ve[i_min] + s*f_ve[i_min];\n		f_ve[i_min]   = c*f_ve[i_min] - s*d_ve[i_min];\n		d_ve[i_min]   = d_tmp;\n		z             = s*d_ve[i_min+1];\n		d_ve[i_min+1] = c*d_ve[i_min+1];\n		if ( V )\n		    rot_rows(V,i_min,i_min+1,c,s,V);\n		/* 2nd Givens' rotation */\n		givens(d_ve[i_min],z, &c, &s);\n		d_ve[i_min]   = c*d_ve[i_min] + s*z;\n		d_tmp         = c*d_ve[i_min+1] - s*f_ve[i_min];\n		f_ve[i_min]   = s*d_ve[i_min+1] + c*f_ve[i_min];\n		d_ve[i_min+1] = d_tmp;\n		if ( i_min+1 < i_max )\n		{\n		    z             = s*f_ve[i_min+1];\n		    f_ve[i_min+1] = c*f_ve[i_min+1];\n		}\n		if ( U )\n		    rot_rows(U,i_min,i_min+1,c,s,U);\n\n		for ( i = i_min+1; i < i_max; i++ )\n		{\n		    /* get Givens' rotation for zeroing z */\n		    givens(f_ve[i-1],z, &c, &s);\n		    f_ve[i-1] = c*f_ve[i-1] + s*z;\n		    d_tmp     = c*d_ve[i] + s*f_ve[i];\n		    f_ve[i]   = c*f_ve[i] - s*d_ve[i];\n		    d_ve[i]   = d_tmp;\n		    z         = s*d_ve[i+1];\n		    d_ve[i+1] = c*d_ve[i+1];\n		    if ( V )\n			rot_rows(V,i,i+1,c,s,V);\n		    /* get 2nd Givens' rotation */\n		    givens(d_ve[i],z, &c, &s);\n		    d_ve[i]   = c*d_ve[i] + s*z;\n		    d_tmp     = c*d_ve[i+1] - s*f_ve[i];\n		    f_ve[i]   = c*f_ve[i] + s*d_ve[i+1];\n		    d_ve[i+1] = d_tmp;\n		    if ( i+1 < i_max )\n		    {\n			z         = s*f_ve[i+1];\n			f_ve[i+1] = c*f_ve[i+1];\n		    }\n		    if ( U )\n			rot_rows(U,i,i+1,c,s,U);\n		}\n		/* should matrix be split? */\n		for ( i = i_min; i < i_max; i++ )\n		    if ( fabs(f_ve[i]) <\n				MACHEPS*(fabs(d_ve[i])+fabs(d_ve[i+1])) )\n		    {\n			split = TRUE;\n			f_ve[i] = 0.0;\n		    }\n		    else if ( fabs(d_ve[i]) < MACHEPS*size )\n		    {\n			split = TRUE;\n			d_ve[i] = 0.0;\n		    }\n		    /* printf(""bisvd: d =\n"");	v_output(d); */\n		    /* printf(""bisvd: f = \n"");	v_output(f); */\n		}\n	}\n	fixsvd(d,U,V);\n\n	return d;\n}\n\n/* bifactor -- perform preliminary factorisation for bisvd\n	-- updates U and/or V, which ever is not NULL */\n#ifndef ANSI_C\nMAT	*bifactor(A,U,V)\nMAT	*A, *U, *V;\n#else\nMAT	*bifactor(MAT *A, MAT *U, MAT *V)\n#endif\n{\n	int	k;\n	STATIC VEC	*tmp1=VNULL, *tmp2=VNULL, *w=VNULL;\n	Real	beta;\n\n	if ( ! A )\n		error(E_NULL,""bifactor"");\n	if ( ( U && ( U->m != U->n ) ) || ( V && ( V->m != V->n ) ) )\n		error(E_SQUARE,""bifactor"");\n	if ( ( U && U->m != A->m ) || ( V && V->m != A->n ) )\n		error(E_SIZES,""bifactor"");\n	tmp1 = v_resize(tmp1,A->m);\n	tmp2 = v_resize(tmp2,A->n);\n	w    = v_resize(w,   max(A->m,A->n));\n	MEM_STAT_REG(tmp1,TYPE_VEC);\n	MEM_STAT_REG(tmp2,TYPE_VEC);\n	MEM_STAT_REG(w,   TYPE_VEC);\n\n	if ( A->m >= A->n )\n	    for ( k = 0; k < A->n; k++ )\n	    {\n		get_col(A,k,tmp1);\n		hhvec(tmp1,k,&beta,tmp1,&(A->me[k][k]));\n		_hhtrcols(A,k,k+1,tmp1,beta,w);\n		if ( U )\n		    _hhtrcols(U,k,0,tmp1,beta,w);\n		if ( k+1 >= A->n )\n		    continue;\n		get_row(A,k,tmp2);\n		hhvec(tmp2,k+1,&beta,tmp2,&(A->me[k][k+1]));\n		hhtrrows(A,k+1,k+1,tmp2,beta);\n		if ( V )\n		    _hhtrcols(V,k+1,0,tmp2,beta,w);\n	    }\n	else\n	    for ( k = 0; k < A->m; k++ )\n	    {\n		get_row(A,k,tmp2);\n		hhvec(tmp2,k,&beta,tmp2,&(A->me[k][k]));\n		hhtrrows(A,k+1,k,tmp2,beta);\n		if ( V )\n		    _hhtrcols(V,k,0,tmp2,beta,w);\n		if ( k+1 >= A->m )\n		    continue;\n		get_col(A,k,tmp1);\n		hhvec(tmp1,k+1,&beta,tmp1,&(A->me[k+1][k]));\n		_hhtrcols(A,k+1,k+1,tmp1,beta,w);\n		if ( U )\n		    _hhtrcols(U,k+1,0,tmp1,beta,w);\n	    }\n\n#ifdef	THREADSAFE\n	V_FREE(tmp1);	V_FREE(tmp2);\n#endif\n\n	return A;\n}\n\n/* svd -- returns vector of singular values in d\n	-- also updates U and/or V, if one or the other is non-NULL\n	-- destroys A */\n#ifndef ANSI_C\nVEC	*svd(A,U,V,d)\nMAT	*A, *U, *V;\nVEC	*d;\n#else\nVEC	*svd(MAT *A, MAT *U, MAT *V, VEC *d)\n#endif\n{\n	STATIC VEC	*f=VNULL;\n	int	i, limit;\n	MAT	*A_tmp;\n\n	if ( ! A )\n		error(E_NULL,""svd"");\n	if ( ( U && ( U->m != U->n ) ) || ( V && ( V->m != V->n ) ) )\n		error(E_SQUARE,""svd"");\n	if ( ( U && U->m != A->m ) || ( V && V->m != A->n ) )\n		error(E_SIZES,""svd"");\n\n	A_tmp = m_copy(A,MNULL);\n	if ( U != MNULL )\n	    m_ident(U);\n	if ( V != MNULL )\n	    m_ident(V);\n	limit = min(A_tmp->m,A_tmp->n);\n	d = v_resize(d,limit);\n	f = v_resize(f,limit-1);\n	MEM_STAT_REG(f,TYPE_VEC);\n\n	bifactor(A_tmp,U,V);\n	if ( A_tmp->m >= A_tmp->n )\n	    for ( i = 0; i < limit; i++ )\n	    {\n		d->ve[i] = A_tmp->me[i][i];\n		if ( i+1 < limit )\n		    f->ve[i] = A_tmp->me[i][i+1];\n	    }\n	else\n	    for ( i = 0; i < limit; i++ )\n	    {\n		d->ve[i] = A_tmp->me[i][i];\n		if ( i+1 < limit )\n		    f->ve[i] = A_tmp->me[i+1][i];\n	    }\n\n\n	if ( A_tmp->m >= A_tmp->n )\n	    bisvd(d,f,U,V);\n	else\n	    bisvd(d,f,V,U);\n\n	M_FREE(A_tmp);\n#ifdef	THREADSAFE\n	V_FREE(f);\n#endif\n\n	return d;\n}\n\n"
leukocyte/meschach_lib/zqrfctr.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  This file contains the routines needed to perform QR factorisation\n  of matrices, as well as Householder transformations.\n  The internal ""factored form"" of a matrix A is not quite standard.\n  The diagonal of A is replaced by the diagonal of R -- not by the 1st non-zero\n  entries of the Householder vectors. The 1st non-zero entries are held in\n  the diag parameter of QRfactor(). The reason for this non-standard\n  representation is that it enables direct use of the Usolve() function\n  rather than requiring that  a seperate function be written just for this case.\n  See, e.g., QRsolve() below for more details.\n\n  Complex version\n  \n*/\n\nstatic	char	rcsid[] = ""$Id: zqrfctr.c,v 1.1 1994/01/13 04:21:22 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""zmatrix.h""\n#include	""zmatrix2.h"" \n\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n\n#define		sign(x)	((x) > 0.0 ? 1 : ((x) < 0.0 ? -1 : 0 ))\n\n/* Note: The usual representation of a Householder transformation is taken\n   to be:\n   P = I - beta.u.u*\n   where beta = 2/(u*.u) and u is called the Householder vector\n   (u* is the conjugate transposed vector of u\n*/\n\n/* zQRfactor -- forms the QR factorisation of A\n	-- factorisation stored in compact form as described above\n	(not quite standard format) */\nZMAT	*zQRfactor(A,diag)\nZMAT	*A;\nZVEC	*diag;\n{\n    unsigned int	k,limit;\n    Real	beta;\n    STATIC	ZVEC	*tmp1=ZVNULL, *w=ZVNULL;\n    \n    if ( ! A || ! diag )\n	error(E_NULL,""zQRfactor"");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit )\n	error(E_SIZES,""zQRfactor"");\n    \n    tmp1 = zv_resize(tmp1,A->m);\n    w    = zv_resize(w,   A->n);\n    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n    MEM_STAT_REG(w,   TYPE_ZVEC);\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* get H/holder vector for the k-th column */\n	zget_col(A,k,tmp1);\n	zhhvec(tmp1,k,&beta,tmp1,&A->me[k][k]);\n	diag->ve[k] = tmp1->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	tracecatch(_zhhtrcols(A,k,k+1,tmp1,beta,w),""zQRfactor"");\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp1);	ZV_FREE(w);\n#endif\n\n    return (A);\n}\n\n/* zQRCPfactor -- forms the QR factorisation of A with column pivoting\n   -- factorisation stored in compact form as described above\n   ( not quite standard format )				*/\nZMAT	*zQRCPfactor(A,diag,px)\nZMAT	*A;\nZVEC	*diag;\nPERM	*px;\n{\n    unsigned int	i, i_max, j, k, limit;\n    STATIC	ZVEC	*tmp1=ZVNULL, *tmp2=ZVNULL, *w=ZVNULL;\n    STATIC	VEC	*gamma=VNULL;\n    Real 	beta;\n    Real	maxgamma, sum, tmp;\n    complex	ztmp;\n    \n    if ( ! A || ! diag || ! px )\n	error(E_NULL,""QRCPfactor"");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit || px->size != A->n )\n	error(E_SIZES,""QRCPfactor"");\n    \n    tmp1 = zv_resize(tmp1,A->m);\n    tmp2 = zv_resize(tmp2,A->m);\n    gamma = v_resize(gamma,A->n);\n    w    = zv_resize(w,A->n);\n    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n    MEM_STAT_REG(tmp2,TYPE_ZVEC);\n    MEM_STAT_REG(gamma,TYPE_VEC);\n    MEM_STAT_REG(w,   TYPE_ZVEC);\n    \n    /* initialise gamma and px */\n    for ( j=0; j<A->n; j++ )\n    {\n	px->pe[j] = j;\n	sum = 0.0;\n	for ( i=0; i<A->m; i++ )\n	    sum += square(A->me[i][j].re) + square(A->me[i][j].im);\n	gamma->ve[j] = sum;\n    }\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* find ""best"" column to use */\n	i_max = k;	maxgamma = gamma->ve[k];\n	for ( i=k+1; i<A->n; i++ )\n	    /* Loop invariant:maxgamma=gamma[i_max]\n	       >=gamma[l];l=k,...,i-1 */\n	    if ( gamma->ve[i] > maxgamma )\n	    {	maxgamma = gamma->ve[i]; i_max = i;	}\n	\n	/* swap columns if necessary */\n	if ( i_max != k )\n	{\n	    /* swap gamma values */\n	    tmp = gamma->ve[k];\n	    gamma->ve[k] = gamma->ve[i_max];\n	    gamma->ve[i_max] = tmp;\n	    \n	    /* update column permutation */\n	    px_transp(px,k,i_max);\n	    \n	    /* swap columns of A */\n	    for ( i=0; i<A->m; i++ )\n	    {\n		ztmp = A->me[i][k];\n		A->me[i][k] = A->me[i][i_max];\n		A->me[i][i_max] = ztmp;\n	    }\n	}\n	\n	/* get H/holder vector for the k-th column */\n	zget_col(A,k,tmp1);\n	/* hhvec(tmp1,k,&beta->ve[k],tmp1,&A->me[k][k]); */\n	zhhvec(tmp1,k,&beta,tmp1,&A->me[k][k]);\n	diag->ve[k] = tmp1->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	_zhhtrcols(A,k,k+1,tmp1,beta,w);\n	\n	/* update gamma values */\n	for ( j=k+1; j<A->n; j++ )\n	    gamma->ve[j] -= square(A->me[k][j].re)+square(A->me[k][j].im);\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp1);	ZV_FREE(tmp2);	V_FREE(gamma);	ZV_FREE(w);\n#endif\n    return (A);\n}\n\n/* zQsolve -- solves Qx = b, Q is an orthogonal matrix stored in compact\n	form a la QRfactor()\n	-- may be in-situ */\nZVEC	*_zQsolve(QR,diag,b,x,tmp)\nZMAT	*QR;\nZVEC	*diag, *b, *x, *tmp;\n{\n    unsigned int	dynamic;\n    int		k, limit;\n    Real	beta, r_ii, tmp_val;\n    \n    limit = min(QR->m,QR->n);\n    dynamic = FALSE;\n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,""_zQsolve"");\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,""_zQsolve"");\n    x = zv_resize(x,QR->m);\n    if ( tmp == ZVNULL )\n	dynamic = TRUE;\n    tmp = zv_resize(tmp,QR->m);\n    \n    /* apply H/holder transforms in normal order */\n    x = zv_copy(b,x);\n    for ( k = 0 ; k < limit ; k++ )\n    {\n	zget_col(QR,k,tmp);\n	r_ii = zabs(tmp->ve[k]);\n	tmp->ve[k] = diag->ve[k];\n	tmp_val = (r_ii*zabs(diag->ve[k]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	/* hhtrvec(tmp,beta->ve[k],k,x,x); */\n	zhhtrvec(tmp,beta,k,x,x);\n    }\n    \n    if ( dynamic )\n	ZV_FREE(tmp);\n    \n    return (x);\n}\n\n/* zmakeQ -- constructs orthogonal matrix from Householder vectors stored in\n   compact QR form */\nZMAT	*zmakeQ(QR,diag,Qout)\nZMAT	*QR,*Qout;\nZVEC	*diag;\n{\n    STATIC	ZVEC	*tmp1=ZVNULL,*tmp2=ZVNULL;\n    unsigned int	i, limit;\n    Real	beta, r_ii, tmp_val;\n    int	j;\n\n    limit = min(QR->m,QR->n);\n    if ( ! QR || ! diag )\n	error(E_NULL,""zmakeQ"");\n    if ( diag->dim < limit )\n	error(E_SIZES,""zmakeQ"");\n    Qout = zm_resize(Qout,QR->m,QR->m);\n\n    tmp1 = zv_resize(tmp1,QR->m);	/* contains basis vec & columns of Q */\n    tmp2 = zv_resize(tmp2,QR->m);	/* contains H/holder vectors */\n    MEM_STAT_REG(tmp1,TYPE_ZVEC);\n    MEM_STAT_REG(tmp2,TYPE_ZVEC);\n\n    for ( i=0; i<QR->m ; i++ )\n    {	/* get i-th column of Q */\n	/* set up tmp1 as i-th basis vector */\n	for ( j=0; j<QR->m ; j++ )\n	    tmp1->ve[j].re = tmp1->ve[j].im = 0.0;\n	tmp1->ve[i].re = 1.0;\n	\n	/* apply H/h transforms in reverse order */\n	for ( j=limit-1; j>=0; j-- )\n	{\n	    zget_col(QR,j,tmp2);\n	    r_ii = zabs(tmp2->ve[j]);\n	    tmp2->ve[j] = diag->ve[j];\n	    tmp_val = (r_ii*zabs(diag->ve[j]));\n	    beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	    /* hhtrvec(tmp2,beta->ve[j],j,tmp1,tmp1); */\n	    zhhtrvec(tmp2,beta,j,tmp1,tmp1);\n	}\n	\n	/* insert into Q */\n	zset_col(Qout,i,tmp1);\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp1);	ZV_FREE(tmp2);\n#endif\n\n    return (Qout);\n}\n\n/* zmakeR -- constructs upper triangular matrix from QR (compact form)\n	-- may be in-situ (all it does is zero the lower 1/2) */\nZMAT	*zmakeR(QR,Rout)\nZMAT	*QR,*Rout;\n{\n    unsigned int	i,j;\n    \n    if ( QR==ZMNULL )\n	error(E_NULL,""zmakeR"");\n    Rout = zm_copy(QR,Rout);\n    \n    for ( i=1; i<QR->m; i++ )\n	for ( j=0; j<QR->n && j<i; j++ )\n	    Rout->me[i][j].re = Rout->me[i][j].im = 0.0;\n    \n    return (Rout);\n}\n\n/* zQRsolve -- solves the system Q.R.x=b where Q & R are stored in compact form\n   -- returns x, which is created if necessary */\nZVEC	*zQRsolve(QR,diag,b,x)\nZMAT	*QR;\nZVEC	*diag, *b, *x;\n{\n    int	limit;\n    STATIC	ZVEC	*tmp = ZVNULL;\n    \n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,""zQRsolve"");\n    limit = min(QR->m,QR->n);\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,""zQRsolve"");\n    tmp = zv_resize(tmp,limit);\n    MEM_STAT_REG(tmp,TYPE_ZVEC);\n\n    x = zv_resize(x,QR->n);\n    _zQsolve(QR,diag,b,x,tmp);\n    x = zUsolve(QR,x,x,0.0);\n    x = zv_resize(x,QR->n);\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* zQRAsolve -- solves the system (Q.R)*.x = b\n	-- Q & R are stored in compact form\n	-- returns x, which is created if necessary */\nZVEC	*zQRAsolve(QR,diag,b,x)\nZMAT	*QR;\nZVEC	*diag, *b, *x;\n{\n    int		j, limit;\n    Real	beta, r_ii, tmp_val;\n    STATIC	ZVEC	*tmp = ZVNULL;\n    \n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,""zQRAsolve"");\n    limit = min(QR->m,QR->n);\n    if ( diag->dim < limit || b->dim != QR->n )\n	error(E_SIZES,""zQRAsolve"");\n\n    x = zv_resize(x,QR->m);\n    x = zUAsolve(QR,b,x,0.0);\n    x = zv_resize(x,QR->m);\n\n    tmp = zv_resize(tmp,x->dim);\n    MEM_STAT_REG(tmp,TYPE_ZVEC);\n    /*  printf(""zQRAsolve: tmp->dim = %d, x->dim = %d\n"", tmp->dim, x->dim); */\n    \n    /* apply H/h transforms in reverse order */\n    for ( j=limit-1; j>=0; j-- )\n    {\n	zget_col(QR,j,tmp);\n	tmp = zv_resize(tmp,QR->m);\n	r_ii = zabs(tmp->ve[j]);\n	tmp->ve[j] = diag->ve[j];\n	tmp_val = (r_ii*zabs(diag->ve[j]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	zhhtrvec(tmp,beta,j,x,x);\n    }\n\n#ifdef	THREADSAFE\n    ZV_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* zQRCPsolve -- solves A.x = b where A is factored by QRCPfactor()\n   -- assumes that A is in the compact factored form */\nZVEC	*zQRCPsolve(QR,diag,pivot,b,x)\nZMAT	*QR;\nZVEC	*diag;\nPERM	*pivot;\nZVEC	*b, *x;\n{\n    if ( ! QR || ! diag || ! pivot || ! b )\n	error(E_NULL,""zQRCPsolve"");\n    if ( (QR->m > diag->dim && QR->n > diag->dim) || QR->n != pivot->size )\n	error(E_SIZES,""zQRCPsolve"");\n    \n    x = zQRsolve(QR,diag,b,x);\n    x = pxinv_zvec(pivot,x,x);\n\n    return x;\n}\n\n/* zUmlt -- compute out = upper_triang(U).x\n	-- may be in situ */\nZVEC	*zUmlt(U,x,out)\nZMAT	*U;\nZVEC	*x, *out;\n{\n    int		i, limit;\n\n    if ( U == ZMNULL || x == ZVNULL )\n	error(E_NULL,""zUmlt"");\n    limit = min(U->m,U->n);\n    if ( limit != x->dim )\n	error(E_SIZES,""zUmlt"");\n    if ( out == ZVNULL || out->dim < limit )\n	out = zv_resize(out,limit);\n\n    for ( i = 0; i < limit; i++ )\n	out->ve[i] = __zip__(&(x->ve[i]),&(U->me[i][i]),limit - i,Z_NOCONJ);\n    return out;\n}\n\n/* zUAmlt -- returns out = upper_triang(U)^T.x */\nZVEC	*zUAmlt(U,x,out)\nZMAT	*U;\nZVEC	*x, *out;\n{\n    /* complex	sum; */\n    complex	tmp;\n    int		i, limit;\n\n    if ( U == ZMNULL || x == ZVNULL )\n	error(E_NULL,""zUAmlt"");\n    limit = min(U->m,U->n);\n    if ( out == ZVNULL || out->dim < limit )\n	out = zv_resize(out,limit);\n\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	tmp = x->ve[i];\n	out->ve[i].re = out->ve[i].im = 0.0;\n	__zmltadd__(&(out->ve[i]),&(U->me[i][i]),tmp,limit-i-1,Z_CONJ);\n    }\n\n    return out;\n}\n\n\n/* zQRcondest -- returns an estimate of the 2-norm condition number of the\n		matrix factorised by QRfactor() or QRCPfactor()\n	-- note that as Q does not affect the 2-norm condition number,\n		it is not necessary to pass the diag, beta (or pivot) vectors\n	-- generates a lower bound on the true condition number\n	-- if the matrix is exactly singular, HUGE_VAL is returned\n	-- note that QRcondest() is likely to be more reliable for\n		matrices factored using QRCPfactor() */\ndouble	zQRcondest(QR)\nZMAT	*QR;\n{\n    STATIC	ZVEC	*y=ZVNULL;\n    Real	norm, norm1, norm2, tmp1, tmp2;\n    complex	sum, tmp;\n    int		i, j, limit;\n\n    if ( QR == ZMNULL )\n	error(E_NULL,""zQRcondest"");\n\n    limit = min(QR->m,QR->n);\n    for ( i = 0; i < limit; i++ )\n	/* if ( QR->me[i][i] == 0.0 ) */\n	if ( is_zero(QR->me[i][i]) )\n	    return HUGE_VAL;\n\n    y = zv_resize(y,limit);\n    MEM_STAT_REG(y,TYPE_ZVEC);\n    /* use the trick for getting a unit vector y with ||R.y||_inf small\n       from the LU condition estimator */\n    for ( i = 0; i < limit; i++ )\n    {\n	sum.re = sum.im = 0.0;\n	for ( j = 0; j < i; j++ )\n	    /* sum -= QR->me[j][i]*y->ve[j]; */\n	    sum = zsub(sum,zmlt(QR->me[j][i],y->ve[j]));\n	/* sum -= (sum < 0.0) ? 1.0 : -1.0; */\n	norm1 = zabs(sum);\n	if ( norm1 == 0.0 )\n	    sum.re = 1.0;\n	else\n	{\n	    sum.re += sum.re / norm1;\n	    sum.im += sum.im / norm1;\n	}\n	/* y->ve[i] = sum / QR->me[i][i]; */\n	y->ve[i] = zdiv(sum,QR->me[i][i]);\n    }\n    zUAmlt(QR,y,y);\n\n    /* now apply inverse power method to R*.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp1,0.0),y,y);\n	zUAsolve(QR,y,y,0.0);\n	tmp2 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp2,0.0),y,y);\n	zUsolve(QR,y,y,0.0);\n    }\n    /* now compute approximation for ||R^{-1}||_2 */\n    norm1 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* now use complementary approach to compute approximation to ||R||_2 */\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	sum.re = sum.im = 0.0;\n	for ( j = i+1; j < limit; j++ )\n	    sum = zadd(sum,zmlt(QR->me[i][j],y->ve[j]));\n	if ( is_zero(QR->me[i][i]) )\n	    return HUGE_VAL;\n	tmp = zdiv(sum,QR->me[i][i]);\n	if ( is_zero(tmp) )\n	{\n	    y->ve[i].re = 1.0;\n	    y->ve[i].im = 0.0;\n	}\n	else\n	{\n	    norm = zabs(tmp);\n	    y->ve[i].re = sum.re / norm;\n	    y->ve[i].im = sum.im / norm;\n	}\n	/* y->ve[i] = (sum >= 0.0) ? 1.0 : -1.0; */\n	/* y->ve[i] = (QR->me[i][i] >= 0.0) ? y->ve[i] : - y->ve[i]; */\n    }\n\n    /* now apply power method to R*.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp1,0.0),y,y);\n	zUmlt(QR,y,y);\n	tmp2 = zv_norm2(y);\n	zv_mlt(zmake(1.0/tmp2,0.0),y,y);\n	zUAmlt(QR,y,y);\n    }\n    norm2 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* printf(""QRcondest: norm1 = %g, norm2 = %g\n"",norm1,norm2); */\n\n#ifdef	THREADSAFE\n    ZV_FREE(y);\n#endif\n\n    return norm1*norm2;\n}\n\n"
leukocyte/meschach_lib/dmacheps.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n#include	<stdio.h>\n\ndouble	dclean(x)\ndouble	x;\n{\n    static double	y;\n    y = x;\n    return y;	/* prevents optimisation */\n}\n\nmain()\n{\n    static double	deps, deps1, dtmp;\n\n    deps = 1.0;\n    while ( dclean(1.0+deps) > 1.0 )\n	deps = 0.5*deps;\n\n    printf(""%g\n"", 2.0*deps);\n}\n"
leukocyte/meschach_lib/znorm.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	A collection of functions for computing norms: scaled and unscaled\n	Complex version\n*/\nstatic	char	rcsid[] = ""$Id: znorm.c,v 1.1 1994/01/13 04:21:31 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""zmatrix.h""\n\n\n\n/* _zv_norm1 -- computes (scaled) 1-norms of vectors */\ndouble	_zv_norm1(x,scale)\nZVEC	*x;\nVEC	*scale;\n{\n    int	i, dim;\n    Real	s, sum;\n    \n    if ( x == ZVNULL )\n	error(E_NULL,""_zv_norm1"");\n    dim = x->dim;\n    \n    sum = 0.0;\n    if ( scale == VNULL )\n	for ( i = 0; i < dim; i++ )\n	    sum += zabs(x->ve[i]);\n    else if ( scale->dim < dim )\n	error(E_SIZES,""_zv_norm1"");\n    else\n	for ( i = 0; i < dim; i++ )\n	{\n	    s = scale->ve[i];\n	    sum += ( s== 0.0 ) ? zabs(x->ve[i]) : zabs(x->ve[i])/fabs(s);\n	}\n    \n    return sum;\n}\n\n/* square -- returns x^2 */\n/******************************\ndouble	square(x)\ndouble	x;\n{	return x*x;	}\n******************************/\n\n#define	square(x)	((x)*(x))\n\n/* _zv_norm2 -- computes (scaled) 2-norm (Euclidean norm) of vectors */\ndouble	_zv_norm2(x,scale)\nZVEC	*x;\nVEC	*scale;\n{\n    int	i, dim;\n    Real	s, sum;\n    \n    if ( x == ZVNULL )\n	error(E_NULL,""_zv_norm2"");\n    dim = x->dim;\n    \n    sum = 0.0;\n    if ( scale == VNULL )\n	for ( i = 0; i < dim; i++ )\n	    sum += square(x->ve[i].re) + square(x->ve[i].im);\n    else if ( scale->dim < dim )\n	error(E_SIZES,""_v_norm2"");\n    else\n	for ( i = 0; i < dim; i++ )\n	{\n	    s = scale->ve[i];\n	    sum += ( s== 0.0 ) ? square(x->ve[i].re) + square(x->ve[i].im) :\n		(square(x->ve[i].re) + square(x->ve[i].im))/square(s);\n	}\n    \n    return sqrt(sum);\n}\n\n#define	max(a,b)	((a) > (b) ? (a) : (b))\n\n/* _zv_norm_inf -- computes (scaled) infinity-norm (supremum norm) of vectors */\ndouble	_zv_norm_inf(x,scale)\nZVEC	*x;\nVEC	*scale;\n{\n    int	i, dim;\n    Real	s, maxval, tmp;\n    \n    if ( x == ZVNULL )\n	error(E_NULL,""_zv_norm_inf"");\n    dim = x->dim;\n    \n    maxval = 0.0;\n    if ( scale == VNULL )\n	for ( i = 0; i < dim; i++ )\n	{\n	    tmp = zabs(x->ve[i]);\n	    maxval = max(maxval,tmp);\n	}\n    else if ( scale->dim < dim )\n	error(E_SIZES,""_zv_norm_inf"");\n    else\n	for ( i = 0; i < dim; i++ )\n	{\n	    s = scale->ve[i];\n	    tmp = ( s == 0.0 ) ? zabs(x->ve[i]) : zabs(x->ve[i])/fabs(s);\n	    maxval = max(maxval,tmp);\n	}\n    \n    return maxval;\n}\n\n/* zm_norm1 -- compute matrix 1-norm -- unscaled\n	-- complex version */\ndouble	zm_norm1(A)\nZMAT	*A;\n{\n    int	i, j, m, n;\n    Real	maxval, sum;\n    \n    if ( A == ZMNULL )\n	error(E_NULL,""zm_norm1"");\n\n    m = A->m;	n = A->n;\n    maxval = 0.0;\n    \n    for ( j = 0; j < n; j++ )\n    {\n	sum = 0.0;\n	for ( i = 0; i < m; i ++ )\n	    sum += zabs(A->me[i][j]);\n	maxval = max(maxval,sum);\n    }\n    \n    return maxval;\n}\n\n/* zm_norm_inf -- compute matrix infinity-norm -- unscaled\n	-- complex version */\ndouble	zm_norm_inf(A)\nZMAT	*A;\n{\n    int	i, j, m, n;\n    Real	maxval, sum;\n    \n    if ( A == ZMNULL )\n	error(E_NULL,""zm_norm_inf"");\n    \n    m = A->m;	n = A->n;\n    maxval = 0.0;\n    \n    for ( i = 0; i < m; i++ )\n    {\n	sum = 0.0;\n	for ( j = 0; j < n; j ++ )\n	    sum += zabs(A->me[i][j]);\n	maxval = max(maxval,sum);\n    }\n    \n    return maxval;\n}\n\n/* zm_norm_frob -- compute matrix frobenius-norm -- unscaled */\ndouble	zm_norm_frob(A)\nZMAT	*A;\n{\n    int	i, j, m, n;\n    Real	sum;\n    \n    if ( A == ZMNULL )\n	error(E_NULL,""zm_norm_frob"");\n    \n    m = A->m;	n = A->n;\n    sum = 0.0;\n    \n    for ( i = 0; i < m; i++ )\n	for ( j = 0; j < n; j ++ )\n	    sum += square(A->me[i][j].re) + square(A->me[i][j].im);\n    \n    return sqrt(sum);\n}\n\n"
leukocyte/meschach_lib/spswap.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Sparse matrix swap and permutation routines\n	Modified Mon 09th Nov 1992, 08:50:54 PM\n	to use Karen George's suggestion to use unordered rows\n*/\n\nstatic	char	rcsid[] = ""$Id: spswap.c,v 1.3 1994/01/13 05:44:43 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""sparse2.h""\n\n\n#define	btos(x)	((x) ? ""TRUE"" : ""FALSE"")\n\n/* scan_to -- updates scan (int) vectors to point to the last row in each\n	column with row # <= max_row, if any */\n#ifndef ANSI_C\nvoid	scan_to(A, scan_row, scan_idx, col_list, max_row)\nSPMAT	*A;\nIVEC	*scan_row, *scan_idx, *col_list;\nint	max_row;\n#else\nvoid	scan_to(SPMAT *A, IVEC *scan_row, IVEC *scan_idx, IVEC *col_list, \n		int max_row)\n#endif\n{\n    int		col, idx, j_idx, row_num;\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( ! A || ! scan_row || ! scan_idx || ! col_list )\n	error(E_NULL,""scan_to"");\n    if ( scan_row->dim != scan_idx->dim || scan_idx->dim != col_list->dim )\n	error(E_SIZES,""scan_to"");\n\n    if ( max_row < 0 )\n	return;\n\n    if ( ! A->flag_col )\n	sp_col_access(A);\n\n    for ( j_idx = 0; j_idx < scan_row->dim; j_idx++ )\n    {\n	row_num = scan_row->ive[j_idx];\n	idx = scan_idx->ive[j_idx];\n	col = col_list->ive[j_idx];\n\n	if ( col < 0 || col >= A->n )\n	    error(E_BOUNDS,""scan_to"");\n	if ( row_num < 0 )\n	{\n	    idx = col;\n	    continue;\n	}\n	r = &(A->row[row_num]);\n	if ( idx < 0 )\n	    error(E_INTERN,""scan_to"");\n	e = &(r->elt[idx]);\n	if ( e->col != col )\n	    error(E_INTERN,""scan_to"");\n	if ( idx < 0 )\n	{\n	    printf(""scan_to: row_num = %d, idx = %d, col = %d\n"",\n		   row_num, idx, col);\n	    error(E_INTERN,""scan_to"");\n	}\n	/* if ( e->nxt_row <= max_row )\n	    chase_col(A, col, &row_num, &idx, max_row); */\n	while ( e->nxt_row >= 0 && e->nxt_row <= max_row )\n	{\n	    row_num = e->nxt_row;\n	    idx = e->nxt_idx;\n	    e = &(A->row[row_num].elt[idx]);\n	}\n	    \n	/* printf(""scan_to: computed j_idx = %d, row_num = %d, idx = %d\n"",\n	       j_idx, row_num, idx); */\n	scan_row->ive[j_idx] = row_num;\n	scan_idx->ive[j_idx] = idx;\n    }\n}\n\n/* patch_col -- patches column access paths for fill-in */\n#ifndef ANSI_C\nvoid patch_col(A, col, old_row, old_idx, row_num, idx)\nSPMAT	*A;\nint	col, old_row, old_idx, row_num, idx;\n#else\nvoid patch_col(SPMAT *A, int col, int old_row, int old_idx, int row_num, \n	       int idx)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n    \n    if ( old_row >= 0 )\n    {\n	r = &(A->row[old_row]);\n	old_idx = sprow_idx2(r,col,old_idx);\n	e = &(r->elt[old_idx]);\n	e->nxt_row = row_num;\n	e->nxt_idx = idx;\n    }\n    else\n    {\n	A->start_row[col] = row_num;\n	A->start_idx[col] = idx;\n    }\n}\n\n/* chase_col -- chases column access path in column col, starting with\n   row_num and idx, to find last row # in this column <= max_row\n   -- row_num is returned; idx is also set by this routine\n   -- assumes that the column access paths (possibly without the\n   nxt_idx fields) are set up */\n#ifndef ANSI_C\nrow_elt *chase_col(A, col, row_num, idx, max_row)\nSPMAT	*A;\nint	col, *row_num, *idx, max_row;\n#else\nrow_elt *chase_col(const SPMAT *A, int col, int *row_num, int *idx, \n		   int max_row)\n#endif\n{\n    int		old_idx, old_row, tmp_idx, tmp_row;\n    SPROW	*r;\n    row_elt	*e;\n    \n    if ( col < 0 || col >= A->n )\n	error(E_BOUNDS,""chase_col"");\n    tmp_row = *row_num;\n    if ( tmp_row < 0 )\n    {\n	if ( A->start_row[col] > max_row )\n	{\n	    tmp_row = -1;\n	    tmp_idx = col;\n	    return (row_elt *)NULL;\n	}\n	else\n	{\n	    tmp_row = A->start_row[col];\n	    tmp_idx = A->start_idx[col];\n	}\n    }\n    else\n	tmp_idx = *idx;\n    \n    old_row = tmp_row;\n    old_idx = tmp_idx;\n    while ( tmp_row >= 0 && tmp_row < max_row )\n    {\n	r = &(A->row[tmp_row]);\n	/* tmp_idx = sprow_idx2(r,col,tmp_idx); */\n	if ( tmp_idx < 0 || tmp_idx >= r->len ||\n	     r->elt[tmp_idx].col != col )\n	{\n#ifdef DEBUG\n	    printf(""chase_col:error: col = %d, row # = %d, idx = %d\n"",\n		   col, tmp_row, tmp_idx);\n	    printf(""chase_col:error: old_row = %d, old_idx = %d\n"",\n		   old_row, old_idx);\n	    printf(""chase_col:error: A =\n"");\n	    sp_dump(stdout,A);\n#endif\n	    error(E_INTERN,""chase_col"");\n	}\n	e = &(r->elt[tmp_idx]);\n	old_row = tmp_row;\n	old_idx = tmp_idx;\n	tmp_row = e->nxt_row;\n	tmp_idx = e->nxt_idx;\n    }\n    if ( old_row > max_row )\n    {\n	old_row = -1;\n	old_idx = col;\n	e = (row_elt *)NULL;\n    }\n    else if ( tmp_row <= max_row && tmp_row >= 0 )\n    {\n	old_row = tmp_row;\n	old_idx = tmp_idx;\n    }\n\n    *row_num = old_row;\n    if ( old_row >= 0 )\n	*idx = old_idx;\n    else\n	*idx = col;\n\n    return e;\n}\n\n/* chase_past -- as for chase_col except that we want the first\n	row whose row # >= min_row; -1 indicates no such row */\n#ifndef ANSI_C\nrow_elt *chase_past(A, col, row_num, idx, min_row)\nSPMAT	*A;\nint	col, *row_num, *idx, min_row;\n#else\nrow_elt *chase_past(const SPMAT *A, int col, int *row_num, int *idx, \n		    int min_row)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n    int		tmp_idx, tmp_row;\n\n    tmp_row = *row_num;\n    tmp_idx = *idx;\n    chase_col(A,col,&tmp_row,&tmp_idx,min_row);\n    if ( tmp_row < 0 )	/* use A->start_row[..] etc. */\n    {\n	if ( A->start_row[col] < 0 )\n	    tmp_row = -1;\n	else\n	{\n	    tmp_row = A->start_row[col];\n	    tmp_idx = A->start_idx[col];\n	}\n    }\n    else if ( tmp_row < min_row )\n    {\n	r = &(A->row[tmp_row]);\n	if ( tmp_idx < 0 || tmp_idx >= r->len ||\n	     r->elt[tmp_idx].col != col )\n	    error(E_INTERN,""chase_past"");\n	tmp_row = r->elt[tmp_idx].nxt_row;\n	tmp_idx = r->elt[tmp_idx].nxt_idx;\n    }\n\n    *row_num = tmp_row;\n    *idx = tmp_idx;\n    if ( tmp_row < 0 )\n	e = (row_elt *)NULL;\n    else\n    {\n	if ( tmp_idx < 0 || tmp_idx >= A->row[tmp_row].len ||\n	     A->row[tmp_row].elt[tmp_idx].col != col )\n	    error(E_INTERN,""bump_col"");\n	e = &(A->row[tmp_row].elt[tmp_idx]);\n    }\n\n    return e;\n}\n\n/* bump_col -- move along to next nonzero entry in column col after row_num\n	-- update row_num and idx */\n#ifndef ANSI_C\nrow_elt *bump_col(A, col, row_num, idx)\nSPMAT	*A;\nint	col, *row_num, *idx;\n#else\nrow_elt *bump_col(const SPMAT *A, int col, int *row_num, int *idx)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n    int		tmp_row, tmp_idx;\n\n    tmp_row = *row_num;\n    tmp_idx = *idx;\n    /* printf(""bump_col: col = %d, row# = %d, idx = %d\n"",\n	   col, *row_num, *idx); */\n    if ( tmp_row < 0 )\n    {\n	tmp_row = A->start_row[col];\n	tmp_idx = A->start_idx[col];\n    }\n    else\n    {\n	r = &(A->row[tmp_row]);\n	if ( tmp_idx < 0 || tmp_idx >= r->len ||\n	     r->elt[tmp_idx].col != col )\n	    error(E_INTERN,""bump_col"");\n	e = &(r->elt[tmp_idx]);\n	tmp_row = e->nxt_row;\n	tmp_idx = e->nxt_idx;\n    }\n    if ( tmp_row < 0 )\n    {\n	e = (row_elt *)NULL;\n	tmp_idx = col;\n    }\n    else\n    {\n	if ( tmp_idx < 0 || tmp_idx >= A->row[tmp_row].len ||\n	     A->row[tmp_row].elt[tmp_idx].col != col )\n	    error(E_INTERN,""bump_col"");\n	e = &(A->row[tmp_row].elt[tmp_idx]);\n    }\n    *row_num = tmp_row;\n    *idx = tmp_idx;\n\n    return e;\n}\n\n\n"
leukocyte/meschach_lib/sparseio.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file has the routines for sparse matrix input/output\n	It works in conjunction with sparse.c, sparse.h etc\n*/\n\n#include        <stdio.h>\n#include        ""sparse.h""\n\nstatic char rcsid[] = ""$Id: sparseio.c,v 1.4 1994/01/13 05:34:25 des Exp $"";\n\n\n\n/* local variables */\nstatic char line[MAXLINE];\n\n/* sp_foutput -- output sparse matrix A to file/stream fp */\n#ifndef ANSI_C\nvoid    sp_foutput(fp,A)\nFILE    *fp;\nSPMAT  *A;\n#else\nvoid    sp_foutput(FILE *fp, const SPMAT *A)\n#endif\n{\n	int     i, j_idx, m /* , n */;\n	SPROW  *rows;\n	row_elt *elts;\n\n	fprintf(fp,""SparseMatrix: "");\n	if ( A == SMNULL )\n	{\n		fprintf(fp,""*** NULL ***\n"");\n		error(E_NULL,""sp_foutput"");    return;\n	}\n	fprintf(fp,""%d by %d\n"",A->m,A->n);\n	m = A->m;       /* n = A->n; */\n	if ( ! (rows=A->row) )\n	{\n		fprintf(fp,""*** NULL rows ***\n"");\n		error(E_NULL,""sp_foutput"");    return;\n	}\n\n	for ( i = 0; i < m; i++ )\n	{\n		fprintf(fp,""row %d: "",i);\n		if ( ! (elts=rows[i].elt) )\n		{\n			fprintf(fp,""*** NULL element list ***\n"");\n			continue;\n		}\n		for ( j_idx = 0; j_idx < rows[i].len; j_idx++ )\n		{\n			fprintf(fp,""%d:%-20.15g "",elts[j_idx].col,\n							elts[j_idx].val);\n			if ( j_idx % 3 == 2 && j_idx != rows[i].len-1 )\n				fprintf(fp,""\n     "");\n		}\n		fprintf(fp,""\n"");\n	}\n	fprintf(fp,""#\n"");	/* to stop looking beyond for next entry */\n}\n\n/* sp_foutput2 -- print out sparse matrix **as a dense matrix**\n	-- see output format used in matrix.h etc */\n/******************************************************************\nvoid    sp_foutput2(fp,A)\nFILE    *fp;\nSPMAT  *A;\n{\n	int     cnt, i, j, j_idx;\n	SPROW  *r;\n	row_elt *elt;\n\n	if ( A == SMNULL )\n	{\n		fprintf(fp,""Matrix: *** NULL ***\n"");\n		return;\n	}\n	fprintf(fp,""Matrix: %d by %d\n"",A->m,A->n);\n	for ( i = 0; i < A->m; i++ )\n	{\n		fprintf(fp,""row %d:"",i);\n		r = &(A->row[i]);\n		elt = r->elt;\n		cnt = j = j_idx = 0;\n		while ( j_idx < r->len || j < A->n )\n		{\n			if ( j_idx >= r->len )\n				fprintf(fp,""%14.9g "",0.0);\n			else if ( j < elt[j_idx].col )\n				fprintf(fp,""%14.9g "",0.0);\n			else\n				fprintf(fp,""%14.9g "",elt[j_idx++].val);\n			if ( cnt++ % 4 == 3 )\n				fprintf(fp,""\n"");\n			j++;\n		}\n		fprintf(fp,""\n"");\n	}\n}\n******************************************************************/\n\n/* sp_dump -- prints ALL relevant information about the sparse matrix A */\n#ifndef ANSI_C\nvoid    sp_dump(fp,A)\nFILE    *fp;\nSPMAT  *A;\n#else\nvoid    sp_dump(FILE *fp, const SPMAT *A)\n#endif\n{\n	int     i, j, j_idx;\n	SPROW  *rows;\n	row_elt *elts;\n\n	fprintf(fp,""SparseMatrix dump:\n"");\n	if ( ! A )\n	{       fprintf(fp,""*** NULL ***\n"");   return; }\n	fprintf(fp,""Matrix at 0x%lx\n"",(long)A);\n	fprintf(fp,""Dimensions: %d by %d\n"",A->m,A->n);\n	fprintf(fp,""MaxDimensions: %d by %d\n"",A->max_m,A->max_n);\n	fprintf(fp,""flag_col = %d, flag_diag = %d\n"",A->flag_col,A->flag_diag);\n	fprintf(fp,""start_row @ 0x%lx:\n"",(long)(A->start_row));\n	for ( j = 0; j < A->n; j++ )\n	{\n		fprintf(fp,""%d "",A->start_row[j]);\n		if ( j % 10 == 9 )\n			fprintf(fp,""\n"");\n	}\n	fprintf(fp,""\n"");\n	fprintf(fp,""start_idx @ 0x%lx:\n"",(long)(A->start_idx));\n	for ( j = 0; j < A->n; j++ )\n	{\n		fprintf(fp,""%d "",A->start_idx[j]);\n		if ( j % 10 == 9 )\n			fprintf(fp,""\n"");\n	}\n	fprintf(fp,""\n"");\n	fprintf(fp,""Rows @ 0x%lx:\n"",(long)(A->row));\n	if ( ! A->row )\n	{       fprintf(fp,""*** NULL row ***\n"");       return; }\n	rows = A->row;\n	for ( i = 0; i < A->m; i++ )\n	{\n		fprintf(fp,""row %d: len = %d, maxlen = %d, diag idx = %d\n"",\n			i,rows[i].len,rows[i].maxlen,rows[i].diag);\n		fprintf(fp,""element list @ 0x%lx\n"",(long)(rows[i].elt));\n		if ( ! rows[i].elt )\n		{\n			fprintf(fp,""*** NULL element list ***\n"");\n			continue;\n		}\n		elts = rows[i].elt;\n		for ( j_idx = 0; j_idx < rows[i].len; j_idx++, elts++ )\n		    fprintf(fp,""Col: %d, Val: %g, nxt_row = %d, nxt_idx = %d\n"",\n			elts->col,elts->val,elts->nxt_row,elts->nxt_idx);\n		fprintf(fp,""\n"");\n	}\n}\n\n#define MINSCRATCH      100\n\n/* sp_finput -- input sparse matrix from stream/file fp\n	-- uses friendly input routine if fp is a tty\n	-- uses format identical to output format otherwise */\n#ifndef ANSI_C\nSPMAT  *sp_finput(fp)\nFILE    *fp;\n#else\nSPMAT  *sp_finput(FILE *fp)\n#endif\n{\n	int     i, len, ret_val;\n	int     col, curr_col, m, n, tmp, tty;\n	Real  val;\n	SPMAT  *A;\n	SPROW  *rows;\n\n	static row_elt *scratch;\n	static int	scratch_len = 0;\n\n	if ( ! scratch )\n	  {\n	    scratch = NEW_A(MINSCRATCH,row_elt);\n	    if ( scratch == NULL )\n	      error(E_MEM,""sp_finput"");\n	    scratch_len = MINSCRATCH;\n	  }\n\n	for ( i = 0; i < scratch_len; i++ )\n	  scratch[i].nxt_row = scratch[i].nxt_idx = -1;\n\n	tty = isatty(fileno(fp));\n\n	if ( tty )\n	{\n		fprintf(stderr,""SparseMatrix: "");\n		do {\n			fprintf(stderr,""input rows cols: "");\n			if ( ! fgets(line,MAXLINE,fp) )\n			    error(E_INPUT,""sp_finput"");\n		} while ( sscanf(line,""%u %u"",&m,&n) != 2 );\n		A = sp_get(m,n,5);\n		rows = A->row;\n\n		for ( i = 0; i < m; i++ )\n		{\n		    /* get a row... */\n		    fprintf(stderr,""Row %d:\n"",i);\n		    fprintf(stderr,""Enter <col> <val> or 'e' to end row\n"");\n		    curr_col = -1;\n\n		    len = 0;\n		    for ( ; ; )  /* forever do... */\n		      {\n		      /* if we need more scratch space, let's get it!\n		       -- using amortized doubling */\n		      if ( len >= scratch_len )\n			{\n			  scratch = RENEW(scratch,2*scratch_len,row_elt);\n			  if ( ! scratch )\n			    error(E_MEM,""sp_finput"");\n			  scratch_len = 2*scratch_len;\n			}\n			do {  /* get an entry... */\n			    fprintf(stderr,""Entry %d: "",len);\n			    if ( ! fgets(line,MAXLINE,fp) )\n				error(E_INPUT,""sp_finput"");\n			    if ( *line == 'e' || *line == 'E' )\n				break;\n#if REAL == DOUBLE\n			} while ( sscanf(line,""%u %lf"",&col,&val) != 2 ||\n#elif REAL == FLOAT\n			} while ( sscanf(line,""%u %f"",&col,&val) != 2 ||\n#endif\n				    col >= n || col <= curr_col );\n\n			if ( *line == 'e' || *line == 'E' )\n			    break;\n\n			scratch[len].col = col;\n			scratch[len].val = val;\n			curr_col = col;\n\n			len++;\n		    }\n\n		    /* Note: len = # elements in row */\n		    if ( len > 5 )\n		     {\n			if (mem_info_is_on()) {\n			   mem_bytes(TYPE_SPMAT,\n					   A->row[i].maxlen*sizeof(row_elt),\n					   len*sizeof(row_elt));  \n			}\n\n			rows[i].elt = (row_elt *)realloc((char *)rows[i].elt,\n							 len*sizeof(row_elt));\n			rows[i].maxlen = len;\n		    }\n		    MEM_COPY(scratch,rows[i].elt,len*sizeof(row_elt));\n		    rows[i].len  = len;\n		    rows[i].diag = sprow_idx(&(rows[i]),i);\n		}\n	}\n	else /* not tty */\n	{\n	        ret_val = 0;\n		skipjunk(fp);\n		fscanf(fp,""SparseMatrix:"");\n		skipjunk(fp);\n		if ( (ret_val=fscanf(fp,""%u by %u"",&m,&n)) != 2 )\n		    error((ret_val == EOF) ? E_EOF : E_FORMAT,""sp_finput"");\n		A = sp_get(m,n,5);\n\n		/* initialise start_row */\n		for ( i = 0; i < A->n; i++ )\n			A->start_row[i] = -1;\n\n		rows = A->row;\n		for ( i = 0; i < m; i++ )\n		{\n		    /* printf(""Reading row # %d\n"",i); */\n		    rows[i].diag = -1;\n		    skipjunk(fp);\n		    if ( (ret_val=fscanf(fp,""row %d :"",&tmp)) != 1 ||\n			 tmp != i )\n			error((ret_val == EOF) ? E_EOF : E_FORMAT,\n			      ""sp_finput"");\n		    curr_col = -1;\n		    len = 0;\n		    for ( ; ; )  /* forever do... */\n		      {\n		      /* if we need more scratch space, let's get it!\n		       -- using amortized doubling */\n		      if ( len >= scratch_len )\n			{\n			  scratch = RENEW(scratch,2*scratch_len,row_elt);\n			  if ( ! scratch )\n			    error(E_MEM,""sp_finput"");\n			  scratch_len = 2*scratch_len;\n			}\n#if REAL == DOUBLE\n			if ( (ret_val=fscanf(fp,""%u : %lf"",&col,&val)) != 2 )\n#elif REAL == FLOAT\n			if ( (ret_val=fscanf(fp,""%u : %f"",&col,&val)) != 2 )\n#endif\n			    break;\n			if ( col <= curr_col || col >= n )\n			    error(E_FORMAT,""sp_finput"");\n			scratch[len].col = col;\n			scratch[len].val = val;\n\n			len++;\n		    }\n		    if ( ret_val == EOF )\n			error(E_EOF,""sp_finput"");\n\n		    if ( len > rows[i].maxlen )\n		    {\n			rows[i].elt = (row_elt *)realloc((char *)rows[i].elt,\n							len*sizeof(row_elt));\n			rows[i].maxlen = len;\n		    }\n		    MEM_COPY(scratch,rows[i].elt,len*sizeof(row_elt));\n		    rows[i].len  = len;\n		    /* printf(""Have read row # %d\n"",i); */\n		    rows[i].diag = sprow_idx(&(rows[i]),i);\n		    /* printf(""Have set diag index for row # %d\n"",i); */\n		}\n	}\n\n	return A;\n}\n\n"
leukocyte/meschach_lib/fft.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Fast Fourier Transform routine\n	Loosely based on the Fortran routine in Rabiner & Gold's\n	""Digital Signal Processing""\n*/\n\nstatic char rcsid[] = ""$Id: fft.c,v 1.4 1996/08/20 14:21:05 stewart Exp $"";\n\n#include        <stdio.h>\n#include        <math.h>\n#include        ""matrix.h""\n#include        ""matrix2.h""\n\n\n/* fft -- d.i.t. fast Fourier transform \n        -- radix-2 FFT only\n        -- vector extended to a power of 2 */\n#ifndef ANSI_C\nvoid    fft(x_re,x_im)\nVEC     *x_re, *x_im;\n#else\nvoid    fft(VEC *x_re, VEC *x_im)\n#endif\n{\n    int         i, ip, j, k, li, n, length;\n    Real      *xr, *xi;\n    Real	theta, pi = 3.1415926535897932384;\n    Real      w_re, w_im, u_re, u_im, t_re, t_im;\n    Real      tmp, tmpr, tmpi;\n\n    if ( ! x_re || ! x_im )\n        error(E_NULL,""fft"");\n    if ( x_re->dim != x_im->dim )\n        error(E_SIZES,""fft"");\n\n    n = 1;\n    while ( x_re->dim > n )\n        n *= 2;\n    x_re = v_resize(x_re,n);\n    x_im = v_resize(x_im,n);\n    /*  printf(""# fft: x_re =\n"");  v_output(x_re); */\n    /*  printf(""# fft: x_im =\n"");  v_output(x_im); */\n    xr   = x_re->ve;\n    xi   = x_im->ve;\n\n    /* Decimation in time (DIT) algorithm */\n    j = 0;\n    for ( i = 0; i < n-1; i++ )\n    {\n        if ( i < j )\n        {\n            tmp = xr[i];\n            xr[i] = xr[j];\n            xr[j] = tmp;\n            tmp = xi[i];\n            xi[i] = xi[j];\n            xi[j] = tmp;\n        }\n        k = n / 2;\n        while ( k <= j )\n        {\n            j -= k;\n            k /= 2;\n        }\n        j += k;\n    }\n\n    /* Actual FFT */\n    for ( li = 1; li < n; li *= 2 )\n    {\n        length = 2*li;\n        theta  = pi/li;\n        u_re   = 1.0;\n        u_im   = 0.0;\n        if ( li == 1 )\n        {\n            w_re = -1.0;\n            w_im =  0.0;\n        }\n        else if ( li == 2 )\n        {\n            w_re =  0.0;\n            w_im =  1.0;\n        }\n        else\n        {\n            w_re = cos(theta);\n            w_im = sin(theta);\n        }\n        for ( j = 0; j < li; j++ )\n        {\n            for ( i =  j; i < n; i += length )\n            {\n                ip = i + li;\n                /* step 1 */\n                t_re = xr[ip]*u_re - xi[ip]*u_im;\n                t_im = xr[ip]*u_im + xi[ip]*u_re;\n                /* step 2 */\n                xr[ip] = xr[i]  - t_re;\n                xi[ip] = xi[i]  - t_im;\n                /* step 3 */\n                xr[i] += t_re;\n                xi[i] += t_im;\n            }\n            tmpr = u_re*w_re - u_im*w_im;\n            tmpi = u_im*w_re + u_re*w_im;\n            u_re = tmpr;\n            u_im = tmpi;\n        }\n    }\n}\n\n/* ifft -- inverse FFT using the same interface as fft() */\n#ifndef ANSI_C\nvoid	ifft(x_re,x_im)\nVEC	*x_re, *x_im;\n#else\nvoid	ifft(VEC *x_re, VEC *x_im)\n#endif\n{\n    /* we just use complex conjugates */\n\n    sv_mlt(-1.0,x_im,x_im);\n    fft(x_re,x_im);\n    sv_mlt(-1.0/((double)(x_re->dim)),x_im,x_im);\n    sv_mlt( 1.0/((double)(x_re->dim)),x_re,x_re);\n}\n"
leukocyte/meschach_lib/submat.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* 1.2 submat.c 11/25/87 */\n\n#include	<stdio.h>\n#include	""matrix.h""\n\nstatic	char	rcsid[] = ""$Id: submat.c,v 1.2 1994/01/13 05:28:12 des Exp $"";\n\n\n/* get_col -- gets a specified column of a matrix and retruns it as a vector */\n#ifndef ANSI_C\nVEC	*get_col(mat,col,vec)\nunsigned int	col;\nMAT	*mat;\nVEC	*vec;\n#else\nVEC	*get_col(const MAT *mat, unsigned int col, VEC *vec)\n#endif\n{\n   unsigned int	i;\n   \n   if ( mat==(MAT *)NULL )\n     error(E_NULL,""get_col"");\n   if ( col >= mat->n )\n     error(E_RANGE,""get_col"");\n   if ( vec==(VEC *)NULL || vec->dim<mat->m )\n     vec = v_resize(vec,mat->m);\n   \n   for ( i=0; i<mat->m; i++ )\n     vec->ve[i] = mat->me[i][col];\n   \n   return (vec);\n}\n\n/* get_row -- gets a specified row of a matrix and retruns it as a vector */\n#ifndef ANSI_C\nVEC	*get_row(mat,row,vec)\nunsigned int	row;\nMAT	*mat;\nVEC	*vec;\n#else\nVEC	*get_row(const MAT *mat, unsigned int row, VEC *vec)\n#endif\n{\n   unsigned int	i;\n   \n   if ( mat==(MAT *)NULL )\n     error(E_NULL,""get_row"");\n   if ( row >= mat->m )\n     error(E_RANGE,""get_row"");\n   if ( vec==(VEC *)NULL || vec->dim<mat->n )\n     vec = v_resize(vec,mat->n);\n   \n   for ( i=0; i<mat->n; i++ )\n     vec->ve[i] = mat->me[row][i];\n   \n   return (vec);\n}\n\n/* _set_col -- sets column of matrix to values given in vec (in situ)\n	-- that is, mat(i0:lim,col) <- vec(i0:lim) */\n#ifndef ANSI_C\nMAT	*_set_col(mat,col,vec,i0)\nMAT	*mat;\nVEC	*vec;\nunsigned int	col,i0;\n#else\nMAT	*_set_col(MAT *mat, unsigned int col, const VEC *vec, unsigned int i0)\n#endif\n{\n   unsigned int	i,lim;\n   \n   if ( mat==(MAT *)NULL || vec==(VEC *)NULL )\n     error(E_NULL,""_set_col"");\n   if ( col >= mat->n )\n     error(E_RANGE,""_set_col"");\n   lim = min(mat->m,vec->dim);\n   for ( i=i0; i<lim; i++ )\n     mat->me[i][col] = vec->ve[i];\n   \n   return (mat);\n}\n\n/* _set_row -- sets row of matrix to values given in vec (in situ) */\n#ifndef ANSI_C\nMAT	*_set_row(mat,row,vec,j0)\nMAT	*mat;\nVEC	*vec;\nunsigned int	row,j0;\n#else\nMAT	*_set_row(MAT *mat, unsigned int row, const VEC *vec, unsigned int j0)\n#endif\n{\n   unsigned int	j,lim;\n   \n   if ( mat==(MAT *)NULL || vec==(VEC *)NULL )\n     error(E_NULL,""_set_row"");\n   if ( row >= mat->m )\n     error(E_RANGE,""_set_row"");\n   lim = min(mat->n,vec->dim);\n   for ( j=j0; j<lim; j++ )\n     mat->me[row][j] = vec->ve[j];\n   \n   return (mat);\n}\n\n/* sub_mat -- returns sub-matrix of old which is formed by the rectangle\n   from (row1,col1) to (row2,col2)\n   -- Note: storage is shared so that altering the ""new""\n   matrix will alter the ""old"" matrix */\n#ifndef ANSI_C\nMAT	*sub_mat(old,row1,col1,row2,col2,new)\nMAT	*old,*new;\nunsigned int	row1,col1,row2,col2;\n#else\nMAT	*sub_mat(const MAT *old, \n		 unsigned int row1, unsigned int col1,\n		 unsigned int row2, unsigned int col2,\n		 MAT *new)\n#endif\n{\n   unsigned int	i;\n   \n   if ( old==(MAT *)NULL )\n     error(E_NULL,""sub_mat"");\n   if ( row1 > row2 || col1 > col2 || row2 >= old->m || col2 >= old->n )\n     error(E_RANGE,""sub_mat"");\n   if ( new==(MAT *)NULL || new->m < row2-row1+1 )\n   {\n      new = NEW(MAT);\n      new->me = NEW_A(row2-row1+1,Real *);\n      if ( new==(MAT *)NULL || new->me==(Real **)NULL )\n	error(E_MEM,""sub_mat"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,0,sizeof(MAT)+\n		      (row2-row1+1)*sizeof(Real *));\n      }\n      \n   }\n   new->m = row2-row1+1;\n   \n   new->n = col2-col1+1;\n   \n   new->base = (Real *)NULL;\n   \n   for ( i=0; i < new->m; i++ )\n     new->me[i] = (old->me[i+row1]) + col1;\n   \n   return (new);\n}\n\n\n/* sub_vec -- returns sub-vector which is formed by the elements i1 to i2\n   -- as for sub_mat, storage is shared */\n#ifndef ANSI_C\nVEC	*sub_vec(old,i1,i2,new)\nVEC	*old, *new;\nint	i1, i2;\n#else\nVEC	*sub_vec(const VEC *old, int i1, int i2, VEC *new)\n#endif\n{\n   if ( old == (VEC *)NULL )\n     error(E_NULL,""sub_vec"");\n   if ( i1 > i2 || old->dim < i2 )\n     error(E_RANGE,""sub_vec"");\n   \n   if ( new == (VEC *)NULL )\n     new = NEW(VEC);\n   if ( new == (VEC *)NULL )\n     error(E_MEM,""sub_vec"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_VEC,0,sizeof(VEC));\n   }\n   \n   \n   new->dim = i2 - i1 + 1;\n   new->ve = &(old->ve[i1]);\n   \n   return new;\n}\n"
leukocyte/meschach_lib/matrixio.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* 1.6 matrixio.c 11/25/87 */\n\n\n#include        <stdio.h>\n#include        <ctype.h>\n#include        ""matrix.h""\n\nstatic char rcsid[] = ""$Id: matrixio.c,v 1.4 1994/01/13 05:31:10 des Exp $"";\n\n\n/* local variables */\nstatic char line[MAXLINE];\n\n\n/**************************************************************************\n  Input routines\n  **************************************************************************/\n/* skipjunk -- skips white spaces and strings of the form #....\n\n   Here .... is a comment string */\n#ifndef ANSI_C\nint     skipjunk(fp)\nFILE    *fp;\n#else\nint	skipjunk(FILE *fp)\n#endif\n{\n     int        c;\n     \n     for ( ; ; )        /* forever do... */\n     {\n	  /* skip blanks */\n	  do\n	       c = getc(fp);\n	  while ( isspace(c) );\n	  \n	  /* skip comments (if any) */\n	  if ( c == '#' )\n	       /* yes it is a comment (line) */\n	       while ( (c=getc(fp)) != '\n' )\n		    ;\n	  else\n	  {\n	       ungetc(c,fp);\n	       break;\n	  }\n     }\n     return 0;\n}\n\n/* m_finput -- input matrix\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by m_foutput\n	except that whitespace and comments (""#..\n"") are skipped\n	-- returns a, which is created if a == NULL on entry */\n#ifndef ANSI_C\nMAT     *m_finput(fp,a)\nFILE    *fp;\nMAT     *a;\n#else\nMAT	*m_finput(FILE *fp, MAT *a)\n#endif\n{\n     MAT        *im_finput(),*bm_finput();\n     \n     if ( isatty(fileno(fp)) )\n	  return im_finput(fp,a);\n     else\n	  return bm_finput(fp,a);\n}\n\n/* im_finput -- interactive input of matrix */\n#ifndef ANSI_C\nMAT     *im_finput(fp,mat)\nFILE    *fp;\nMAT     *mat;\n#else\nMAT     *im_finput(FILE *fp,MAT *mat)\n#endif\n{\n     char       c;\n     unsigned int      i, j, m, n, dynamic;\n     /* dynamic set to TRUE if memory allocated here */\n     \n     /* get matrix size */\n     if ( mat != (MAT *)NULL && mat->m<MAXDIM && mat->n<MAXDIM )\n     {  m = mat->m;     n = mat->n;     dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,""Matrix: rows cols:"");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""im_finput"");\n	  } while ( sscanf(line,""%u%u"",&m,&n)<2 || m>MAXDIM || n>MAXDIM );\n	  mat = m_get(m,n);\n     }\n     \n     /* input elements */\n     for ( i=0; i<m; i++ )\n     {\n     redo:\n	  fprintf(stderr,""row %u:\n"",i);\n	  for ( j=0; j<n; j++ )\n	       do\n	       {\n	       redo2:\n		    fprintf(stderr,""entry (%u,%u): "",i,j);\n		    if ( !dynamic )\n			 fprintf(stderr,""old %14.9g new: "",\n				 mat->me[i][j]);\n		    if ( fgets(line,MAXLINE,fp)==NULL )\n			 error(E_INPUT,""im_finput"");\n		    if ( (*line == 'b' || *line == 'B') && j > 0 )\n		    {   j--;    dynamic = FALSE;        goto redo2;     }\n		    if ( (*line == 'f' || *line == 'F') && j < n-1 )\n		    {   j++;    dynamic = FALSE;        goto redo2;     }\n#if REAL == DOUBLE\n	       } while ( *line=='\0' || sscanf(line,""%lf"",&mat->me[i][j])<1 );\n#elif REAL == FLOAT\n	       } while ( *line=='\0' || sscanf(line,""%f"",&mat->me[i][j])<1 );\n#endif\n	  fprintf(stderr,""Continue: "");\n	  fscanf(fp,""%c"",&c);\n	  if ( c == 'n' || c == 'N' )\n	  {    dynamic = FALSE;                 goto redo;      }\n	  if ( (c == 'b' || c == 'B') /* && i > 0 */ )\n	  {     if ( i > 0 )\n		    i--;\n		dynamic = FALSE;        goto redo;\n	  }\n     }\n     \n     return (mat);\n}\n\n/* bm_finput -- batch-file input of matrix */\n#ifndef ANSI_C\nMAT     *bm_finput(fp,mat)\nFILE    *fp;\nMAT     *mat;\n#else\nMAT     *bm_finput(FILE *fp,MAT *mat)\n#endif\n{\n     unsigned int      i,j,m,n,dummy;\n     int        io_code;\n     \n     /* get dimension */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp,"" Matrix: %u by %u"",&m,&n)) < 2 ||\n	 m>MAXDIM || n>MAXDIM )\n	  error(io_code==EOF ? E_EOF : E_FORMAT,""bm_finput"");\n     \n     /* allocate memory if necessary */\n     if ( mat==(MAT *)NULL )\n	  mat = m_resize(mat,m,n);\n     \n     /* get entries */\n     for ( i=0; i<m; i++ )\n     {\n	  skipjunk(fp);\n	  if ( fscanf(fp,"" row %u:"",&dummy) < 1 )\n	       error(E_FORMAT,""bm_finput"");\n	  for ( j=0; j<n; j++ )\n#if REAL == DOUBLE\n	       if ((io_code=fscanf(fp,""%lf"",&mat->me[i][j])) < 1 )\n#elif REAL == FLOAT\n	       if ((io_code=fscanf(fp,""%f"",&mat->me[i][j])) < 1 )\n#endif\n		    error(io_code==EOF ? 7 : 6,""bm_finput"");\n     }\n     \n     return (mat);\n}\n\n/* px_finput -- inputs permutation from file/stream fp\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by px_foutput\n	except that whitespace and comments (""#..\n"") are skipped\n	-- returns px, which is created if px == NULL on entry */\n#ifndef ANSI_C\nPERM    *px_finput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nPERM    *px_finput(FILE *fp,PERM *px)\n#endif\n{\n     PERM       *ipx_finput(),*bpx_finput();\n     \n     if ( isatty(fileno(fp)) )\n	  return ipx_finput(fp,px);\n     else\n	  return bpx_finput(fp,px);\n}\n\n\n/* ipx_finput -- interactive input of permutation */\n#ifndef ANSI_C\nPERM    *ipx_finput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nPERM    *ipx_finput(FILE *fp,PERM *px)\n#endif\n{\n     unsigned int      i,j,size,dynamic; /* dynamic set if memory allocated here */\n     unsigned int      entry,ok;\n     \n     /* get permutation size */\n     if ( px!=(PERM *)NULL && px->size<MAXDIM )\n     {  size = px->size;        dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,""Permutation: size: "");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""ipx_finput"");\n	  } while ( sscanf(line,""%u"",&size)<1 || size>MAXDIM );\n	  px = px_get(size);\n     }\n     \n     /* get entries */\n     i = 0;\n     while ( i<size )\n     {\n	  /* input entry */\n	  do\n	  {\n	  redo:\n	       fprintf(stderr,""entry %u: "",i);\n	       if ( !dynamic )\n		    fprintf(stderr,""old: %u->%u new: "",\n			    i,px->pe[i]);\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""ipx_finput"");\n	       if ( (*line == 'b' || *line == 'B') && i > 0 )\n	       {        i--;    dynamic = FALSE;        goto redo;      }\n	  } while ( *line=='\0' || sscanf(line,""%u"",&entry) < 1 );\n	  /* check entry */\n	  ok = (entry < size);\n	  for ( j=0; j<i; j++ )\n	       ok &= (entry != px->pe[j]);\n	  if ( ok )\n	  {\n	       px->pe[i] = entry;\n	       i++;\n	  }\n     }\n     \n     return (px);\n}\n\n/* bpx_finput -- batch-file input of permutation */\n#ifndef ANSI_C\nPERM    *bpx_finput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nPERM    *bpx_finput(FILE *fp,PERM *px)\n#endif\n{\n     unsigned int      i,j,size,entry,ok;\n     int        io_code;\n     \n     /* get size of permutation */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp,"" Permutation: size:%u"",&size)) < 1 ||\n	 size>MAXDIM )\n	  error(io_code==EOF ? 7 : 6,""bpx_finput"");\n     \n     /* allocate memory if necessary */\n     if ( px==(PERM *)NULL || px->size<size )\n	  px = px_resize(px,size);\n     \n     /* get entries */\n     skipjunk(fp);\n     i = 0;\n     while ( i<size )\n     {\n	  /* input entry */\n	  if ((io_code=fscanf(fp,""%*u -> %u"",&entry)) < 1 )\n	       error(io_code==EOF ? 7 : 6,""bpx_finput"");\n	  /* check entry */\n	  ok = (entry < size);\n	  for ( j=0; j<i; j++ )\n	       ok &= (entry != px->pe[j]);\n	  if ( ok )\n	  {\n	       px->pe[i] = entry;\n	       i++;\n	  }\n	  else\n	       error(E_BOUNDS,""bpx_finput"");\n     }\n     \n     return (px);\n}\n\n/* v_finput -- inputs vector from file/stream fp\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by px_foutput\n	except that whitespace and comments (""#..\n"") are skipped\n	-- returns x, which is created if x == NULL on entry */\n#ifndef ANSI_C\nVEC     *v_finput(fp,x)\nFILE    *fp;\nVEC     *x;\n#else\nVEC     *v_finput(FILE *fp,VEC *x)\n#endif\n{\n     VEC        *ifin_vec(),*bfin_vec();\n     \n     if ( isatty(fileno(fp)) )\n	  return ifin_vec(fp,x);\n     else\n	  return bfin_vec(fp,x);\n}\n\n/* ifin_vec -- interactive input of vector */\n#ifndef ANSI_C\nVEC     *ifin_vec(fp,vec)\nFILE    *fp;\nVEC     *vec;\n#else\nVEC     *ifin_vec(FILE *fp,VEC *vec)\n#endif\n{\n     unsigned int      i,dim,dynamic;  /* dynamic set if memory allocated here */\n     \n     /* get vector dimension */\n     if ( vec != (VEC *)NULL && vec->dim<MAXDIM )\n     {  dim = vec->dim; dynamic = FALSE;        }\n     else\n     {\n	  dynamic = TRUE;\n	  do\n	  {\n	       fprintf(stderr,""Vector: dim: "");\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""ifin_vec"");\n	  } while ( sscanf(line,""%u"",&dim)<1 || dim>MAXDIM );\n	  vec = v_get(dim);\n     }\n     \n     /* input elements */\n     for ( i=0; i<dim; i++ )\n	  do\n	  {\n	  redo:\n	       fprintf(stderr,""entry %u: "",i);\n	       if ( !dynamic )\n		    fprintf(stderr,""old %14.9g new: "",vec->ve[i]);\n	       if ( fgets(line,MAXLINE,fp)==NULL )\n		    error(E_INPUT,""ifin_vec"");\n	       if ( (*line == 'b' || *line == 'B') && i > 0 )\n	       {        i--;    dynamic = FALSE;        goto redo;         }\n	       if ( (*line == 'f' || *line == 'F') && i < dim-1 )\n	       {        i++;    dynamic = FALSE;        goto redo;         }\n#if REAL == DOUBLE\n	  } while ( *line=='\0' || sscanf(line,""%lf"",&vec->ve[i]) < 1 );\n#elif REAL == FLOAT\n          } while ( *line=='\0' || sscanf(line,""%f"",&vec->ve[i]) < 1 );\n#endif\n     \n     return (vec);\n}\n\n/* bfin_vec -- batch-file input of vector */\n#ifndef ANSI_C\nVEC     *bfin_vec(fp,vec)\nFILE    *fp;\nVEC     *vec;\n#else\nVEC     *bfin_vec(FILE *fp,VEC *vec)\n#endif\n{\n     unsigned int      i,dim;\n     int        io_code;\n     \n     /* get dimension */\n     skipjunk(fp);\n     if ((io_code=fscanf(fp,"" Vector: dim:%u"",&dim)) < 1 ||\n	 dim>MAXDIM )\n	  error(io_code==EOF ? 7 : 6,""bfin_vec"");\n     \n     /* allocate memory if necessary */\n     if ( vec==(VEC *)NULL )\n	  vec = v_resize(vec,dim);\n     \n     /* get entries */\n     skipjunk(fp);\n     for ( i=0; i<dim; i++ )\n#if REAL == DOUBLE\n	  if ((io_code=fscanf(fp,""%lf"",&vec->ve[i])) < 1 )\n#elif REAL == FLOAT\n	  if ((io_code=fscanf(fp,""%f"",&vec->ve[i])) < 1 )\n#endif\n	       error(io_code==EOF ? 7 : 6,""bfin_vec"");\n     \n     return (vec);\n}\n\n/**************************************************************************\n  Output routines\n  **************************************************************************/\nstatic const char    *format = ""%14.9g "";\n\n/* setformat -- sets the printf format string for the Meschach I/O operations\n	-- returns the previous format string */\n#ifndef ANSI_C\nchar	*setformat(f_string)\nchar    *f_string;\n#else\nconst char	*setformat(const char *f_string)\n#endif\n{\n    const char	*old_f_string;\n    old_f_string = format;\n    if ( f_string != (char *)NULL && *f_string != '\0' )\n	format = f_string;\n\n    return old_f_string;\n}\n\n/* m_foutput -- prints a representation of the matrix a onto file/stream fp */\n#ifndef ANSI_C\nvoid    m_foutput(fp,a)\nFILE    *fp;\nMAT     *a;\n#else\nvoid    m_foutput(FILE *fp, const MAT *a)\n#endif\n{\n     unsigned int      i, j, tmp;\n     \n     if ( a == (MAT *)NULL )\n     {  fprintf(fp,""Matrix: NULL\n"");   return;         }\n     fprintf(fp,""Matrix: %d by %d\n"",a->m,a->n);\n     if ( a->me == (Real **)NULL )\n     {  fprintf(fp,""NULL\n"");           return;         }\n     for ( i=0; i<a->m; i++ )   /* for each row... */\n     {\n	  fprintf(fp,""row %u: "",i);\n	  for ( j=0, tmp=2; j<a->n; j++, tmp++ )\n	  {             /* for each col in row... */\n	       fprintf(fp,format,a->me[i][j]);\n	       if ( ! (tmp % 5) )       putc('\n',fp);\n	  }\n	  if ( tmp % 5 != 1 )   putc('\n',fp);\n     }\n}\n\n/* px_foutput -- prints a representation of px onto file/stream fp */\n#ifndef ANSI_C\nvoid    px_foutput(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nvoid	px_foutput(FILE *fp, const PERM *px)\n#endif\n{\n     unsigned int      i;\n     \n     if ( px == (PERM *)NULL )\n     {  fprintf(fp,""Permutation: NULL\n"");      return;         }\n     fprintf(fp,""Permutation: size: %u\n"",px->size);\n     if ( px->pe == (unsigned int *)NULL )\n     {  fprintf(fp,""NULL\n"");   return;         }\n     for ( i=0; i<px->size; i++ )\n	if ( ! (i % 8) && i != 0 )\n	  fprintf(fp,""\n  %u->%u "",i,px->pe[i]);\n	else\n	  fprintf(fp,""%u->%u "",i,px->pe[i]);\n     fprintf(fp,""\n"");\n}\n\n/* v_foutput -- prints a representation of x onto file/stream fp */\n#ifndef ANSI_C\nvoid    v_foutput(fp,x)\nFILE    *fp;\nVEC     *x;\n#else\nvoid	v_foutput(FILE *fp, const VEC *x)\n#endif\n{\n     unsigned int      i, tmp;\n     \n     if ( x == (VEC *)NULL )\n     {  fprintf(fp,""Vector: NULL\n"");   return;         }\n     fprintf(fp,""Vector: dim: %d\n"",x->dim);\n     if ( x->ve == (Real *)NULL )\n     {  fprintf(fp,""NULL\n"");   return;         }\n     for ( i=0, tmp=0; i<x->dim; i++, tmp++ )\n     {\n	  fprintf(fp,format,x->ve[i]);\n	  if ( tmp % 5 == 4 )   putc('\n',fp);\n     }\n     if ( tmp % 5 != 0 )        putc('\n',fp);\n}\n\n/* m_dump -- prints a dump of all pointers and data in a onto fp\n	-- suitable for low-level debugging */\n#ifndef ANSI_C\nvoid    m_dump(fp,a)\nFILE    *fp;\nMAT     *a;\n#else\nvoid	m_dump(FILE *fp, const MAT *a)\n#endif\n{\n	unsigned int   i, j, tmp;\n     \n     if ( a == (MAT *)NULL )\n     {  fprintf(fp,""Matrix: NULL\n"");   return;         }\n     fprintf(fp,""Matrix: %d by %d @ 0x%lx\n"",a->m,a->n,(long)a);\n     fprintf(fp,""\tmax_m = %d, max_n = %d, max_size = %d\n"",\n	     a->max_m, a->max_n, a->max_size);\n     if ( a->me == (Real **)NULL )\n     {  fprintf(fp,""NULL\n"");           return;         }\n     fprintf(fp,""a->me @ 0x%lx\n"",(long)(a->me));\n     fprintf(fp,""a->base @ 0x%lx\n"",(long)(a->base));\n     for ( i=0; i<a->m; i++ )   /* for each row... */\n     {\n	  fprintf(fp,""row %u: @ 0x%lx "",i,(long)(a->me[i]));\n	  for ( j=0, tmp=2; j<a->n; j++, tmp++ )\n	  {             /* for each col in row... */\n	       fprintf(fp,format,a->me[i][j]);\n	       if ( ! (tmp % 5) )       putc('\n',fp);\n	  }\n	  if ( tmp % 5 != 1 )   putc('\n',fp);\n     }\n}\n\n/* px_dump --  prints a dump of all pointers and data in a onto fp\n	-- suitable for low-level debugging */\n#ifndef ANSI_C\nvoid    px_dump(fp,px)\nFILE    *fp;\nPERM    *px;\n#else\nvoid	px_dump(FILE *fp, const PERM *px)\n#endif\n{\n     unsigned int      i;\n     \n     if ( ! px )\n     {  fprintf(fp,""Permutation: NULL\n"");      return;         }\n     fprintf(fp,""Permutation: size: %u @ 0x%lx\n"",px->size,(long)(px));\n     if ( ! px->pe )\n     {  fprintf(fp,""NULL\n"");   return;         }\n     fprintf(fp,""px->pe @ 0x%lx\n"",(long)(px->pe));\n     for ( i=0; i<px->size; i++ )\n	  fprintf(fp,""%u->%u "",i,px->pe[i]);\n     fprintf(fp,""\n"");\n}\n\n\n/* v_dump --  prints a dump of all pointers and data in a onto fp\n	-- suitable for low-level debugging */\n#ifndef ANSI_C\nvoid    v_dump(fp,x)\nFILE    *fp;\nVEC     *x;\n#else\nvoid	v_dump(FILE *fp, const VEC *x)\n#endif\n{\n     unsigned int      i, tmp;\n     \n     if ( ! x )\n     {  fprintf(fp,""Vector: NULL\n"");   return;         }\n     fprintf(fp,""Vector: dim: %d @ 0x%lx\n"",x->dim,(long)(x));\n     if ( ! x->ve )\n     {  fprintf(fp,""NULL\n"");   return;         }\n     fprintf(fp,""x->ve @ 0x%lx\n"",(long)(x->ve));\n     for ( i=0, tmp=0; i<x->dim; i++, tmp++ )\n     {\n	  fprintf(fp,format,x->ve[i]);\n	  if ( tmp % 5 == 4 )   putc('\n',fp);\n     }\n     if ( tmp % 5 != 0 )        putc('\n',fp);\n}\n\n\n/* iv_foutput -- print a representation of iv on stream fp */\n#ifndef ANSI_C\nvoid	iv_foutput(fp,iv)\nFILE	*fp;\nIVEC	*iv;\n#else\nvoid	iv_foutput(FILE *fp, const IVEC *iv)\n#endif\n{\n   int	i;\n   \n   fprintf(fp,""IntVector: "");\n   if ( iv == IVNULL )\n   {\n      fprintf(fp,""**** NULL ****\n"");\n      return;\n   }\n   fprintf(fp,""dim: %d\n"",iv->dim);\n   for ( i = 0; i < iv->dim; i++ )\n   {\n      if ( (i+1) % 8 )\n	fprintf(fp,""%8d "",iv->ive[i]);\n      else\n	fprintf(fp,""%8d\n"",iv->ive[i]);\n   }\n   if ( i % 8 )\n     fprintf(fp,""\n"");\n}\n\n\n/* iv_finput -- input integer vector from stream fp\n	-- input from a terminal is handled interactively\n	-- batch/file input has the same format as produced by\n	iv_foutput except that whitespace and comments (""#...\n"") \n	are skipped */\n#ifndef ANSI_C\nIVEC	*iv_finput(fp,x)\nFILE	*fp;\nIVEC	*x;\n#else\nIVEC	*iv_finput(FILE *fp, IVEC *x)\n#endif\n{\n   IVEC	*iiv_finput(),*biv_finput();\n   \n   if ( isatty(fileno(fp)) )\n     return iiv_finput(fp,x);\n   else\n     return biv_finput(fp,x);\n}\n\n/* iiv_finput -- interactive input of IVEC iv */\n#ifndef ANSI_C\nIVEC	*iiv_finput(fp,iv)\nFILE	*fp;\nIVEC	*iv;\n#else\nIVEC	*iiv_finput(FILE *fp, IVEC *iv)\n#endif\n{\n   unsigned int	i,dim,dynamic;	/* dynamic set if memory allocated here */\n   \n   /* get dimension */\n   if ( iv != (IVEC *)NULL && iv->dim<MAXDIM )\n   {	dim = iv->dim;	dynamic = FALSE;	}\n   else\n   {\n      dynamic = TRUE;\n      do\n      {\n	 fprintf(stderr,""IntVector: dim: "");\n	 if ( fgets(line,MAXLINE,fp)==NULL )\n	   error(E_INPUT,""iiv_finput"");\n      } while ( sscanf(line,""%u"",&dim)<1 || dim>MAXDIM );\n      iv = iv_get(dim);\n   }\n   \n   /* input elements */\n   for ( i=0; i<dim; i++ )\n     do\n     {\n      redo:\n	fprintf(stderr,""entry %u: "",i);\n	if ( !dynamic )\n	  fprintf(stderr,""old: %-9d  new: "",iv->ive[i]);\n	if ( fgets(line,MAXLINE,fp)==NULL )\n	  error(E_INPUT,""iiv_finput"");\n	if ( (*line == 'b' || *line == 'B') && i > 0 )\n	{	i--;	dynamic = FALSE;	goto redo;	   }\n	if ( (*line == 'f' || *line == 'F') && i < dim-1 )\n	{	i++;	dynamic = FALSE;	goto redo;	   }\n     } while ( *line=='\0' || sscanf(line,""%d"",&iv->ive[i]) < 1 );\n   \n   return (iv);\n}\n\n/* biv_finput -- batch-file input of IVEC iv */\n#ifndef ANSI_C\nIVEC	*biv_finput(fp,iv)\nFILE	*fp;\nIVEC	*iv;\n#else\nIVEC	*biv_finput(FILE *fp, IVEC *iv)\n#endif\n{\n   unsigned int	i,dim;\n   int	io_code;\n   \n   /* get dimension */\n   skipjunk(fp);\n   if ((io_code=fscanf(fp,"" IntVector: dim:%u"",&dim)) < 1 ||\n       dim>MAXDIM )\n     error(io_code==EOF ? 7 : 6,""biv_finput"");\n   \n   /* allocate memory if necessary */\n   if ( iv==(IVEC *)NULL || iv->dim<dim )\n     iv = iv_resize(iv,dim);\n   \n   /* get entries */\n   skipjunk(fp);\n   for ( i=0; i<dim; i++ )\n     if ((io_code=fscanf(fp,""%d"",&iv->ive[i])) < 1 )\n       error(io_code==EOF ? 7 : 6,""biv_finput"");\n   \n   return (iv);\n}\n\n/* iv_dump -- dumps all the contents of IVEC iv onto stream fp */\n#ifndef ANSI_C\nvoid	iv_dump(fp,iv)\nFILE*fp;\nIVEC*iv;\n#else\nvoid	iv_dump(FILE *fp, const IVEC *iv)\n#endif\n{\n   int		i;\n   \n   fprintf(fp,""IntVector: "");\n   if ( ! iv )\n   {\n      fprintf(fp,""**** NULL ****\n"");\n      return;\n   }\n   fprintf(fp,""dim: %d, max_dim: %d\n"",iv->dim,iv->max_dim);\n   fprintf(fp,""ive @ 0x%lx\n"",(long)(iv->ive));\n   for ( i = 0; i < iv->max_dim; i++ )\n   {\n      if ( (i+1) % 8 )\n	fprintf(fp,""%8d "",iv->ive[i]);\n      else\n	fprintf(fp,""%8d\n"",iv->ive[i]);\n   }\n   if ( i % 8 )\n     fprintf(fp,""\n"");\n}	\n\n"
leukocyte/meschach_lib/extras.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Memory port routines: MEM_COPY and MEM_ZERO\n*/\n\n/* For BSD 4.[23] environments: using bcopy() and bzero() */\n\n#include ""machine.h""\n\n#ifndef MEM_COPY\nvoid	MEM_COPY(from,to,len)\nchar	*from, *to;\nint	len;\n{\n    int		i;\n\n    if ( from < to )\n    {\n	for ( i = 0; i < len; i++ )\n	    *to++ = *from++;\n    }\n    else\n    {\n	from += len;	to += len;\n	for ( i = 0; i < len; i++ )\n	    *(--to) = *(--from);\n    }\n}\n#endif\n\n#ifndef MEM_ZERO\nvoid	MEM_ZERO(ptr,len)\nchar	*ptr;\nint	len;\n{\n    int		i;\n\n    for ( i = 0; i < len; i++ )\n	*(ptr++) = '\0';\n}\n#endif\n\n/*\n	This file contains versions of something approximating the well-known\n	BLAS routines in C, suitable for Meschach (hence the `m').\n	These are ""vanilla"" implementations, at least with some consideration\n	of the effects of caching and paging, and maybe some loop unrolling\n	for register-rich machines\n*/\n\n/*\n	Organisation of matrices: it is assumed that matrices are represented\n	by Real **'s. To keep flexibility, there is also an ""initial\n	column"" parameter j0, so that the actual elements used are\n		A[0][j0],   A[0][j0+1],   ..., A[0][j0+n-1]\n		A[1][j0],   A[1][j0+1],   ..., A[1][j0+n-1]\n		   ..         ..          ...      ..\n		A[m-1][j0], A[m-1][j0+1], ..., A[m-1][j0+n-1]\n*/\n\nstatic char	rcsid[] = ""$Id: extras.c,v 1.4 1995/06/08 15:13:15 des Exp $"";\n\n#include	<math.h>\n\n#define	REGISTER_RICH	1\n\n/* mblar-1 routines */\n\n/* Mscale -- sets x <- alpha.x */\nvoid	Mscale(len,alpha,x)\nint	len;\ndouble	alpha;\nReal	*x;\n{\n    register int	i;\n\n    for ( i = 0; i < len; i++ )\n	x[i] *= alpha;\n}\n\n/* Mswap -- swaps x and y */\nvoid	Mswap(len,x,y)\nint	len;\nReal	*x, *y;\n{\n    register int	i;\n    register Real	tmp;\n\n    for ( i = 0; i < len; i++ )\n    {\n	tmp = x[i];\n	x[i] = y[i];\n	y[i] = tmp;\n    }\n}\n\n/* Mcopy -- copies x to y */\nvoid	Mcopy(len,x,y)\nint	len;\nReal	*x, *y;\n{\n    register int	i;\n\n    for ( i = 0; i < len; i++ )\n	y[i] = x[i];\n}\n\n/* Maxpy -- y <- y + alpha.x */\nvoid	Maxpy(len,alpha,x,y)\nint	len;\ndouble	alpha;\nReal	*x, *y;\n{\n    register int	i, len4;\n\n    /****************************************\n    for ( i = 0; i < len; i++ )\n	y[i] += alpha*x[i];\n    ****************************************/\n\n#ifdef REGISTER_RICH\n    len4 = len / 4;\n    len  = len % 4;\n    for ( i = 0; i < len4; i++ )\n    {\n	y[4*i]   += alpha*x[4*i];\n	y[4*i+1] += alpha*x[4*i+1];\n	y[4*i+2] += alpha*x[4*i+2];\n	y[4*i+3] += alpha*x[4*i+3];\n    }\n    x += 4*len4;	y += 4*len4;\n#endif\n    for ( i = 0; i < len; i++ )\n	y[i] += alpha*x[i];\n}\n\n/* Mdot -- returns x'.y */\ndouble	Mdot(len,x,y)\nint	len;\nReal	*x, *y;\n{\n    register int	i, len4;\n    register Real	sum;\n\n#ifndef REGISTER_RICH\n    sum = 0.0;\n#endif\n\n#ifdef REGISTER_RICH\n    register Real	sum0, sum1, sum2, sum3;\n    \n    sum0 = sum1 = sum2 = sum3 = 0.0;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    \n    for ( i = 0; i < len4; i++ )\n    {\n	sum0 += x[4*i  ]*y[4*i  ];\n	sum1 += x[4*i+1]*y[4*i+1];\n	sum2 += x[4*i+2]*y[4*i+2];\n	sum3 += x[4*i+3]*y[4*i+3];\n    }\n    sum = sum0 + sum1 + sum2 + sum3;\n    x += 4*len4;	y += 4*len4;\n#endif\n\n    for ( i = 0; i < len; i++ )\n	sum += x[i]*y[i];\n\n    return sum;\n}\n\n#ifndef ABS\n#define	ABS(x)	((x) >= 0 ? (x) : -(x))\n#endif\n\n/* Mnorminf -- returns ||x||_inf */\ndouble	Mnorminf(len,x)\nint	len;\nReal	*x;\n{\n    register int	i;\n    register Real	tmp, max_val;\n\n    max_val = 0.0;\n    for ( i = 0; i < len; i++ )\n    {\n	tmp = ABS(x[i]);\n	if ( max_val < tmp )\n	    max_val = tmp;\n    }\n\n    return max_val;\n}\n\n/* Mnorm1 -- returns ||x||_1 */\ndouble	Mnorm1(len,x)\nint	len;\nReal	*x;\n{\n    register int	i;\n    register Real	sum;\n\n    sum = 0.0;\n    for ( i = 0; i < len; i++ )\n	sum += ABS(x[i]);\n\n    return sum;\n}\n\n/* Mnorm2 -- returns ||x||_2 */\ndouble	Mnorm2(len,x)\nint	len;\nReal	*x;\n{\n    register int	i;\n    register Real	norm, invnorm, sum, tmp;\n\n    norm = Mnorminf(len,x);\n    if ( norm == 0.0 )\n	return 0.0;\n    invnorm = 1.0/norm;\n    sum = 0.0;\n    for ( i = 0; i < len; i++ )\n    {\n	tmp = x[i]*invnorm;\n	sum += tmp*tmp;\n    }\n\n    return sum/invnorm;\n}\n\n/* mblar-2 routines */\n\n/* Mmv -- y <- alpha.A.x + beta.y */\nvoid	Mmv(m,n,alpha,A,j0,x,beta,y)\nint	m, n, j0;\ndouble	alpha, beta;\nReal	**A, *x, *y;\n{\n    register int	i, j, m4, n4;\n    register Real	sum0, sum1, sum2, sum3, tmp0, tmp1, tmp2, tmp3;\n    register Real	*dp0, *dp1, *dp2, *dp3;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	y[i] += alpha*Mdot(n,&(A[i][j0]),x);\n    ****************************************/\n\n    m4 = n4 = 0;\n\n#ifdef REGISTER_RICH\n    m4 = m / 4;\n    m  = m % 4;\n    n4 = n / 4;\n    n  = n % 4;\n\n    for ( i = 0; i < m4; i++ )\n    {\n	sum0 = sum1 = sum2 = sum3 = 0.0;\n	dp0 = &(A[4*i  ][j0]);\n	dp1 = &(A[4*i+1][j0]);\n	dp2 = &(A[4*i+2][j0]);\n	dp3 = &(A[4*i+3][j0]);\n\n	for ( j = 0; j < n4; j++ )\n	{\n	    tmp0 = x[4*j  ];\n	    tmp1 = x[4*j+1];\n	    tmp2 = x[4*j+2];\n	    tmp3 = x[4*j+3];\n	    sum0 = sum0 + dp0[j]*tmp0 + dp0[j+1]*tmp1 +\n		dp0[j+2]*tmp2 + dp0[j+3]*tmp3;\n	    sum1 = sum1 + dp1[j]*tmp0 + dp1[j+1]*tmp1 +\n		dp1[j+2]*tmp2 + dp1[j+3]*tmp3;\n	    sum2 = sum2 + dp2[j]*tmp0 + dp2[j+1]*tmp1 +\n		dp2[j+2]*tmp2 + dp2[j+3]*tmp3;\n	    sum3 = sum3 + dp3[j]*tmp0 + dp3[j+1]*tmp2 +\n		dp3[j+2]*tmp2 + dp3[j+3]*tmp3;\n	}\n	for ( j = 0; j < n; j++ )\n	{\n	    sum0 += dp0[4*n4+j]*x[4*n4+j];\n	    sum1 += dp1[4*n4+j]*x[4*n4+j];\n	    sum2 += dp2[4*n4+j]*x[4*n4+j];\n	    sum3 += dp3[4*n4+j]*x[4*n4+j];\n	}\n	y[4*i  ] = beta*y[4*i  ] + alpha*sum0;\n	y[4*i+1] = beta*y[4*i+1] + alpha*sum1;\n	y[4*i+2] = beta*y[4*i+2] + alpha*sum2;\n	y[4*i+3] = beta*y[4*i+3] + alpha*sum3;\n    }\n#endif\n\n    for ( i = 0; i < m; i++ )\n	y[4*m4+i] = beta*y[i] + alpha*Mdot(4*n4+n,&(A[4*m4+i][j0]),x);\n}\n\n/* Mvm -- y <- alpha.A^T.x + beta.y */\nvoid	Mvm(m,n,alpha,A,j0,x,beta,y)\nint	m, n, j0;\ndouble	alpha, beta;\nReal	**A, *x, *y;\n{\n    register int	i, j, m4, n2;\n    register Real	*Aref;\n    register Real 	tmp;\n\n#ifdef REGISTER_RICH\n    register Real	*Aref0, *Aref1;\n    register Real	tmp0, tmp1;\n    register Real	yval0, yval1, yval2, yval3;\n#endif\n\n    if ( beta != 1.0 )\n	Mscale(m,beta,y);\n    /****************************************\n    for ( j = 0; j < n; j++ )\n	Maxpy(m,alpha*x[j],&(A[j][j0]),y);\n    ****************************************/\n    m4 = n2 = 0;\n\n    m4 = m / 4;\n    m  = m % 4;\n#ifdef REGISTER_RICH\n    n2 = n / 2;\n    n  = n % 2;\n\n    for ( j = 0; j < n2; j++ )\n    {\n	tmp0 = alpha*x[2*j];\n	tmp1 = alpha*x[2*j+1];\n	Aref0 = &(A[2*j  ][j0]);\n	Aref1 = &(A[2*j+1][j0]);\n	for ( i = 0; i < m4; i++ )\n	{\n	    yval0 = y[4*i  ] + tmp0*Aref0[4*i  ];\n	    yval1 = y[4*i+1] + tmp0*Aref0[4*i+1];\n	    yval2 = y[4*i+2] + tmp0*Aref0[4*i+2];\n	    yval3 = y[4*i+3] + tmp0*Aref0[4*i+3];\n	    y[4*i  ] = yval0 + tmp1*Aref1[4*i  ];\n	    y[4*i+1] = yval1 + tmp1*Aref1[4*i+1];\n	    y[4*i+2] = yval2 + tmp1*Aref1[4*i+2];\n	    y[4*i+3] = yval3 + tmp1*Aref1[4*i+3];\n	}\n	y += 4*m4;	Aref0 += 4*m4;	Aref1 += 4*m4;\n	for ( i = 0; i < m; i++ )\n	    y[i] += tmp0*Aref0[i] + tmp1*Aref1[i];\n    }\n#endif\n\n    for ( j = 0; j < n; j++ )\n    {\n	tmp = alpha*x[2*n2+j];\n	Aref = &(A[2*n2+j][j0]);\n	for ( i = 0; i < m4; i++ )\n	{\n	    y[4*i  ] += tmp*Aref[4*i  ];\n	    y[4*i+1] += tmp*Aref[4*i+1];\n	    y[4*i+2] += tmp*Aref[4*i+2];\n	    y[4*i+3] += tmp*Aref[4*i+3];\n	}\n	y += 4*m4;	Aref += 4*m4;\n	for ( i = 0; i < m; i++ )\n	    y[i] += tmp*Aref[i];\n    }\n}\n\n/* Mupdate -- A <- A + alpha.x.y^T */\nvoid	Mupdate(m,n,alpha,x,y,A,j0)\nint	m, n, j0;\ndouble	alpha;\nReal	**A, *x, *y;\n{\n    register int	i, j, n4;\n    register Real	*Aref;\n    register Real 	tmp;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	Maxpy(n,alpha*x[i],y,&(A[i][j0]));\n    ****************************************/\n\n    n4 = n / 4;\n    n  = n % 4;\n    for ( i = 0; i < m; i++ )\n    {\n	tmp = alpha*x[i];\n	Aref = &(A[i][j0]);\n	for ( j = 0; j < n4; j++ )\n	{\n	    Aref[4*j  ] += tmp*y[4*j  ];\n	    Aref[4*j+1] += tmp*y[4*j+1];\n	    Aref[4*j+2] += tmp*y[4*j+2];\n	    Aref[4*j+3] += tmp*y[4*j+3];\n	}\n	Aref += 4*n4;	y += 4*n4;\n	for ( j = 0; j < n; j++ )\n	    Aref[j] += tmp*y[j];\n    }\n}\n\n/* mblar-3 routines */\n\n/* Mmm -- C <- C + alpha.A.B */\nvoid	Mmm(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n    /* register Real	tmp, sum; */\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	for ( k = 0; k < p; k++ )\n	    Maxpy(n,alpha*A[i][Aj0+k],&(B[k][Bj0]),&(C[i][Cj0]));\n    ****************************************/\n    for ( i = 0; i < m; i++ )\n	Mvm(p,n,alpha,B,Bj0,&(A[i][Aj0]),1.0,&(C[i][Cj0]));\n}\n\n/* Mmtrm -- C <- C + alpha.A^T.B */\nvoid	Mmtrm(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	for ( k = 0; k < p; k++ )\n	    Maxpy(n,alpha*A[k][Aj0+i],&(B[k][Bj0]),&(C[i][Cj0]));\n    ****************************************/\n    for ( k = 0; k < p; k++ )\n	Mupdate(m,n,alpha,&(A[k][Aj0]),&(B[k][Bj0]),C,Cj0);\n}\n\n/* Mmmtr -- C <- C + alpha.A.B^T */\nvoid	Mmmtr(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n\n    /****************************************\n    for ( i = 0; i < m; i++ )\n	for ( j = 0; j < n; j++ )\n	    C[i][Cj0+j] += alpha*Mdot(p,&(A[i][Aj0]),&(B[j][Bj0]));\n    ****************************************/\n    for ( i = 0; i < m; i++ )\n	Mmv(n,p,alpha,B,Bj0,&(A[i][Aj0]),1.0,&(C[i][Cj0]));\n}\n\n/* Mmtrmtr -- C <- C + alpha.A^T.B^T */\nvoid	Mmtrmtr(m,n,p,alpha,A,Aj0,B,Bj0,C,Cj0)\nint	m, n, p;	/* C is m x n */\ndouble  alpha;\nReal	**A, **B, **C;\nint	Aj0, Bj0, Cj0;\n{\n    register int	i, j, k;\n\n    for ( i = 0; i < m; i++ )\n	for ( j = 0; j < n; j++ )\n	    for ( k = 0; k < p; k++ )\n		C[i][Cj0+j] += A[i][Aj0+k]*B[k][Bj0+j];\n}\n\n"
leukocyte/meschach_lib/zlufctr.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n	Complex version\n*/\n\nstatic	char	rcsid[] = ""$Id: zlufctr.c,v 1.3 1996/08/20 20:07:09 stewart Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""zmatrix.h""\n#include        ""zmatrix2.h""\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* zLUfactor -- Gaussian elimination with scaled partial pivoting\n		-- Note: returns LU matrix which is A */\nZMAT	*zLUfactor(A,pivot)\nZMAT	*A;\nPERM	*pivot;\n{\n	unsigned int	i, j, m, n;\n	int	i_max, k, k_max;\n	Real	dtemp, max1;\n	complex	**A_v, *A_piv, *A_row, temp;\n	STATIC	VEC	*scale = VNULL;\n\n	if ( A==ZMNULL || pivot==PNULL )\n		error(E_NULL,""zLUfactor"");\n	if ( pivot->size != A->m )\n		error(E_SIZES,""zLUfactor"");\n	m = A->m;	n = A->n;\n	scale = v_resize(scale,A->m);\n	MEM_STAT_REG(scale,TYPE_VEC);\n	A_v = A->me;\n\n	/* initialise pivot with identity permutation */\n	for ( i=0; i<m; i++ )\n	    pivot->pe[i] = i;\n\n	/* set scale parameters */\n	for ( i=0; i<m; i++ )\n	{\n		max1 = 0.0;\n		for ( j=0; j<n; j++ )\n		{\n			dtemp = zabs(A_v[i][j]);\n			max1 = max(max1,dtemp);\n		}\n		scale->ve[i] = max1;\n	}\n\n	/* main loop */\n	k_max = min(m,n)-1;\n	for ( k=0; k<k_max; k++ )\n	{\n	    /* find best pivot row */\n	    max1 = 0.0;	i_max = -1;\n	    for ( i=k; i<m; i++ )\n		if ( scale->ve[i] > 0.0 )\n		{\n		    dtemp = zabs(A_v[i][k])/scale->ve[i];\n		    if ( dtemp > max1 )\n		    { max1 = dtemp;	i_max = i;	}\n		}\n	    \n	    /* if no pivot then ignore column k... */\n	    if ( i_max == -1 )\n		continue;\n\n	    /* do we pivot ? */\n	    if ( i_max != k )	/* yes we do... */\n	    {\n		px_transp(pivot,i_max,k);\n		for ( j=0; j<n; j++ )\n		{\n		    temp = A_v[i_max][j];\n		    A_v[i_max][j] = A_v[k][j];\n		    A_v[k][j] = temp;\n		}\n	    }\n	    \n	    /* row operations */\n	    for ( i=k+1; i<m; i++ )	/* for each row do... */\n	    {	/* Note: divide by zero should never happen */\n		temp = A_v[i][k] = zdiv(A_v[i][k],A_v[k][k]);\n		A_piv = &(A_v[k][k+1]);\n		A_row = &(A_v[i][k+1]);\n		temp.re = - temp.re;\n		temp.im = - temp.im;\n		if ( k+1 < n )\n		    __zmltadd__(A_row,A_piv,temp,(int)(n-(k+1)),Z_NOCONJ);\n		/*********************************************\n		  for ( j=k+1; j<n; j++ )\n		  A_v[i][j] -= temp*A_v[k][j];\n		  (*A_row++) -= temp*(*A_piv++);\n		*********************************************/\n	    }\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(scale);\n#endif\n\n	return A;\n}\n\n\n/* zLUsolve -- given an LU factorisation in A, solve Ax=b */\nZVEC	*zLUsolve(A,pivot,b,x)\nZMAT	*A;\nPERM	*pivot;\nZVEC	*b,*x;\n{\n	if ( A==ZMNULL || b==ZVNULL || pivot==PNULL )\n		error(E_NULL,""zLUsolve"");\n	if ( A->m != A->n || A->n != b->dim )\n		error(E_SIZES,""zLUsolve"");\n\n	x = px_zvec(pivot,b,x);	/* x := P.b */\n	zLsolve(A,x,x,1.0);	/* implicit diagonal = 1 */\n	zUsolve(A,x,x,0.0);	/* explicit diagonal */\n\n	return (x);\n}\n\n/* zLUAsolve -- given an LU factorisation in A, solve A^*.x=b */\nZVEC	*zLUAsolve(LU,pivot,b,x)\nZMAT	*LU;\nPERM	*pivot;\nZVEC	*b,*x;\n{\n	if ( ! LU || ! b || ! pivot )\n		error(E_NULL,""zLUAsolve"");\n	if ( LU->m != LU->n || LU->n != b->dim )\n		error(E_SIZES,""zLUAsolve"");\n\n	x = zv_copy(b,x);\n	zUAsolve(LU,x,x,0.0);	/* explicit diagonal */\n	zLAsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */\n	pxinv_zvec(pivot,x,x);	/* x := P^*.x */\n\n	return (x);\n}\n\n/* zm_inverse -- returns inverse of A, provided A is not too rank deficient\n	-- uses LU factorisation */\nZMAT	*zm_inverse(A,out)\nZMAT	*A, *out;\n{\n	int	i;\n	STATIC ZVEC	*tmp=ZVNULL, *tmp2=ZVNULL;\n	STATIC ZMAT	*A_cp=ZMNULL;\n	STATIC PERM	*pivot=PNULL;\n\n	if ( ! A )\n	    error(E_NULL,""zm_inverse"");\n	if ( A->m != A->n )\n	    error(E_SQUARE,""zm_inverse"");\n	if ( ! out || out->m < A->m || out->n < A->n )\n	    out = zm_resize(out,A->m,A->n);\n\n	A_cp = zm_resize(A_cp,A->m,A->n);\n	A_cp = zm_copy(A,A_cp);\n	tmp = zv_resize(tmp,A->m);\n	tmp2 = zv_resize(tmp2,A->m);\n	pivot = px_resize(pivot,A->m);\n	MEM_STAT_REG(A_cp,TYPE_ZMAT);\n	MEM_STAT_REG(tmp, TYPE_ZVEC);\n	MEM_STAT_REG(tmp2,TYPE_ZVEC);\n	MEM_STAT_REG(pivot,TYPE_PERM);\n	tracecatch(zLUfactor(A_cp,pivot),""zm_inverse"");\n	for ( i = 0; i < A->n; i++ )\n	{\n	    zv_zero(tmp);\n	    tmp->ve[i].re = 1.0;\n	    tmp->ve[i].im = 0.0;\n	    tracecatch(zLUsolve(A_cp,pivot,tmp,tmp2),""zm_inverse"");\n	    zset_col(out,i,tmp2);\n	}\n\n#ifdef	THREADSAFE\n	ZV_FREE(tmp);	ZV_FREE(tmp2);\n	ZM_FREE(A_cp);	PX_FREE(pivot);\n#endif\n\n	return out;\n}\n\n/* zLUcondest -- returns an estimate of the condition number of LU given the\n	LU factorisation in compact form */\ndouble	zLUcondest(LU,pivot)\nZMAT	*LU;\nPERM	*pivot;\n{\n    STATIC	ZVEC	*y = ZVNULL, *z = ZVNULL;\n    Real	cond_est, L_norm, U_norm, norm, sn_inv;\n    complex	sum;\n    int		i, j, n;\n\n    if ( ! LU || ! pivot )\n	error(E_NULL,""zLUcondest"");\n    if ( LU->m != LU->n )\n	error(E_SQUARE,""zLUcondest"");\n    if ( LU->n != pivot->size )\n	error(E_SIZES,""zLUcondest"");\n\n    n = LU->n;\n    y = zv_resize(y,n);\n    z = zv_resize(z,n);\n    MEM_STAT_REG(y,TYPE_ZVEC);\n    MEM_STAT_REG(z,TYPE_ZVEC);\n\n    cond_est = 0.0;		/* should never be returned */\n\n    for ( i = 0; i < n; i++ )\n    {\n	sum.re = 1.0;\n	sum.im = 0.0;\n	for ( j = 0; j < i; j++ )\n	    /* sum -= LU->me[j][i]*y->ve[j]; */\n	    sum = zsub(sum,zmlt(LU->me[j][i],y->ve[j]));\n	/* sum -= (sum < 0.0) ? 1.0 : -1.0; */\n	sn_inv = 1.0 / zabs(sum);\n	sum.re += sum.re * sn_inv;\n	sum.im += sum.im * sn_inv;\n	if ( is_zero(LU->me[i][i]) )\n	    return HUGE_VAL;\n	/* y->ve[i] = sum / LU->me[i][i]; */\n	y->ve[i] = zdiv(sum,LU->me[i][i]);\n    }\n\n    zLAsolve(LU,y,y,1.0);\n    zLUsolve(LU,pivot,y,z);\n\n    /* now estimate norm of A (even though it is not directly available) */\n    /* actually computes ||L||_inf.||U||_inf */\n    U_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	norm = 0.0;\n	for ( j = i; j < n; j++ )\n	    norm += zabs(LU->me[i][j]);\n	if ( norm > U_norm )\n	    U_norm = norm;\n    }\n    L_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	norm = 1.0;\n	for ( j = 0; j < i; j++ )\n	    norm += zabs(LU->me[i][j]);\n	if ( norm > L_norm )\n	    L_norm = norm;\n    }\n\n    tracecatch(cond_est = U_norm*L_norm*zv_norm_inf(z)/zv_norm_inf(y),\n	       ""zLUcondest"");\n#ifdef	THREADSAFE\n    ZV_FREE(y);		ZV_FREE(z);\n#endif\n\n    return cond_est;\n}\n"
leukocyte/meschach_lib/solve.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* solve.c 1.2 11/25/87 */\nstatic	char	rcsid[] = ""$Id: solve.c,v 1.3 1994/01/13 05:29:57 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""matrix2.h""\n\n\n\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* Usolve -- back substitution with optional over-riding diagonal\n		-- can be in-situ but doesn't need to be */\n#ifndef ANSI_C\nVEC	*Usolve(matrix,b,out,diag)\nMAT	*matrix;\nVEC	*b, *out;\ndouble	diag;\n#else\nVEC	*Usolve(const MAT *matrix, const VEC *b, VEC *out, double diag)\n#endif\n{\n	unsigned int	dim /* , j */;\n	int	i, i_lim;\n	Real	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum, tiny;\n\n	if ( matrix==MNULL || b==VNULL )\n		error(E_NULL,""Usolve"");\n	dim = min(matrix->m,matrix->n);\n	if ( b->dim < dim )\n		error(E_SIZES,""Usolve"");\n	if ( out==VNULL || out->dim < dim )\n		out = v_resize(out,matrix->n);\n	mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n\n	tiny = 10.0/HUGE_VAL;\n\n	for ( i=dim-1; i>=0; i-- )\n		if ( b_ent[i] != 0.0 )\n		    break;\n		else\n		    out_ent[i] = 0.0;\n	i_lim = i;\n\n	for (    ; i>=0; i-- )\n	{\n		sum = b_ent[i];\n		mat_row = &(mat_ent[i][i+1]);\n		out_col = &(out_ent[i+1]);\n		sum -= __ip__(mat_row,out_col,i_lim-i);\n		/******************************************************\n		for ( j=i+1; j<=i_lim; j++ )\n			sum -= mat_ent[i][j]*out_ent[j];\n			sum -= (*mat_row++)*(*out_col++);\n		******************************************************/\n		if ( diag==0.0 )\n		{\n			if ( fabs(mat_ent[i][i]) <= tiny*fabs(sum) )\n				error(E_SING,""Usolve"");\n			else\n				out_ent[i] = sum/mat_ent[i][i];\n		}\n		else\n			out_ent[i] = sum/diag;\n	}\n\n	return (out);\n}\n\n/* Lsolve -- forward elimination with (optional) default diagonal value */\n#ifndef ANSI_C\nVEC	*Lsolve(matrix,b,out,diag)\nMAT	*matrix;\nVEC	*b,*out;\ndouble	diag;\n#else\nVEC	*Lsolve(const MAT *matrix, const VEC *b, VEC *out, double diag)\n#endif\n{\n	unsigned int	dim, i, i_lim /* , j */;\n	Real	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum, tiny;\n\n	if ( matrix==(MAT *)NULL || b==(VEC *)NULL )\n		error(E_NULL,""Lsolve"");\n	dim = min(matrix->m,matrix->n);\n	if ( b->dim < dim )\n		error(E_SIZES,""Lsolve"");\n	if ( out==(VEC *)NULL || out->dim < dim )\n		out = v_resize(out,matrix->n);\n	mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n\n	for ( i=0; i<dim; i++ )\n		if ( b_ent[i] != 0.0 )\n		    break;\n		else\n		    out_ent[i] = 0.0;\n	i_lim = i;\n\n	tiny = 10.0/HUGE_VAL;\n\n	for (    ; i<dim; i++ )\n	{\n		sum = b_ent[i];\n		mat_row = &(mat_ent[i][i_lim]);\n		out_col = &(out_ent[i_lim]);\n		sum -= __ip__(mat_row,out_col,(int)(i-i_lim));\n		/*****************************************************\n		for ( j=i_lim; j<i; j++ )\n			sum -= mat_ent[i][j]*out_ent[j];\n			sum -= (*mat_row++)*(*out_col++);\n		******************************************************/\n		if ( diag==0.0 )\n		{\n			if ( fabs(mat_ent[i][i]) <= tiny*fabs(sum) )\n				error(E_SING,""Lsolve"");\n			else\n				out_ent[i] = sum/mat_ent[i][i];\n		}\n		else\n			out_ent[i] = sum/diag;\n	}\n\n	return (out);\n}\n\n\n/* UTsolve -- forward elimination with (optional) default diagonal value\n		using UPPER triangular part of matrix */\n#ifndef ANSI_C\nVEC	*UTsolve(U,b,out,diag)\nMAT	*U;\nVEC	*b,*out;\ndouble	diag;\n#else\nVEC	*UTsolve(const MAT *U, const VEC *b, VEC *out, double diag)\n#endif\n{\n    unsigned int	dim, i, i_lim;\n    Real	**U_me, *b_ve, *out_ve, tmp, invdiag, tiny;\n    \n    if ( ! U || ! b )\n	error(E_NULL,""UTsolve"");\n    dim = min(U->m,U->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""UTsolve"");\n    out = v_resize(out,U->n);\n    U_me = U->me;	b_ve = b->ve;	out_ve = out->ve;\n\n    tiny = 10.0/HUGE_VAL;\n\n    for ( i=0; i<dim; i++ )\n	if ( b_ve[i] != 0.0 )\n	    break;\n	else\n	    out_ve[i] = 0.0;\n    i_lim = i;\n    if ( b != out )\n    {\n	__zero__(out_ve,out->dim);\n	MEM_COPY(&(b_ve[i_lim]),&(out_ve[i_lim]),(dim-i_lim)*sizeof(Real));\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (    ; i<dim; i++ )\n	{\n	    tmp = U_me[i][i];\n	    if ( fabs(tmp) <= tiny*fabs(out_ve[i]) )\n		error(E_SING,""UTsolve"");\n	    out_ve[i] /= tmp;\n	    __mltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),-out_ve[i],dim-i-1);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (    ; i<dim; i++ )\n	{\n	    out_ve[i] *= invdiag;\n	    __mltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),-out_ve[i],dim-i-1);\n	}\n    }\n    return (out);\n}\n\n/* Dsolve -- solves Dx=b where D is the diagonal of A -- may be in-situ */\n#ifndef ANSI_C\nVEC	*Dsolve(A,b,x)\nMAT	*A;\nVEC	*b,*x;\n#else\nVEC	*Dsolve(const MAT *A, const VEC *b, VEC *x)\n#endif\n{\n    unsigned int	dim, i;\n    Real	tiny;\n    \n    if ( ! A || ! b )\n	error(E_NULL,""Dsolve"");\n    dim = min(A->m,A->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""Dsolve"");\n    x = v_resize(x,A->n);\n\n    tiny = 10.0/HUGE_VAL;\n\n    dim = b->dim;\n    for ( i=0; i<dim; i++ )\n	if ( fabs(A->me[i][i]) <= tiny*fabs(b->ve[i]) )\n	    error(E_SING,""Dsolve"");\n	else\n	    x->ve[i] = b->ve[i]/A->me[i][i];\n    \n    return (x);\n}\n\n/* LTsolve -- back substitution with optional over-riding diagonal\n		using the LOWER triangular part of matrix\n		-- can be in-situ but doesn't need to be */\n#ifndef ANSI_C\nVEC	*LTsolve(L,b,out,diag)\nMAT	*L;\nVEC	*b, *out;\ndouble	diag;\n#else\nVEC	*LTsolve(const MAT *L, const VEC *b, VEC *out, double diag)\n#endif\n{\n    unsigned int	dim;\n    int		i, i_lim;\n    Real	**L_me, *b_ve, *out_ve, tmp, invdiag, tiny;\n    \n    if ( ! L || ! b )\n	error(E_NULL,""LTsolve"");\n    dim = min(L->m,L->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""LTsolve"");\n    out = v_resize(out,L->n);\n    L_me = L->me;	b_ve = b->ve;	out_ve = out->ve;\n\n    tiny = 10.0/HUGE_VAL;\n    \n    for ( i=dim-1; i>=0; i-- )\n	if ( b_ve[i] != 0.0 )\n	    break;\n    i_lim = i;\n\n    if ( b != out )\n    {\n	__zero__(out_ve,out->dim);\n	MEM_COPY(b_ve,out_ve,(i_lim+1)*sizeof(Real));\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (        ; i>=0; i-- )\n	{\n	    tmp = L_me[i][i];\n	    if ( fabs(tmp) <= tiny*fabs(out_ve[i]) )\n		error(E_SING,""LTsolve"");\n	    out_ve[i] /= tmp;\n	    __mltadd__(out_ve,L_me[i],-out_ve[i],i);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (        ; i>=0; i-- )\n	{\n	    out_ve[i] *= invdiag;\n	    __mltadd__(out_ve,L_me[i],-out_ve[i],i);\n	}\n    }\n    \n    return (out);\n}\n"
leukocyte/meschach_lib/copy.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\nstatic	char	rcsid[] = ""$Id: copy.c,v 1.2 1994/01/13 05:37:14 des Exp $"";\n#include	<stdio.h>\n#include	""matrix.h""\n\n\n\n/* _m_copy -- copies matrix into new area\n	-- out(i0:m,j0:n) <- in(i0:m,j0:n) */\n#ifndef ANSI_C\nMAT	*_m_copy(in,out,i0,j0)\nMAT	*in,*out;\nunsigned int	i0,j0;\n#else\nMAT	*_m_copy(const MAT *in, MAT *out, unsigned int i0, unsigned int j0)\n#endif\n{\n	unsigned int	i /* ,j */;\n\n	if ( in==MNULL )\n		error(E_NULL,""_m_copy"");\n	if ( in==out )\n		return (out);\n	if ( out==MNULL || out->m < in->m || out->n < in->n )\n		out = m_resize(out,in->m,in->n);\n\n	for ( i=i0; i < in->m; i++ )\n		MEM_COPY(&(in->me[i][j0]),&(out->me[i][j0]),\n				(in->n - j0)*sizeof(Real));\n		/* for ( j=j0; j < in->n; j++ )\n			out->me[i][j] = in->me[i][j]; */\n\n	return (out);\n}\n\n/* _v_copy -- copies vector into new area\n	-- out(i0:dim) <- in(i0:dim) */\n#ifndef ANSI_C\nVEC	*_v_copy(in,out,i0)\nVEC	*in,*out;\nunsigned int	i0;\n#else\nVEC	*_v_copy(const VEC *in, VEC *out, unsigned int i0)\n#endif\n{\n	/* unsigned int	i,j; */\n\n	if ( in==VNULL )\n		error(E_NULL,""_v_copy"");\n	if ( in==out )\n		return (out);\n	if ( out==VNULL || out->dim < in->dim )\n		out = v_resize(out,in->dim);\n\n	MEM_COPY(&(in->ve[i0]),&(out->ve[i0]),(in->dim - i0)*sizeof(Real));\n	/* for ( i=i0; i < in->dim; i++ )\n		out->ve[i] = in->ve[i]; */\n\n	return (out);\n}\n\n/* px_copy -- copies permutation 'in' to 'out'\n	-- out is resized to in->size */\n#ifndef ANSI_C\nPERM	*px_copy(in,out)\nPERM	*in,*out;\n#else\nPERM	*px_copy(const PERM *in, PERM *out)\n#endif\n{\n	/* int	i; */\n\n	if ( in == PNULL )\n		error(E_NULL,""px_copy"");\n	if ( in == out )\n		return out;\n	if ( out == PNULL || out->size != in->size )\n		out = px_resize(out,in->size);\n\n	MEM_COPY(in->pe,out->pe,in->size*sizeof(unsigned int));\n	/* for ( i = 0; i < in->size; i++ )\n		out->pe[i] = in->pe[i]; */\n\n	return out;\n}\n\n/*\n	The .._move() routines are for moving blocks of memory around\n	within Meschach data structures and for re-arranging matrices,\n	vectors etc.\n*/\n\n/* m_move -- copies selected pieces of a matrix\n	-- moves the m0 x n0 submatrix with top-left cor-ordinates (i0,j0)\n	   to the corresponding submatrix of out with top-left co-ordinates\n	   (i1,j1)\n	-- out is resized (& created) if necessary */\n#ifndef ANSI_C\nMAT	*m_move(in,i0,j0,m0,n0,out,i1,j1)\nMAT	*in, *out;\nint	i0, j0, m0, n0, i1, j1;\n#else\nMAT	*m_move(const MAT *in, int i0,int j0, int m0,int n0,\n		MAT *out, int i1, int j1)\n#endif\n{\n    int		i;\n\n    if ( ! in )\n	error(E_NULL,""m_move"");\n    if ( i0 < 0 || j0 < 0 || i1 < 0 || j1 < 0 || m0 < 0 || n0 < 0 ||\n	 i0+m0 > in->m || j0+n0 > in->n )\n	error(E_BOUNDS,""m_move"");\n\n    if ( ! out )\n	out = m_resize(out,i1+m0,j1+n0);\n    else if ( i1+m0 > out->m || j1+n0 > out->n )\n	out = m_resize(out,max(out->m,i1+m0),max(out->n,j1+n0));\n\n    for ( i = 0; i < m0; i++ )\n	MEM_COPY(&(in->me[i0+i][j0]),&(out->me[i1+i][j1]),\n		 n0*sizeof(Real));\n\n    return out;\n}\n\n/* v_move -- copies selected pieces of a vector\n	-- moves the length dim0 subvector with initial index i0\n	   to the corresponding subvector of out with initial index i1\n	-- out is resized if necessary */\n#ifndef ANSI_C\nVEC	*v_move(in,i0,dim0,out,i1)\nVEC	*in, *out;\nint	i0, dim0, i1;\n#else\nVEC	*v_move(const VEC *in, int i0, int dim0,\n		VEC *out, int i1)\n#endif\n{\n    if ( ! in )\n	error(E_NULL,""v_move"");\n    if ( i0 < 0 || dim0 < 0 || i1 < 0 ||\n	 i0+dim0 > in->dim )\n	error(E_BOUNDS,""v_move"");\n\n    if ( (! out) || i1+dim0 > out->dim )\n	out = v_resize(out,i1+dim0);\n\n    MEM_COPY(&(in->ve[i0]),&(out->ve[i1]),dim0*sizeof(Real));\n\n    return out;\n}\n\n/* mv_move -- copies selected piece of matrix to a vector\n	-- moves the m0 x n0 submatrix with top-left co-ordinate (i0,j0) to\n	   the subvector with initial index i1 (and length m0*n0)\n	-- rows are copied contiguously\n	-- out is resized if necessary */\n#ifndef ANSI_C\nVEC	*mv_move(in,i0,j0,m0,n0,out,i1)\nMAT	*in;\nVEC	*out;\nint	i0, j0, m0, n0, i1;\n#else\nVEC	*mv_move(const MAT *in, int i0,int j0, int m0, int n0,\n		 VEC *out, int i1)\n#endif\n{\n    int		dim1, i;\n\n    if ( ! in )\n	error(E_NULL,""mv_move"");\n    if ( i0 < 0 || j0 < 0 || m0 < 0 || n0 < 0 || i1 < 0 ||\n	 i0+m0 > in->m || j0+n0 > in->n )\n	error(E_BOUNDS,""mv_move"");\n\n    dim1 = m0*n0;\n    if ( (! out) || i1+dim1 > out->dim )\n	out = v_resize(out,i1+dim1);\n\n    for ( i = 0; i < m0; i++ )\n	MEM_COPY(&(in->me[i0+i][j0]),&(out->ve[i1+i*n0]),n0*sizeof(Real));\n\n    return out;\n}\n\n/* vm_move -- copies selected piece of vector to a matrix\n	\n-- moves the subvector with initial index i0 and length m1*n1 to\n	   the m1 x n1 submatrix with top-left co-ordinate (i1,j1)\n        -- copying is done by rows\n	-- out is resized if necessary */\n#ifndef ANSI_C\nMAT	*vm_move(in,i0,out,i1,j1,m1,n1)\nVEC	*in;\nMAT	*out;\nint	i0, i1, j1, m1, n1;\n#else\nMAT	*vm_move(const VEC *in, int i0,\n		 MAT *out, int i1, int j1, int m1, int n1)\n#endif\n{\n    int		dim0, i;\n\n    if ( ! in )\n	error(E_NULL,""vm_move"");\n    if ( i0 < 0 || i1 < 0 || j1 < 0 || m1 < 0 || n1 < 0 ||\n	 i0+m1*n1 > in->dim )\n	error(E_BOUNDS,""vm_move"");\n\n    if ( ! out )\n	out = m_resize(out,i1+m1,j1+n1);\n    else\n	out = m_resize(out,max(i1+m1,out->m),max(j1+n1,out->n));\n\n    dim0 = m1*n1;\n    for ( i = 0; i < m1; i++ )\n	MEM_COPY(&(in->ve[i0+i*n1]),&(out->me[i1+i][j1]),n1*sizeof(Real));\n\n    return out;\n}\n"
leukocyte/meschach_lib/tutadv.c,"\n/* routines from the section 8 of tutorial.txt */\n\n#include ""matrix.h""\n\n#define M3D_LIST    3      /* list number */\n#define TYPE_MAT3D  0      /* the number of a type */\n\n/* type for 3 dimensional matrices */\ntypedef struct {\n	int l,m,n;    /* actual dimensions */\n	int max_l, max_m, max_n;    /* maximal dimensions */\n	Real ***me;    /* pointer to matrix elements */\n	               /* we do not consider segmented memory */\n        Real *base, **me2d;  /* me and me2d are additional pointers \n				to base */\n} MAT3D;\n\n\n/* function for creating a variable of MAT3D type */\n\nMAT3D *m3d_get(l,m,n)\nint l,m,n;\n{\n  MAT3D *mat;\n  int i,j,k;\n\n  /* check if arguments are positive */\n  if (l <= 0 || m <= 0 || n <= 0)\n    error(E_NEG,""m3d_get"");\n\n	/* new structure */\n  if ((mat = NEW(MAT3D)) == (MAT3D *)NULL)\n    error(E_MEM,""m3d_get"");\n  else if (mem_info_is_on()) {\n	/* record how many bytes is allocated */\n    mem_bytes_list(TYPE_MAT3D,0,sizeof(MAT3D),M3D_LIST);\n	/* record a new allocated variable */\n    mem_numvar_list(TYPE_MAT3D,1,M3D_LIST);\n  }\n\n  mat->l = mat->max_l = l;\n  mat->m = mat->max_m = m;\n  mat->n = mat->max_n = n;\n\n	/* allocate memory for 3D array */\n  if ((mat->base = NEW_A(l*m*n,Real)) == (Real *)NULL) \n    error(E_MEM,""m3d_get"");\n  else if (mem_info_is_on())\n    mem_bytes_list(TYPE_MAT3D,0,l*m*n*sizeof(Real),M3D_LIST);\n\n	/* allocate memory for 2D pointers */\n  if ((mat->me2d = NEW_A(l*m,Real *)) == (Real **)NULL)\n    error(E_MEM,""m3d_get"");\n  else if (mem_info_is_on())\n    mem_bytes_list(TYPE_MAT3D,0,l*m*sizeof(Real *),M3D_LIST);  	\n\n	/* allocate  memory for 1D pointers */\n  if ((mat->me = NEW_A(l,Real **)) == (Real ***)NULL)\n    error(E_MEM,""m3d_get"");\n  else if (mem_info_is_on())\n    mem_bytes_list(TYPE_MAT3D,0,l*sizeof(Real **),M3D_LIST);\n\n  	/* pointers to 2D matrices */\n  for (i=0,k=0; i < l; i++)\n    for (j=0; j < m; j++)\n      mat->me2d[k++] = &mat->base[(i*m+j)*n];\n\n       /* pointers to rows */\n  for (i=0; i < l; i++)\n    mat->me[i] = &mat->me2d[i*m];\n\n  return mat;\n}\n\n\n/* deallocate a variable of type MAT3D */\n\nint m3d_free(mat)\nMAT3D *mat;\n{\n 	  /* do not try to deallocate the NULL pointer */\n  if (mat == (MAT3D *)NULL)\n    return -1;\n	\n	  /* first deallocate base */\n  if (mat->base != (Real *)NULL) {\n    if (mem_info_is_on())\n	/* record how many bytes is deallocated */\n      mem_bytes_list(TYPE_MAT3D,mat->max_l*mat->max_m*mat->max_n*sizeof(Real),\n		     0,M3D_LIST);\n    free((char *)mat->base);\n  }\n\n 	/* deallocate array of 2D pointers */\n  if (mat->me2d != (Real **)NULL) {\n    if (mem_info_is_on())\n	/* record how many bytes is deallocated */\n      mem_bytes_list(TYPE_MAT3D,mat->max_l*mat->max_m*sizeof(Real *),\n		     0,M3D_LIST);\n    free((char *)mat->me2d);\n  }\n\n 	/* deallocate array of 1D pointers */\n  if (mat->me != (Real ***)NULL) {\n    if (mem_info_is_on())\n	/* record how many bytes is deallocated */\n      mem_bytes_list(TYPE_MAT3D,mat->max_l*sizeof(Real **),0,M3D_LIST);\n    free((char *)mat->me);\n  }\n\n	/* deallocate  MAT3D structure */\n  if (mem_info_is_on()) {\n    mem_bytes_list(TYPE_MAT3D,sizeof(MAT3D),0,M3D_LIST);\n    mem_numvar_list(TYPE_MAT3D,-1,M3D_LIST);\n  }\n  free((char *)mat);\n\n  return 0;\n}\n\n/*=============================================*/\n\nchar *m3d_names[] = {\n  ""MAT3D""\n};\n\n\n#define M3D_NUM  (sizeof(m3d_names)/sizeof(*m3d_names))\n\nint (*m3d_free_funcs[M3D_NUM])() = {\n  m3d_free\n};\n\nstatic MEM_ARRAY m3d_sum[M3D_NUM];\n\n\n/* test routing for allocating/deallocating static variables */\nvoid test_stat(k)\nint k;\n{\n   static MAT3D *work;\n\n   if (!work) {\n      work = m3d_get(10,10,10);\n      mem_stat_reg_list((void **)&work,TYPE_MAT3D,M3D_LIST);\n      work->me[9][9][9] = -3.14;\n   }\n   \n   if (k == 9) \n     printf("" work[9][9][9] = %g\n"",work->me[9][9][9]);\n}\n\n\nvoid main()\n{\n  MAT3D *M;\n  int i,j,k;\n\n  mem_info_on(TRUE);\n  /* can be the first command */\n  mem_attach_list(M3D_LIST,M3D_NUM,m3d_names,m3d_free_funcs,m3d_sum);\n\n  M = m3d_get(3,4,5);\n  mem_info_file(stdout,M3D_LIST);\n\n  /* make use of M->me[i][j][k], where i,j,k are non-negative and \n	i < 3, j < 4, k < 5 */\n\n  mem_stat_mark(1);\n  for (i=0; i < 3; i++)\n    for (j=0; j < 4; j++)\n      for (k=0; k < 5; k++) {\n	 test_stat(i+j+k);\n	 M->me[i][j][k] = i+j+k;\n      }\n  mem_stat_free_list(1,M3D_LIST);\n  mem_info_file(stdout,M3D_LIST);\n\n  printf("" M[%d][%d][%d] = %g\n"",2,3,4,M->me[2][3][4]);\n\n  mem_stat_mark(2);\n  test_stat(9);\n  mem_stat_free_list(2,M3D_LIST);\n\n  m3d_free(M);  /* if M is not necessary */\n  mem_info_file(stdout,M3D_LIST);\n\n}\n\n\n\n"
leukocyte/meschach_lib/zmachine.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  This file contains basic routines which are used by the functions\n  involving complex vectors.\n  These are the routines that should be modified in order to take\n  full advantage of specialised architectures (pipelining, vector\n  processors etc).\n  */\nstatic	char	*rcsid = ""$Id: zmachine.c,v 1.1 1994/01/13 04:25:41 des Exp $"";\n\n#include	<math.h>\n#include	""machine.h""\n#include        ""zmatrix.h""\n\n\n/* __zconj__ -- complex conjugate */\n#ifndef ANSI_C\nvoid	__zconj__(zp,len)\ncomplex	*zp;\nint	len;\n#else\nvoid	__zconj__(complex zp[], int len)\n#endif\n{\n    int		i;\n\n    for ( i = 0; i < len; i++ )\n	zp[i].im = - zp[i].im;\n}\n\n/* __zip__ -- inner product\n	-- computes sum_i zp1[i].zp2[i] if flag == 0\n		    sum_i zp1[i]*.zp2[i] if flag != 0 */\n#ifndef ANSI_C\ncomplex	__zip__(zp1,zp2,len,flag)\ncomplex	*zp1, *zp2;\nint	flag, len;\n#else\ncomplex	__zip__(const complex *zp1, const complex *zp2, int len, int flag)\n#endif\n{\n    complex	sum;\n    int		i;\n\n    sum.re = sum.im = 0.0;\n    if ( flag )\n    {\n	for ( i = 0; i < len; i++ )\n	{\n	    sum.re += zp1[i].re*zp2[i].re + zp1[i].im*zp2[i].im;\n	    sum.im += zp1[i].re*zp2[i].im - zp1[i].im*zp2[i].re;\n	}\n    }\n    else\n    {\n	for ( i = 0; i < len; i++ )\n	{\n	    sum.re += zp1[i].re*zp2[i].re - zp1[i].im*zp2[i].im;\n	    sum.im += zp1[i].re*zp2[i].im + zp1[i].im*zp2[i].re;\n	}\n    }\n\n    return sum;\n}\n\n/* __zmltadd__ -- scalar multiply and add i.e. complex saxpy\n	-- computes zp1[i] += s.zp2[i]  if flag == 0\n	-- computes zp1[i] += s.zp2[i]* if flag != 0 */\n#ifndef ANSI_C\nvoid	__zmltadd__(zp1,zp2,s,len,flag)\ncomplex	*zp1, *zp2, s;\nint	flag, len;\n#else\nvoid	__zmltadd__(complex *zp1, const complex *zp2, complex s,\n		    int len, int flag)\n#endif\n{\n    int		i;\n    LongReal	t_re, t_im;\n\n    if ( ! flag )\n    {\n	for ( i = 0; i < len; i++ )\n	{\n	    t_re = zp1[i].re + s.re*zp2[i].re - s.im*zp2[i].im;\n	    t_im = zp1[i].im + s.re*zp2[i].im + s.im*zp2[i].re;\n	    zp1[i].re = t_re;\n	    zp1[i].im = t_im;\n	}\n    }\n    else\n    {\n	for ( i = 0; i < len; i++ )\n	{\n	    t_re = zp1[i].re + s.re*zp2[i].re + s.im*zp2[i].im;\n	    t_im = zp1[i].im - s.re*zp2[i].im + s.im*zp2[i].re;\n	    zp1[i].re = t_re;\n	    zp1[i].im = t_im;\n	}\n    }\n}\n\n/* __zmlt__ scalar complex multiply array c.f. sv_mlt() */\n#ifndef ANSI_C\nvoid	__zmlt__(zp,s,out,len)\ncomplex	*zp, s, *out;\nregister int	len;\n#else\nvoid	__zmlt__(const complex *zp, complex s, complex *out, int len)\n#endif\n{\n    int		i;\n    LongReal	t_re, t_im;\n\n    for ( i = 0; i < len; i++ )\n    {\n	t_re = s.re*zp[i].re - s.im*zp[i].im;\n	t_im = s.re*zp[i].im + s.im*zp[i].re;\n	out[i].re = t_re;\n	out[i].im = t_im;\n    }\n}\n\n/* __zadd__ -- add complex arrays c.f. v_add() */\n#ifndef ANSI_C\nvoid	__zadd__(zp1,zp2,out,len)\ncomplex	*zp1, *zp2, *out;\nint	len;\n#else\nvoid	__zadd__(const complex *zp1, const complex *zp2, complex *out, int len)\n#endif\n{\n    int		i;\n    for ( i = 0; i < len; i++ )\n    {\n	out[i].re = zp1[i].re + zp2[i].re;\n	out[i].im = zp1[i].im + zp2[i].im;\n    }\n}\n\n/* __zsub__ -- subtract complex arrays c.f. v_sub() */\n#ifndef ANSI_C\nvoid	__zsub__(zp1,zp2,out,len)\ncomplex	*zp1, *zp2, *out;\nint	len;\n#else\nvoid	__zsub__(const complex *zp1, const complex *zp2, complex *out, int len)\n#endif\n{\n    int		i;\n    for ( i = 0; i < len; i++ )\n    {\n	out[i].re = zp1[i].re - zp2[i].re;\n	out[i].im = zp1[i].im - zp2[i].im;\n    }\n}\n\n/* __zzero__ -- zeros an array of complex numbers */\n#ifndef ANSI_C\nvoid	__zzero__(zp,len)\ncomplex	*zp;\nint	len;\n#else\nvoid	__zzero__(complex *zp, int len)\n#endif\n{\n    /* if a Real precision zero is equivalent to a string of nulls */\n    MEM_ZERO((char *)zp,len*sizeof(complex));\n    /* else, need to zero the array entry by entry */\n    /******************************\n    while ( len-- )\n    {\n	zp->re = zp->im = 0.0;\n	zp++;\n    }\n    ******************************/\n}\n\n"
leukocyte/meschach_lib/machine.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  This file contains basic routines which are used by the functions\n  in meschach.a etc.\n  These are the routines that should be modified in order to take\n  full advantage of specialised architectures (pipelining, vector\n  processors etc).\n  */\n\nstatic	char	*rcsid = ""$Id: machine.c,v 1.4 1994/01/13 05:28:56 des Exp $"";\n\n#include	""machine.h""\n\n/* __ip__ -- inner product */\n#ifndef ANSI_C\ndouble	__ip__(dp1,dp2,len)\nregister Real	*dp1, *dp2;\nint	len;\n#else\ndouble	__ip__(const Real *dp1, const Real *dp2, int len)\n#endif\n{\n#ifdef VUNROLL\n    register int	len4;\n    register Real	sum1, sum2, sum3;\n#endif\n    register int	i;\n    register Real     sum;\n\n    sum = 0.0;\n#ifdef VUNROLL\n    sum1 = sum2 = sum3 = 0.0;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    \n    for ( i = 0; i < len4; i++ )\n    {\n	sum  += dp1[4*i]*dp2[4*i];\n	sum1 += dp1[4*i+1]*dp2[4*i+1];\n	sum2 += dp1[4*i+2]*dp2[4*i+2];\n	sum3 += dp1[4*i+3]*dp2[4*i+3];\n    }\n    sum  += sum1 + sum2 + sum3;\n    dp1 += 4*len4;	dp2 += 4*len4;\n#endif\n    \n    for ( i = 0; i < len; i++ )\n	sum  += dp1[i]*dp2[i];\n    \n    return sum;\n}\n\n/* __mltadd__ -- scalar multiply and add c.f. v_mltadd() */\n#ifndef ANSI_C\nvoid	__mltadd__(dp1,dp2,s,len)\nregister Real	*dp1, *dp2;\nregister double s;\nregister int	len;\n#else\nvoid	__mltadd__(Real *dp1, const Real *dp2, double s, int len)\n#endif\n{\n    register int	i;\n#ifdef VUNROLL\n    register int        len4;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    for ( i = 0; i < len4; i++ )\n    {\n	dp1[4*i]   += s*dp2[4*i];\n	dp1[4*i+1] += s*dp2[4*i+1];\n	dp1[4*i+2] += s*dp2[4*i+2];\n	dp1[4*i+3] += s*dp2[4*i+3];\n    }\n    dp1 += 4*len4;	dp2 += 4*len4;\n#endif\n    \n    for ( i = 0; i < len; i++ )\n	dp1[i] += s*dp2[i];\n}\n\n/* __smlt__ scalar multiply array c.f. sv_mlt() */\n#ifndef ANSI_C\nvoid	__smlt__(dp,s,out,len)\nregister Real	*dp, *out;\nregister double s;\nregister int	len;\n#else\nvoid	__smlt__(const Real *dp, double s, Real *out, int len)\n#endif\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	out[i] = s*dp[i];\n}\n\n/* __add__ -- add arrays c.f. v_add() */\n#ifndef ANSI_C\nvoid	__add__(dp1,dp2,out,len)\nregister Real	*dp1, *dp2, *out;\nregister int	len;\n#else\nvoid	__add__(const Real *dp1, const Real *dp2, Real *out, int len)\n#endif\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	out[i] = dp1[i] + dp2[i];\n}\n\n/* __sub__ -- subtract arrays c.f. v_sub() */\n#ifndef ANSI_C\nvoid	__sub__(dp1,dp2,out,len)\nregister Real	*dp1, *dp2, *out;\nregister int	len;\n#else\nvoid	__sub__(const Real *dp1, const Real *dp2, Real *out, int len)\n#endif\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	out[i] = dp1[i] - dp2[i];\n}\n\n/* __zero__ -- zeros an array of floating point numbers */\n#ifndef ANSI_C\nvoid	__zero__(dp,len)\nregister Real	*dp;\nregister int	len;\n#else\nvoid	__zero__(Real *dp, int len)\n#endif\n{\n#ifdef CHAR0ISDBL0\n    /* if a floating point zero is equivalent to a string of nulls */\n    MEM_ZERO((char *)dp,len*sizeof(Real));\n#else\n    /* else, need to zero the array entry by entry */\n    int	i;\n    for ( i = 0; i < len; i++ )\n	dp[i] = 0.0;\n#endif\n}\n\n"
leukocyte/meschach_lib/conjgrad.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Conjugate gradient routines file\n	Uses sparse matrix input & sparse Cholesky factorisation in pccg().\n\n	All the following routines use routines to define a matrix\n		rather than use any explicit representation\n		(with the exeception of the pccg() pre-conditioner)\n	The matrix A is defined by\n\n		VEC *(*A)(void *params, VEC *x, VEC *y)\n\n	where y = A.x on exit, and y is returned. The params argument is\n	intended to make it easier to re-use & modify such routines.\n\n	If we have a sparse matrix data structure\n		SPMAT	*A_mat;\n	then these can be used by passing sp_mv_mlt as the function, and\n	A_mat as the param.\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include	""sparse.h""\nstatic char	rcsid[] = ""$Id: conjgrad.c,v 1.4 1994/01/13 05:36:45 des Exp $"";\n\n\n/* #define	MAX_ITER	10000 */\nstatic	int	max_iter = 10000;\nint	cg_num_iters;\n\n/* matrix-as-routine type definition */\n/* #ifdef ANSI_C */\n/* typedef VEC	*(*MTX_FN)(void *params, VEC *x, VEC *out); */\n/* #else */\ntypedef VEC	*(*MTX_FN)();\n/* #endif */\n#ifdef ANSI_C\nVEC	*spCHsolve(SPMAT *,VEC *,VEC *);\n#else\nVEC	*spCHsolve();\n#endif\n\n/* cg_set_maxiter -- sets maximum number of iterations if numiter > 1\n	-- just returns current max_iter otherwise\n	-- returns old maximum */\nint	cg_set_maxiter(numiter)\nint	numiter;\n{\n	int	temp;\n\n	if ( numiter < 2 )\n	    return max_iter;\n	temp = max_iter;\n	max_iter = numiter;\n	return temp;\n}\n\n\n/* pccg -- solves A.x = b using pre-conditioner M\n			(assumed factored a la spCHfctr())\n	-- results are stored in x (if x != NULL), which is returned */\nVEC	*pccg(A,A_params,M_inv,M_params,b,eps,x)\nMTX_FN	A, M_inv;\nVEC	*b, *x;\ndouble	eps;\nvoid	*A_params, *M_params;\n{\n	VEC	*r = VNULL, *p = VNULL, *q = VNULL, *z = VNULL;\n	int	k;\n	Real	alpha, beta, ip, old_ip, norm_b;\n\n	if ( ! A || ! b )\n		error(E_NULL,""pccg"");\n	if ( x == b )\n		error(E_INSITU,""pccg"");\n	x = v_resize(x,b->dim);\n	if ( eps <= 0.0 )\n		eps = MACHEPS;\n\n	r = v_get(b->dim);\n	p = v_get(b->dim);\n	q = v_get(b->dim);\n	z = v_get(b->dim);\n\n	norm_b = v_norm2(b);\n\n	v_zero(x);\n	r = v_copy(b,r);\n	old_ip = 0.0;\n	for ( k = 0; ; k++ )\n	{\n		if ( v_norm2(r) < eps*norm_b )\n			break;\n		if ( k > max_iter )\n		    error(E_ITER,""pccg"");\n		if ( M_inv )\n		    (*M_inv)(M_params,r,z);\n		else\n		    v_copy(r,z);	/* M == identity */\n		ip = in_prod(z,r);\n		if ( k )	/* if ( k > 0 ) ... */\n		{\n		    beta = ip/old_ip;\n		    p = v_mltadd(z,p,beta,p);\n		}\n		else		/* if ( k == 0 ) ... */\n		{\n		    beta = 0.0;\n		    p = v_copy(z,p);\n		    old_ip = 0.0;\n		}\n		q = (*A)(A_params,p,q);\n		alpha = ip/in_prod(p,q);\n		x = v_mltadd(x,p,alpha,x);\n		r = v_mltadd(r,q,-alpha,r);\n		old_ip = ip;\n	}\n	cg_num_iters = k;\n\n	V_FREE(p);\n	V_FREE(q);\n	V_FREE(r);\n	V_FREE(z);\n\n	return x;\n}\n\n/* sp_pccg -- a simple interface to pccg() which uses sparse matrix\n		data structures\n	-- assumes that LLT contains the Cholesky factorisation of the\n		actual pre-conditioner */\nVEC	*sp_pccg(A,LLT,b,eps,x)\nSPMAT	*A, *LLT;\nVEC	*b, *x;\ndouble	eps;\n{	return pccg(sp_mv_mlt,A,spCHsolve,LLT,b,eps,x);		}\n\n\n/*\n	Routines for performing the CGS (Conjugate Gradient Squared)\n	algorithm of P. Sonneveld:\n	    ""CGS, a fast Lanczos-type solver for nonsymmetric linear\n		systems"", SIAM J. Sci. & Stat. Comp. v. 10, pp. 36--52\n*/\n\n/* cgs -- uses CGS to compute a solution x to A.x=b\n	-- the matrix A is not passed explicitly, rather a routine\n		A is passed where A(x,Ax,params) computes\n		Ax = A.x\n	-- the computed solution is passed */\nVEC	*cgs(A,A_params,b,r0,tol,x)\nMTX_FN	A;\nVEC	*x, *b;\nVEC	*r0;		/* tilde r0 parameter -- should be random??? */\ndouble	tol;		/* error tolerance used */\nvoid	*A_params;\n{\n	VEC	*p, *q, *r, *u, *v, *tmp1, *tmp2;\n	Real	alpha, beta, norm_b, rho, old_rho, sigma;\n	int	iter;\n\n	if ( ! A || ! x || ! b || ! r0 )\n		error(E_NULL,""cgs"");\n	if ( x->dim != b->dim || r0->dim != x->dim )\n		error(E_SIZES,""cgs"");\n	if ( tol <= 0.0 )\n		tol = MACHEPS;\n\n	p = v_get(x->dim);\n	q = v_get(x->dim);\n	r = v_get(x->dim);\n	u = v_get(x->dim);\n	v = v_get(x->dim);\n	tmp1 = v_get(x->dim);\n	tmp2 = v_get(x->dim);\n\n	norm_b = v_norm2(b);\n	(*A)(A_params,x,tmp1);\n	v_sub(b,tmp1,r);\n	v_zero(p);	v_zero(q);\n	old_rho = 1.0;\n\n	iter = 0;\n	while ( v_norm2(r) > tol*norm_b )\n	{\n		if ( ++iter > max_iter ) break;\n		/*    error(E_ITER,""cgs"");  */\n		rho = in_prod(r0,r);\n		if ( old_rho == 0.0 )\n		    error(E_SING,""cgs"");\n		beta = rho/old_rho;\n		v_mltadd(r,q,beta,u);\n		v_mltadd(q,p,beta,tmp1);\n		v_mltadd(u,tmp1,beta,p);\n\n		(*A)(A_params,p,v);\n\n		sigma = in_prod(r0,v);\n		if ( sigma == 0.0 )\n		    error(E_SING,""cgs"");\n		alpha = rho/sigma;\n		v_mltadd(u,v,-alpha,q);\n		v_add(u,q,tmp1);\n\n		(*A)(A_params,tmp1,tmp2);\n\n		v_mltadd(r,tmp2,-alpha,r);\n		v_mltadd(x,tmp1,alpha,x);\n\n		old_rho = rho;\n	}\n	cg_num_iters = iter;\n\n	V_FREE(p);	V_FREE(q);	V_FREE(r);\n	V_FREE(u);	V_FREE(v);\n	V_FREE(tmp1);	V_FREE(tmp2);\n\n	return x;\n}\n\n/* sp_cgs -- simple interface for SPMAT data structures */\nVEC	*sp_cgs(A,b,r0,tol,x)\nSPMAT	*A;\nVEC	*b, *r0, *x;\ndouble	tol;\n{	return cgs(sp_mv_mlt,A,b,r0,tol,x);	}\n\n/*\n	Routine for performing LSQR -- the least squares QR algorithm\n	of Paige and Saunders:\n		""LSQR: an algorithm for sparse linear equations and\n		sparse least squares"", ACM Trans. Math. Soft., v. 8\n		pp. 43--71 (1982)\n*/\n/* lsqr -- sparse CG-like least squares routine:\n	-- finds min_x ||A.x-b||_2 using A defined through A & AT\n	-- returns x (if x != NULL) */\nVEC	*lsqr(A,AT,A_params,b,tol,x)\nMTX_FN	A, AT;	/* AT is A transposed */\nVEC	*x, *b;\ndouble	tol;		/* error tolerance used */\nvoid	*A_params;\n{\n	VEC	*u, *v, *w, *tmp;\n	Real	alpha, beta, norm_b, phi, phi_bar,\n				rho, rho_bar, rho_max, theta;\n	Real	s, c;	/* for Givens' rotations */\n	int	iter, m, n;\n\n	if ( ! b || ! x )\n		error(E_NULL,""lsqr"");\n	if ( tol <= 0.0 )\n		tol = MACHEPS;\n\n	m = b->dim;	n = x->dim;\n	u = v_get((unsigned int)m);\n	v = v_get((unsigned int)n);\n	w = v_get((unsigned int)n);\n	tmp = v_get((unsigned int)n);\n	norm_b = v_norm2(b);\n\n	v_zero(x);\n	beta = v_norm2(b);\n	if ( beta == 0.0 )\n		return x;\n	sv_mlt(1.0/beta,b,u);\n	tracecatch((*AT)(A_params,u,v),""lsqr"");\n	alpha = v_norm2(v);\n	if ( alpha == 0.0 )\n		return x;\n	sv_mlt(1.0/alpha,v,v);\n	v_copy(v,w);\n	phi_bar = beta;		rho_bar = alpha;\n\n	rho_max = 1.0;\n	iter = 0;\n	do {\n		if ( ++iter > max_iter )\n		    error(E_ITER,""lsqr"");\n\n		tmp = v_resize(tmp,m);\n		tracecatch((*A) (A_params,v,tmp),""lsqr"");\n\n		v_mltadd(tmp,u,-alpha,u);\n		beta = v_norm2(u);	sv_mlt(1.0/beta,u,u);\n\n		tmp = v_resize(tmp,n);\n		tracecatch((*AT)(A_params,u,tmp),""lsqr"");\n		v_mltadd(tmp,v,-beta,v);\n		alpha = v_norm2(v);	sv_mlt(1.0/alpha,v,v);\n\n		rho = sqrt(rho_bar*rho_bar+beta*beta);\n		if ( rho > rho_max )\n		    rho_max = rho;\n		c   = rho_bar/rho;\n		s   = beta/rho;\n		theta   =  s*alpha;\n		rho_bar = -c*alpha;\n		phi     =  c*phi_bar;\n		phi_bar =  s*phi_bar;\n\n		/* update x & w */\n		if ( rho == 0.0 )\n		    error(E_SING,""lsqr"");\n		v_mltadd(x,w,phi/rho,x);\n		v_mltadd(v,w,-theta/rho,w);\n	} while ( fabs(phi_bar*alpha*c) > tol*norm_b/rho_max );\n\n	cg_num_iters = iter;\n\n	V_FREE(tmp);	V_FREE(u);	V_FREE(v);	V_FREE(w);\n\n	return x;\n}\n\n/* sp_lsqr -- simple interface for SPMAT data structures */\nVEC	*sp_lsqr(A,b,tol,x)\nSPMAT	*A;\nVEC	*b, *x;\ndouble	tol;\n{	return lsqr(sp_mv_mlt,sp_vm_mlt,A,b,tol,x);	}\n\n"
leukocyte/meschach_lib/itersym.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* itersym.c 17/09/93 */\n\n\n/* \n  ITERATIVE METHODS - implementation of several iterative methods;\n  see also iter0.c\n  */\n\n#include        <stdio.h>\n#include	<math.h>\n#include        ""matrix.h""\n#include        ""matrix2.h""\n#include	""sparse.h""\n#include        ""iter.h""\n\nstatic char rcsid[] = ""$Id: itersym.c,v 1.2 1995/01/30 14:55:54 des Exp $"";\n\n\n#ifdef ANSI_C\nVEC	*spCHsolve(const SPMAT *,VEC *,VEC *);\nVEC	*trieig(VEC *,VEC *,MAT *);\n#else\nVEC	*spCHsolve();\nVEC	*trieig();\n#endif\n\n\n\n/* iter_spcg -- a simple interface to iter_cg() which uses sparse matrix\n   data structures\n   -- assumes that LLT contains the Cholesky factorisation of the\n   actual preconditioner;\n   use always as follows:\n   x = iter_spcg(A,LLT,b,eps,x,limit,steps);\n   or \n   x = iter_spcg(A,LLT,b,eps,VNULL,limit,steps);\n   In the second case the solution vector is created.\n   */\n#ifndef ANSI_C\nVEC  *iter_spcg(A,LLT,b,eps,x,limit,steps)\nSPMAT	*A, *LLT;\nVEC	*b, *x;\ndouble	eps;\nint *steps, limit;\n#else\nVEC  *iter_spcg(SPMAT *A, SPMAT *LLT, VEC *b, double eps, VEC *x,\n		int limit, int *steps)\n#endif\n{	\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *)A;\n   ip->Bx = (Fun_Ax) spCHsolve;\n   ip->B_par = (void *)LLT;\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = eps;\n   ip->limit = limit;\n   ip->x = x;\n   iter_cg(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n/* \n  Conjugate gradients method;\n  */\n#ifndef ANSI_C\nVEC  *iter_cg(ip)\nITER *ip;\n#else\nVEC  *iter_cg(ITER *ip)\n#endif\n{\n   STATIC VEC *r = VNULL, *p = VNULL, *q = VNULL, *z = VNULL;\n   Real	alpha, beta, inner, old_inner, nres;\n   VEC *rr;   /* rr == r or rr == z */\n   \n   if (ip == INULL)\n     error(E_NULL,""iter_cg"");\n   if (!ip->Ax || !ip->b)\n     error(E_NULL,""iter_cg"");\n   if ( ip->x == ip->b )\n     error(E_INSITU,""iter_cg"");\n   if (!ip->stop_crit)\n     error(E_NULL,""iter_cg"");\n   \n   if ( ip->eps <= 0.0 )\n     ip->eps = MACHEPS;\n   \n   r = v_resize(r,ip->b->dim);\n   p = v_resize(p,ip->b->dim);\n   q = v_resize(q,ip->b->dim);\n   \n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(p,TYPE_VEC);\n   MEM_STAT_REG(q,TYPE_VEC);\n   \n   if (ip->Bx != (Fun_Ax)NULL) {\n      z = v_resize(z,ip->b->dim);\n      MEM_STAT_REG(z,TYPE_VEC);\n      rr = z;\n   }\n   else rr = r;\n   \n   if (ip->x != VNULL) {\n      if (ip->x->dim != ip->b->dim)\n	error(E_SIZES,""iter_cg"");\n      ip->Ax(ip->A_par,ip->x,p);    		/* p = A*x */\n      v_sub(ip->b,p,r);		 		/* r = b - A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n      v_copy(ip->b,r);\n   }\n   \n   old_inner = 0.0;\n   for ( ip->steps = 0; ip->steps <= ip->limit; ip->steps++ )\n   {\n      if ( ip->Bx )\n	(ip->Bx)(ip->B_par,r,rr);		/* rr = B*r */\n      \n      inner = in_prod(rr,r);\n      nres = sqrt(fabs(inner));\n      if (ip->info) ip->info(ip,nres,r,rr);\n      if (ip->steps == 0) ip->init_res = nres;\n      if ( ip->stop_crit(ip,nres,r,rr) ) break;\n      \n      if ( ip->steps )	/* if ( ip->steps > 0 ) ... */\n      {\n	 beta = inner/old_inner;\n	 p = v_mltadd(rr,p,beta,p);\n      }\n      else		/* if ( ip->steps == 0 ) ... */\n      {\n	 beta = 0.0;\n	 p = v_copy(rr,p);\n	 old_inner = 0.0;\n      }\n      (ip->Ax)(ip->A_par,p,q);     /* q = A*p */\n      alpha = in_prod(p,q);\n      if (sqrt(fabs(alpha)) <= MACHEPS*ip->init_res) \n	error(E_BREAKDOWN,""iter_cg"");\n      alpha = inner/alpha;\n      v_mltadd(ip->x,p,alpha,ip->x);\n      v_mltadd(r,q,-alpha,r);\n      old_inner = inner;\n   }\n\n#ifdef	THREADSAFE\n   V_FREE(r);   V_FREE(p);   V_FREE(q);   V_FREE(z);\n#endif\n\n   return ip->x;\n}\n\n\n\n/* iter_lanczos -- raw lanczos algorithm -- no re-orthogonalisation\n   -- creates T matrix of size == m,\n   but no larger than before beta_k == 0\n   -- uses passed routine to do matrix-vector multiplies */\n#ifndef ANSI_C\nvoid	iter_lanczos(ip,a,b,beta2,Q)\nITER    *ip;\nVEC	*a, *b;\nReal	*beta2;\nMAT	*Q;\n#else\nvoid	iter_lanczos(ITER *ip, VEC *a, VEC *b, Real *beta2, MAT *Q)\n#endif\n{\n   int	j;\n   STATIC VEC	*v = VNULL, *w = VNULL, *tmp = VNULL;\n   Real	alpha, beta, c;\n   \n   if ( ! ip )\n     error(E_NULL,""iter_lanczos"");\n   if ( ! ip->Ax || ! ip->x || ! a || ! b )\n     error(E_NULL,""iter_lanczos"");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,""iter_lanczos"");\n   if ( Q && ( Q->n < ip->x->dim || Q->m < ip->k ) )\n     error(E_SIZES,""iter_lanczos"");\n   \n   a = v_resize(a,(unsigned int)ip->k);	\n   b = v_resize(b,(unsigned int)(ip->k-1));\n   v = v_resize(v,ip->x->dim);\n   w = v_resize(w,ip->x->dim);\n   tmp = v_resize(tmp,ip->x->dim);\n   MEM_STAT_REG(v,TYPE_VEC);\n   MEM_STAT_REG(w,TYPE_VEC);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n   \n   beta = 1.0;\n   v_zero(a);\n   v_zero(b);\n   if (Q) m_zero(Q);\n   \n   /* normalise x as w */\n   c = v_norm2(ip->x);\n   if (c <= MACHEPS) { /* ip->x == 0 */\n      *beta2 = 0.0;\n      return;\n   }\n   else \n     sv_mlt(1.0/c,ip->x,w);\n   \n   (ip->Ax)(ip->A_par,w,v);\n   \n   for ( j = 0; j < ip->k; j++ )\n   {\n      /* store w in Q if Q not NULL */\n      if ( Q ) set_row(Q,j,w);\n      \n      alpha = in_prod(w,v);\n      a->ve[j] = alpha;\n      v_mltadd(v,w,-alpha,v);\n      beta = v_norm2(v);\n      if ( beta == 0.0 )\n      {\n	 *beta2 = 0.0;\n	 return;\n      }\n      \n      if ( j < ip->k-1 )\n	b->ve[j] = beta;\n      v_copy(w,tmp);\n      sv_mlt(1/beta,v,w);\n      sv_mlt(-beta,tmp,v);\n      (ip->Ax)(ip->A_par,w,tmp);\n      v_add(v,tmp,v);\n   }\n   *beta2 = beta;\n\n#ifdef	THREADSAFE\n   V_FREE(v);   V_FREE(w);   V_FREE(tmp);\n#endif\n}\n\n/* iter_splanczos -- version that uses sparse matrix data structure */\n#ifndef ANSI_C\nvoid    iter_splanczos(A,m,x0,a,b,beta2,Q)\nSPMAT	*A;\nint     m;\nVEC     *x0, *a, *b;\nReal    *beta2;\nMAT     *Q;\n#else\nvoid    iter_splanczos(SPMAT *A, int m, VEC *x0, \n		       VEC *a, VEC *b, Real *beta2, MAT *Q)\n#endif\n{	\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->shared_x = ip->shared_b = TRUE;\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   ip->x = x0;\n   ip->k = m;\n   iter_lanczos(ip,a,b,beta2,Q);	\n   iter_free(ip);   /* release only ITER structure */\n}\n\n\n#ifndef ANSI_C\nextern	double	frexp(), ldexp();\n#else\nextern	double	frexp(double num, int *exponent),\n  ldexp(double num, int exponent);\n#endif\n\n/* product -- returns the product of a long list of numbers\n   -- answer stored in mant (mantissa) and expt (exponent) */\n#ifndef ANSI_C\nstatic	double	product(a,offset,expt)\nVEC	*a;\ndouble	offset;\nint	*expt;\n#else\nstatic	double	product(VEC *a, double offset, int *expt)\n#endif\n{\n   Real	mant, tmp_fctr;\n   int	i, tmp_expt;\n   \n   if ( ! a )\n     error(E_NULL,""product"");\n   \n   mant = 1.0;\n   *expt = 0;\n   if ( offset == 0.0 )\n     for ( i = 0; i < a->dim; i++ )\n     {\n	mant *= frexp(a->ve[i],&tmp_expt);\n	*expt += tmp_expt;\n	if ( ! (i % 10) )\n	{\n	   mant = frexp(mant,&tmp_expt);\n	   *expt += tmp_expt;\n	}\n     }\n   else\n     for ( i = 0; i < a->dim; i++ )\n     {\n	tmp_fctr = a->ve[i] - offset;\n	tmp_fctr += (tmp_fctr > 0.0 ) ? -MACHEPS*offset :\n	  MACHEPS*offset;\n	mant *= frexp(tmp_fctr,&tmp_expt);\n	*expt += tmp_expt;\n	if ( ! (i % 10) )\n	{\n	   mant = frexp(mant,&tmp_expt);\n	   *expt += tmp_expt;\n	}\n     }\n   \n   mant = frexp(mant,&tmp_expt);\n   *expt += tmp_expt;\n   \n   return mant;\n}\n\n/* product2 -- returns the product of a long list of numbers (except the k'th)\n   -- answer stored in mant (mantissa) and expt (exponent) */\n#ifndef ANSI_C\nstatic	double	product2(a,k,expt)\nVEC	*a;\nint	k;	/* entry of a to leave out */\nint	*expt;\n#else\nstatic	double	product2(VEC *a, int k, int *expt)\n#endif\n{\n   Real	mant, mu, tmp_fctr;\n   int	i, tmp_expt;\n   \n   if ( ! a )\n     error(E_NULL,""product2"");\n   if ( k < 0 || k >= a->dim )\n     error(E_BOUNDS,""product2"");\n   \n   mant = 1.0;\n   *expt = 0;\n   mu = a->ve[k];\n   for ( i = 0; i < a->dim; i++ )\n   {\n      if ( i == k )\n	continue;\n      tmp_fctr = a->ve[i] - mu;\n      tmp_fctr += ( tmp_fctr > 0.0 ) ? -MACHEPS*mu : MACHEPS*mu;\n      mant *= frexp(tmp_fctr,&tmp_expt);\n      *expt += tmp_expt;\n      if ( ! (i % 10) )\n      {\n	 mant = frexp(mant,&tmp_expt);\n	 *expt += tmp_expt;\n      }\n   }\n   mant = frexp(mant,&tmp_expt);\n   *expt += tmp_expt;\n   \n   return mant;\n}\n\n/* dbl_cmp -- comparison function to pass to qsort() */\n#ifndef ANSI_C\nstatic	int	dbl_cmp(x,y)\nReal	*x, *y;\n#else\nstatic	int	dbl_cmp(Real *x, Real *y)\n#endif\n{\n   Real	tmp;\n   \n   tmp = *x - *y;\n   return (tmp > 0 ? 1 : tmp < 0 ? -1: 0);\n}\n\n/* iter_lanczos2 -- lanczos + error estimate for every e-val\n   -- uses Cullum & Willoughby approach, Sparse Matrix Proc. 1978\n   -- returns multiple e-vals where multiple e-vals may not exist\n   -- returns evals vector */\n#ifndef ANSI_C\nVEC	*iter_lanczos2(ip,evals,err_est)\nITER 	*ip;            /* ITER structure */\nVEC	*evals;		/* eigenvalue vector */\nVEC	*err_est;	/* error estimates of eigenvalues */\n#else\nVEC	*iter_lanczos2(ITER *ip, VEC *evals, VEC *err_est)\n#endif\n{\n   VEC		*a;\n   STATIC	VEC	*b=VNULL, *a2=VNULL, *b2=VNULL;\n   Real	beta, pb_mant, det_mant, det_mant1, det_mant2;\n   int	i, pb_expt, det_expt, det_expt1, det_expt2;\n   \n   if ( ! ip )\n     error(E_NULL,""iter_lanczos2"");\n   if ( ! ip->Ax || ! ip->x )\n     error(E_NULL,""iter_lanczos2"");\n   if ( ip->k <= 0 )\n     error(E_RANGE,""iter_lanczos2"");\n   \n   a = evals;\n   a = v_resize(a,(unsigned int)ip->k);\n   b = v_resize(b,(unsigned int)(ip->k-1));\n   MEM_STAT_REG(b,TYPE_VEC);\n   \n   iter_lanczos(ip,a,b,&beta,MNULL);\n   \n   /* printf(""# beta =%g\n"",beta); */\n   pb_mant = 0.0;\n   if ( err_est )\n   {\n      pb_mant = product(b,(double)0.0,&pb_expt);\n      /* printf(""# pb_mant = %g, pb_expt = %d\n"",pb_mant, pb_expt); */\n   }\n   \n   /* printf(""# diags =\n"");	v_output(a); */\n   /* printf(""# off diags =\n"");	v_output(b); */\n   a2 = v_resize(a2,a->dim - 1);\n   b2 = v_resize(b2,b->dim - 1);\n   MEM_STAT_REG(a2,TYPE_VEC);\n   MEM_STAT_REG(b2,TYPE_VEC);\n   for ( i = 0; i < a2->dim - 1; i++ )\n   {\n      a2->ve[i] = a->ve[i+1];\n      b2->ve[i] = b->ve[i+1];\n   }\n   a2->ve[a2->dim-1] = a->ve[a2->dim];\n   \n   trieig(a,b,MNULL);\n   \n   /* sort evals as a courtesy */\n   qsort((void *)(a->ve),(int)(a->dim),sizeof(Real),(int (*)())dbl_cmp);\n   \n   /* error estimates */\n   if ( err_est )\n   {\n      err_est = v_resize(err_est,(unsigned int)ip->k);\n      \n      trieig(a2,b2,MNULL);\n      /* printf(""# a =\n"");	v_output(a); */\n      /* printf(""# a2 =\n"");	v_output(a2); */\n      \n      for ( i = 0; i < a->dim; i++ )\n      {\n	 det_mant1 = product2(a,i,&det_expt1);\n	 det_mant2 = product(a2,(double)a->ve[i],&det_expt2);\n	 /* printf(""# det_mant1=%g, det_expt1=%d\n"",\n	    det_mant1,det_expt1); */\n	 /* printf(""# det_mant2=%g, det_expt2=%d\n"",\n	    det_mant2,det_expt2); */\n	 if ( det_mant1 == 0.0 )\n	 {   /* multiple e-val of T */\n	    err_est->ve[i] = 0.0;\n	    continue;\n	 }\n	 else if ( det_mant2 == 0.0 )\n	 {\n	    err_est->ve[i] = HUGE_VAL;\n	    continue;\n	 }\n	 if ( (det_expt1 + det_expt2) % 2 )\n	   /* if odd... */\n	   det_mant = sqrt(2.0*fabs(det_mant1*det_mant2));\n	 else /* if even... */\n	   det_mant = sqrt(fabs(det_mant1*det_mant2));\n	 det_expt = (det_expt1+det_expt2)/2;\n	 err_est->ve[i] = fabs(beta*\n			       ldexp(pb_mant/det_mant,pb_expt-det_expt));\n      }\n   }\n\n#ifdef	THREADSAFE\n   V_FREE(b);   V_FREE(a2);   V_FREE(b2);\n#endif\n\n   return a;\n}\n\n/* iter_splanczos2 -- version of iter_lanczos2() that uses sparse matrix data\n   structure */\n#ifndef ANSI_C\nVEC    *iter_splanczos2(A,m,x0,evals,err_est)\nSPMAT	*A;\nint	 m;\nVEC	*x0;		/* initial vector */\nVEC	*evals;		/* eigenvalue vector */\nVEC	*err_est;	/* error estimates of eigenvalues */\n#else\nVEC    *iter_splanczos2(SPMAT *A, int m, VEC *x0, VEC *evals, VEC *err_est)\n#endif\n{	\n   ITER *ip;\n   VEC *a;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   ip->x = x0;\n   ip->k = m;\n   a = iter_lanczos2(ip,evals,err_est);	\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return a;\n}\n\n\n\n\n/*\n  Conjugate gradient method\n  Another variant - mainly for testing\n  */\n#ifndef ANSI_C\nVEC  *iter_cg1(ip)\nITER *ip;\n#else\nVEC  *iter_cg1(ITER *ip)\n#endif\n{\n   STATIC VEC *r = VNULL, *p = VNULL, *q = VNULL, *z = VNULL;\n   Real	alpha;\n   double inner,nres;\n   VEC *rr;   /* rr == r or rr == z */\n   \n   if (ip == INULL)\n     error(E_NULL,""iter_cg"");\n   if (!ip->Ax || !ip->b)\n     error(E_NULL,""iter_cg"");\n   if ( ip->x == ip->b )\n     error(E_INSITU,""iter_cg"");\n   if (!ip->stop_crit)\n     error(E_NULL,""iter_cg"");\n   \n   if ( ip->eps <= 0.0 )\n     ip->eps = MACHEPS;\n   \n   r = v_resize(r,ip->b->dim);\n   p = v_resize(p,ip->b->dim);\n   q = v_resize(q,ip->b->dim);\n   \n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(p,TYPE_VEC);\n   MEM_STAT_REG(q,TYPE_VEC);\n   \n   if (ip->Bx != (Fun_Ax)NULL) {\n      z = v_resize(z,ip->b->dim);\n      MEM_STAT_REG(z,TYPE_VEC);\n      rr = z;\n   }\n   else rr = r;\n   \n   if (ip->x != VNULL) {\n      if (ip->x->dim != ip->b->dim)\n	error(E_SIZES,""iter_cg"");\n      ip->Ax(ip->A_par,ip->x,p);    		/* p = A*x */\n      v_sub(ip->b,p,r);		 		/* r = b - A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n      v_copy(ip->b,r);\n   }\n   \n   if (ip->Bx) (ip->Bx)(ip->B_par,r,p);\n   else v_copy(r,p);\n   \n   inner = in_prod(p,r);\n   nres = sqrt(fabs(inner));\n   if (ip->info) ip->info(ip,nres,r,p);\n   if ( nres == 0.0) return ip->x;\n   \n   for ( ip->steps = 0; ip->steps <= ip->limit; ip->steps++ )\n   {\n      ip->Ax(ip->A_par,p,q);\n      inner = in_prod(q,p);\n      if (sqrt(fabs(inner)) <= MACHEPS*ip->init_res)\n	error(E_BREAKDOWN,""iter_cg1"");\n\n      alpha = in_prod(p,r)/inner;\n      v_mltadd(ip->x,p,alpha,ip->x);\n      v_mltadd(r,q,-alpha,r);\n      \n      rr = r;\n      if (ip->Bx) {\n	 ip->Bx(ip->B_par,r,z);\n	 rr = z;\n      }\n      \n      nres = in_prod(r,rr);\n      if (nres < 0.0) {\n	 warning(WARN_RES_LESS_0,""iter_cg"");\n	 break;\n      }\n      nres = sqrt(fabs(nres));\n      if (ip->info) ip->info(ip,nres,r,z);\n      if (ip->steps == 0) ip->init_res = nres;\n      if ( ip->stop_crit(ip,nres,r,z) ) break;\n      \n      alpha = -in_prod(rr,q)/inner;\n      v_mltadd(rr,p,alpha,p);\n      \n   }\n\n#ifdef	THREADSAFE\n   V_FREE(r);   V_FREE(p);   V_FREE(q);   V_FREE(z);\n#endif\n\n   return ip->x;\n}\n\n\n"
leukocyte/meschach_lib/qrfactor.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  This file contains the routines needed to perform QR factorisation\n  of matrices, as well as Householder transformations.\n  The internal ""factored form"" of a matrix A is not quite standard.\n  The diagonal of A is replaced by the diagonal of R -- not by the 1st non-zero\n  entries of the Householder vectors. The 1st non-zero entries are held in\n  the diag parameter of QRfactor(). The reason for this non-standard\n  representation is that it enables direct use of the Usolve() function\n  rather than requiring that  a seperate function be written just for this case.\n  See, e.g., QRsolve() below for more details.\n  \n*/\n\n\nstatic	char	rcsid[] = ""$Id: qrfactor.c,v 1.5 1994/01/13 05:35:07 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""matrix2.h""\n\n\n\n\n\n#define		sign(x)	((x) > 0.0 ? 1 : ((x) < 0.0 ? -1 : 0 ))\n\nextern	VEC	*Usolve();	/* See matrix2.h */\n\n/* Note: The usual representation of a Householder transformation is taken\n   to be:\n   P = I - beta.u.uT\n   where beta = 2/(uT.u) and u is called the Householder vector\n   */\n\n/* QRfactor -- forms the QR factorisation of A -- factorisation stored in\n   compact form as described above ( not quite standard format ) */\n#ifndef ANSI_C\nMAT	*QRfactor(A,diag)\nMAT	*A;\nVEC	*diag;\n#else\nMAT	*QRfactor(MAT *A, VEC *diag)\n#endif\n{\n    unsigned int	k,limit;\n    Real	beta;\n    STATIC	VEC	*hh=VNULL, *w=VNULL;\n    \n    if ( ! A || ! diag )\n	error(E_NULL,""QRfactor"");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit )\n	error(E_SIZES,""QRfactor"");\n    \n    hh = v_resize(hh,A->m);\n    w  = v_resize(w, A->n);\n    MEM_STAT_REG(hh,TYPE_VEC);\n    MEM_STAT_REG(w, TYPE_VEC);\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* get H/holder vector for the k-th column */\n	get_col(A,k,hh);\n	/* hhvec(hh,k,&beta->ve[k],hh,&A->me[k][k]); */\n	hhvec(hh,k,&beta,hh,&A->me[k][k]);\n	diag->ve[k] = hh->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	/* hhtrcols(A,k,k+1,hh,beta->ve[k]); */\n	_hhtrcols(A,k,k+1,hh,beta,w);\n    }\n\n#ifdef	THREADSAFE\n    V_FREE(hh);	V_FREE(w);\n#endif\n\n    return (A);\n}\n\n/* QRCPfactor -- forms the QR factorisation of A with column pivoting\n   -- factorisation stored in compact form as described above\n   ( not quite standard format )				*/\n#ifndef ANSI_C\nMAT	*QRCPfactor(A,diag,px)\nMAT	*A;\nVEC	*diag;\nPERM	*px;\n#else\nMAT	*QRCPfactor(MAT *A, VEC *diag, PERM *px)\n#endif\n{\n    unsigned int	i, i_max, j, k, limit;\n    STATIC	VEC	*gamma=VNULL, *tmp1=VNULL, *tmp2=VNULL, *w=VNULL;\n    Real	beta, maxgamma, sum, tmp;\n    \n    if ( ! A || ! diag || ! px )\n	error(E_NULL,""QRCPfactor"");\n    limit = min(A->m,A->n);\n    if ( diag->dim < limit || px->size != A->n )\n	error(E_SIZES,""QRCPfactor"");\n    \n    tmp1 = v_resize(tmp1,A->m);\n    tmp2 = v_resize(tmp2,A->m);\n    gamma = v_resize(gamma,A->n);\n    w    = v_resize(w,   A->n);\n    MEM_STAT_REG(tmp1,TYPE_VEC);\n    MEM_STAT_REG(tmp2,TYPE_VEC);\n    MEM_STAT_REG(gamma,TYPE_VEC);\n    MEM_STAT_REG(w,   TYPE_VEC);\n    \n    /* initialise gamma and px */\n    for ( j=0; j<A->n; j++ )\n    {\n	px->pe[j] = j;\n	sum = 0.0;\n	for ( i=0; i<A->m; i++ )\n	    sum += square(A->me[i][j]);\n	gamma->ve[j] = sum;\n    }\n    \n    for ( k=0; k<limit; k++ )\n    {\n	/* find ""best"" column to use */\n	i_max = k;	maxgamma = gamma->ve[k];\n	for ( i=k+1; i<A->n; i++ )\n	    /* Loop invariant:maxgamma=gamma[i_max]\n	       >=gamma[l];l=k,...,i-1 */\n	    if ( gamma->ve[i] > maxgamma )\n	    {	maxgamma = gamma->ve[i]; i_max = i;	}\n	\n	/* swap columns if necessary */\n	if ( i_max != k )\n	{\n	    /* swap gamma values */\n	    tmp = gamma->ve[k];\n	    gamma->ve[k] = gamma->ve[i_max];\n	    gamma->ve[i_max] = tmp;\n	    \n	    /* update column permutation */\n	    px_transp(px,k,i_max);\n	    \n	    /* swap columns of A */\n	    for ( i=0; i<A->m; i++ )\n	    {\n		tmp = A->me[i][k];\n		A->me[i][k] = A->me[i][i_max];\n		A->me[i][i_max] = tmp;\n	    }\n	}\n	\n	/* get H/holder vector for the k-th column */\n	get_col(A,k,tmp1);\n	/* hhvec(tmp1,k,&beta->ve[k],tmp1,&A->me[k][k]); */\n	hhvec(tmp1,k,&beta,tmp1,&A->me[k][k]);\n	diag->ve[k] = tmp1->ve[k];\n	\n	/* apply H/holder vector to remaining columns */\n	/* hhtrcols(A,k,k+1,tmp1,beta->ve[k]); */\n	_hhtrcols(A,k,k+1,tmp1,beta,w);\n	\n	/* update gamma values */\n	for ( j=k+1; j<A->n; j++ )\n	    gamma->ve[j] -= square(A->me[k][j]);\n    }\n\n#ifdef	THREADSAFE\n    V_FREE(gamma);	V_FREE(tmp1);	V_FREE(tmp2);	V_FREE(w);\n#endif\n\n    return (A);\n}\n\n/* Qsolve -- solves Qx = b, Q is an orthogonal matrix stored in compact\n   form a la QRfactor() -- may be in-situ */\n#ifndef ANSI_C\nVEC	*_Qsolve(QR,diag,b,x,tmp)\nMAT	*QR;\nVEC	*diag, *b, *x, *tmp;\n#else\nVEC	*_Qsolve(const MAT *QR, const VEC *diag, const VEC *b, \n		 VEC *x, VEC *tmp)\n#endif\n{\n    unsigned int	dynamic;\n    int		k, limit;\n    Real	beta, r_ii, tmp_val;\n    \n    limit = min(QR->m,QR->n);\n    dynamic = FALSE;\n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,""_Qsolve"");\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,""_Qsolve"");\n    x = v_resize(x,QR->m);\n    if ( tmp == VNULL )\n	dynamic = TRUE;\n    tmp = v_resize(tmp,QR->m);\n    \n    /* apply H/holder transforms in normal order */\n    x = v_copy(b,x);\n    for ( k = 0 ; k < limit ; k++ )\n    {\n	get_col(QR,k,tmp);\n	r_ii = fabs(tmp->ve[k]);\n	tmp->ve[k] = diag->ve[k];\n	tmp_val = (r_ii*fabs(diag->ve[k]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	/* hhtrvec(tmp,beta->ve[k],k,x,x); */\n	hhtrvec(tmp,beta,k,x,x);\n    }\n    \n    if ( dynamic )\n	V_FREE(tmp);\n    \n    return (x);\n}\n\n/* makeQ -- constructs orthogonal matrix from Householder vectors stored in\n   compact QR form */\n#ifndef ANSI_C\nMAT	*makeQ(QR,diag,Qout)\nMAT	*QR,*Qout;\nVEC	*diag;\n#else\nMAT	*makeQ(const MAT *QR,const VEC *diag, MAT *Qout)\n#endif\n{\n    STATIC	VEC	*tmp1=VNULL,*tmp2=VNULL;\n    unsigned int	i, limit;\n    Real	beta, r_ii, tmp_val;\n    int	j;\n    \n    limit = min(QR->m,QR->n);\n    if ( ! QR || ! diag )\n	error(E_NULL,""makeQ"");\n    if ( diag->dim < limit )\n	error(E_SIZES,""makeQ"");\n    if ( Qout==(MAT *)NULL || Qout->m < QR->m || Qout->n < QR->m )\n	Qout = m_get(QR->m,QR->m);\n    \n    tmp1 = v_resize(tmp1,QR->m);	/* contains basis vec & columns of Q */\n    tmp2 = v_resize(tmp2,QR->m);	/* contains H/holder vectors */\n    MEM_STAT_REG(tmp1,TYPE_VEC);\n    MEM_STAT_REG(tmp2,TYPE_VEC);\n    \n    for ( i=0; i<QR->m ; i++ )\n    {	/* get i-th column of Q */\n	/* set up tmp1 as i-th basis vector */\n	for ( j=0; j<QR->m ; j++ )\n	    tmp1->ve[j] = 0.0;\n	tmp1->ve[i] = 1.0;\n	\n	/* apply H/h transforms in reverse order */\n	for ( j=limit-1; j>=0; j-- )\n	{\n	    get_col(QR,j,tmp2);\n	    r_ii = fabs(tmp2->ve[j]);\n	    tmp2->ve[j] = diag->ve[j];\n	    tmp_val = (r_ii*fabs(diag->ve[j]));\n	    beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	    /* hhtrvec(tmp2,beta->ve[j],j,tmp1,tmp1); */\n	    hhtrvec(tmp2,beta,j,tmp1,tmp1);\n	}\n	\n	/* insert into Q */\n	set_col(Qout,i,tmp1);\n    }\n\n#ifdef	THREADSAFE\n    V_FREE(tmp1);	V_FREE(tmp2);\n#endif\n\n    return (Qout);\n}\n\n/* makeR -- constructs upper triangular matrix from QR (compact form)\n   -- may be in-situ (all it does is zero the lower 1/2) */\n#ifndef ANSI_C\nMAT	*makeR(QR,Rout)\nMAT	*QR,*Rout;\n#else\nMAT	*makeR(const MAT *QR, MAT *Rout)\n#endif\n{\n    unsigned int	i,j;\n    \n    if ( QR==MNULL )\n	error(E_NULL,""makeR"");\n    Rout = m_copy(QR,Rout);\n    \n    for ( i=1; i<QR->m; i++ )\n	for ( j=0; j<QR->n && j<i; j++ )\n	    Rout->me[i][j] = 0.0;\n    \n    return (Rout);\n}\n\n/* QRsolve -- solves the system Q.R.x=b where Q & R are stored in compact form\n   -- returns x, which is created if necessary */\n#ifndef ANSI_C\nVEC	*QRsolve(QR,diag,b,x)\nMAT	*QR;\nVEC	*diag /* , *beta */ , *b, *x;\n#else\nVEC	*QRsolve(const MAT *QR, const VEC *diag, const VEC *b, VEC *x)\n#endif\n{\n    int	limit;\n    STATIC	VEC	*tmp = VNULL;\n    \n    if ( ! QR || ! diag || ! b )\n	error(E_NULL,""QRsolve"");\n    limit = min(QR->m,QR->n);\n    if ( diag->dim < limit || b->dim != QR->m )\n	error(E_SIZES,""QRsolve"");\n    tmp = v_resize(tmp,limit);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n\n    x = v_resize(x,QR->n);\n    _Qsolve(QR,diag,b,x,tmp);\n    x = Usolve(QR,x,x,0.0);\n    v_resize(x,QR->n);\n\n#ifdef	THREADSAFE\n    V_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* QRCPsolve -- solves A.x = b where A is factored by QRCPfactor()\n   -- assumes that A is in the compact factored form */\n#ifndef ANSI_C\nVEC	*QRCPsolve(QR,diag,pivot,b,x)\nMAT	*QR;\nVEC	*diag;\nPERM	*pivot;\nVEC	*b, *x;\n#else\nVEC	*QRCPsolve(const MAT *QR, const VEC *diag, PERM *pivot,\n		   const VEC *b, VEC *x)\n#endif\n{\n    STATIC	VEC	*tmp=VNULL;\n    \n    if ( ! QR || ! diag || ! pivot || ! b )\n	error(E_NULL,""QRCPsolve"");\n    if ( (QR->m > diag->dim &&QR->n > diag->dim) || QR->n != pivot->size )\n	error(E_SIZES,""QRCPsolve"");\n    \n    tmp = QRsolve(QR,diag,b,tmp);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n    x = pxinv_vec(pivot,tmp,x);\n\n#ifdef	THREADSAFE\n    V_FREE(tmp);\n#endif\n\n    return x;\n}\n\n/* Umlt -- compute out = upper_triang(U).x\n	-- may be in situ */\n#ifndef ANSI_C\nstatic	VEC	*Umlt(U,x,out)\nMAT	*U;\nVEC	*x, *out;\n#else\nstatic	VEC	*Umlt(const MAT *U, const VEC *x, VEC *out)\n#endif\n{\n    int		i, limit;\n\n    if ( U == MNULL || x == VNULL )\n	error(E_NULL,""Umlt"");\n    limit = min(U->m,U->n);\n    if ( limit != x->dim )\n	error(E_SIZES,""Umlt"");\n    if ( out == VNULL || out->dim < limit )\n	out = v_resize(out,limit);\n\n    for ( i = 0; i < limit; i++ )\n	out->ve[i] = __ip__(&(x->ve[i]),&(U->me[i][i]),limit - i);\n    return out;\n}\n\n/* UTmlt -- returns out = upper_triang(U)^T.x */\n#ifndef ANSI_C\nstatic	VEC	*UTmlt(U,x,out)\nMAT	*U;\nVEC	*x, *out;\n#else\nstatic	VEC	*UTmlt(const MAT *U, const VEC *x, VEC *out)\n#endif\n{\n    Real	sum;\n    int		i, j, limit;\n\n    if ( U == MNULL || x == VNULL )\n	error(E_NULL,""UTmlt"");\n    limit = min(U->m,U->n);\n    if ( out == VNULL || out->dim < limit )\n	out = v_resize(out,limit);\n\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	sum = 0.0;\n	for ( j = 0; j <= i; j++ )\n	    sum += U->me[j][i]*x->ve[j];\n	out->ve[i] = sum;\n    }\n    return out;\n}\n\n/* QRTsolve -- solve A^T.sc = c where the QR factors of A are stored in\n	compact form\n	-- returns sc\n	-- original due to Mike Osborne modified Wed 09th Dec 1992 */\n#ifndef ANSI_C\nVEC *QRTsolve(A,diag,c,sc)\nMAT *A;\nVEC *diag, *c, *sc;\n#else\nVEC *QRTsolve(const MAT *A, const VEC *diag, const VEC *c, VEC *sc)\n#endif\n{\n    int		i, j, k, n, p;\n    Real	beta, r_ii, s, tmp_val;\n\n    if ( ! A || ! diag || ! c )\n	error(E_NULL,""QRTsolve"");\n    if ( diag->dim < min(A->m,A->n) )\n	error(E_SIZES,""QRTsolve"");\n    sc = v_resize(sc,A->m);\n    n = sc->dim;\n    p = c->dim;\n    if ( n == p )\n	k = p-2;\n    else\n	k = p-1;\n    v_zero(sc);\n    sc->ve[0] = c->ve[0]/A->me[0][0];\n    if ( n ==  1)\n	return sc;\n    if ( p > 1)\n    {\n	for ( i = 1; i < p; i++ )\n	{\n	    s = 0.0;\n	    for ( j = 0; j < i; j++ )\n		s += A->me[j][i]*sc->ve[j];\n	    if ( A->me[i][i] == 0.0 )\n		error(E_SING,""QRTsolve"");\n	    sc->ve[i]=(c->ve[i]-s)/A->me[i][i];\n	}\n    }\n    for (i = k; i >= 0; i--)\n    {\n	s = diag->ve[i]*sc->ve[i];\n	for ( j = i+1; j < n; j++ )\n	    s += A->me[j][i]*sc->ve[j];\n	r_ii = fabs(A->me[i][i]);\n	tmp_val = (r_ii*fabs(diag->ve[i]));\n	beta = ( tmp_val == 0.0 ) ? 0.0 : 1.0/tmp_val;\n	tmp_val = beta*s;\n	sc->ve[i] -= tmp_val*diag->ve[i];\n	for ( j = i+1; j < n; j++ )\n	    sc->ve[j] -= tmp_val*A->me[j][i];\n    }\n\n    return sc;\n}\n\n/* QRcondest -- returns an estimate of the 2-norm condition number of the\n		matrix factorised by QRfactor() or QRCPfactor()\n	-- note that as Q does not affect the 2-norm condition number,\n		it is not necessary to pass the diag, beta (or pivot) vectors\n	-- generates a lower bound on the true condition number\n	-- if the matrix is exactly singular, HUGE_VAL is returned\n	-- note that QRcondest() is likely to be more reliable for\n		matrices factored using QRCPfactor() */\n#ifndef ANSI_C\ndouble	QRcondest(QR)\nMAT	*QR;\n#else\ndouble	QRcondest(const MAT *QR)\n#endif\n{\n    STATIC	VEC	*y=VNULL;\n    Real	norm1, norm2, sum, tmp1, tmp2;\n    int		i, j, limit;\n\n    if ( QR == MNULL )\n	error(E_NULL,""QRcondest"");\n\n    limit = min(QR->m,QR->n);\n    for ( i = 0; i < limit; i++ )\n	if ( QR->me[i][i] == 0.0 )\n	    return HUGE_VAL;\n\n    y = v_resize(y,limit);\n    MEM_STAT_REG(y,TYPE_VEC);\n    /* use the trick for getting a unit vector y with ||R.y||_inf small\n       from the LU condition estimator */\n    for ( i = 0; i < limit; i++ )\n    {\n	sum = 0.0;\n	for ( j = 0; j < i; j++ )\n	    sum -= QR->me[j][i]*y->ve[j];\n	sum -= (sum < 0.0) ? 1.0 : -1.0;\n	y->ve[i] = sum / QR->me[i][i];\n    }\n    UTmlt(QR,y,y);\n\n    /* now apply inverse power method to R^T.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = v_norm2(y);\n	sv_mlt(1/tmp1,y,y);\n	UTsolve(QR,y,y,0.0);\n	tmp2 = v_norm2(y);\n	sv_mlt(1/v_norm2(y),y,y);\n	Usolve(QR,y,y,0.0);\n    }\n    /* now compute approximation for ||R^{-1}||_2 */\n    norm1 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* now use complementary approach to compute approximation to ||R||_2 */\n    for ( i = limit-1; i >= 0; i-- )\n    {\n	sum = 0.0;\n	for ( j = i+1; j < limit; j++ )\n	    sum += QR->me[i][j]*y->ve[j];\n	y->ve[i] = (sum >= 0.0) ? 1.0 : -1.0;\n	y->ve[i] = (QR->me[i][i] >= 0.0) ? y->ve[i] : - y->ve[i];\n    }\n\n    /* now apply power method to R^T.R */\n    for ( i = 0; i < 3; i++ )\n    {\n	tmp1 = v_norm2(y);\n	sv_mlt(1/tmp1,y,y);\n	Umlt(QR,y,y);\n	tmp2 = v_norm2(y);\n	sv_mlt(1/tmp2,y,y);\n	UTmlt(QR,y,y);\n    }\n    norm2 = sqrt(tmp1)*sqrt(tmp2);\n\n    /* printf(""QRcondest: norm1 = %g, norm2 = %g\n"",norm1,norm2); */\n\n#ifdef THREADSAFE\n    V_FREE(y);\n#endif\n\n    return norm1*norm2;\n}\n"
leukocyte/meschach_lib/init.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This is a file of routines for zero-ing, and initialising\n	vectors, matrices and permutations.\n	This is to be included in the matrix.a library\n*/\n\nstatic	char	rcsid[] = ""$Id: init.c,v 1.6 1994/01/13 05:36:58 des Exp $"";\n\n#include	<stdio.h>\n#include	""matrix.h""\n\n/* v_zero -- zero the vector x */\n#ifndef ANSI_C\nVEC	*v_zero(x)\nVEC	*x;\n#else\nVEC	*v_zero(VEC *x)\n#endif\n{\n	if ( x == VNULL )\n		error(E_NULL,""v_zero"");\n\n	__zero__(x->ve,x->dim);\n	/* for ( i = 0; i < x->dim; i++ )\n		x->ve[i] = 0.0; */\n\n	return x;\n}\n\n\n/* iv_zero -- zero the vector ix */\n#ifndef ANSI_C\nIVEC	*iv_zero(ix)\nIVEC	*ix;\n#else\nIVEC	*iv_zero(IVEC *ix)\n#endif\n{\n   int i;\n   \n   if ( ix == IVNULL )\n     error(E_NULL,""iv_zero"");\n   \n   for ( i = 0; i < ix->dim; i++ )\n     ix->ive[i] = 0; \n   \n   return ix;\n}\n\n\n/* m_zero -- zero the matrix A */\n#ifndef ANSI_C\nMAT	*m_zero(A)\nMAT	*A;\n#else\nMAT	*m_zero(MAT *A)\n#endif\n{\n	int	i, A_m, A_n;\n	Real	**A_me;\n\n	if ( A == MNULL )\n		error(E_NULL,""m_zero"");\n\n	A_m = A->m;	A_n = A->n;	A_me = A->me;\n	for ( i = 0; i < A_m; i++ )\n		__zero__(A_me[i],A_n);\n		/* for ( j = 0; j < A_n; j++ )\n			A_me[i][j] = 0.0; */\n\n	return A;\n}\n\n/* mat_id -- set A to being closest to identity matrix as possible\n	-- i.e. A[i][j] == 1 if i == j and 0 otherwise */\n#ifndef ANSI_C\nMAT	*m_ident(A)\nMAT	*A;\n#else\nMAT	*m_ident(MAT *A)\n#endif\n{\n	int	i, size;\n\n	if ( A == MNULL )\n		error(E_NULL,""m_ident"");\n\n	m_zero(A);\n	size = min(A->m,A->n);\n	for ( i = 0; i < size; i++ )\n		A->me[i][i] = 1.0;\n\n	return A;\n}\n	\n/* px_ident -- set px to identity permutation */\n#ifndef ANSI_C\nPERM	*px_ident(px)\nPERM	*px;\n#else\nPERM	*px_ident(PERM *px)\n#endif\n{\n	int	i, px_size;\n	unsigned int	*px_pe;\n\n	if ( px == PNULL )\n		error(E_NULL,""px_ident"");\n\n	px_size = px->size;	px_pe = px->pe;\n	for ( i = 0; i < px_size; i++ )\n		px_pe[i] = i;\n\n	return px;\n}\n\n/* Pseudo random number generator data structures */\n/* Knuth's lagged Fibonacci-based generator: See ""Seminumerical Algorithms:\n   The Art of Computer Programming"" sections 3.2-3.3 */\n\n#ifdef ANSI_C\n#ifndef LONG_MAX\n#include	<limits.h>\n#endif\n#endif\n\n#ifdef LONG_MAX\n#define MODULUS	LONG_MAX\n#else\n#define MODULUS	1000000000L	/* assuming long's at least 32 bits long */\n#endif\n#define MZ	0L\n\nstatic long mrand_list[56];\nstatic int  started = FALSE;\nstatic int  inext = 0, inextp = 31;\n\n\n/* mrand -- pseudo-random number generator */\n#ifdef ANSI_C\ndouble mrand(void)\n#else\ndouble mrand()\n#endif\n{\n    long	lval;\n    static Real  factor = 1.0/((Real)MODULUS);\n    \n    if ( ! started )\n	smrand(3127);\n    \n    inext = (inext >= 54) ? 0 : inext+1;\n    inextp = (inextp >= 54) ? 0 : inextp+1;\n\n    lval = mrand_list[inext]-mrand_list[inextp];\n    if ( lval < 0L )\n	lval += MODULUS;\n    mrand_list[inext] = lval;\n    \n    return (double)lval*factor;\n}\n\n/* mrandlist -- fills the array a[] with len random numbers */\n#ifndef ANSI_C\nvoid	mrandlist(a, len)\nReal	a[];\nint	len;\n#else\nvoid	mrandlist(Real a[], int len)\n#endif\n{\n    int		i;\n    long	lval;\n    static Real  factor = 1.0/((Real)MODULUS);\n    \n    if ( ! started )\n	smrand(3127);\n    \n    for ( i = 0; i < len; i++ )\n    {\n	inext = (inext >= 54) ? 0 : inext+1;\n	inextp = (inextp >= 54) ? 0 : inextp+1;\n	\n	lval = mrand_list[inext]-mrand_list[inextp];\n	if ( lval < 0L )\n	    lval += MODULUS;\n	mrand_list[inext] = lval;\n	\n	a[i] = (Real)lval*factor;\n    }\n}\n\n\n/* smrand -- set seed for mrand() */\n#ifndef ANSI_C\nvoid smrand(seed)\nint	seed;\n#else\nvoid smrand(int seed)\n#endif\n{\n    int		i;\n\n    mrand_list[0] = (123413*seed) % MODULUS;\n    for ( i = 1; i < 55; i++ )\n	mrand_list[i] = (123413*mrand_list[i-1]) % MODULUS;\n\n    started = TRUE;\n\n    /* run mrand() through the list sufficient times to\n       thoroughly randomise the array */\n    for ( i = 0; i < 55*55; i++ )\n	mrand();\n}\n#undef MODULUS\n#undef MZ\n#undef FAC\n\n/* v_rand -- initialises x to be a random vector, components\n	independently & uniformly ditributed between 0 and 1 */\n#ifndef ANSI_C\nVEC	*v_rand(x)\nVEC	*x;\n#else\nVEC	*v_rand(VEC *x)\n#endif\n{\n	/* int	i; */\n\n	if ( ! x )\n		error(E_NULL,""v_rand"");\n\n	/* for ( i = 0; i < x->dim; i++ ) */\n	    /* x->ve[i] = rand()/((Real)MAX_RAND); */\n	    /* x->ve[i] = mrand(); */\n	mrandlist(x->ve,x->dim);\n\n	return x;\n}\n\n/* m_rand -- initialises A to be a random vector, components\n	independently & uniformly distributed between 0 and 1 */\n#ifndef ANSI_C\nMAT	*m_rand(A)\nMAT	*A;\n#else\nMAT	*m_rand(MAT *A)\n#endif\n{\n	int	i /* , j */;\n\n	if ( ! A )\n		error(E_NULL,""m_rand"");\n\n	for ( i = 0; i < A->m; i++ )\n		/* for ( j = 0; j < A->n; j++ ) */\n		    /* A->me[i][j] = rand()/((Real)MAX_RAND); */\n		    /* A->me[i][j] = mrand(); */\n	    mrandlist(A->me[i],A->n);\n\n	return A;\n}\n\n/* v_ones -- fills x with one's */\n#ifndef ANSI_C\nVEC	*v_ones(x)\nVEC	*x;\n#else\nVEC	*v_ones(VEC *x)\n#endif\n{\n	int	i;\n\n	if ( ! x )\n		error(E_NULL,""v_ones"");\n\n	for ( i = 0; i < x->dim; i++ )\n		x->ve[i] = 1.0;\n\n	return x;\n}\n\n/* m_ones -- fills matrix with one's */\n#ifndef ANSI_C\nMAT	*m_ones(A)\nMAT	*A;\n#else\nMAT	*m_ones(MAT *A)\n#endif\n{\n	int	i, j;\n\n	if ( ! A )\n		error(E_NULL,""m_ones"");\n\n	for ( i = 0; i < A->m; i++ )\n		for ( j = 0; j < A->n; j++ )\n		    A->me[i][j] = 1.0;\n\n	return A;\n}\n\n/* v_count -- initialises x so that x->ve[i] == i */\n#ifndef ANSI_C\nVEC	*v_count(x)\nVEC	*x;\n#else\nVEC	*v_count(VEC *x)\n#endif\n{\n	int	i;\n\n	if ( ! x )\n	    error(E_NULL,""v_count"");\n\n	for ( i = 0; i < x->dim; i++ )\n	    x->ve[i] = (Real)i;\n\n	return x;\n}\n"
leukocyte/meschach_lib/zhsehldr.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n		Files for matrix computations\n\n	Householder transformation file. Contains routines for calculating\n	householder transformations, applying them to vectors and matrices\n	by both row & column.\n\n	Complex version\n*/\n\nstatic	char	rcsid[] = ""$Id: zhsehldr.c,v 1.2 1994/04/07 01:43:47 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""zmatrix.h""\n#include        ""zmatrix2.h""\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n/* zhhvec -- calulates Householder vector to eliminate all entries after the\n	i0 entry of the vector vec. It is returned as out. May be in-situ */\nZVEC	*zhhvec(vec,i0,beta,out,newval)\nZVEC	*vec,*out;\nint	i0;\nReal	*beta;\ncomplex	*newval;\n{\n	complex	tmp;\n	Real	norm, abs_val;\n\n	if ( i0 < 0 || i0 >= vec->dim )\n	    error(E_BOUNDS,""zhhvec"");\n	out = _zv_copy(vec,out,i0);\n	tmp = _zin_prod(out,out,i0,Z_CONJ);\n	if ( tmp.re <= 0.0 )\n	{\n		*beta = 0.0;\n		*newval = out->ve[i0];\n		return (out);\n	}\n	norm = sqrt(tmp.re);\n	abs_val = zabs(out->ve[i0]);\n	*beta = 1.0/(norm * (norm+abs_val));\n	if ( abs_val == 0.0 )\n	{\n	  newval->re = norm;\n	  newval->im = 0.0;\n	}\n	else\n	{ \n	  abs_val = -norm / abs_val;\n	  newval->re = abs_val*out->ve[i0].re;\n	  newval->im = abs_val*out->ve[i0].im;\n	}	abs_val = -norm / abs_val;\n	out->ve[i0].re -= newval->re;\n	out->ve[i0].im -= newval->im;\n\n	return (out);\n}\n\n/* zhhtrvec -- apply Householder transformation to vector -- may be in-situ */\nZVEC	*zhhtrvec(hh,beta,i0,in,out)\nZVEC	*hh,*in,*out;	/* hh = Householder vector */\nint	i0;\ndouble	beta;\n{\n	complex	scale, tmp;\n	/* unsigned int	i; */\n\n	if ( hh==ZVNULL || in==ZVNULL )\n		error(E_NULL,""zhhtrvec"");\n	if ( in->dim != hh->dim )\n		error(E_SIZES,""zhhtrvec"");\n	if ( i0 < 0 || i0 > in->dim )\n	    error(E_BOUNDS,""zhhvec"");\n\n	tmp = _zin_prod(hh,in,i0,Z_CONJ);\n	scale.re = -beta*tmp.re;\n	scale.im = -beta*tmp.im;\n	out = zv_copy(in,out);\n	__zmltadd__(&(out->ve[i0]),&(hh->ve[i0]),scale,\n		    (int)(in->dim-i0),Z_NOCONJ);\n	/************************************************************\n	for ( i=i0; i<in->dim; i++ )\n		out->ve[i] = in->ve[i] - scale*hh->ve[i];\n	************************************************************/\n\n	return (out);\n}\n\n/* zhhtrrows -- transform a matrix by a Householder vector by rows\n	starting at row i0 from column j0 \n	-- in-situ\n	-- that is, M(i0:m,j0:n) <- M(i0:m,j0:n)(I-beta.hh(j0:n).hh(j0:n)^T) */\nZMAT	*zhhtrrows(M,i0,j0,hh,beta)\nZMAT	*M;\nint	i0, j0;\nZVEC	*hh;\ndouble	beta;\n{\n	complex	ip, scale;\n	int	i /*, j */;\n\n	if ( M==ZMNULL || hh==ZVNULL )\n		error(E_NULL,""zhhtrrows"");\n	if ( M->n != hh->dim )\n		error(E_RANGE,""zhhtrrows"");\n	if ( i0 < 0 || i0 > M->m || j0 < 0 || j0 > M->n )\n		error(E_BOUNDS,""zhhtrrows"");\n\n	if ( beta == 0.0 )	return (M);\n\n	/* for each row ... */\n	for ( i = i0; i < M->m; i++ )\n	{	/* compute inner product */\n		ip = __zip__(&(M->me[i][j0]),&(hh->ve[j0]),\n			     (int)(M->n-j0),Z_NOCONJ);\n		/**************************************************\n		ip = 0.0;\n		for ( j = j0; j < M->n; j++ )\n			ip += M->me[i][j]*hh->ve[j];\n		**************************************************/\n		scale.re = -beta*ip.re;\n		scale.im = -beta*ip.im;\n		/* if ( scale == 0.0 ) */\n		if ( is_zero(scale) )\n		    continue;\n\n		/* do operation */\n		__zmltadd__(&(M->me[i][j0]),&(hh->ve[j0]),scale,\n			    (int)(M->n-j0),Z_CONJ);\n		/**************************************************\n		for ( j = j0; j < M->n; j++ )\n			M->me[i][j] -= scale*hh->ve[j];\n		**************************************************/\n	}\n\n	return (M);\n}\n\n/* zhhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- calls _zhhtrcols() with the scratch vector w\n	-- Meschach internal routines should call _zhhtrcols() to\n	avoid excessive memory allocation/de-allocation\n*/\nZMAT	*zhhtrcols(M,i0,j0,hh,beta)\nZMAT	*M;\nint	i0, j0;\nZVEC	*hh;\ndouble	beta;\n{\n	/* Real	ip, scale; */\n	complex	scale;\n	int	i /*, k */;\n	STATIC	ZVEC	*w = ZVNULL;\n\n	if ( M==ZMNULL || hh==ZVNULL )\n		error(E_NULL,""zhhtrcols"");\n	if ( M->m != hh->dim )\n		error(E_SIZES,""zhhtrcols"");\n	if ( i0 < 0 || i0 > M->m || j0 < 0 || j0 > M->n )\n		error(E_BOUNDS,""zhhtrcols"");\n\n	if ( beta == 0.0 )	return (M);\n\n	if ( ! w || w->dim < M->n )\n	  w = zv_resize(w,M->n);\n	MEM_STAT_REG(w,TYPE_ZVEC);\n\n	M = _zhhtrcols(M,i0,j0,hh,beta,w);\n\n#ifdef THREADSAFE\n	ZV_FREE(w);\n#endif\n\n	return M;\n}\n\n/* _zhhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- scratch vector w passed as argument\n	-- raises error if w == NULL */\nZMAT	*_zhhtrcols(M,i0,j0,hh,beta,w)\nZMAT	*M;\nint	i0, j0;\nZVEC	*hh;\ndouble	beta;\nZVEC	*w;\n{\n	/* Real	ip, scale; */\n	complex	scale;\n	int	i /*, k */;\n\n	if ( M==ZMNULL || hh==ZVNULL )\n		error(E_NULL,""zhhtrcols"");\n	if ( M->m != hh->dim )\n		error(E_SIZES,""zhhtrcols"");\n	if ( i0 < 0 || i0 > M->m || j0 < 0 || j0 > M->n )\n		error(E_BOUNDS,""zhhtrcols"");\n\n	if ( beta == 0.0 )	return (M);\n\n	if ( w->dim < M->n )\n	  w = zv_resize(w,M->n);\n	zv_zero(w);\n\n	for ( i = i0; i < M->m; i++ )\n	    /* if ( hh->ve[i] != 0.0 ) */\n	    if ( ! is_zero(hh->ve[i]) )\n		__zmltadd__(&(w->ve[j0]),&(M->me[i][j0]),hh->ve[i],\n			    (int)(M->n-j0),Z_CONJ);\n	for ( i = i0; i < M->m; i++ )\n	    /* if ( hh->ve[i] != 0.0 ) */\n	    if ( ! is_zero(hh->ve[i]) )\n	    {\n		scale.re = -beta*hh->ve[i].re;\n		scale.im = -beta*hh->ve[i].im;\n		__zmltadd__(&(M->me[i][j0]),&(w->ve[j0]),scale,\n			    (int)(M->n-j0),Z_CONJ);\n	    }\n\n	return (M);\n}\n\n"
leukocyte/meschach_lib/iotort.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/* iotort.c  10/11/93 */\n/* test of I/O functions */\n\n\nstatic char rcsid[] = ""$Id: $"";\n\n#include ""sparse.h""\n#include ""zmatrix.h""\n\n\n#define	errmesg(mesg)	printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)	printf(""# Testing %s...\n"",mesg);\n\n\nvoid main()\n{\n   VEC *x;\n   MAT *A;\n   PERM *pivot;\n   IVEC *ix;\n   SPMAT *spA;\n   ZVEC *zx;\n   ZMAT *ZA;\n   char yes;\n   int i;\n   FILE *fp;\n\n   mem_info_on(TRUE);\n\n   if ((fp = fopen(""iotort.dat"",""w"")) == NULL) {\n      printf("" !!! Cannot open file %s for writing\n\n"",""iotort.dat"");\n      exit(1);\n   }\n     \n   x = v_get(10);\n   A = m_get(3,3);\n   zx = zv_get(10);\n   ZA = zm_get(3,3);\n   pivot = px_get(10);\n   ix = iv_get(10);\n   spA = sp_get(3,3,2);\n\n   v_rand(x);\n   m_rand(A);\n   zv_rand(zx);\n   zm_rand(ZA);\n   px_ident(pivot);\n   for (i=0; i < 10; i++)\n     ix->ive[i] = i+1;\n   for (i=0; i < spA->m; i++) {\n      sp_set_val(spA,i,i,1.0);\n      if (i > 0) sp_set_val(spA,i-1,i,-1.0);\n   }\n\n   notice("" VEC output"");\n   v_foutput(fp,x);\n   notice("" MAT output"");\n   m_foutput(fp,A);\n   notice("" ZVEC output"");\n   zv_foutput(fp,zx);\n   notice("" ZMAT output"");\n   zm_foutput(fp,ZA);\n   notice("" PERM output"");\n   px_foutput(fp,pivot);\n   notice("" IVEC output"");\n   iv_foutput(fp,ix);\n   notice("" SPMAT output"");\n   sp_foutput(fp,spA);\n   fprintf(fp,""Y"");\n   fclose(fp);\n\n   printf(""\nENTER SOME VALUES:\n\n"");\n\n   if ((fp = fopen(""iotort.dat"",""r"")) == NULL) {\n      printf("" !!! Cannot open file %s for reading\n\n"",""iotort.dat"");\n      exit(1);\n   }\n\n   notice("" VEC input/output"");\n   x = v_finput(fp,x);\n   v_output(x);\n\n   notice("" MAT input/output"");\n   A = m_finput(fp,A);\n   m_output(A);\n\n   notice("" ZVEC input/output"");\n   zx = zv_finput(fp,zx);\n   zv_output(zx);\n\n   notice("" ZMAT input/output"");\n   ZA = zm_finput(fp,ZA);\n   zm_output(ZA);\n\n   notice("" PERM input/output"");\n   pivot = px_finput(fp,pivot);\n   px_output(pivot);\n\n   notice("" IVEC input/output"");\n   ix = iv_finput(fp,ix);\n   iv_output(ix);\n\n   notice("" SPMAT input/output"");\n   SP_FREE(spA);\n   spA = sp_finput(fp);\n   sp_output(spA);\n\n   notice("" general input"");\n   finput(fp,"" finish the test?  "",""%c"",&yes);\n   if (yes == 'y' || yes == 'Y' )\n     printf("" YES\n"");\n   else printf("" NO\n"");\n   fclose(fp);\n\n   mem_info();\n}\n"
leukocyte/meschach_lib/ivecop.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* ivecop.c  */\n\n#include	<stdio.h>\n#include 	""matrix.h""\n\nstatic	char	rcsid[] = ""$Id: ivecop.c,v 1.6 1996/08/20 18:19:21 stewart Exp $"";\n\nstatic char    line[MAXLINE];\n\n\n\n/* iv_get -- get integer vector -- see also memory.c */\n#ifndef ANSI_C\nIVEC	*iv_get(dim)\nint	dim;\n#else\nIVEC	*iv_get(int dim)\n#endif\n{\n   IVEC	*iv;\n   /* unsigned int	i; */\n   \n   if (dim < 0)\n     error(E_NEG,""iv_get"");\n\n   if ((iv=NEW(IVEC)) == IVNULL )\n     error(E_MEM,""iv_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_IVEC,0,sizeof(IVEC));\n      mem_numvar(TYPE_IVEC,1);\n   }\n   \n   iv->dim = iv->max_dim = dim;\n   if ((iv->ive = NEW_A(dim,int)) == (int *)NULL )\n     error(E_MEM,""iv_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_IVEC,0,dim*sizeof(int));\n   }\n   \n   return (iv);\n}\n\n/* iv_free -- returns iv & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	iv_free(iv)\nIVEC	*iv;\n#else\nint	iv_free(IVEC *iv)\n#endif\n{\n   if ( iv==IVNULL || iv->dim > MAXDIM )\n     /* don't trust it */\n     return (-1);\n   \n   if ( iv->ive == (int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_IVEC,sizeof(IVEC),0);\n	 mem_numvar(TYPE_IVEC,-1);\n      }\n      free((char *)iv);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_IVEC,sizeof(IVEC)+iv->max_dim*sizeof(int),0);\n	 mem_numvar(TYPE_IVEC,-1);\n      }	\n      free((char *)iv->ive);\n      free((char *)iv);\n   }\n   \n   return (0);\n}\n\n/* iv_resize -- returns the IVEC with dimension new_dim\n   -- iv is set to the zero vector */\n#ifndef ANSI_C\nIVEC	*iv_resize(iv,new_dim)\nIVEC	*iv;\nint	new_dim;\n#else\nIVEC	*iv_resize(IVEC *iv, int new_dim)\n#endif\n{\n   int	i;\n   \n   if (new_dim < 0)\n     error(E_NEG,""iv_resize"");\n\n   if ( ! iv )\n     return iv_get(new_dim);\n   \n   if (new_dim == iv->dim)\n     return iv;\n\n   if ( new_dim > iv->max_dim )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_IVEC,iv->max_dim*sizeof(int),\n		      new_dim*sizeof(int));\n      }\n      iv->ive = RENEW(iv->ive,new_dim,int);\n      if ( ! iv->ive )\n	error(E_MEM,""iv_resize"");\n      iv->max_dim = new_dim;\n   }\n   if ( iv->dim <= new_dim )\n     for ( i = iv->dim; i < new_dim; i++ )\n       iv->ive[i] = 0;\n   iv->dim = new_dim;\n   \n   return iv;\n}\n\n/* iv_copy -- copy integer vector in to out\n   -- out created/resized if necessary */\n#ifndef ANSI_C\nIVEC	*iv_copy(in,out)\nIVEC	*in, *out;\n#else\nIVEC	*iv_copy(const IVEC *in, IVEC *out)\n#endif\n{\n   int		i;\n   \n   if ( ! in )\n     error(E_NULL,""iv_copy"");\n   out = iv_resize(out,in->dim);\n   for ( i = 0; i < in->dim; i++ )\n     out->ive[i] = in->ive[i];\n   \n   return out;\n}\n\n/* iv_move -- move selected pieces of an IVEC\n	-- moves the length dim0 subvector with initial index i0\n	   to the corresponding subvector of out with initial index i1\n	-- out is resized if necessary */\n#ifndef ANSI_C\nIVEC	*iv_move(in,i0,dim0,out,i1)\nIVEC	*in, *out;\nint	i0, dim0, i1;\n#else\nIVEC	*iv_move(const IVEC *in, int i0, int dim0, IVEC *out, int i1)\n#endif\n{\n    if ( ! in )\n	error(E_NULL,""iv_move"");\n    if ( i0 < 0 || dim0 < 0 || i1 < 0 ||\n	 i0+dim0 > in->dim )\n	error(E_BOUNDS,""iv_move"");\n\n    if ( (! out) || i1+dim0 > out->dim )\n	out = iv_resize(out,i1+dim0);\n\n    MEM_COPY(&(in->ive[i0]),&(out->ive[i1]),dim0*sizeof(int));\n\n    return out;\n}\n\n/* iv_add -- integer vector addition -- may be in-situ */\n#ifndef ANSI_C\nIVEC	*iv_add(iv1,iv2,out)\nIVEC	*iv1,*iv2,*out;\n#else\nIVEC	*iv_add(const IVEC *iv1, const IVEC *iv2, IVEC *out)\n#endif\n{\n   unsigned int	i;\n   int	*out_ive, *iv1_ive, *iv2_ive;\n   \n   if ( iv1==IVNULL || iv2==IVNULL )\n     error(E_NULL,""iv_add"");\n   if ( iv1->dim != iv2->dim )\n     error(E_SIZES,""iv_add"");\n   if ( out==IVNULL || out->dim != iv1->dim )\n     out = iv_resize(out,iv1->dim);\n   \n   out_ive = out->ive;\n   iv1_ive = iv1->ive;\n   iv2_ive = iv2->ive;\n   \n   for ( i = 0; i < iv1->dim; i++ )\n     out_ive[i] = iv1_ive[i] + iv2_ive[i];\n   \n   return (out);\n}\n\n\n\n/* iv_sub -- integer vector addition -- may be in-situ */\n#ifndef ANSI_C\nIVEC	*iv_sub(iv1,iv2,out)\nIVEC	*iv1,*iv2,*out;\n#else\nIVEC	*iv_sub(const IVEC *iv1, const IVEC *iv2, IVEC *out)\n#endif\n{\n   unsigned int	i;\n   int	*out_ive, *iv1_ive, *iv2_ive;\n   \n   if ( iv1==IVNULL || iv2==IVNULL )\n     error(E_NULL,""iv_sub"");\n   if ( iv1->dim != iv2->dim )\n     error(E_SIZES,""iv_sub"");\n   if ( out==IVNULL || out->dim != iv1->dim )\n     out = iv_resize(out,iv1->dim);\n   \n   out_ive = out->ive;\n   iv1_ive = iv1->ive;\n   iv2_ive = iv2->ive;\n   \n   for ( i = 0; i < iv1->dim; i++ )\n     out_ive[i] = iv1_ive[i] - iv2_ive[i];\n   \n   return (out);\n}\n\n#define	MAX_STACK	60\n\n\n/* iv_sort -- sorts vector x, and generates permutation that gives the order\n   of the components; x = [1.3, 3.7, 0.5] -> [0.5, 1.3, 3.7] and\n   the permutation is order = [2, 0, 1].\n   -- if order is NULL on entry then it is ignored\n   -- the sorted vector x is returned */\n#ifndef ANSI_C\nIVEC	*iv_sort(x, order)\nIVEC	*x;\nPERM	*order;\n#else\nIVEC	*iv_sort(IVEC *x, PERM *order)\n#endif\n{\n   int		*x_ive, tmp, v;\n   /* int		*order_pe; */\n   int		dim, i, j, l, r, tmp_i;\n   int		stack[MAX_STACK], sp;\n   \n   if ( ! x )\n     error(E_NULL,""iv_sort"");\n   if ( order != PNULL && order->size != x->dim )\n     order = px_resize(order, x->dim);\n   \n   x_ive = x->ive;\n   dim = x->dim;\n   if ( order != PNULL )\n     px_ident(order);\n   \n   if ( dim <= 1 )\n     return x;\n   \n   /* using quicksort algorithm in Sedgewick,\n      ""Algorithms in C"", Ch. 9, pp. 118--122 (1990) */\n   sp = 0;\n   l = 0;	r = dim-1;	v = x_ive[0];\n   for ( ; ; )\n   {\n      while ( r > l )\n      {\n	 /* ""i = partition(x_ive,l,r);"" */\n	 v = x_ive[r];\n	 i = l-1;\n	 j = r;\n	 for ( ; ; )\n	 {\n	    while ( x_ive[++i] < v )\n	      ;\n	    --j;\n	    while ( x_ive[j] > v && j != 0 )\n	      --j;\n	    if ( i >= j )	break;\n	    \n	    tmp = x_ive[i];\n	    x_ive[i] = x_ive[j];\n	    x_ive[j] = tmp;\n	    if ( order != PNULL )\n	    {\n	       tmp_i = order->pe[i];\n	       order->pe[i] = order->pe[j];\n	       order->pe[j] = tmp_i;\n	    }\n	 }\n	 tmp = x_ive[i];\n	 x_ive[i] = x_ive[r];\n	 x_ive[r] = tmp;\n	 if ( order != PNULL )\n	 {\n	    tmp_i = order->pe[i];\n	    order->pe[i] = order->pe[r];\n	    order->pe[r] = tmp_i;\n	 }\n	 \n	 if ( i-l > r-i )\n	 {   stack[sp++] = l;   stack[sp++] = i-1;   l = i+1;   }\n	 else\n	 {   stack[sp++] = i+1;   stack[sp++] = r;   r = i-1;   }\n      }\n      \n      /* recursion elimination */\n      if ( sp == 0 )\n	break;\n      r = stack[--sp];\n      l = stack[--sp];\n   }\n   \n   return x;\n}\n"
leukocyte/meschach_lib/tutorial.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/* tutorial.c 10/12/1993 */\n\n/* routines from Chapter 1 of Meschach */\n\nstatic char rcsid[] = ""$Id: tutorial.c,v 1.3 1994/01/16 22:53:09 des Exp $"";\n\n#include <math.h>\n#include ""matrix.h""\n\n/* rk4 -- 4th order Runge--Kutta method */\ndouble rk4(f,t,x,h)\ndouble t, h;\nVEC    *(*f)(), *x;\n{\n   static VEC *v1=VNULL, *v2=VNULL, *v3=VNULL, *v4=VNULL;\n   static VEC *temp=VNULL;\n   \n   /* do not work with NULL initial vector */\n   if ( x == VNULL )\n     error(E_NULL,""rk4"");\n\n   /* ensure that v1, ..., v4, temp are of the correct size */\n   v1   = v_resize(v1,x->dim);\n   v2   = v_resize(v2,x->dim);\n   v3   = v_resize(v3,x->dim);\n   v4   = v_resize(v4,x->dim);\n   temp = v_resize(temp,x->dim);\n\n   /* register workspace variables */\n   MEM_STAT_REG(v1,TYPE_VEC);\n   MEM_STAT_REG(v2,TYPE_VEC);\n   MEM_STAT_REG(v3,TYPE_VEC);\n   MEM_STAT_REG(v4,TYPE_VEC);\n   MEM_STAT_REG(temp,TYPE_VEC);\n   /* end of memory allocation */\n\n   (*f)(t,x,v1); /* most compilers allow: ""f(t,x,v1);"" */\n   v_mltadd(x,v1,0.5*h,temp);    /* temp = x+.5*h*v1 */\n   (*f)(t+0.5*h,temp,v2);\n   v_mltadd(x,v2,0.5*h,temp);    /* temp = x+.5*h*v2 */\n   (*f)(t+0.5*h,temp,v3);\n   v_mltadd(x,v3,h,temp);        /* temp = x+h*v3 */\n   (*f)(t+h,temp,v4);\n   \n   /* now add: v1+2*v2+2*v3+v4 */\n   v_copy(v1,temp);              /* temp = v1 */\n   v_mltadd(temp,v2,2.0,temp);   /* temp = v1+2*v2 */\n   v_mltadd(temp,v3,2.0,temp);   /* temp = v1+2*v2+2*v3 */\n   v_add(temp,v4,temp);          /* temp = v1+2*v2+2*v3+v4 */\n   \n   /* adjust x */\n   v_mltadd(x,temp,h/6.0,x);     /* x = x+(h/6)*temp */\n   \n   return t+h;                   /* return the new time */\n}\n\n\n\n/* rk4 -- 4th order Runge-Kutta method */\n/* another variant */\ndouble rk4_var(f,t,x,h)\ndouble t, h;\nVEC    *(*f)(), *x;\n{\n   static VEC *v1, *v2, *v3, *v4, *temp;\n   \n   /* do not work with NULL initial vector */\n   if ( x == VNULL )        error(E_NULL,""rk4"");\n   \n   /* ensure that v1, ..., v4, temp are of the correct size */\n   v_resize_vars(x->dim, &v1, &v2, &v3, &v4, &temp, NULL);\n\n   /* register workspace variables */\n   mem_stat_reg_vars(0, TYPE_VEC, __FILE__, __LINE__,\n		     &v1, &v2, &v3, &v4, &temp, NULL);\n   /* end of memory allocation */\n\n   (*f)(t,x,v1);             v_mltadd(x,v1,0.5*h,temp);\n   (*f)(t+0.5*h,temp,v2);    v_mltadd(x,v2,0.5*h,temp);\n   (*f)(t+0.5*h,temp,v3);    v_mltadd(x,v3,h,temp);\n   (*f)(t+h,temp,v4);\n   \n   /* now add: temp = v1+2*v2+2*v3+v4 */\n   v_linlist(temp, v1, 1.0, v2, 2.0, v3, 2.0, v4, 1.0, VNULL);\n   /* adjust x */\n   v_mltadd(x,temp,h/6.0,x);     /* x = x+(h/6)*temp */\n   \n   return t+h;                   /* return the new time */\n}\n\n\n/* f -- right-hand side of ODE solver */\nVEC	*f(t,x,out)\nVEC	*x, *out;\ndouble	t;\n{\n   if ( x == VNULL || out == VNULL )\n     error(E_NULL,""f"");\n   if ( x->dim != 2 || out->dim != 2 )\n     error(E_SIZES,""f"");\n   \n   out->ve[0] = x->ve[1];\n   out->ve[1] = - x->ve[0];\n   \n   return out;\n}\n\n\nvoid tutor_rk4()\n{\n   VEC        *x;\n   VEC        *f();\n   double     h, t, t_fin;\n   double     rk4();\n   \n   input(""Input initial time: "",""%lf"",&t);\n   input(""Input final time: "",  ""%lf"",&t_fin);\n   x = v_get(2);    /* this is the size needed by f() */\n   prompter(""Input initial state:\n"");	x = v_input(VNULL);\n   input(""Input step size: "",   ""%lf"",&h);\n   \n   printf(""# At time %g, the state is\n"",t);\n   v_output(x);\n   while (t < t_fin)\n   {\n      /* you can use t = rk4_var(f,t,x,min(h,t_fin-t)); */\n      t = rk4(f,t,x,min(h,t_fin-t));   /* new t is returned */\n      printf(""# At time %g, the state is\n"",t);\n      v_output(x);\n   }\n}\n\n\n\n\n#include ""matrix2.h""\n\nvoid tutor_ls()\n{\n   MAT *A, *QR;\n   VEC *b, *x, *diag;\n   \n   /* read in A matrix */\n   printf(""Input A matrix:\n"");\n   \n   A = m_input(MNULL);     /* A has whatever size is input */\n   \n   if ( A->m < A->n )\n   {\n      printf(""Need m >= n to obtain least squares fit\n"");\n      exit(0);\n   }\n   printf(""# A =\n"");       m_output(A);\n   diag = v_get(A->m);\n   /* QR is to be the QR factorisation of A */\n   QR = m_copy(A,MNULL);\n   QRfactor(QR,diag);   \n   /* read in b vector */\n   printf(""Input b vector:\n"");\n   b = v_get(A->m);\n   b = v_input(b);\n   printf(""# b =\n"");       v_output(b);\n   \n   /* solve for x */\n   x = QRsolve(QR,diag,b,VNULL);\n   printf(""Vector of best fit parameters is\n"");\n   v_output(x);\n   /* ... and work out norm of errors... */\n   printf(""||A*x-b|| = %g\n"",\n	  v_norm2(v_sub(mv_mlt(A,x,VNULL),b,VNULL)));\n}\n\n\n#include ""iter.h""\n\n\n#define N 50\n#define VEC2MAT(v,m)  vm_move((v),0,(m),0,0,N,N);\n\n#define PI 3.141592653589793116\n#define index(i,j) (N*((i)-1)+(j)-1)\n\n/* right hand side function (for generating b) */\ndouble f1(x,y)\ndouble x,y;\n{\n  /* return 2.0*PI*PI*sin(PI*x)*sin(PI*y); */\n   return exp(x*y);\n}\n\n/* discrete laplacian */\nSPMAT *laplacian(A)\nSPMAT *A;\n{\n   Real h;\n   int i,j;\n   \n   if (!A)\n     A = sp_get(N*N,N*N,5);\n\n   for ( i = 1; i <= N; i++ )\n     for ( j = 1; j <= N; j++ )\n     {\n        if ( i < N )\n	  sp_set_val(A,index(i,j),index(i+1,j),-1.0);\n        if ( i > 1 )\n	  sp_set_val(A,index(i,j),index(i-1,j),-1.0);\n        if ( j < N )\n	  sp_set_val(A,index(i,j),index(i,j+1),-1.0);\n        if ( j > 1 )\n	  sp_set_val(A,index(i,j),index(i,j-1),-1.0);\n        sp_set_val(A,index(i,j),index(i,j),4.0);\n     }\n   return A;\n}\n\n/* generating right hand side */\nVEC *rhs_lap(b)\nVEC *b;\n{\n   Real h,h2,x,y;\n   int i,j;\n   \n   if (!b)\n     b = v_get(N*N);\n\n   h = 1.0/(N+1);      /* for a unit square */\n   h2 = h*h;\n   x = 0.0;\n   for ( i = 1; i <= N; i++ ) {\n      x += h;\n      y = 0.0;\n     for ( j = 1; j <= N; j++ ) {\n	y += h;\n	b->ve[index(i,j)] = h2*f1(x,y);\n     }\n   }\n   return b;\n}\n   \nvoid tut_lap()\n{\n   SPMAT *A, *LLT;\n   VEC *b, *out, *x;\n   MAT *B;\n   int num_steps;\n   FILE *fp;\n\n   A = sp_get(N*N,N*N,5);\n   b = v_get(N*N);\n\n   laplacian(A);\n   LLT = sp_copy(A);\n   spICHfactor(LLT);\n\n   out = v_get(A->m);\n   x = v_get(A->m);\n\n   rhs_lap(b);   /* new rhs */\n   iter_spcg(A,LLT,b,1e-6,out,1000,&num_steps);\n   printf(""Number of iterations = %d\n"",num_steps);\n\n   /* save b as a MATLAB matrix */\n\n   fp = fopen(""laplace.mat"",""w"");  /* b will be saved in laplace.mat */\n   if (fp == NULL) {\n      printf(""Cannot open %s\n"",""laplace.mat"");\n      exit(1);\n   }\n   \n   /* b must be transformed to a matrix */\n   \n   B = m_get(N,N);\n   VEC2MAT(out,B);\n   m_save(fp,B,""sol"");  /* sol is an internal name in MATLAB */\n\n}\n\n\nvoid main()\n{\n   int i;\n\n   input(""Choose the problem (1=Runge-Kutta, 2=least squares,3=laplace): "",\n	 ""%d"",&i);\n   switch (i) {\n    case 1: tutor_rk4(); break;\n    case 2: tutor_ls(); break;\n    case 3: tut_lap(); break;\n    default: \n      printf("" Wrong value of i (only 1, 2 or 3)\n\n"");\n      break;\n   }\n\n}\n\n"
leukocyte/meschach_lib/mfuntort.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* mfuntort.c,  10/11/93 */\n\nstatic char rcsid[] = ""$Id: mfuntort.c,v 1.2 1994/01/14 01:08:06 des Exp $"";\n\n#include        <stdio.h>\n#include        <math.h>\n#include        ""matrix.h""\n#include        ""matrix2.h""\n\n\n#define errmesg(mesg)   printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)    printf(""# Testing %s...\n"",mesg);\n\n#define DIM  10\n\nvoid main()\n{\n\n   MAT *A, *B, *C, *OUTA, *OUTB, *TMP;\n   MAT *exp_A_expected, *exp_A;\n   VEC *x, *b;\n   double c, eps = 1e-10;\n   int i, j, q_out, j_out;\n\n   mem_info_on(TRUE);\n\n   A = m_get(DIM,DIM);\n   B = m_get(DIM,DIM);\n   C = m_get(DIM,DIM);\n   OUTA = m_get(DIM,DIM);\n   OUTB = m_get(DIM,DIM);\n   TMP = m_get(DIM,DIM);\n   x = v_get(DIM);\n   b = v_get(6);\n\n   notice(""exponent of a matrix"");\n\n   m_ident(A);\n   mem_stat_mark(1);\n   _m_exp(A,eps,OUTA,&q_out,&j_out);\n   printf(""# q_out = %d, j_out = %d\n"",q_out,j_out);\n\n   m_exp(A,eps,OUTA);\n   sm_mlt(exp(1.0),A,A);\n   m_sub(OUTA,A,TMP);\n   printf(""# ||exp(I) - e*I|| = %g\n"",m_norm_inf(TMP));\n\n   m_rand(A);\n   m_transp(A,TMP);\n   m_add(A,TMP,A);\n   B = m_copy(A,B);\n\n   m_exp(A,eps,OUTA);\n\n   symmeig(B,OUTB,x);\n   m_zero(TMP);\n   for (i=0; i < x->dim; i++)\n     TMP->me[i][i] = exp(x->ve[i]);\n   m_mlt(OUTB,TMP,C);\n   mmtr_mlt(C,OUTB,TMP);\n   m_sub(TMP,OUTA,TMP);\n   printf(""# ||exp(A) - Q*exp(lambda)*Q^T|| = %g\n"",m_norm_inf(TMP));\n\n   notice(""polynomial of a matrix"");\n   m_rand(A);\n   m_transp(A,TMP);\n   m_add(A,TMP,A);\n   B = m_copy(A,B);\n   v_rand(b);\n\n   m_poly(A,b,OUTA);\n\n   symmeig(B,OUTB,x);\n   m_zero(TMP);\n   for (i=0; i < x->dim; i++) {\n      c = b->ve[b->dim-1];\n      for (j=b->dim-2; j >= 0; j--) \n	c = c*x->ve[i] + b->ve[j];\n      TMP->me[i][i] = c;\n   }\n   m_mlt(OUTB,TMP,C);\n   mmtr_mlt(C,OUTB,TMP);\n   m_sub(TMP,OUTA,TMP);\n   printf(""# ||poly(A) - Q*poly(lambda)*Q^T|| = %g\n"",m_norm_inf(TMP));\n   mem_stat_free(1);\n\n\n   /* Brook Milligan's test */\n\n   M_FREE(A);\n   M_FREE(B);\n   M_FREE(C);\n\n   notice(""exponent of a nonsymmetric matrix"");\n   A = m_get (2, 2);\n   A -> me [0][0] = 1.0;\n   A -> me [0][1] = 1.0;\n   A -> me [1][0] = 4.0;\n   A -> me [1][1] = 1.0;\n   \n   exp_A_expected = m_get(2, 2);\n   exp_A_expected -> me [0][0] = exp (3.0) / 2.0 + exp (-1.0) / 2.0;\n   exp_A_expected -> me [0][1] = exp (3.0) / 4.0 - exp (-1.0) / 4.0;\n   exp_A_expected -> me [1][0] = exp (3.0)       - exp (-1.0);\n   exp_A_expected -> me [1][1] = exp (3.0) / 2.0 + exp (-1.0) / 2.0;\n   \n   printf (""A:\n"");\n   for (i = 0; i < 2; i++)\n   {\n      for (j = 0; j < 2; j++)\n        printf (""   %15.8e"", A -> me [i][j]);\n      printf (""\n"");\n   }\n   \n   printf (""\nexp(A) (expected):\n"");\n   for (i = 0; i < 2; i++)\n   {\n      for (j = 0; j < 2; j++)\n        printf (""   %15.8e"", exp_A_expected -> me [i][j]);\n      printf (""\n"");\n   }\n   \n   mem_stat_mark(3);\n   exp_A = m_exp (A, 1e-16,NULL);\n   mem_stat_free(3);\n\n   printf (""\nexp(A):\n"");\n   for (i = 0; i < 2; i++)\n   {\n      for (j = 0; j < 2; j++)\n        printf (""   %15.8e"", exp_A -> me [i][j]);\n      printf (""\n"");\n   }\n   printf (""\nexp(A) - exp(A) (expected):\n"");\n   for (i = 0; i < 2; i++)\n   {\n      for (j = 0; j < 2; j++)\n        printf (""   %15.8e"", exp_A -> me [i][j] - exp_A_expected -> me [i][j]);\n      printf (""\n"");\n   }\n\n   M_FREE(A);\n   M_FREE(B);\n   M_FREE(C);\n   M_FREE(exp_A);\n   M_FREE(exp_A_expected);\n   M_FREE(OUTA);\n   M_FREE(OUTB);\n   M_FREE(TMP);\n   V_FREE(b);\n   V_FREE(x);\n\n   mem_info();\n}\n\n"
leukocyte/meschach_lib/spchfctr.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Sparse Cholesky factorisation code\n	To be used with sparse.h, sparse.c etc\n\n*/\n\nstatic char	rcsid[] = ""$Id: spchfctr.c,v 1.5 1996/08/20 19:45:33 stewart Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""sparse2.h""\n\n\n#ifndef MALLOCDECL\n#ifndef ANSI_C\nextern	char	*calloc(), *realloc();\n#endif\n#endif\n\n\n\n/* sprow_ip -- finds the (partial) inner product of a pair of sparse rows\n	-- uses a ""merging"" approach & assumes column ordered rows\n	-- row indices for inner product are all < lim */\n#ifndef ANSI_C\nstatic double	sprow_ip(row1, row2, lim)\nSPROW	*row1, *row2;\nint	lim;\n#else\nstatic double	sprow_ip(const SPROW *row1, const SPROW *row2, int lim)\n#endif\n{\n	int			idx1, idx2, len1, len2, tmp;\n	register row_elt	*elts1, *elts2;\n	register Real		sum;\n\n	elts1 = row1->elt;	elts2 = row2->elt;\n	len1 = row1->len;	len2 = row2->len;\n\n	sum = 0.0;\n\n	if ( len1 <= 0 || len2 <= 0 )\n		return 0.0;\n	if ( elts1->col >= lim || elts2->col >= lim )\n		return 0.0;\n\n	/* use sprow_idx() to speed up inner product where one row is\n		much longer than the other */\n	idx1 = idx2 = 0;\n	if ( len1 > 2*len2 )\n	{\n		idx1 = sprow_idx(row1,elts2->col);\n		idx1 = (idx1 < 0) ? -(idx1+2) : idx1;\n		if ( idx1 < 0 )\n			error(E_UNKNOWN,""sprow_ip"");\n		len1 -= idx1;\n	}\n	else if ( len2 > 2*len1 )\n	{\n		idx2 = sprow_idx(row2,elts1->col);\n		idx2 = (idx2 < 0) ? -(idx2+2) : idx2;\n		if ( idx2 < 0 )\n			error(E_UNKNOWN,""sprow_ip"");\n		len2 -= idx2;\n	}\n	if ( len1 <= 0 || len2 <= 0 )\n		return 0.0;\n\n	elts1 = &(elts1[idx1]);		elts2 = &(elts2[idx2]);\n\n\n	for ( ; ; )	/* forever do... */\n	{\n		if ( (tmp=elts1->col-elts2->col) < 0 )\n		{\n		    len1--;		elts1++;\n		    if ( ! len1 || elts1->col >= lim )\n			break;\n		}\n		else if ( tmp > 0 )\n		{\n		    len2--;		elts2++;\n		    if ( ! len2 || elts2->col >= lim )\n			break;\n		}\n		else\n		{\n		    sum += elts1->val * elts2->val;\n		    len1--;		elts1++;\n		    len2--;		elts2++;\n		    if ( ! len1 || ! len2 ||\n				elts1->col >= lim || elts2->col >= lim )\n			break;\n		}\n	}\n\n	return sum;\n}\n\n/* sprow_sqr -- returns same as sprow_ip(row, row, lim) */\n#ifndef ANSI_C\nstatic double	sprow_sqr(row, lim)\nSPROW	*row;\nint	lim;\n#else\nstatic double	sprow_sqr(const SPROW *row, int lim)\n#endif\n{\n	register	row_elt	*elts;\n	int		idx, len;\n	register	Real	sum, tmp;\n\n	sum = 0.0;\n	elts = row->elt;	len = row->len;\n	for ( idx = 0; idx < len; idx++, elts++ )\n	{\n		if ( elts->col >= lim )\n			break;\n		tmp = elts->val;\n		sum += tmp*tmp;\n	}\n\n	return sum;\n}\n\nstatic	int	*scan_row = (int *)NULL, *scan_idx = (int *)NULL,\n			*col_list = (int *)NULL;\nstatic	int	scan_len = 0;\n\n/* set_scan -- expand scan_row and scan_idx arrays\n	-- return new length */\n#ifndef ANSI_C\nint	set_scan(new_len)\nint	new_len;\n#else\nint	set_scan(int new_len)\n#endif\n{\n	if ( new_len <= scan_len )\n		return scan_len;\n	if ( new_len <= scan_len+5 )\n		new_len += 5;\n\n	/* update scan_len */\n        scan_len = new_len;\n\n	if ( ! scan_row || ! scan_idx || ! col_list )\n	{\n		scan_row = (int *)calloc(new_len,sizeof(int));\n		scan_idx = (int *)calloc(new_len,sizeof(int));\n		col_list = (int *)calloc(new_len,sizeof(int));\n	}\n	else\n	{\n		scan_row = (int *)realloc((char *)scan_row,new_len*sizeof(int));\n		scan_idx = (int *)realloc((char *)scan_idx,new_len*sizeof(int));\n		col_list = (int *)realloc((char *)col_list,new_len*sizeof(int));\n	}\n\n	if ( ! scan_row || ! scan_idx || ! col_list )\n		error(E_MEM,""set_scan"");\n	return new_len;\n}\n\n/* spCHfactor -- sparse Cholesky factorisation\n	-- only the lower triangular part of A (incl. diagonal) is used */\n#ifndef ANSI_C\nSPMAT	*spCHfactor(A)\nSPMAT	*A;\n#else\nSPMAT	*spCHfactor(SPMAT *A)\n#endif\n{\n	register 	int	i;\n	int	idx, k, m, minim, n, num_scan, diag_idx, tmp1;\n	Real	pivot, tmp2;\n	SPROW	*r_piv, *r_op;\n	row_elt	*elt_piv, *elt_op, *old_elt;\n\n	if ( A == SMNULL )\n		error(E_NULL,""spCHfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""spCHfactor"");\n\n	/* set up access paths if not already done so */\n	sp_col_access(A);\n	sp_diag_access(A);\n\n	/* printf(""spCHfactor() -- checkpoint 1\n""); */\n	m = A->m;	n = A->n;\n	for ( k = 0; k < m; k++ )\n	{\n		r_piv = &(A->row[k]);\n		if ( r_piv->len > scan_len )\n			set_scan(r_piv->len);\n		elt_piv = r_piv->elt;\n		diag_idx = sprow_idx2(r_piv,k,r_piv->diag);\n		if ( diag_idx < 0 )\n			error(E_POSDEF,""spCHfactor"");\n		old_elt = &(elt_piv[diag_idx]);\n		for ( i = 0; i < r_piv->len; i++ )\n		{\n			if ( elt_piv[i].col > k )\n				break;\n			col_list[i] = elt_piv[i].col;\n			scan_row[i] = elt_piv[i].nxt_row;\n			scan_idx[i] = elt_piv[i].nxt_idx;\n		}\n		/* printf(""spCHfactor() -- checkpoint 2\n""); */\n		num_scan = i;	/* number of actual entries in scan_row etc. */\n		/* printf(""num_scan = %d\n"",num_scan); */\n\n		/* set diagonal entry of Cholesky factor */\n		tmp2 = elt_piv[diag_idx].val - sprow_sqr(r_piv,k);\n		if ( tmp2 <= 0.0 )\n			error(E_POSDEF,""spCHfactor"");\n		elt_piv[diag_idx].val = pivot = sqrt(tmp2);\n\n		/* now set the k-th column of the Cholesky factors */\n		/* printf(""k = %d\n"",k); */\n		for ( ; ; )	/* forever do... */\n		{\n		    /* printf(""spCHfactor() -- checkpoint 3\n""); */\n		    /* find next row where something (non-trivial) happens\n			i.e. find min(scan_row) */\n		    /* printf(""scan_row: ""); */\n		    minim = n;\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			tmp1 = scan_row[i];\n			/* printf(""%d "",tmp1); */\n			minim = ( tmp1 >= 0 && tmp1 < minim ) ? tmp1 : minim;\n		    }\n		    /* printf(""minim = %d\n"",minim); */\n		    /* printf(""col_list: ""); */\n		    /*  for ( i = 0; i < num_scan; i++ ) */\n			/*  printf(""%d "",col_list[i]); */\n		    /*  printf(""\n""); */\n\n		    if ( minim >= n )\n			break;	/* nothing more to do for this column */\n		    r_op = &(A->row[minim]);\n		    elt_op = r_op->elt;\n\n		    /* set next entry in column k of Cholesky factors */\n		    idx = sprow_idx2(r_op,k,scan_idx[num_scan-1]);\n		    if ( idx < 0 )\n		    {	/* fill-in */\n			sp_set_val(A,minim,k,\n					-sprow_ip(r_piv,r_op,k)/pivot);\n			/* in case a realloc() has occurred... */\n			elt_op = r_op->elt;\n			/* now set up column access path again */\n			idx = sprow_idx2(r_op,k,-(idx+2));\n			tmp1 = old_elt->nxt_row;\n			old_elt->nxt_row = minim;\n			r_op->elt[idx].nxt_row = tmp1;\n			tmp1 = old_elt->nxt_idx;\n			old_elt->nxt_idx = idx;\n			r_op->elt[idx].nxt_idx = tmp1;\n		    }\n		    else\n		        elt_op[idx].val = (elt_op[idx].val -\n				sprow_ip(r_piv,r_op,k))/pivot;\n\n		    /* printf(""spCHfactor() -- checkpoint 4\n""); */\n\n		    /* remember current element in column k for column chain */\n		    idx = sprow_idx2(r_op,k,idx);\n		    old_elt = &(r_op->elt[idx]);\n\n		    /* update scan_row */\n		    /* printf(""spCHfactor() -- checkpoint 5\n""); */\n		    /* printf(""minim = %d\n"",minim); */\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			if ( scan_row[i] != minim )\n				continue;\n			idx = sprow_idx2(r_op,col_list[i],scan_idx[i]);\n			if ( idx < 0 )\n			{	scan_row[i] = -1;	continue;	}\n			scan_row[i] = elt_op[idx].nxt_row;\n			scan_idx[i] = elt_op[idx].nxt_idx;\n			/* printf(""scan_row[%d] = %d\n"",i,scan_row[i]); */\n			/* printf(""scan_idx[%d] = %d\n"",i,scan_idx[i]); */\n		    }\n			\n		}\n	    /* printf(""spCHfactor() -- checkpoint 6\n""); */\n	    /* sp_dump(stdout,A); */\n	    /* printf(""\n\n\n""); */\n	}\n\n	return A;\n}\n\n/* spCHsolve -- solve L.L^T.out=b where L is a sparse matrix,\n	-- out, b dense vectors\n	-- returns out; operation may be in-situ */\n#ifndef ANSI_C\nVEC	*spCHsolve(L,b,out)\nSPMAT	*L;\nVEC	*b, *out;\n#else\nVEC	*spCHsolve(SPMAT *L, const VEC *b, VEC *out)\n#endif\n{\n	int	i, j_idx, n, scan_idx, scan_row;\n	SPROW	*row;\n	row_elt	*elt;\n	Real	diag_val, sum, *out_ve;\n\n	if ( L == SMNULL || b == VNULL )\n		error(E_NULL,""spCHsolve"");\n	if ( L->m != L->n )\n		error(E_SQUARE,""spCHsolve"");\n	if ( b->dim != L->m )\n		error(E_SIZES,""spCHsolve"");\n\n	if ( ! L->flag_col )\n		sp_col_access(L);\n	if ( ! L->flag_diag )\n		sp_diag_access(L);\n\n	out = v_copy(b,out);\n	out_ve = out->ve;\n\n	/* forward substitution: solve L.x=b for x */\n	n = L->n;\n	for ( i = 0; i < n; i++ )\n	{\n		sum = out_ve[i];\n		row = &(L->row[i]);\n		elt = row->elt;\n		for ( j_idx = 0; j_idx < row->len; j_idx++, elt++ )\n		{\n		    if ( elt->col >= i )\n			break;\n		    sum -= elt->val*out_ve[elt->col];\n		}\n		if ( row->diag >= 0 )\n		    out_ve[i] = sum/(row->elt[row->diag].val);\n		else\n		    error(E_SING,""spCHsolve"");\n	}\n\n	/* backward substitution: solve L^T.out = x for out */\n	for ( i = n-1; i >= 0; i-- )\n	{\n		sum = out_ve[i];\n		row = &(L->row[i]);\n		/* Note that row->diag >= 0 by above loop */\n		elt = &(row->elt[row->diag]);\n		diag_val = elt->val;\n\n		/* scan down column */\n		scan_idx = elt->nxt_idx;\n		scan_row = elt->nxt_row;\n		while ( scan_row >= 0 /* && scan_idx >= 0 */ )\n		{\n		    row = &(L->row[scan_row]);\n		    elt = &(row->elt[scan_idx]);\n		    sum -= elt->val*out_ve[scan_row];\n		    scan_idx = elt->nxt_idx;\n		    scan_row = elt->nxt_row;\n		}\n		out_ve[i] = sum/diag_val;\n	}\n\n	return out;\n}\n\n/* spICHfactor -- sparse Incomplete Cholesky factorisation\n	-- does a Cholesky factorisation assuming NO FILL-IN\n	-- as for spCHfactor(), only the lower triangular part of A is used */\n#ifndef ANSI_C\nSPMAT	*spICHfactor(A)\nSPMAT	*A;\n#else\nSPMAT	*spICHfactor(SPMAT *A)\n#endif\n{\n	int	k, m, n, nxt_row, nxt_idx, diag_idx;\n	Real	pivot, tmp2;\n	SPROW	*r_piv, *r_op;\n	row_elt	*elt_piv, *elt_op;\n\n	if ( A == SMNULL )\n		error(E_NULL,""spICHfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""spICHfactor"");\n\n	/* set up access paths if not already done so */\n	if ( ! A->flag_col )\n		sp_col_access(A);\n	if ( ! A->flag_diag )\n		sp_diag_access(A);\n\n	m = A->m;	n = A->n;\n	for ( k = 0; k < m; k++ )\n	{\n		r_piv = &(A->row[k]);\n\n		diag_idx = r_piv->diag;\n		if ( diag_idx < 0 )\n			error(E_POSDEF,""spICHfactor"");\n\n		elt_piv = r_piv->elt;\n\n		/* set diagonal entry of Cholesky factor */\n		tmp2 = elt_piv[diag_idx].val - sprow_sqr(r_piv,k);\n		if ( tmp2 <= 0.0 )\n			error(E_POSDEF,""spICHfactor"");\n		elt_piv[diag_idx].val = pivot = sqrt(tmp2);\n\n		/* find next row where something (non-trivial) happens */\n		nxt_row = elt_piv[diag_idx].nxt_row;\n		nxt_idx = elt_piv[diag_idx].nxt_idx;\n\n		/* now set the k-th column of the Cholesky factors */\n		while ( nxt_row >= 0 && nxt_idx >= 0 )\n		{\n		    /* nxt_row and nxt_idx give next next row (& index)\n			of the entry to be modified */\n		    r_op = &(A->row[nxt_row]);\n		    elt_op = r_op->elt;\n		    elt_op[nxt_idx].val = (elt_op[nxt_idx].val -\n				sprow_ip(r_piv,r_op,k))/pivot;\n\n		    nxt_row = elt_op[nxt_idx].nxt_row;\n		    nxt_idx = elt_op[nxt_idx].nxt_idx;\n		}\n	}\n\n	return A;\n}\n\n\n/* spCHsymb -- symbolic sparse Cholesky factorisation\n	-- does NOT do any floating point arithmetic; just sets up the structure\n	-- only the lower triangular part of A (incl. diagonal) is used */\n#ifndef ANSI_C\nSPMAT	*spCHsymb(A)\nSPMAT	*A;\n#else\nSPMAT	*spCHsymb(SPMAT *A)\n#endif\n{\n	register 	int	i;\n	int	idx, k, m, minim, n, num_scan, diag_idx, tmp1;\n	SPROW	*r_piv, *r_op;\n	row_elt	*elt_piv, *elt_op, *old_elt;\n\n	if ( A == SMNULL )\n		error(E_NULL,""spCHsymb"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""spCHsymb"");\n\n	/* set up access paths if not already done so */\n	if ( ! A->flag_col )\n		sp_col_access(A);\n	if ( ! A->flag_diag )\n		sp_diag_access(A);\n\n	/* printf(""spCHsymb() -- checkpoint 1\n""); */\n	m = A->m;	n = A->n;\n	for ( k = 0; k < m; k++ )\n	{\n		r_piv = &(A->row[k]);\n		if ( r_piv->len > scan_len )\n			set_scan(r_piv->len);\n		elt_piv = r_piv->elt;\n		diag_idx = sprow_idx2(r_piv,k,r_piv->diag);\n		if ( diag_idx < 0 )\n			error(E_POSDEF,""spCHsymb"");\n		old_elt = &(elt_piv[diag_idx]);\n		for ( i = 0; i < r_piv->len; i++ )\n		{\n			if ( elt_piv[i].col > k )\n				break;\n			col_list[i] = elt_piv[i].col;\n			scan_row[i] = elt_piv[i].nxt_row;\n			scan_idx[i] = elt_piv[i].nxt_idx;\n		}\n		/* printf(""spCHsymb() -- checkpoint 2\n""); */\n		num_scan = i;	/* number of actual entries in scan_row etc. */\n		/* printf(""num_scan = %d\n"",num_scan); */\n\n		/* now set the k-th column of the Cholesky factors */\n		/* printf(""k = %d\n"",k); */\n		for ( ; ; )	/* forever do... */\n		{\n		    /* printf(""spCHsymb() -- checkpoint 3\n""); */\n		    /* find next row where something (non-trivial) happens\n			i.e. find min(scan_row) */\n		    minim = n;\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			tmp1 = scan_row[i];\n			/* printf(""%d "",tmp1); */\n			minim = ( tmp1 >= 0 && tmp1 < minim ) ? tmp1 : minim;\n		    }\n\n		    if ( minim >= n )\n			break;	/* nothing more to do for this column */\n		    r_op = &(A->row[minim]);\n		    elt_op = r_op->elt;\n\n		    /* set next entry in column k of Cholesky factors */\n		    idx = sprow_idx2(r_op,k,scan_idx[num_scan-1]);\n		    if ( idx < 0 )\n		    {	/* fill-in */\n			sp_set_val(A,minim,k,0.0);\n			/* in case a realloc() has occurred... */\n			elt_op = r_op->elt;\n			/* now set up column access path again */\n			idx = sprow_idx2(r_op,k,-(idx+2));\n			tmp1 = old_elt->nxt_row;\n			old_elt->nxt_row = minim;\n			r_op->elt[idx].nxt_row = tmp1;\n			tmp1 = old_elt->nxt_idx;\n			old_elt->nxt_idx = idx;\n			r_op->elt[idx].nxt_idx = tmp1;\n		    }\n\n		    /* printf(""spCHsymb() -- checkpoint 4\n""); */\n\n		    /* remember current element in column k for column chain */\n		    idx = sprow_idx2(r_op,k,idx);\n		    old_elt = &(r_op->elt[idx]);\n\n		    /* update scan_row */\n		    /* printf(""spCHsymb() -- checkpoint 5\n""); */\n		    /* printf(""minim = %d\n"",minim); */\n		    for ( i = 0; i < num_scan; i++ )\n		    {\n			if ( scan_row[i] != minim )\n				continue;\n			idx = sprow_idx2(r_op,col_list[i],scan_idx[i]);\n			if ( idx < 0 )\n			{	scan_row[i] = -1;	continue;	}\n			scan_row[i] = elt_op[idx].nxt_row;\n			scan_idx[i] = elt_op[idx].nxt_idx;\n			/* printf(""scan_row[%d] = %d\n"",i,scan_row[i]); */\n			/* printf(""scan_idx[%d] = %d\n"",i,scan_idx[i]); */\n		    }\n			\n		}\n	    /* printf(""spCHsymb() -- checkpoint 6\n""); */\n	}\n\n	return A;\n}\n\n/* comp_AAT -- compute A.A^T where A is a given sparse matrix */\n#ifndef ANSI_C\nSPMAT	*comp_AAT(A)\nSPMAT	*A;\n#else\nSPMAT	*comp_AAT(SPMAT *A)\n#endif\n{\n	SPMAT	*AAT;\n	SPROW	*r, *r2;\n	row_elt	*elts, *elts2;\n	int	i, idx, idx2, j, m, minim, n, num_scan, tmp1;\n	Real	ip;\n\n	if ( ! A )\n		error(E_NULL,""comp_AAT"");\n	m = A->m;	n = A->n;\n\n	/* set up column access paths */\n	if ( ! A->flag_col )\n		sp_col_access(A);\n\n	AAT = sp_get(m,m,10);\n\n	for ( i = 0; i < m; i++ )\n	{\n		/* initialisation */\n		r = &(A->row[i]);\n		elts = r->elt;\n\n		/* set up scan lists for this row */\n		if ( r->len > scan_len )\n		    set_scan(r->len);\n		for ( j = 0; j < r->len; j++ )\n		{\n		    col_list[j] = elts[j].col;\n		    scan_row[j] = elts[j].nxt_row;\n		    scan_idx[j] = elts[j].nxt_idx;\n		}\n		num_scan = r->len;\n\n		/* scan down the rows for next non-zero not\n			associated with a diagonal entry */\n		for ( ; ; )\n		{\n		    minim = m;\n		    for ( idx = 0; idx < num_scan; idx++ )\n		    {\n			tmp1 = scan_row[idx];\n			minim = ( tmp1 >= 0 && tmp1 < minim ) ? tmp1 : minim;\n		    }\n		    if ( minim >= m )\n		 	break;\n		    r2 = &(A->row[minim]);\n		    if ( minim > i )\n		    {\n			ip = sprow_ip(r,r2,n);\n		        sp_set_val(AAT,minim,i,ip);\n		        sp_set_val(AAT,i,minim,ip);\n		    }\n		    /* update scan entries */\n		    elts2 = r2->elt;\n		    for ( idx = 0; idx < num_scan; idx++ )\n		    {\n			if ( scan_row[idx] != minim || scan_idx[idx] < 0 )\n			    continue;\n			idx2 = scan_idx[idx];\n			scan_row[idx] = elts2[idx2].nxt_row;\n			scan_idx[idx] = elts2[idx2].nxt_idx;\n		    }\n		}\n\n		/* set the diagonal entry */\n		sp_set_val(AAT,i,i,sprow_sqr(r,n));\n	}\n\n	return AAT;\n}\n\n"
leukocyte/meschach_lib/spbkp.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  Sparse matrix Bunch--Kaufman--Parlett factorisation and solve\n  Radical revision started Thu 05th Nov 1992, 09:36:12 AM\n  to use Karen George's suggestion of leaving the the row elements unordered\n  Radical revision completed Mon 07th Dec 1992, 10:59:57 AM\n*/\n\nstatic	char	rcsid[] = ""$Id: spbkp.c,v 1.6 1996/08/20 19:53:10 stewart Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""sparse2.h""\n\n\n#ifdef MALLOCDECL\n#include <malloc.h>\n#endif\n\n#define alpha	0.6403882032022076 /* = (1+sqrt(17))/8 */\n\n\n#define	btos(x)	((x) ? ""TRUE"" : ""FALSE"")\n\n/* assume no use of sqr() uses side-effects */\n#define	sqr(x)	((x)*(x))\n\n/* unord_get_idx -- returns index (encoded if entry not allocated)\n	of the element of row r with column j\n	-- uses linear search */\n#ifndef ANSI_C\nint	unord_get_idx(r,j)\nSPROW	*r;\nint	j;\n#else\nint	unord_get_idx(SPROW *r, int j)\n#endif\n{\n    int		idx;\n    row_elt	*e;\n\n    if ( ! r || ! r->elt )\n	error(E_NULL,""unord_get_idx"");\n    for ( idx = 0, e = r->elt; idx < r->len; idx++, e++ )\n	if ( e->col == j )\n	    break;\n    if ( idx >= r->len )\n	return -(r->len+2);\n    else\n	return idx;\n}\n\n/* unord_get_val -- returns value of the (i,j) entry of A\n	-- same assumptions as unord_get_idx() */\n#ifndef ANSI_C\ndouble	unord_get_val(A,i,j)\nSPMAT	*A;\nint	i, j;\n#else\ndouble	unord_get_val(SPMAT *A, int i, int j)\n#endif\n{\n    SPROW	*r;\n    int		idx;\n\n    if ( ! A )\n	error(E_NULL,""unord_get_val"");\n    if ( i < 0 || i >= A->m || j < 0 || j >= A->n )\n	error(E_BOUNDS,""unord_get_val"");\n\n    r = &(A->row[i]);\n    idx = unord_get_idx(r,j);\n    if ( idx < 0 )\n	return 0.0;\n    else\n	return r->elt[idx].val;\n}\n\n	    \n/* bkp_swap_elt -- swaps the (i,j) with the (k,l) entry of sparse matrix\n	-- either or both of the entries may be unallocated */\n#ifndef ANSI_C\nstatic SPMAT	*bkp_swap_elt(A,i1,j1,idx1,i2,j2,idx2)\nSPMAT	*A;\nint	i1, j1, idx1, i2, j2, idx2;\n#else\nstatic SPMAT	*bkp_swap_elt(SPMAT *A, int i1, int j1, \n			      int idx1, int i2, int j2, int idx2)\n#endif\n{\n    int		tmp_row, tmp_idx;\n    SPROW	*r1, *r2;\n    row_elt	*e1, *e2;\n    Real	tmp;\n\n    if ( ! A )\n	error(E_NULL,""bkp_swap_elt"");\n\n    if ( i1 < 0 || j1 < 0 || i2 < 0 || j2 < 0 ||\n	 i1 >= A->m || j1 >= A->n || i2 >= A->m || j2 >= A->n )\n    {\n	error(E_BOUNDS,""bkp_swap_elt"");\n    }\n\n    if ( i1 == i2 && j1 == j2 )\n	return A;\n    if ( idx1 < 0 && idx2 < 0 )	/* neither allocated */\n	return A;\n\n    r1 = &(A->row[i1]);		r2 = &(A->row[i2]);\n    /* if ( idx1 >= r1->len || idx2 >= r2->len )\n	error(E_BOUNDS,""bkp_swap_elt""); */\n    if ( idx1 < 0 )	/* assume not allocated */\n    {\n	idx1 = r1->len;\n	if ( idx1 >= r1->maxlen )\n	{    tracecatch(sprow_xpd(r1,2*r1->maxlen+1,TYPE_SPMAT),\n			""bkp_swap_elt"");	}\n	r1->len = idx1+1;\n	r1->elt[idx1].col = j1;\n	r1->elt[idx1].val = 0.0;\n	/* now patch up column access path */\n	tmp_row = -1;	tmp_idx = j1;\n	chase_col(A,j1,&tmp_row,&tmp_idx,i1-1);\n\n	if ( tmp_row < 0 )\n	{\n	    r1->elt[idx1].nxt_row = A->start_row[j1];\n	    r1->elt[idx1].nxt_idx = A->start_idx[j1];\n	    A->start_row[j1] = i1;\n	    A->start_idx[j1] = idx1;\n	}\n	else\n	{\n	    row_elt	*tmp_e;\n\n	    tmp_e = &(A->row[tmp_row].elt[tmp_idx]);\n	    r1->elt[idx1].nxt_row = tmp_e->nxt_row;\n	    r1->elt[idx1].nxt_idx = tmp_e->nxt_idx;\n	    tmp_e->nxt_row = i1;\n	    tmp_e->nxt_idx = idx1;\n	}\n    }\n    else if ( r1->elt[idx1].col != j1 )\n	error(E_INTERN,""bkp_swap_elt"");\n    if ( idx2 < 0 )\n    {\n	idx2 = r2->len;\n	if ( idx2 >= r2->maxlen )\n	{    tracecatch(sprow_xpd(r2,2*r2->maxlen+1,TYPE_SPMAT),\n			""bkp_swap_elt"");	}\n\n	r2->len = idx2+1;\n	r2->elt[idx2].col = j2;\n	r2->elt[idx2].val = 0.0;\n	/* now patch up column access path */\n	tmp_row = -1;	tmp_idx = j2;\n	chase_col(A,j2,&tmp_row,&tmp_idx,i2-1);\n	if ( tmp_row < 0 )\n	{\n	    r2->elt[idx2].nxt_row = A->start_row[j2];\n	    r2->elt[idx2].nxt_idx = A->start_idx[j2];\n	    A->start_row[j2] = i2;\n	    A->start_idx[j2] = idx2;\n	}\n	else\n	{\n	    row_elt	*tmp_e;\n\n	    tmp_e = &(A->row[tmp_row].elt[tmp_idx]);\n	    r2->elt[idx2].nxt_row = tmp_e->nxt_row;\n	    r2->elt[idx2].nxt_idx = tmp_e->nxt_idx;\n	    tmp_e->nxt_row = i2;\n	    tmp_e->nxt_idx = idx2;\n	}\n    }\n    else if ( r2->elt[idx2].col != j2 )\n	error(E_INTERN,""bkp_swap_elt"");\n\n    e1 = &(r1->elt[idx1]);	e2 = &(r2->elt[idx2]);\n\n    tmp = e1->val;\n    e1->val = e2->val;\n    e2->val = tmp;\n\n    return A;\n}\n\n/* bkp_bump_col -- bumps row and idx to next entry in column j */\n#ifndef ANSI_C\nrow_elt	*bkp_bump_col(A, j, row, idx)\nSPMAT	*A;\nint	j, *row, *idx;\n#else\nrow_elt	*bkp_bump_col(SPMAT *A, int j, int *row, int *idx)\n#endif\n{\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( *row < 0 )\n    {\n	*row = A->start_row[j];\n	*idx = A->start_idx[j];\n    }\n    else\n    {\n	r = &(A->row[*row]);\n	e = &(r->elt[*idx]);\n	if ( e->col != j )\n	    error(E_INTERN,""bkp_bump_col"");\n	*row = e->nxt_row;\n	*idx = e->nxt_idx;\n    }\n    if ( *row < 0 )\n	return (row_elt *)NULL;\n    else\n	return &(A->row[*row].elt[*idx]);\n}\n\n/* bkp_interchange -- swap rows/cols i and j (symmetric pivot)\n	-- uses just the upper triangular part */\n#ifndef ANSI_C\nSPMAT	*bkp_interchange(A, i1, i2)\nSPMAT	*A;\nint	i1, i2;\n#else\nSPMAT	*bkp_interchange(SPMAT *A, int i1, int i2)\n#endif\n{\n    int		tmp_row, tmp_idx;\n    int		row1, row2, idx1, idx2, tmp_row1, tmp_idx1, tmp_row2, tmp_idx2;\n    SPROW	*r1, *r2;\n    row_elt	*e1, *e2;\n    IVEC	*done_list = IVNULL;\n\n    if ( ! A )\n	error(E_NULL,""bkp_interchange"");\n    if ( i1 < 0 || i1 >= A->n || i2 < 0 || i2 >= A->n )\n	error(E_BOUNDS,""bkp_interchange"");\n    if ( A->m != A->n )\n	error(E_SQUARE,""bkp_interchange"");\n\n    if ( i1 == i2 )\n	return A;\n    if ( i1 > i2 )\n    {	tmp_idx = i1;	i1 = i2;	i2 = tmp_idx;	}\n\n    done_list = iv_resize(done_list,A->n);\n    for ( tmp_idx = 0; tmp_idx < A->n; tmp_idx++ )\n	done_list->ive[tmp_idx] = FALSE;\n    row1 = -1;		idx1 = i1;\n    row2 = -1;		idx2 = i2;\n    e1 = bkp_bump_col(A,i1,&row1,&idx1);\n    e2 = bkp_bump_col(A,i2,&row2,&idx2);\n\n    while ( (row1 >= 0 && row1 < i1) || (row2 >= 0 && row2 < i1) )\n	/* Note: ""row2 < i1"" not ""row2 < i2"" as we must stop before the\n	   ""knee bend"" */\n    {\n	if ( row1 >= 0 && row1 < i1 && ( row1 < row2 || row2 < 0 ) )\n	{\n	    tmp_row1 = row1;	tmp_idx1 = idx1;\n	    e1 = bkp_bump_col(A,i1,&tmp_row1,&tmp_idx1);\n	    if ( ! done_list->ive[row1] )\n	    {\n		if ( row1 == row2 )\n		    bkp_swap_elt(A,row1,i1,idx1,row1,i2,idx2);\n		else\n		    bkp_swap_elt(A,row1,i1,idx1,row1,i2,-1);\n		done_list->ive[row1] = TRUE;\n	    }\n	    row1 = tmp_row1;	idx1 = tmp_idx1;\n	}\n	else if ( row2 >= 0 && row2 < i1 && ( row2 < row1 || row1 < 0 ) )\n	{\n	    tmp_row2 = row2;	tmp_idx2 = idx2;\n	    e2 = bkp_bump_col(A,i2,&tmp_row2,&tmp_idx2);\n	    if ( ! done_list->ive[row2] )\n	    {\n		if ( row1 == row2 )\n		    bkp_swap_elt(A,row2,i1,idx1,row2,i2,idx2);\n		else\n		    bkp_swap_elt(A,row2,i1,-1,row2,i2,idx2);\n		done_list->ive[row2] = TRUE;\n	    }\n	    row2 = tmp_row2;	idx2 = tmp_idx2;\n	}\n	else if ( row1 == row2 )\n	{\n	    tmp_row1 = row1;	tmp_idx1 = idx1;\n	    e1 = bkp_bump_col(A,i1,&tmp_row1,&tmp_idx1);\n	    tmp_row2 = row2;	tmp_idx2 = idx2;\n	    e2 = bkp_bump_col(A,i2,&tmp_row2,&tmp_idx2);\n	    if ( ! done_list->ive[row1] )\n	    {\n		bkp_swap_elt(A,row1,i1,idx1,row2,i2,idx2);\n		done_list->ive[row1] = TRUE;\n	    }\n	    row1 = tmp_row1;	idx1 = tmp_idx1;\n	    row2 = tmp_row2;	idx2 = tmp_idx2;\n	}\n    }\n\n    /* ensure we are **past** the first knee */\n    while ( row2 >= 0 && row2 <= i1 )\n	e2 = bkp_bump_col(A,i2,&row2,&idx2);\n\n    /* at/after 1st ""knee bend"" */\n    r1 = &(A->row[i1]);\n    idx1 = 0;\n    e1 = &(r1->elt[idx1]);\n    while ( row2 >= 0 && row2 < i2 )\n    {\n	/* used for update of e2 at end of loop */\n	tmp_row = row2;	tmp_idx = idx2;\n	if ( ! done_list->ive[row2] )\n	{\n	    r2 = &(A->row[row2]);\n	    bkp_bump_col(A,i2,&tmp_row,&tmp_idx);\n	    done_list->ive[row2] = TRUE;\n	    tmp_idx1 = unord_get_idx(r1,row2);\n	    tracecatch(bkp_swap_elt(A,row2,i2,idx2,i1,row2,tmp_idx1),\n		       ""bkp_interchange"");\n	}\n\n	/* update e1 and e2 */\n	row2 = tmp_row;	idx2 = tmp_idx;\n	e2 = ( row2 >= 0 ) ? &(A->row[row2].elt[idx2]) : (row_elt *)NULL;\n    }\n\n    idx1 = 0;\n    e1 = r1->elt;\n    while ( idx1 < r1->len )\n    {\n	if ( e1->col >= i2 || e1->col <= i1 )\n	{\n	    idx1++;\n	    e1++;\n	    continue;\n	}\n	if ( ! done_list->ive[e1->col] )\n	{\n	    tmp_idx2 = unord_get_idx(&(A->row[e1->col]),i2);\n	    tracecatch(bkp_swap_elt(A,i1,e1->col,idx1,e1->col,i2,tmp_idx2),\n		       ""bkp_interchange"");\n	    done_list->ive[e1->col] = TRUE;\n	}\n	idx1++;\n	e1++;\n    }\n\n    /* at/after 2nd ""knee bend"" */\n    idx1 = 0;\n    e1 = &(r1->elt[idx1]);\n    r2 = &(A->row[i2]);\n    idx2 = 0;\n    e2 = &(r2->elt[idx2]);\n    while ( idx1 < r1->len )\n    {\n	if ( e1->col <= i2 )\n	{\n	    idx1++;	e1++;\n	    continue;\n	}\n	if ( ! done_list->ive[e1->col] )\n	{\n	    tmp_idx2 = unord_get_idx(r2,e1->col);\n	    tracecatch(bkp_swap_elt(A,i1,e1->col,idx1,i2,e1->col,tmp_idx2),\n		       ""bkp_interchange"");\n	    done_list->ive[e1->col] = TRUE;\n	}\n	idx1++;	e1++;\n    }\n\n    idx2 = 0;	e2 = r2->elt;\n    while ( idx2 < r2->len )\n    {\n	if ( e2->col <= i2 )\n	{\n	    idx2++;	e2++;\n	    continue;\n	}\n	if ( ! done_list->ive[e2->col] )\n	{\n	    tmp_idx1 = unord_get_idx(r1,e2->col);\n	    tracecatch(bkp_swap_elt(A,i2,e2->col,idx2,i1,e2->col,tmp_idx1),\n		       ""bkp_interchange"");\n	    done_list->ive[e2->col] = TRUE;\n	}\n	idx2++;	e2++;\n    }\n\n    /* now interchange the digonal entries! */\n    idx1 = unord_get_idx(&(A->row[i1]),i1);\n    idx2 = unord_get_idx(&(A->row[i2]),i2);\n    if ( idx1 >= 0 || idx2 >= 0 )\n    {\n	tracecatch(bkp_swap_elt(A,i1,i1,idx1,i2,i2,idx2),\n		   ""bkp_interchange"");\n    }\n\n    return A;\n}\n\n\n/* iv_min -- returns minimum of an integer vector\n   -- sets index to the position in iv if index != NULL */\n#ifndef ANSI_C\nint	iv_min(iv,index)\nIVEC	*iv;\nint	*index;\n#else\nint	iv_min(IVEC *iv, int *index)\n#endif\n{\n    int		i, i_min, min_val, tmp;\n    \n    if ( ! iv ) \n	error(E_NULL,""iv_min"");\n    if ( iv->dim <= 0 )\n	error(E_SIZES,""iv_min"");\n    i_min = 0;\n    min_val = iv->ive[0];\n    for ( i = 1; i < iv->dim; i++ )\n    {\n	tmp = iv->ive[i];\n	if ( tmp < min_val )\n	{\n	    min_val = tmp;\n	    i_min = i;\n	}\n    }\n    \n    if ( index != (int *)NULL )\n	*index = i_min;\n    \n    return min_val;\n}\n\n/* max_row_col -- returns max { |A[j][k]| : k >= i, k != j, k != l } given j\n	using symmetry and only the upper triangular part of A */\n#ifndef ANSI_C\nstatic double max_row_col(A,i,j,l)\nSPMAT	*A;\nint	i, j, l;\n#else\nstatic double max_row_col(SPMAT *A, int i,int j, int l)\n#endif\n{\n    int		row_num, idx;\n    SPROW	*r;\n    row_elt	*e;\n    Real	max_val, tmp;\n\n    if ( ! A )\n	error(E_NULL,""max_row_col"");\n    if ( i < 0 || i > A->n || j < 0 || j >= A->n )\n	error(E_BOUNDS,""max_row_col"");\n\n    max_val = 0.0;\n\n    idx = unord_get_idx(&(A->row[i]),j);\n    if ( idx < 0 )\n    {\n	row_num = -1;	idx = j;\n	e = chase_past(A,j,&row_num,&idx,i);\n    }\n    else\n    {\n	row_num = i;\n	e = &(A->row[i].elt[idx]);\n    }\n    while ( row_num >= 0 && row_num < j )\n    {\n	if ( row_num != l )\n	{\n	    tmp = fabs(e->val);\n	    if ( tmp > max_val )\n		max_val = tmp;\n	}\n	e = bump_col(A,j,&row_num,&idx);\n    }\n    r = &(A->row[j]);\n    for ( idx = 0, e = r->elt; idx < r->len; idx++, e++ )\n    {\n	if ( e->col > j && e->col != l )\n	{\n	    tmp = fabs(e->val);\n	    if ( tmp > max_val )\n		max_val = tmp;\n	}\n    }\n\n    return max_val;\n}\n\n/* nonzeros -- counts non-zeros in A */\n#ifndef ANSI_C\nstatic int	nonzeros(A)\nSPMAT	*A;\n#else\nstatic int	nonzeros(const SPMAT *A)\n#endif\n{\n    int		cnt, i;\n\n    if ( ! A )\n	return 0;\n    cnt = 0;\n    for ( i = 0; i < A->m; i++ )\n	cnt += A->row[i].len;\n\n    return cnt;\n}\n\n/* chk_col_access -- for spBKPfactor()\n	-- checks that column access path is OK */\n#ifndef ANSI_C\nint	chk_col_access(A)\nSPMAT	*A;\n#else\nint	chk_col_access(const SPMAT *A)\n#endif\n{\n    int		cnt_nz, j, row, idx;\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( ! A )\n	error(E_NULL,""chk_col_access"");\n\n    /* count nonzeros as we go down columns */\n    cnt_nz = 0;\n    for ( j = 0; j < A->n; j++ )\n    {\n	row = A->start_row[j];\n	idx = A->start_idx[j];\n	while ( row >= 0 )\n	{\n	    if ( row >= A->m || idx < 0 )\n		return FALSE;\n	    r = &(A->row[row]);\n	    if ( idx >= r->len )\n		return FALSE;\n	    e = &(r->elt[idx]);\n	    if ( e->nxt_row >= 0 && e->nxt_row <= row )\n		return FALSE;\n	    row = e->nxt_row;\n	    idx = e->nxt_idx;\n	    cnt_nz++;\n	}\n    }\n\n    if ( cnt_nz != nonzeros(A) )\n	return FALSE;\n    else\n	return TRUE;\n}\n\n/* col_cmp -- compare two columns -- for sorting rows using qsort() */\n#ifndef ANSI_C\nstatic int	col_cmp(e1,e2)\nrow_elt	*e1, *e2;\n#else\nstatic int	col_cmp(const row_elt *e1, const row_elt *e2)\n#endif\n{\n    return e1->col - e2->col;\n}\n\n/* spBKPfactor -- sparse Bunch-Kaufman-Parlett factorisation of A in-situ\n   -- A is factored into the form P'AP = MDM' where \n   P is a permutation matrix, M lower triangular and D is block\n   diagonal with blocks of size 1 or 2\n   -- P is stored in pivot; blocks[i]==i iff D[i][i] is a block */\n#ifndef ANSI_C\nSPMAT	*spBKPfactor(A,pivot,blocks,tol)\nSPMAT	*A;\nPERM	*pivot, *blocks;\ndouble	tol;\n#else\nSPMAT	*spBKPfactor(SPMAT *A, PERM *pivot, PERM *blocks, double tol)\n#endif\n{\n    int		i, j, k, l, n, onebyone, r;\n    int		idx, idx1, idx_piv;\n    int		row_num;\n    int		best_deg, best_j, best_l, best_cost, mark_cost, deg, deg_j,\n			deg_l, ignore_deg;\n    int		list_idx, list_idx2, old_list_idx;\n    SPROW	*row, *r_piv, *r1_piv;\n    row_elt	*e, *e1;\n    Real	aii, aip1, aip1i;\n    Real	det, max_j, max_l, s, t;\n    STATIC IVEC	*scan_row = IVNULL, *scan_idx = IVNULL, *col_list = IVNULL,\n		*tmp_iv = IVNULL;\n    STATIC IVEC *deg_list = IVNULL;\n    STATIC IVEC	*orig_idx = IVNULL, *orig1_idx = IVNULL;\n    STATIC PERM	*order = PNULL;\n\n    if ( ! A || ! pivot || ! blocks )\n	error(E_NULL,""spBKPfactor"");\n    if ( A->m != A->n )\n	error(E_SQUARE,""spBKPfactor"");\n    if ( A->m != pivot->size || pivot->size != blocks->size )\n	error(E_SIZES,""spBKPfactor"");\n    if ( tol <= 0.0 || tol > 1.0 )\n	error(E_RANGE,""spBKPfactor"");\n    \n    n = A->n;\n    \n    px_ident(pivot);	px_ident(blocks);\n    sp_col_access(A);	sp_diag_access(A);\n    ignore_deg = FALSE;\n\n    deg_list = iv_resize(deg_list,n);\n    if ( order != NULL )\n      px_ident(order);\n    order = px_resize(order,n);\n    MEM_STAT_REG(deg_list,TYPE_IVEC);\n    MEM_STAT_REG(order,TYPE_PERM);\n\n    scan_row = iv_resize(scan_row,5);\n    scan_idx = iv_resize(scan_idx,5);\n    col_list = iv_resize(col_list,5);\n    orig_idx = iv_resize(orig_idx,5);\n    orig_idx = iv_resize(orig1_idx,5);\n    orig_idx = iv_resize(tmp_iv,5);\n    MEM_STAT_REG(scan_row,TYPE_IVEC);\n    MEM_STAT_REG(scan_idx,TYPE_IVEC);\n    MEM_STAT_REG(col_list,TYPE_IVEC);\n    MEM_STAT_REG(orig_idx,TYPE_IVEC);\n    MEM_STAT_REG(orig1_idx,TYPE_IVEC);\n    MEM_STAT_REG(tmp_iv,TYPE_IVEC);\n\n    for ( i = 0; i < n-1; i = onebyone ? i+1 : i+2 )\n    {\n	/* now we want to use a Markowitz-style selection rule for\n	   determining which rows to swap and whether to use\n	   1x1 or 2x2 pivoting */\n\n	/* get list of degrees of nodes */\n	deg_list = iv_resize(deg_list,n-i);\n	if ( ! ignore_deg )\n	    for ( j = i; j < n; j++ )\n		deg_list->ive[j-i] = 0;\n	else\n	{\n	    for ( j = i; j < n; j++ )\n		deg_list->ive[j-i] = 1;\n	    if ( i < n )\n		deg_list->ive[0] = 0;\n	}\n	order = px_resize(order,n-i);\n	px_ident(order);\n\n	if ( ! ignore_deg )\n	{\n	    for ( j = i; j < n; j++ )\n	    {\n		/* idx = sprow_idx(&(A->row[j]),j+1); */\n		/* idx = fixindex(idx); */\n		idx = 0;\n		row = &(A->row[j]);\n		e = &(row->elt[idx]);\n		/* deg_list->ive[j-i] += row->len - idx; */\n		for ( ; idx < row->len; idx++, e++ )\n		    if ( e->col >= i )\n			deg_list->ive[e->col - i]++;\n	    }\n	    /* now deg_list[k] == degree of node k+i */\n	    \n	    /* now sort them into increasing order */\n	    iv_sort(deg_list,order);\n	    /* now deg_list[idx] == degree of node i+order[idx] */\n	}\n\n	/* now we can chase through the nodes in order of increasing\n	   degree, picking out the ones that satisfy our stability\n	   criterion */\n	list_idx = 0;	r = -1;\n	best_j = best_l = -1;\n	for ( deg = 0; deg <= n; deg++ )\n	{\n	    Real	ajj, all, ajl;\n\n	    if ( list_idx >= deg_list->dim )\n		break;	/* That's all folks! */\n	    old_list_idx = list_idx;\n	    while ( list_idx < deg_list->dim &&\n		    deg_list->ive[list_idx] <= deg )\n	    {\n		j = i+order->pe[list_idx];\n		if ( j < i )\n		    continue;\n		/* can we use row/col j for a 1 x 1 pivot? */\n		/* find max_j = max_{k>=i} {|A[k][j]|,|A[j][k]|} */\n		ajj = fabs(unord_get_val(A,j,j));\n		if ( ajj == 0.0 )\n		{\n		    list_idx++;\n		    continue;	/* can't use this for 1 x 1 pivot */\n		}\n\n		max_j = max_row_col(A,i,j,-1);\n		if ( ajj >= tol/* *alpha */ *max_j )\n		{\n		    onebyone = TRUE;\n		    best_j = j;\n		    best_deg = deg_list->ive[list_idx];\n		    break;\n		}\n		list_idx++;\n	    }\n	    if ( best_j >= 0 )\n		break;\n	    best_cost = 2*n;	/* > any possible Markowitz cost (bound) */\n	    best_j = best_l = -1;\n	    list_idx = old_list_idx;\n	    while ( list_idx < deg_list->dim &&\n		    deg_list->ive[list_idx] <= deg )\n	    {\n		j = i+order->pe[list_idx];\n		ajj = fabs(unord_get_val(A,j,j));\n		for ( list_idx2 = 0; list_idx2 < list_idx; list_idx2++ )\n		{\n		    deg_j = deg;\n		    deg_l = deg_list->ive[list_idx2];\n		    l = i+order->pe[list_idx2];\n		    if ( l < i )\n			continue;\n		    /* try using rows/cols (j,l) for a 2 x 2 pivot block */\n		    all = fabs(unord_get_val(A,l,l));\n		    ajl = ( j > l ) ? fabs(unord_get_val(A,l,j)) :\n					   fabs(unord_get_val(A,j,l));\n		    det = fabs(ajj*all - ajl*ajl);\n		    if ( det == 0.0 )\n			continue;\n		    max_j = max_row_col(A,i,j,l);\n		    max_l = max_row_col(A,i,l,j);\n		    if ( tol*(all*max_j+ajl*max_l) < det &&\n			 tol*(ajl*max_j+ajj*max_l) < det )\n		    {\n			/* acceptably stable 2 x 2 pivot */\n			/* this is actually an overestimate of the\n			   Markowitz cost for choosing (j,l) */\n			mark_cost = (ajj == 0.0) ?\n			    ((all == 0.0) ? deg_j+deg_l : deg_j+2*deg_l) :\n				((all == 0.0) ? 2*deg_j+deg_l :\n				 2*(deg_j+deg_l));\n			if ( mark_cost < best_cost )\n			{\n			    onebyone = FALSE;\n			    best_cost = mark_cost;\n			    best_j = j;\n			    best_l = l;\n			    best_deg = deg_j;\n			}\n		    }\n		}\n		list_idx++;\n	    }\n	    if ( best_j >= 0 )\n		break;\n	}\n\n	if ( best_deg > (int)floor(0.8*(n-i)) )\n	    ignore_deg = TRUE;\n\n	/* now do actual interchanges */\n	if ( best_j >= 0 && onebyone )\n	{\n	    bkp_interchange(A,i,best_j);\n	    px_transp(pivot,i,best_j);\n	}\n	else if ( best_j >= 0 && best_l >= 0 && ! onebyone )\n	{\n	    if ( best_j == i || best_j == i+1 )\n	    {\n		if ( best_l == i || best_l == i+1 )\n		{\n		    /* no pivoting, but must update blocks permutation */\n		    px_transp(blocks,i,i+1);\n		    goto dopivot;\n		}\n		bkp_interchange(A,(best_j == i) ? i+1 : i,best_l);\n		px_transp(pivot,(best_j == i) ? i+1 : i,best_l);\n	    }\n	    else if ( best_l == i || best_l == i+1 )\n	    {\n		bkp_interchange(A,(best_l == i) ? i+1 : i,best_j);\n		px_transp(pivot,(best_l == i) ? i+1 : i,best_j);\n	    }\n	    else /* best_j & best_l outside i, i+1 */\n	    {\n		if ( i != best_j )\n		{\n		    bkp_interchange(A,i,best_j);\n		    px_transp(pivot,i,best_j);\n		}\n		if ( i+1 != best_l )\n		{\n		    bkp_interchange(A,i+1,best_l);\n		    px_transp(pivot,i+1,best_l);\n		}\n	    }\n	}\n	else	/* can't pivot &/or nothing to pivot */\n	    continue;\n\n	/* update blocks permutation */\n	if ( ! onebyone )\n	    px_transp(blocks,i,i+1);\n\n	dopivot:\n	if ( onebyone )\n	{\n	    int		idx_j, idx_k, s_idx, s_idx2;\n	    row_elt	*e_ij, *e_ik;\n\n	    r_piv = &(A->row[i]);\n	    idx_piv = unord_get_idx(r_piv,i);\n	    /* if idx_piv < 0 then aii == 0 and no pivoting can be done;\n	       -- this means that we should continue to the next iteration */\n	    if ( idx_piv < 0 )\n		continue;\n	    aii = r_piv->elt[idx_piv].val;\n	    if ( aii == 0.0 )\n		continue;\n\n	    /* for ( j = i+1; j < n; j++ )  { ... pivot step ... } */\n	    /* initialise scan_... etc for the 1 x 1 pivot */\n	    scan_row = iv_resize(scan_row,r_piv->len);\n	    scan_idx = iv_resize(scan_idx,r_piv->len);\n	    col_list = iv_resize(col_list,r_piv->len);\n	    orig_idx = iv_resize(orig_idx,r_piv->len);\n	    row_num = i;	s_idx = idx = 0;\n	    e = &(r_piv->elt[idx]);\n	    for ( idx = 0; idx < r_piv->len; idx++, e++ )\n	    {\n		if ( e->col < i )\n		    continue;\n		scan_row->ive[s_idx] = i;\n		scan_idx->ive[s_idx] = idx;\n		orig_idx->ive[s_idx] = idx;\n		col_list->ive[s_idx] = e->col;\n		s_idx++;\n	    }\n	    scan_row = iv_resize(scan_row,s_idx);\n	    scan_idx = iv_resize(scan_idx,s_idx);\n	    col_list = iv_resize(col_list,s_idx);\n	    orig_idx = iv_resize(orig_idx,s_idx);\n\n	    order = px_resize(order,scan_row->dim);\n	    px_ident(order);\n	    iv_sort(col_list,order);\n\n	    tmp_iv = iv_resize(tmp_iv,scan_row->dim);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_idx);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_row->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_row);\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n		tmp_iv->ive[idx] = orig_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,orig_idx);\n\n	    /* now do actual pivot */\n	    /* for ( j = i+1; j < n-1; j++ ) .... */\n\n	    for ( s_idx = 0; s_idx < scan_row->dim; s_idx++ )\n	    {\n		idx_j = orig_idx->ive[s_idx];\n		if ( idx_j < 0 )\n		    error(E_INTERN,""spBKPfactor"");\n		e_ij = &(r_piv->elt[idx_j]);\n		j = e_ij->col;\n		if ( j < i+1 )\n		    continue;\n		scan_to(A,scan_row,scan_idx,col_list,j);\n\n		/* compute multiplier */\n		t = e_ij->val / aii;\n\n		/* for ( k = j; k < n; k++ ) { .... update A[j][k] .... } */\n		/* this is the row in which pivoting is done */\n		row = &(A->row[j]);\n		for ( s_idx2 = s_idx; s_idx2 < scan_row->dim; s_idx2++ )\n		{\n		    idx_k = orig_idx->ive[s_idx2];\n		    e_ik = &(r_piv->elt[idx_k]);\n		    k = e_ik->col;\n		    /* k >= j since col_list has been sorted */\n\n		    if ( scan_row->ive[s_idx2] == j )\n		    {	/* no fill-in -- can be done directly */\n			idx = scan_idx->ive[s_idx2];\n			/* idx = sprow_idx2(row,k,idx); */\n			row->elt[idx].val -= t*e_ik->val;\n		    }\n		    else\n		    {	/* fill-in -- insert entry & patch column */\n			int	old_row, old_idx;\n			row_elt	*old_e, *new_e;\n\n			old_row = scan_row->ive[s_idx2];\n			old_idx = scan_idx->ive[s_idx2];\n			/* old_idx = sprow_idx2(&(A->row[old_row]),k,old_idx); */\n\n			if ( old_idx < 0 )\n			    error(E_INTERN,""spBKPfactor"");\n			/* idx = sprow_idx(row,k); */\n			/* idx = fixindex(idx); */\n			idx = row->len;\n\n			/* sprow_set_val(row,k,-t*e_ik->val); */\n			if ( row->len >= row->maxlen )\n			{ tracecatch(sprow_xpd(row,2*row->maxlen+1,TYPE_SPMAT),\n				     ""spBKPfactor"");		}\n\n			row->len = idx+1;\n\n			new_e = &(row->elt[idx]);\n			new_e->val = -t*e_ik->val;\n			new_e->col = k;\n\n			old_e = &(A->row[old_row].elt[old_idx]);\n			new_e->nxt_row = old_e->nxt_row;\n			new_e->nxt_idx = old_e->nxt_idx;\n			old_e->nxt_row = j;\n			old_e->nxt_idx = idx;\n		    }\n		}\n		e_ij->val = t;\n	    }\n	}\n	else /* onebyone == FALSE */\n	{	/* do 2 x 2 pivot */\n	    int	idx_k, idx1_k, s_idx, s_idx2;\n	    int	old_col;\n	    row_elt	*e_tmp;\n\n	    r_piv = &(A->row[i]);\n	    idx_piv = unord_get_idx(r_piv,i);\n	    aii = aip1i = 0.0;\n	    e_tmp = r_piv->elt;\n	    for ( idx_piv = 0; idx_piv < r_piv->len; idx_piv++, e_tmp++ )\n		if ( e_tmp->col == i )\n		    aii = e_tmp->val;\n	        else if ( e_tmp->col == i+1 )\n		    aip1i = e_tmp->val;\n\n	    r1_piv = &(A->row[i+1]);\n	    e_tmp = r1_piv->elt;\n	    aip1 = unord_get_val(A,i+1,i+1);\n	    det = aii*aip1 - aip1i*aip1i;	/* Must have det < 0 */\n	    if ( aii == 0.0 && aip1i == 0.0 )\n	    {\n		/* error(E_RANGE,""spBKPfactor""); */\n		onebyone = TRUE;\n		continue;	/* cannot pivot */\n	    }\n\n	    if ( det == 0.0 )\n	    {\n		if ( aii != 0.0 )\n		    error(E_RANGE,""spBKPfactor"");\n		onebyone = TRUE;\n		continue;	/* cannot pivot */\n	    }\n	    aip1i = aip1i/det;\n	    aii = aii/det;\n	    aip1 = aip1/det;\n	    \n	    /* initialise scan_... etc for the 2 x 2 pivot */\n	    s_idx = r_piv->len + r1_piv->len;\n	    scan_row = iv_resize(scan_row,s_idx);\n	    scan_idx = iv_resize(scan_idx,s_idx);\n	    col_list = iv_resize(col_list,s_idx);\n	    orig_idx = iv_resize(orig_idx,s_idx);\n	    orig1_idx = iv_resize(orig1_idx,s_idx);\n\n	    e = r_piv->elt;\n	    for ( idx = 0; idx < r_piv->len; idx++, e++ )\n	    {\n		scan_row->ive[idx] = i;\n		scan_idx->ive[idx] = idx;\n		col_list->ive[idx] = e->col;\n		orig_idx->ive[idx] = idx;\n		orig1_idx->ive[idx] = -1;\n	    }\n	    e = r_piv->elt;\n	    e1 = r1_piv->elt;\n	    for ( idx = 0; idx < r1_piv->len; idx++, e1++ )\n	    {\n		scan_row->ive[idx+r_piv->len] = i+1;\n		scan_idx->ive[idx+r_piv->len] = idx;\n		col_list->ive[idx+r_piv->len] = e1->col;\n		orig_idx->ive[idx+r_piv->len] = -1;\n		orig1_idx->ive[idx+r_piv->len] = idx;\n	    }\n\n	    e1 = r1_piv->elt;\n	    order = px_resize(order,scan_row->dim);\n	    px_ident(order);\n	    iv_sort(col_list,order);\n	    tmp_iv = iv_resize(tmp_iv,scan_row->dim);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_idx);\n	    for ( idx = 0; idx < order->size; idx++ )\n		tmp_iv->ive[idx] = scan_row->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,scan_row);\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n		tmp_iv->ive[idx] = orig_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,orig_idx);\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n		tmp_iv->ive[idx] = orig1_idx->ive[order->pe[idx]];\n	    iv_copy(tmp_iv,orig1_idx);\n\n	    s_idx = 0;\n	    old_col = -1;\n	    for ( idx = 0; idx < scan_row->dim; idx++ )\n	    {\n		if ( col_list->ive[idx] == old_col )\n		{\n		    if ( scan_row->ive[idx] == i )\n		    {\n			scan_row->ive[s_idx-1] = scan_row->ive[idx];\n			scan_idx->ive[s_idx-1] = scan_idx->ive[idx];\n			col_list->ive[s_idx-1] = col_list->ive[idx];\n			orig_idx->ive[s_idx-1] = orig_idx->ive[idx];\n			orig1_idx->ive[s_idx-1] = orig1_idx->ive[idx-1];\n		    }\n		    else if ( idx > 0 )\n		    {\n			scan_row->ive[s_idx-1] = scan_row->ive[idx-1];\n			scan_idx->ive[s_idx-1] = scan_idx->ive[idx-1];\n			col_list->ive[s_idx-1] = col_list->ive[idx-1];\n			orig_idx->ive[s_idx-1] = orig_idx->ive[idx-1];\n			orig1_idx->ive[s_idx-1] = orig1_idx->ive[idx];\n		    }\n		}\n		else\n		{\n		    scan_row->ive[s_idx] = scan_row->ive[idx];\n		    scan_idx->ive[s_idx] = scan_idx->ive[idx];\n		    col_list->ive[s_idx] = col_list->ive[idx];\n		    orig_idx->ive[s_idx] = orig_idx->ive[idx];\n		    orig1_idx->ive[s_idx] = orig1_idx->ive[idx];\n		    s_idx++;\n		}\n		old_col = col_list->ive[idx];\n	    }\n	    scan_row = iv_resize(scan_row,s_idx);\n	    scan_idx = iv_resize(scan_idx,s_idx);\n	    col_list = iv_resize(col_list,s_idx);\n	    orig_idx = iv_resize(orig_idx,s_idx);\n	    orig1_idx = iv_resize(orig1_idx,s_idx);\n\n	    /* for ( j = i+2; j < n; j++ )  { .... row operation .... } */\n	    for ( s_idx = 0; s_idx < scan_row->dim; s_idx++ )\n	    {\n		int	idx_piv, idx1_piv;\n		Real	aip1j, aij, aik, aip1k;\n		row_elt	*e_ik, *e_ip1k;\n\n		j = col_list->ive[s_idx];\n		if ( j < i+2 )\n		    continue;\n		tracecatch(scan_to(A,scan_row,scan_idx,col_list,j),\n			   ""spBKPfactor"");\n\n		idx_piv = orig_idx->ive[s_idx];\n		aij = ( idx_piv < 0 ) ? 0.0 : r_piv->elt[idx_piv].val;\n		/* aij = ( s_idx < r_piv->len ) ? r_piv->elt[s_idx].val :\n		    0.0; */\n		/* aij   = sp_get_val(A,i,j); */\n		idx1_piv = orig1_idx->ive[s_idx];\n		aip1j = ( idx1_piv < 0 ) ? 0.0 : r1_piv->elt[idx1_piv].val;\n		/* aip1j = ( s_idx < r_piv->len ) ? 0.0 :\n		    r1_piv->elt[s_idx-r_piv->len].val; */\n		/* aip1j = sp_get_val(A,i+1,j); */\n		s = - aip1i*aip1j + aip1*aij;\n		t = - aip1i*aij + aii*aip1j;\n\n		/* for ( k = j; k < n; k++ )  { .... update entry .... } */\n		row = &(A->row[j]);\n		/* set idx_k and idx1_k indices */\n		s_idx2 = s_idx;\n		k = col_list->ive[s_idx2];\n		idx_k = orig_idx->ive[s_idx2];\n		idx1_k = orig1_idx->ive[s_idx2];\n\n		while ( s_idx2 < scan_row->dim )\n		{\n		    k = col_list->ive[s_idx2];\n		    idx_k = orig_idx->ive[s_idx2];\n		    idx1_k = orig1_idx->ive[s_idx2];\n		    e_ik = ( idx_k < 0 ) ? (row_elt *)NULL :\n			&(r_piv->elt[idx_k]);\n		    e_ip1k = ( idx1_k < 0 ) ? (row_elt *)NULL :\n			&(r1_piv->elt[idx1_k]);\n		    aik = ( idx_k >= 0 ) ? e_ik->val : 0.0;\n		    aip1k = ( idx1_k >= 0 ) ? e_ip1k->val : 0.0;\n		    if ( scan_row->ive[s_idx2] == j )\n		    {	/* no fill-in */\n			row = &(A->row[j]);\n			/* idx = sprow_idx(row,k); */\n			idx = scan_idx->ive[s_idx2];\n			if ( idx < 0 )\n			    error(E_INTERN,""spBKPfactor"");\n			row->elt[idx].val -= s*aik + t*aip1k;\n		    }\n		    else\n		    {	/* fill-in -- insert entry & patch column */\n			Real	tmp;\n			int	old_row, old_idx;\n			row_elt	*old_e, *new_e;\n\n			tmp = - s*aik - t*aip1k;\n			if ( tmp != 0.0 )\n			{\n			    row = &(A->row[j]);\n			    old_row = scan_row->ive[s_idx2];\n			    old_idx = scan_idx->ive[s_idx2];\n\n			    idx = row->len;\n			    if ( row->len >= row->maxlen )\n			    {  tracecatch(sprow_xpd(row,2*row->maxlen+1,\n						    TYPE_SPMAT),\n					   ""spBKPfactor"");	    }\n\n			    row->len = idx + 1;\n			    /* idx = sprow_idx(row,k); */\n			    new_e = &(row->elt[idx]);\n			    new_e->val = tmp;\n			    new_e->col = k;\n\n			    if ( old_row < 0 )\n				error(E_INTERN,""spBKPfactor"");\n			    /* old_idx = sprow_idx2(&(A->row[old_row]),\n						  k,old_idx); */\n			    old_e = &(A->row[old_row].elt[old_idx]);\n			    new_e->nxt_row = old_e->nxt_row;\n			    new_e->nxt_idx = old_e->nxt_idx;\n			    old_e->nxt_row = j;\n			    old_e->nxt_idx = idx;\n			}\n		    }\n\n		    /* update idx_k, idx1_k, s_idx2 etc */\n		    s_idx2++;\n		}\n\n		/* store multipliers -- may involve fill-in (!) */\n		/* idx = sprow_idx(r_piv,j); */\n		idx = orig_idx->ive[s_idx];\n		if ( idx >= 0 )\n		{\n		    r_piv->elt[idx].val = s;\n		}\n		else if ( s != 0.0 )\n		{\n		    int		old_row, old_idx;\n		    row_elt	*new_e, *old_e;\n\n		    old_row = -1;	old_idx = j;\n\n		    if ( i > 0 )\n		    {\n			tracecatch(chase_col(A,j,&old_row,&old_idx,i-1),\n				   ""spBKPfactor"");\n		    }\n		    /* sprow_set_val(r_piv,j,s); */\n		    idx = r_piv->len;\n		    if ( r_piv->len >= r_piv->maxlen )\n		    {	tracecatch(sprow_xpd(r_piv,2*r_piv->maxlen+1,\n					     TYPE_SPMAT),\n				   ""spBKPfactor"");		    }\n\n		    r_piv->len = idx + 1;\n		    /* idx = sprow_idx(r_piv,j); */\n		    /* if ( idx < 0 )\n			error(E_INTERN,""spBKPfactor""); */\n		    new_e = &(r_piv->elt[idx]);\n		    new_e->val = s;\n		    new_e->col = j;\n		    if ( old_row < 0 )\n		    {\n			new_e->nxt_row = A->start_row[j];\n			new_e->nxt_idx = A->start_idx[j];\n			A->start_row[j] = i;\n			A->start_idx[j] = idx;\n		    }\n		    else\n		    {\n			/* old_idx = sprow_idx2(&(A->row[old_row]),j,old_idx);*/\n			if ( old_idx < 0 )\n			    error(E_INTERN,""spBKPfactor"");\n			old_e = &(A->row[old_row].elt[old_idx]);\n			new_e->nxt_row = old_e->nxt_row;\n			new_e->nxt_idx = old_e->nxt_idx;\n			old_e->nxt_row = i;\n			old_e->nxt_idx = idx;\n		    }\n		}\n		/* idx1 = sprow_idx(r1_piv,j); */\n		idx1 = orig1_idx->ive[s_idx];\n		if ( idx1 >= 0 )\n		{\n		    r1_piv->elt[idx1].val = t;\n		}\n		else if ( t != 0.0 )\n		{\n		    int		old_row, old_idx;\n		    row_elt	*new_e, *old_e;\n\n		    old_row = -1;	old_idx = j;\n		    tracecatch(chase_col(A,j,&old_row,&old_idx,i),\n			       ""spBKPfactor"");\n		    /* sprow_set_val(r1_piv,j,t); */\n		    idx1 = r1_piv->len;\n		    if ( r1_piv->len >= r1_piv->maxlen )\n		    {	tracecatch(sprow_xpd(r1_piv,2*r1_piv->maxlen+1,\n					     TYPE_SPMAT),\n				   ""spBKPfactor"");		    }\n\n		    r1_piv->len = idx1 + 1;\n		    /* idx1 = sprow_idx(r1_piv,j); */\n		    /* if ( idx < 0 )\n			error(E_INTERN,""spBKPfactor""); */\n		    new_e = &(r1_piv->elt[idx1]);\n		    new_e->val = t;\n		    new_e->col = j;\n		    if ( idx1 < 0 )\n			error(E_INTERN,""spBKPfactor"");\n		    new_e = &(r1_piv->elt[idx1]);\n		    if ( old_row < 0 )\n		    {\n			new_e->nxt_row = A->start_row[j];\n			new_e->nxt_idx = A->start_idx[j];\n			A->start_row[j] = i+1;\n			A->start_idx[j] = idx1;\n		    }\n		    else\n		    {\n			old_idx = sprow_idx2(&(A->row[old_row]),j,old_idx);\n			if ( old_idx < 0 )\n			    error(E_INTERN,""spBKPfactor"");\n			old_e = &(A->row[old_row].elt[old_idx]);\n			new_e->nxt_row = old_e->nxt_row;\n			new_e->nxt_idx = old_e->nxt_idx;\n			old_e->nxt_row = i+1;\n			old_e->nxt_idx = idx1;\n		    }\n		}\n	    }\n	}\n    }\n\n    /* now sort the rows arrays */\n    for ( i = 0; i < A->m; i++ )\n	qsort(A->row[i].elt,A->row[i].len,sizeof(row_elt),(int(*)())col_cmp);\n    A->flag_col = A->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n    IV_FREE(scan_row);	IV_FREE(scan_idx);	IV_FREE(col_list);\n    IV_FREE(tmp_iv);	IV_FREE(deg_list);	IV_FREE(orig_idx);\n    IV_FREE(orig1_idx);	PX_FREE(order);\n#endif\n    return A;\n}\n\n/* spBKPsolve -- solves A.x = b where A has been factored a la BKPfactor()\n   -- returns x, which is created if NULL */\n#ifndef ANSI_C\nVEC	*spBKPsolve(A,pivot,block,b,x)\nSPMAT	*A;\nPERM	*pivot, *block;\nVEC	*b, *x;\n#else\nVEC	*spBKPsolve(SPMAT *A, PERM *pivot, PERM *block,\n		    const VEC *b, VEC *x)\n#endif\n{\n    STATIC VEC	*tmp=VNULL;	/* dummy storage needed */\n    int		i /* , j */, n, onebyone;\n    int		row_num, idx;\n    Real	a11, a12, a22, b1, b2, det, sum, *tmp_ve, tmp_diag;\n    SPROW	*r;\n    row_elt	*e;\n    \n    if ( ! A || ! pivot || ! block || ! b )\n	error(E_NULL,""spBKPsolve"");\n    if ( A->m != A->n )\n	error(E_SQUARE,""spBKPsolve"");\n    n = A->n;\n    if ( b->dim != n || pivot->size != n || block->size != n )\n	error(E_SIZES,""spBKPsolve"");\n    x = v_resize(x,n);\n    tmp = v_resize(tmp,n);\n    MEM_STAT_REG(tmp,TYPE_VEC);\n    \n    tmp_ve = tmp->ve;\n\n    if ( ! A->flag_col )\n	sp_col_access(A);\n\n    px_vec(pivot,b,tmp);\n    /* printf(""# BKPsolve: effect of pivot: tmp =\n"");	v_output(tmp); */\n\n    /* solve for lower triangular part */\n    for ( i = 0; i < n; i++ )\n    {\n	sum = tmp_ve[i];\n	if ( block->pe[i] < i )\n	{\n	    /* for ( j = 0; j < i-1; j++ )\n		  sum -= A_me[j][i]*tmp_ve[j]; */\n	    row_num = -1;	idx = i;\n	    e = bump_col(A,i,&row_num,&idx);\n	    while ( row_num >= 0 && row_num < i-1 )\n	    {\n		sum -= e->val*tmp_ve[row_num];\n		e = bump_col(A,i,&row_num,&idx);\n	    }\n	}\n	else\n	{\n	    /* for ( j = 0; j < i; j++ )\n	          sum -= A_me[j][i]*tmp_ve[j]; */\n	    row_num = -1; idx = i;\n	    e = bump_col(A,i,&row_num,&idx);\n	    while ( row_num >= 0 && row_num < i )\n	    {\n		sum -= e->val*tmp_ve[row_num];\n		e = bump_col(A,i,&row_num,&idx);\n	    }\n	}\n	tmp_ve[i] = sum;\n    }\n\n    /* printf(""# BKPsolve: solving L part: tmp =\n"");	v_output(tmp); */\n    /* solve for diagonal part */\n    for ( i = 0; i < n; i = onebyone ? i+1 : i+2 )\n    {\n	onebyone = ( block->pe[i] == i );\n	if ( onebyone )\n	{\n	    /* tmp_ve[i] /= A_me[i][i]; */\n	    tmp_diag = sp_get_val(A,i,i);\n	    if ( tmp_diag == 0.0 )\n		error(E_SING,""spBKPsolve"");\n	    tmp_ve[i] /= tmp_diag;\n	}\n	else\n	{\n	    a11 = sp_get_val(A,i,i);\n	    a22 = sp_get_val(A,i+1,i+1);\n	    a12 = sp_get_val(A,i,i+1);\n	    b1 = tmp_ve[i];\n	    b2 = tmp_ve[i+1];\n	    det = a11*a22-a12*a12;	/* < 0 : see BKPfactor() */\n	    if ( det == 0.0 )\n		error(E_SING,""BKPsolve"");\n	    det = 1/det;\n	    tmp_ve[i]   = det*(a22*b1-a12*b2);\n	    tmp_ve[i+1] = det*(a11*b2-a12*b1);\n	}\n    }\n\n    /* printf(""# BKPsolve: solving D part: tmp =\n"");	v_output(tmp); */\n    /* solve for transpose of lower triangular part */\n    for ( i = n-2; i >= 0; i-- )\n    {\n	sum = tmp_ve[i];\n	if ( block->pe[i] > i )\n	{\n	    /* onebyone is false */\n	    /* for ( j = i+2; j < n; j++ )\n		  sum -= A_me[i][j]*tmp_ve[j]; */\n	    if ( i+2 >= n )\n		continue;\n	    r = &(A->row[i]);\n	    idx = sprow_idx(r,i+2);\n	    idx = fixindex(idx);\n	    e = &(r->elt[idx]);\n	    for ( ; idx < r->len; idx++, e++ )\n		sum -= e->val*tmp_ve[e->col];\n	}\n	else /* onebyone */\n	{\n	    /* for ( j = i+1; j < n; j++ )\n		  sum -= A_me[i][j]*tmp_ve[j]; */\n	    r = &(A->row[i]);\n	    idx = sprow_idx(r,i+1);\n	    idx = fixindex(idx);\n	    e = &(r->elt[idx]);\n	    for ( ; idx < r->len; idx++, e++ )\n		sum -= e->val*tmp_ve[e->col];\n	}\n	tmp_ve[i] = sum;\n    }\n\n    /* printf(""# BKPsolve: solving L^T part: tmp =\n"");v_output(tmp); */\n    /* and do final permutation */\n    x = pxinv_vec(pivot,tmp,x);\n\n#ifdef	THREADSAFE\n    V_FREE(tmp);\n#endif\n\n    return x;\n}\n\n\n\n"
leukocyte/meschach_lib/sprow.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  Sparse rows package\n  See also: sparse.h, matrix.h\n  */\n\n#include	<stdio.h>\n#include	<math.h>\n#include        <stdlib.h>\n#include	""sparse.h""\n\n\nstatic char	rcsid[] = ""$Id: sprow.c,v 1.1 1994/01/13 05:35:36 des Exp $"";\n\n#define	MINROWLEN	10\n\n\n#ifndef MEX\n/* sprow_dump - prints relevant information about the sparse row r */\n#ifndef ANSI_C\nvoid sprow_dump(fp,r)\nFILE *fp;\nSPROW *r;\n#else\nvoid sprow_dump(FILE *fp, const SPROW *r)\n#endif\n{\n   int  j_idx;\n   row_elt *elts;\n   \n   fprintf(fp,""SparseRow dump:\n"");\n   if ( ! r )\n   {       fprintf(fp,""*** NULL row ***\n"");   return; }\n   \n   fprintf(fp,""row: len = %d, maxlen = %d, diag idx = %d\n"",\n	   r->len,r->maxlen,r->diag);\n   fprintf(fp,""element list @ 0x%lx\n"",(long)(r->elt));\n   if ( ! r->elt )\n   {\n      fprintf(fp,""*** NULL element list ***\n"");\n      return;\n   }\n   elts = r->elt;\n   for ( j_idx = 0; j_idx < r->len; j_idx++, elts++ )\n     fprintf(fp,""Col: %d, Val: %g, nxt_row = %d, nxt_idx = %d\n"",\n	     elts->col,elts->val,elts->nxt_row,elts->nxt_idx);\n   fprintf(fp,""\n"");\n}\n#endif /* MEX */\n\n/* sprow_idx -- get index into row for a given column in a given row\n   -- return -1 on error\n   -- return -(idx+2) where idx is index to insertion point */\n#ifndef ANSI_C\nint	sprow_idx(r,col)\nSPROW	*r;\nint	col;\n#else\nint	sprow_idx(const SPROW *r, int col)\n#endif\n{\n   register int		lo, hi, mid;\n   int			tmp;\n   register row_elt	*r_elt;\n   \n   /*******************************************\n     if ( r == (SPROW *)NULL )\n     return -1;\n     if ( col < 0 )\n     return -1;\n     *******************************************/\n   \n   r_elt = r->elt;\n   if ( r->len <= 0 )\n     return -2;\n   \n   /* try the hint */\n   /* if ( hint >= 0 && hint < r->len && r_elt[hint].col == col )\n      return hint; */\n   \n   /* otherwise use binary search... */\n   /* code from K&R Ch. 6, p. 125 */\n   lo = 0;		hi = r->len - 1;	mid = lo;\n   while ( lo <= hi )\n   {\n      mid = (hi + lo)/2;\n      if ( (tmp=r_elt[mid].col-col) > 0 )\n	hi = mid-1;\n      else if ( tmp < 0 )\n	lo = mid+1;\n      else /* tmp == 0 */\n	return mid;\n   }\n   tmp = r_elt[mid].col - col;\n   \n   if ( tmp > 0 )\n     return -(mid+2);	/* insert at mid   */\n   else /* tmp < 0 */\n     return -(mid+3);	/* insert at mid+1 */\n}\n\n\n/* sprow_get -- gets, initialises and returns a SPROW structure\n   -- max. length is maxlen */\n#ifndef ANSI_C\nSPROW	*sprow_get(maxlen)\nint	maxlen;\n#else\nSPROW	*sprow_get(int maxlen)\n#endif\n{\n   SPROW	*r;\n   \n   if ( maxlen < 0 )\n     error(E_NEG,""sprow_get"");\n\n   r = NEW(SPROW);\n   if ( ! r )\n     error(E_MEM,""sprow_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPROW,0,sizeof(SPROW));\n      mem_numvar(TYPE_SPROW,1);\n   }\n   r->elt = NEW_A(maxlen,row_elt);\n   if ( ! r->elt )\n     error(E_MEM,""sprow_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPROW,0,maxlen*sizeof(row_elt));\n   }\n   r->len = 0;\n   r->maxlen = maxlen;\n   r->diag = -1;\n   \n   return r;\n}\n\n\n/* sprow_xpd -- expand row by means of realloc()\n   -- type must be TYPE_SPMAT if r is a row of a SPMAT structure,\n      otherwise it must be TYPE_SPROW\n   -- returns r */\n#ifndef ANSI_C\nSPROW	*sprow_xpd(r,n,type)\nSPROW	*r;\nint	n,type;\n#else\nSPROW	*sprow_xpd(SPROW *r, int n, int type)\n#endif\n{\n   int	newlen;\n   \n   if ( ! r ) {\n     r = NEW(SPROW);\n     if (! r ) \n       error(E_MEM,""sprow_xpd"");\n     else if ( mem_info_is_on()) {\n	if (type != TYPE_SPMAT && type != TYPE_SPROW)\n	  warning(WARN_WRONG_TYPE,""sprow_xpd"");\n	mem_bytes(type,0,sizeof(SPROW));\n	if (type == TYPE_SPROW)\n	  mem_numvar(type,1);\n     }\n   }\n\n   if ( ! r->elt )\n   {\n      r->elt = NEW_A((unsigned)n,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,""sprow_xpd"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(type,0,n*sizeof(row_elt));\n      }\n      r->len = 0;\n      r->maxlen = n;\n      return r;\n   }\n   if ( n <= r->len )\n     newlen = max(2*r->len + 1,MINROWLEN);\n   else\n     newlen = n;\n   if ( newlen <= r->maxlen )\n   {\n      MEM_ZERO((char *)(&(r->elt[r->len])),\n	       (newlen-r->len)*sizeof(row_elt));\n      r->len = newlen;\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(type,r->maxlen*sizeof(row_elt),\n		     newlen*sizeof(row_elt)); \n      }\n      r->elt = RENEW(r->elt,newlen,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,""sprow_xpd"");\n      r->maxlen = newlen;\n      r->len = newlen;\n   }\n   \n   return r;\n}\n\n/* sprow_resize -- resize a SPROW variable by means of realloc()\n   -- n is a new size\n   -- returns r */\n#ifndef ANSI_C\nSPROW	*sprow_resize(r,n,type)\nSPROW	*r;\nint	n,type;\n#else\nSPROW	*sprow_resize(SPROW *r, int n, int type)\n#endif\n{\n   if (n < 0)\n     error(E_NEG,""sprow_resize"");\n\n   if ( ! r ) \n     return sprow_get(n);\n   \n   if (n == r->len)\n     return r;\n\n   if ( ! r->elt )\n   {\n      r->elt = NEW_A((unsigned)n,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,""sprow_resize"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(type,0,n*sizeof(row_elt));\n      }\n      r->maxlen = r->len = n;\n      return r;\n   }\n\n   if ( n <= r->maxlen )\n     r->len = n;\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(type,r->maxlen*sizeof(row_elt),\n		   n*sizeof(row_elt)); \n      }\n      r->elt = RENEW(r->elt,n,row_elt);\n      if ( ! r->elt )\n	error(E_MEM,""sprow_resize"");\n      r->maxlen = r->len = n;\n   }\n   \n   return r;\n}\n\n\n/* release a row of a matrix */\n#ifndef ANSI_C\nint sprow_free(r)\nSPROW	*r;\n#else\nint sprow_free(SPROW *r)\n#endif\n{\n   if ( ! r )\n     return -1;\n\n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPROW,sizeof(SPROW),0);\n      mem_numvar(TYPE_SPROW,-1);\n   }\n   \n   if ( r->elt )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPROW,r->maxlen*sizeof(row_elt),0);\n      }\n      free((char *)r->elt);\n   }\n   free((char *)r);\n   return 0;\n}\n\n\n/* sprow_merge -- merges r1 and r2 into r_out\n   -- cannot be done in-situ\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_merge(r1,r2,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint type;\n#else\nSPROW	*sprow_merge(const SPROW *r1, const SPROW *r2, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,""sprow_merge"");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,""sprow_merge"");\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   idx1 = idx2 = idx_out = 0;\n   elt1 = r1->elt;	elt2 = r2->elt;	elt_out = r_out->elt;\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->len;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( elt1->col == elt2->col && idx2 < len2 )\n	 {	elt2++;		idx2++;	}\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_copy -- copies r1 and r2 into r_out\n   -- cannot be done in-situ\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_copy(r1,r2,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint type;\n#else\nSPROW	*sprow_copy(const SPROW *r1, const SPROW *r2, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,""sprow_copy"");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,""sprow_copy"");\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   idx1 = idx2 = idx_out = 0;\n   elt1 = r1->elt;	elt2 = r2->elt;	elt_out = r_out->elt;\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      while ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( elt1->col == elt2->col && idx2 < len2 )\n	 {	elt2++;		idx2++;	}\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = 0.0;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_mltadd -- sets r_out <- r1 + alpha.r2\n   -- cannot be in situ\n   -- only for columns j0, j0+1, ...\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_mltadd(r1,r2,alpha,j0,r_out,type)\nSPROW	*r1, *r2, *r_out;\ndouble	alpha;\nint	j0, type;\n#else\nSPROW	*sprow_mltadd(const SPROW *r1,const SPROW *r2, double alpha,\n		      int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,""sprow_mltadd"");\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,""sprow_mltadd"");\n   if ( j0 < 0 )\n     error(E_BOUNDS,""sprow_mltadd"");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   /* idx1 = idx2 = idx_out = 0; */\n   idx1    = sprow_idx(r1,j0);\n   idx2    = sprow_idx(r2,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx2    = (idx2 < 0) ? -(idx2+2) : idx2;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n   elt2    = &(r2->elt[idx2]);\n   elt_out = &(r_out->elt[idx_out]);\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( idx2 < len2 && elt1->col == elt2->col )\n	 {\n	    elt_out->val += alpha*elt2->val;\n	    elt2++;		idx2++;\n	 }\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = alpha*elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_add -- sets r_out <- r1 + r2\n   -- cannot be in situ\n   -- only for columns j0, j0+1, ...\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_add(r1,r2,j0,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint	j0, type;\n#else\nSPROW	*sprow_add(const SPROW *r1,const SPROW *r2, \n		   int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,""sprow_add"");\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,""sprow_add"");\n   if ( j0 < 0 )\n     error(E_BOUNDS,""sprow_add"");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   /* idx1 = idx2 = idx_out = 0; */\n   idx1    = sprow_idx(r1,j0);\n   idx2    = sprow_idx(r2,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx2    = (idx2 < 0) ? -(idx2+2) : idx2;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n   elt2    = &(r2->elt[idx2]);\n   elt_out = &(r_out->elt[idx_out]);\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( idx2 < len2 && elt1->col == elt2->col )\n	 {\n	    elt_out->val += elt2->val;\n	    elt2++;		idx2++;\n	 }\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n/* sprow_sub -- sets r_out <- r1 - r2\n   -- cannot be in situ\n   -- only for columns j0, j0+1, ...\n   -- type must be TYPE_SPMAT or TYPE_SPROW depending on\n      whether r_out is a row of a SPMAT structure\n      or a SPROW variable\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_sub(r1,r2,j0,r_out,type)\nSPROW	*r1, *r2, *r_out;\nint	j0, type;\n#else\nSPROW	*sprow_sub(const SPROW *r1, const SPROW *r2,\n		   int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx2, idx_out, len1, len2, len_out;\n   row_elt	*elt1, *elt2, *elt_out;\n   \n   if ( ! r1 || ! r2 )\n     error(E_NULL,""sprow_sub"");\n   if ( r1 == r_out || r2 == r_out )\n     error(E_INSITU,""sprow_sub"");\n   if ( j0 < 0 )\n     error(E_BOUNDS,""sprow_sub"");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;	len2 = r2->len;	len_out = r_out->maxlen;\n   /* idx1 = idx2 = idx_out = 0; */\n   idx1    = sprow_idx(r1,j0);\n   idx2    = sprow_idx(r2,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx2    = (idx2 < 0) ? -(idx2+2) : idx2;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n   elt2    = &(r2->elt[idx2]);\n   elt_out = &(r_out->elt[idx_out]);\n   \n   while ( idx1 < len1 || idx2 < len2 )\n   {\n      if ( idx_out >= len_out )\n      {   /* r_out is too small */\n	 r_out->len = idx_out;\n	 r_out = sprow_xpd(r_out,0,type);\n	 len_out = r_out->maxlen;\n	 elt_out = &(r_out->elt[idx_out]);\n      }\n      if ( idx2 >= len2 || (idx1 < len1 && elt1->col <= elt2->col) )\n      {\n	 elt_out->col = elt1->col;\n	 elt_out->val = elt1->val;\n	 if ( idx2 < len2 && elt1->col == elt2->col )\n	 {\n	    elt_out->val -= elt2->val;\n	    elt2++;		idx2++;\n	 }\n	 elt1++;	idx1++;\n      }\n      else\n      {\n	 elt_out->col = elt2->col;\n	 elt_out->val = -elt2->val;\n	 elt2++;	idx2++;\n      }\n      elt_out++;	idx_out++;\n   }\n   r_out->len = idx_out;\n   \n   return r_out;\n}\n\n\n/* sprow_smlt -- sets r_out <- alpha*r1 \n   -- can be in situ\n   -- only for columns j0, j0+1, ...\n   -- returns r_out */\n#ifndef ANSI_C\nSPROW	*sprow_smlt(r1,alpha,j0,r_out,type)\nSPROW	*r1, *r_out;\ndouble	alpha;\nint	j0, type;\n#else\nSPROW	*sprow_smlt(const SPROW *r1, double alpha, int j0, SPROW *r_out, int type)\n#endif\n{\n   int	idx1, idx_out, len1;\n   row_elt	*elt1, *elt_out;\n   \n   if ( ! r1 )\n     error(E_NULL,""sprow_smlt"");\n   if ( j0 < 0 )\n     error(E_BOUNDS,""sprow_smlt"");\n   if ( ! r_out )\n     r_out = sprow_get(MINROWLEN);\n   \n   /* Initialise */\n   len1 = r1->len;\n   idx1    = sprow_idx(r1,j0);\n   idx_out = sprow_idx(r_out,j0);\n   idx1    = (idx1 < 0) ? -(idx1+2) : idx1;\n   idx_out = (idx_out < 0) ? -(idx_out+2) : idx_out;\n   elt1    = &(r1->elt[idx1]);\n\n   r_out = sprow_resize(r_out,idx_out+len1-idx1,type);  \n   elt_out = &(r_out->elt[idx_out]);\n\n   for ( ; idx1 < len1; elt1++,elt_out++,idx1++,idx_out++ )\n   {\n      elt_out->col = elt1->col;\n      elt_out->val = alpha*elt1->val;\n   }\n\n   r_out->len = idx_out;\n\n   return r_out;\n}\n\n#ifndef MEX\n/* sprow_foutput -- print a representation of r on stream fp */\n#ifndef ANSI_C\nvoid	sprow_foutput(fp,r)\nFILE	*fp;\nSPROW	*r;\n#else\nvoid	sprow_foutput(FILE *fp, const SPROW *r)\n#endif\n{\n   int	i, len;\n   row_elt	*e;\n   \n   if ( ! r )\n   {\n      fprintf(fp,""SparseRow: **** NULL ****\n"");\n      return;\n   }\n   len = r->len;\n   fprintf(fp,""SparseRow: length: %d\n"",len);\n   for ( i = 0, e = r->elt; i < len; i++, e++ )\n     fprintf(fp,""Column %d: %g, next row: %d, next index %d\n"",\n	     e->col, e->val, e->nxt_row, e->nxt_idx);\n}\n#endif\n\n\n/* sprow_set_val -- sets the j-th column entry of the sparse row r\n   -- Note: destroys the usual column & row access paths */\n#ifndef ANSI_C\ndouble  sprow_set_val(r,j,val)\nSPROW   *r;\nint     j;\ndouble  val;\n#else\ndouble  sprow_set_val(SPROW *r, int j, double val)\n#endif\n{\n   int  idx, idx2, new_len;\n   \n   if ( ! r )\n     error(E_NULL,""sprow_set_val"");\n   \n   idx = sprow_idx(r,j);\n   if ( idx >= 0 )\n   {    r->elt[idx].val = val;  return val;     }\n   /* else */ if ( idx < -1 )\n   {\n      /* shift & insert new value */\n      idx = -(idx+2);   /* this is the intended insertion index */\n      if ( r->len >= r->maxlen )\n      {\n         r->len = r->maxlen;\n         new_len = max(2*r->maxlen+1,5);\n         if (mem_info_is_on()) {\n            mem_bytes(TYPE_SPROW,r->maxlen*sizeof(row_elt),\n                        new_len*sizeof(row_elt)); \n         }\n         \n         r->elt = RENEW(r->elt,new_len,row_elt);\n         if ( ! r->elt )        /* can't allocate */\n           error(E_MEM,""sprow_set_val"");\n         r->maxlen = 2*r->maxlen+1;\n      }\n      for ( idx2 = r->len-1; idx2 >= idx; idx2-- )\n        MEM_COPY((char *)(&(r->elt[idx2])),\n                 (char *)(&(r->elt[idx2+1])),sizeof(row_elt));\n      /************************************************************\n        if ( idx < r->len )\n        MEM_COPY((char *)(&(r->elt[idx])),(char *)(&(r->elt[idx+1])),\n        (r->len-idx)*sizeof(row_elt));\n        ************************************************************/\n      r->len++;\n      r->elt[idx].col = j;\n      r->elt[idx].nxt_row = -1;\n      r->elt[idx].nxt_idx = -1;\n      return r->elt[idx].val = val;\n   }\n   /* else -- idx == -1, error in index/matrix! */\n   return 0.0;\n}\n\n\n"
leukocyte/meschach_lib/zgivens.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Givens operations file. Contains routines for calculating and\n	applying givens rotations for/to vectors and also to matrices by\n	row and by column.\n\n	Complex version.\n*/\n\nstatic	char	rcsid[] = ""$Id: "";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""zmatrix.h""\n#include        ""zmatrix2.h""\n\n/*\n	(Complex) Givens rotation matrix:\n		[ c   -s ]\n		[ s*   c ]\n	Note that c is real and s is complex\n*/\n\n/* zgivens -- returns c,s parameters for Givens rotation to\n		eliminate y in the **column** vector [ x y ] */\nvoid	zgivens(x,y,c,s)\ncomplex	x,y,*s;\nReal	*c;\n{\n	Real	inv_norm, norm;\n	complex	tmp;\n\n	/* this is a safe way of computing sqrt(|x|^2+|y|^2) */\n	tmp.re = zabs(x);	tmp.im = zabs(y);\n	norm = zabs(tmp);\n\n	if ( norm == 0.0 )\n	{	*c = 1.0;	s->re = s->im = 0.0;	} /* identity */\n	else\n	{\n	    inv_norm = 1.0 / tmp.re;	/* inv_norm = 1/|x| */\n	    x.re *= inv_norm;\n	    x.im *= inv_norm;		/* normalise x */\n	    inv_norm = 1.0/norm;		/* inv_norm = 1/||[x,y]||2 */\n	    *c = tmp.re * inv_norm;\n	    /* now compute - conj(normalised x).y/||[x,y]||2 */\n	    s->re = - inv_norm*(x.re*y.re + x.im*y.im);\n	    s->im =   inv_norm*(x.re*y.im - x.im*y.re);\n	}\n}\n\n/* rot_zvec -- apply Givens rotation to x's i & k components */\nZVEC	*rot_zvec(x,i,k,c,s,out)\nZVEC	*x,*out;\nint	i,k;\ndouble	c;\ncomplex	s;\n{\n\n	complex	temp1, temp2;\n\n	if ( x==ZVNULL )\n		error(E_NULL,""rot_zvec"");\n	if ( i < 0 || i >= x->dim || k < 0 || k >= x->dim )\n		error(E_RANGE,""rot_zvec"");\n	if ( x != out )\n	    out = zv_copy(x,out);\n\n	/* temp1 = c*out->ve[i] - s*out->ve[k]; */\n	temp1.re = c*out->ve[i].re\n	    - s.re*out->ve[k].re + s.im*out->ve[k].im;\n	temp1.im = c*out->ve[i].im\n	    - s.re*out->ve[k].im - s.im*out->ve[k].re;\n\n	/* temp2 = c*out->ve[k] + zconj(s)*out->ve[i]; */\n	temp2.re = c*out->ve[k].re\n		+ s.re*out->ve[i].re + s.im*out->ve[i].im;\n	temp2.im = c*out->ve[k].im\n		+ s.re*out->ve[i].im - s.im*out->ve[i].re;\n\n	out->ve[i] = temp1;\n	out->ve[k] = temp2;\n\n	return (out);\n}\n\n/* zrot_rows -- premultiply mat by givens rotation described by c,s */\nZMAT	*zrot_rows(mat,i,k,c,s,out)\nZMAT	*mat,*out;\nint	i,k;\ndouble	c;\ncomplex	s;\n{\n	unsigned int	j;\n	complex	temp1, temp2;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,""zrot_rows"");\n	if ( i < 0 || i >= mat->m || k < 0 || k >= mat->m )\n		error(E_RANGE,""zrot_rows"");\n\n	if ( mat != out )\n		out = zm_copy(mat,zm_resize(out,mat->m,mat->n));\n\n	/* temp1 = c*out->me[i][j] - s*out->me[k][j]; */\n	for ( j=0; j<mat->n; j++ )\n	{\n	    /* temp1 = c*out->me[i][j] - s*out->me[k][j]; */\n	    temp1.re = c*out->me[i][j].re\n		- s.re*out->me[k][j].re + s.im*out->me[k][j].im;\n	    temp1.im = c*out->me[i][j].im\n		- s.re*out->me[k][j].im - s.im*out->me[k][j].re;\n	    \n	    /* temp2 = c*out->me[k][j] + conj(s)*out->me[i][j]; */\n	    temp2.re = c*out->me[k][j].re\n		+ s.re*out->me[i][j].re + s.im*out->me[i][j].im;\n	    temp2.im = c*out->me[k][j].im\n		+ s.re*out->me[i][j].im - s.im*out->me[i][j].re;\n	    \n	    out->me[i][j] = temp1;\n	    out->me[k][j] = temp2;\n	}\n\n	return (out);\n}\n\n/* zrot_cols -- postmultiply mat by adjoint Givens rotation described by c,s */\nZMAT	*zrot_cols(mat,i,k,c,s,out)\nZMAT	*mat,*out;\nint	i,k;\ndouble	c;\ncomplex	s;\n{\n	unsigned int	j;\n	complex	x, y;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,""zrot_cols"");\n	if ( i < 0 || i >= mat->n || k < 0 || k >= mat->n )\n		error(E_RANGE,""zrot_cols"");\n\n	if ( mat != out )\n		out = zm_copy(mat,zm_resize(out,mat->m,mat->n));\n\n	for ( j=0; j<mat->m; j++ )\n	{\n	    x = out->me[j][i];	y = out->me[j][k];\n	    /* out->me[j][i] = c*x - conj(s)*y; */\n	    out->me[j][i].re = c*x.re - s.re*y.re - s.im*y.im;\n	    out->me[j][i].im = c*x.im - s.re*y.im + s.im*y.re;\n	    \n	    /* out->me[j][k] = c*y + s*x; */\n	    out->me[j][k].re = c*y.re + s.re*x.re - s.im*x.im;\n	    out->me[j][k].im = c*y.im + s.re*x.im + s.im*x.re;\n	}\n\n	return (out);\n}\n\n"
leukocyte/meschach_lib/hessen.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n/*\n		File containing routines for determining Hessenberg\n	factorisations.\n*/\n\nstatic	char	rcsid[] = ""$Id: hessen.c,v 1.2 1994/01/13 05:36:24 des Exp $"";\n\n#include	<stdio.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\n\n/* Hfactor -- compute Hessenberg factorisation in compact form.\n	-- factorisation performed in situ\n	-- for details of the compact form see QRfactor.c and matrix2.doc */\n#ifndef ANSI_C\nMAT	*Hfactor(A, diag, beta)\nMAT	*A;\nVEC	*diag, *beta;\n#else\nMAT	*Hfactor(MAT *A, VEC *diag, VEC *beta)\n#endif\n{\n	STATIC	VEC	*hh = VNULL, *w = VNULL;\n	int	k, limit;\n\n	if ( ! A || ! diag || ! beta )\n		error(E_NULL,""Hfactor"");\n	if ( diag->dim < A->m - 1 || beta->dim < A->m - 1 )\n		error(E_SIZES,""Hfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""Hfactor"");\n	limit = A->m - 1;\n\n	hh = v_resize(hh,A->m);\n	w  = v_resize(w,A->n);\n	MEM_STAT_REG(hh,TYPE_VEC);\n	MEM_STAT_REG(w, TYPE_VEC);\n\n	for ( k = 0; k < limit; k++ )\n	  {\n	    /* compute the Householder vector hh */\n	    get_col(A,(unsigned int)k,hh);\n	    /* printf(""the %d'th column = "");	v_output(hh); */\n	    hhvec(hh,k+1,&beta->ve[k],hh,&A->me[k+1][k]);\n	    /* diag->ve[k] = hh->ve[k+1]; */\n	    v_set_val(diag,k,v_entry(hh,k+1));\n	    /* printf(""H/h vector = "");	v_output(hh); */\n	    /* printf(""from the %d'th entry\n"",k+1); */\n	    /* printf(""beta = %g\n"",beta->ve[k]); */\n\n	    /* apply Householder operation symmetrically to A */\n	    _hhtrcols(A,k+1,k+1,hh,v_entry(beta,k),w);\n	    hhtrrows(A,0  ,k+1,hh,v_entry(beta,k));\n	    /* printf(""A = "");		m_output(A); */\n	  }\n\n#ifdef THREADSAFE\n	V_FREE(hh);	V_FREE(w);\n#endif\n\n	return (A);\n}\n\n/* makeHQ -- construct the Hessenberg orthogonalising matrix Q;\n	-- i.e. Hess M = Q.M.Q'	*/\n#ifndef ANSI_C\nMAT	*makeHQ(H, diag, beta, Qout)\nMAT	*H, *Qout;\nVEC	*diag, *beta;\n#else\nMAT	*makeHQ(MAT *H, VEC *diag, VEC *beta, MAT *Qout)\n#endif\n{\n	int	i, j, limit;\n	STATIC	VEC	*tmp1 = VNULL, *tmp2 = VNULL;\n\n	if ( H==(MAT *)NULL || diag==(VEC *)NULL || beta==(VEC *)NULL )\n		error(E_NULL,""makeHQ"");\n	limit = H->m - 1;\n	if ( diag->dim < limit || beta->dim < limit )\n		error(E_SIZES,""makeHQ"");\n	if ( H->m != H->n )\n		error(E_SQUARE,""makeHQ"");\n	Qout = m_resize(Qout,H->m,H->m);\n\n	tmp1 = v_resize(tmp1,H->m);\n	tmp2 = v_resize(tmp2,H->m);\n	MEM_STAT_REG(tmp1,TYPE_VEC);\n	MEM_STAT_REG(tmp2,TYPE_VEC);\n\n	for ( i = 0; i < H->m; i++ )\n	{\n		/* tmp1 = i'th basis vector */\n		for ( j = 0; j < H->m; j++ )\n			/* tmp1->ve[j] = 0.0; */\n		    v_set_val(tmp1,j,0.0);\n		/* tmp1->ve[i] = 1.0; */\n		v_set_val(tmp1,i,1.0);\n\n		/* apply H/h transforms in reverse order */\n		for ( j = limit-1; j >= 0; j-- )\n		{\n			get_col(H,(unsigned int)j,tmp2);\n			/* tmp2->ve[j+1] = diag->ve[j]; */\n			v_set_val(tmp2,j+1,v_entry(diag,j));\n			hhtrvec(tmp2,beta->ve[j],j+1,tmp1,tmp1);\n		}\n\n		/* insert into Qout */\n		set_col(Qout,(unsigned int)i,tmp1);\n	}\n\n#ifdef THREADSAFE\n	V_FREE(tmp1);	V_FREE(tmp2);\n#endif\n\n	return (Qout);\n}\n\n/* makeH -- construct actual Hessenberg matrix */\n#ifndef ANSI_C\nMAT	*makeH(H,Hout)\nMAT	*H, *Hout;\n#else\nMAT	*makeH(const MAT *H, MAT *Hout)\n#endif\n{\n	int	i, j, limit;\n\n	if ( H==(MAT *)NULL )\n		error(E_NULL,""makeH"");\n	if ( H->m != H->n )\n		error(E_SQUARE,""makeH"");\n	Hout = m_resize(Hout,H->m,H->m);\n	Hout = m_copy(H,Hout);\n\n	limit = H->m;\n	for ( i = 1; i < limit; i++ )\n		for ( j = 0; j < i-1; j++ )\n			/* Hout->me[i][j] = 0.0;*/\n		    m_set_val(Hout,i,j,0.0);\n\n	return (Hout);\n}\n\n"
leukocyte/meschach_lib/torture.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	This file contains a series of tests for the Meschach matrix\n	library, parts 1 and 2\n*/\n\nstatic char rcsid[] = ""$Id: torture.c,v 1.6 1994/08/25 15:22:11 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix2.h""\n#include        ""matlab.h""\n\n#define	errmesg(mesg)	printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)	printf(""# Testing %s...\n"",mesg);\n\nstatic char *test_err_list[] = {\n   ""unknown error"",			/* 0 */\n   ""testing error messages"",		/* 1 */\n   ""unexpected end-of-file""		/* 2 */\n};\n\n\n#define MAX_TEST_ERR   (sizeof(test_err_list)/sizeof(char *))\n\n/* extern	int	malloc_chain_check(); */\n/* #define MEMCHK() if ( malloc_chain_check(0) ) \\n{ printf(""Error in malloc chain: \""%s\"", line %d\n"", \\n	 __FILE__, __LINE__); exit(0); } */\n#define	MEMCHK() \n\n/* cmp_perm -- returns 1 if pi1 == pi2, 0 otherwise */\nint	cmp_perm(pi1, pi2)\nPERM	*pi1, *pi2;\n{\n    int		i;\n\n    if ( ! pi1 || ! pi2 )\n	error(E_NULL,""cmp_perm"");\n    if ( pi1->size != pi2->size )\n	return 0;\n    for ( i = 0; i < pi1->size; i++ )\n	if ( pi1->pe[i] != pi2->pe[i] )\n	    return 0;\n    return 1;\n}\n\n/* px_rand -- generates sort-of random permutation */\nPERM	*px_rand(pi)\nPERM	*pi;\n{\n    int		i, j, k;\n\n    if ( ! pi )\n	error(E_NULL,""px_rand"");\n\n    for ( i = 0; i < 3*pi->size; i++ )\n    {\n	j = (rand() >> 8) % pi->size;\n	k = (rand() >> 8) % pi->size;\n	px_transp(pi,j,k);\n    }\n\n    return pi;\n}\n\n#define	SAVE_FILE	""asx5213a.mat""\n#define	MATLAB_NAME	""alpha""\nchar	name[81] = MATLAB_NAME;\n\nint main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n   VEC	*x = VNULL, *y = VNULL, *z = VNULL, *u = VNULL, *v = VNULL, \n        *w = VNULL;\n   VEC	*diag = VNULL, *beta = VNULL;\n   PERM	*pi1 = PNULL, *pi2 = PNULL, *pi3 = PNULL, *pivot = PNULL, \n        *blocks = PNULL;\n   MAT	*A = MNULL, *B = MNULL, *C = MNULL, *D = MNULL, *Q = MNULL, \n        *U = MNULL;\n   BAND *bA, *bB, *bC;\n   Real	cond_est, s1, s2, s3;\n   int	i, j, seed;\n   FILE	*fp;\n   char	*cp;\n\n\n    mem_info_on(TRUE);\n\n    setbuf(stdout,(char *)NULL);\n\n    seed = 1111;\n    if ( argc > 2 )\n    {\n	printf(""usage: %s [seed]\n"",argv[0]);\n	exit(0);\n    }\n    else if ( argc == 2 )\n	sscanf(argv[1], ""%d"", &seed);\n\n    /* set seed for rand() */\n    smrand(seed);\n\n    mem_stat_mark(1);\n\n    /* print version information */\n    m_version();\n\n    printf(""# grep \""^Error\"" the output for a listing of errors\n"");\n    printf(""# Don't panic if you see \""Error\"" appearing; \n"");\n    printf(""# Also check the reported size of error\n"");\n    printf(""# This program uses randomly generated problems and therefore\n"");\n    printf(""# may occasionally produce ill-conditioned problems\n"");\n    printf(""# Therefore check the size of the error compared with MACHEPS\n"");\n    printf(""# If the error is within 1000*MACHEPS then don't worry\n"");\n    printf(""# If you get an error of size 0.1 or larger there is \n"");\n    printf(""# probably a bug in the code or the compilation procedure\n\n"");\n    printf(""# seed = %d\n"",seed);\n\n    printf(""# Check: MACHEPS = %g\n"",MACHEPS);\n    /* allocate, initialise, copy and resize operations */\n    /* VEC */\n    notice(""vector initialise, copy & resize"");\n    x = v_get(12);\n    y = v_get(15);\n    z = v_get(12);\n    v_rand(x);\n    v_rand(y);\n    z = v_copy(x,z);\n    if ( v_norm2(v_sub(x,z,z)) >= MACHEPS )\n	errmesg(""VEC copy"");\n    v_copy(x,y);\n    x = v_resize(x,10);\n    y = v_resize(y,10);\n    if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n	errmesg(""VEC copy/resize"");\n    x = v_resize(x,15);\n    y = v_resize(y,15);\n    if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n	errmesg(""VEC resize"");\n\n    /* MAT */\n    notice(""matrix initialise, copy & resize"");\n    A = m_get(8,5);\n    B = m_get(3,9);\n    C = m_get(8,5);\n    m_rand(A);\n    m_rand(B);\n    C = m_copy(A,C);\n    if ( m_norm_inf(m_sub(A,C,C)) >= MACHEPS )\n	errmesg(""MAT copy"");\n    m_copy(A,B);\n    A = m_resize(A,3,5);\n    B = m_resize(B,3,5);\n    if ( m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n	errmesg(""MAT copy/resize"");\n    A = m_resize(A,10,10);\n    B = m_resize(B,10,10);\n    if ( m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n	errmesg(""MAT resize"");\n\n    MEMCHK();\n\n    /* PERM */\n    notice(""permutation initialise, inverting & permuting vectors"");\n    pi1 = px_get(15);\n    pi2 = px_get(12);\n    px_rand(pi1);\n    v_rand(x);\n    px_vec(pi1,x,z);\n    y = v_resize(y,x->dim);\n    pxinv_vec(pi1,z,y);\n    if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n	errmesg(""PERMute vector"");\n    pi2 = px_inv(pi1,pi2);\n    pi3 = px_mlt(pi1,pi2,PNULL);\n    for ( i = 0; i < pi3->size; i++ )\n	if ( pi3->pe[i] != i )\n	    errmesg(""PERM inverse/multiply"");\n\n    /* testing catch() etc */\n    notice(""error handling routines"");\n    catch(E_NULL,\n	  catchall(v_add(VNULL,VNULL,VNULL);\n		     errmesg(""tracecatch() failure""),\n		     printf(""# tracecatch() caught error\n"");\n		     error(E_NULL,""main""));\n	             errmesg(""catch() failure""),\n	  printf(""# catch() caught E_NULL error\n""));\n\n    /* testing attaching a new error list (error list 2) */\n\n    notice(""attaching error lists"");\n    printf(""# IT IS NOT A REAL WARNING ... \n"");\n    err_list_attach(2,MAX_TEST_ERR,test_err_list,TRUE);\n    if (!err_is_list_attached(2)) \n       errmesg(""attaching the error list 2"");\n    ev_err(__FILE__,1,__LINE__,""main"",2);\n    err_list_free(2);\n    if (err_is_list_attached(2)) \n       errmesg(""detaching the error list 2"");\n\n    /* testing inner products and v_mltadd() etc */\n    notice(""inner products and linear combinations"");\n    u = v_get(x->dim);\n    v_rand(u);\n    v_rand(x);\n    v_resize(y,x->dim);\n    v_rand(y);\n    v_mltadd(y,x,-in_prod(x,y)/in_prod(x,x),z);\n    if ( fabs(in_prod(x,z)) >= MACHEPS*x->dim )\n	errmesg(""v_mltadd()/in_prod()"");\n    s1 = -in_prod(x,y)/(v_norm2(x)*v_norm2(x));\n    sv_mlt(s1,x,u);\n    v_add(y,u,u);\n    if ( v_norm2(v_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg(""sv_mlt()/v_norm2()"");\n\n#ifdef ANSI_C \n    v_linlist(u,x,s1,y,1.0,VNULL);\n    if ( v_norm2(v_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg(""v_linlist()"");\n#endif\n#ifdef VARARGS\n    v_linlist(u,x,s1,y,1.0,VNULL);\n    if ( v_norm2(v_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg(""v_linlist()"");\n#endif\n\n\n    MEMCHK();\n\n    /* vector norms */\n    notice(""vector norms"");\n    x = v_resize(x,12);\n    v_rand(x);\n    for ( i = 0; i < x->dim; i++ )\n	if ( v_entry(x,i) >= 0.5 )\n	    v_set_val(x,i,1.0);\n        else\n	    v_set_val(x,i,-1.0);\n    s1 = v_norm1(x);\n    s2 = v_norm2(x);	\n    s3 = v_norm_inf(x);\n    if ( fabs(s1 - x->dim) >= MACHEPS*x->dim ||\n	 fabs(s2 - sqrt((Real)(x->dim))) >= MACHEPS*x->dim ||\n	 fabs(s3 - 1.0) >= MACHEPS )\n	errmesg(""v_norm1/2/_inf()"");\n\n    /* test matrix multiply etc */\n    notice(""matrix multiply and invert"");\n    A = m_resize(A,10,10);\n    B = m_resize(B,10,10);\n    m_rand(A);\n    m_inverse(A,B);\n    m_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""m_inverse()/m_mlt()"");\n\n    MEMCHK();\n\n    /* ... and transposes */\n    notice(""transposes and transpose-multiplies"");\n    m_transp(A,A);	/* can do square matrices in situ */\n    mtrm_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""m_transp()/mtrm_mlt()"");\n    m_transp(A,A);\n    m_transp(B,B);\n    mmtr_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""m_transp()/mmtr_mlt()"");\n    sm_mlt(3.71,B,B);\n    mmtr_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-3.71);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""sm_mlt()/mmtr_mlt()"");\n    m_transp(B,B);\n    sm_mlt(1.0/3.71,B,B);\n\n    MEMCHK();\n\n    /* ... and matrix-vector multiplies */\n    notice(""matrix-vector multiplies"");\n    x = v_resize(x,A->n);\n    y = v_resize(y,A->m);\n    z = v_resize(z,A->m);\n    u = v_resize(u,A->n);\n    v_rand(x);\n    v_rand(y);\n    mv_mlt(A,x,z);\n    s1 = in_prod(y,z);\n    vm_mlt(A,y,u);\n    s2 = in_prod(u,x);\n    if ( fabs(s1 - s2) >= (MACHEPS*x->dim)*x->dim )\n	errmesg(""mv_mlt()/vm_mlt()"");\n    mv_mlt(B,z,u);\n    if ( v_norm2(v_sub(u,x,u)) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""mv_mlt()/m_inverse()"");\n\n    MEMCHK();\n\n    /* get/set row/col */\n    notice(""getting and setting rows and cols"");\n    x = v_resize(x,A->n);\n    y = v_resize(y,B->m);\n    x = get_row(A,3,x);\n    y = get_col(B,3,y);\n    if ( fabs(in_prod(x,y) - 1.0) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""get_row()/get_col()"");\n    sv_mlt(-1.0,x,x);\n    sv_mlt(-1.0,y,y);\n    set_row(A,3,x);\n    set_col(B,3,y);\n    m_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	m_set_val(C,i,i,m_entry(C,i,i)-1.0);\n    if ( m_norm_inf(C) >= MACHEPS*m_norm_inf(A)*m_norm_inf(B)*5 )\n	errmesg(""set_row()/set_col()"");\n\n    MEMCHK();\n\n    /* matrix norms */\n    notice(""matrix norms"");\n    A = m_resize(A,11,15);\n    m_rand(A);\n    s1 = m_norm_inf(A);\n    B = m_transp(A,B);\n    s2 = m_norm1(B);\n    if ( fabs(s1 - s2) >= MACHEPS*A->m )\n	errmesg(""m_norm1()/m_norm_inf()"");\n    C = mtrm_mlt(A,A,C);\n    s1 = 0.0;\n    for ( i = 0; i < C->m && i < C->n; i++ )\n	s1 += m_entry(C,i,i);\n    if ( fabs(sqrt(s1) - m_norm_frob(A)) >= MACHEPS*A->m*A->n )\n	errmesg(""m_norm_frob"");\n\n    MEMCHK();\n    \n    /* permuting rows and columns */\n    notice(""permuting rows & cols"");\n    A = m_resize(A,11,15);\n    B = m_resize(B,11,15);\n    pi1 = px_resize(pi1,A->m);\n    px_rand(pi1);\n    x = v_resize(x,A->n);\n    y = mv_mlt(A,x,y);\n    px_rows(pi1,A,B);\n    px_vec(pi1,y,z);\n    mv_mlt(B,x,u);\n    if ( v_norm2(v_sub(z,u,u)) >= MACHEPS*A->m )\n	errmesg(""px_rows()"");\n    pi1 = px_resize(pi1,A->n);\n    px_rand(pi1);\n    px_cols(pi1,A,B);\n    pxinv_vec(pi1,x,z);\n    mv_mlt(B,z,u);\n    if ( v_norm2(v_sub(y,u,u)) >= MACHEPS*A->n )\n	errmesg(""px_cols()"");\n\n    MEMCHK();\n\n    /* MATLAB save/load */\n    notice(""MATLAB save/load"");\n    A = m_resize(A,12,11);\n    if ( (fp=fopen(SAVE_FILE,""w"")) == (FILE *)NULL )\n	printf(""Cannot perform MATLAB save/load test\n"");\n    else\n    {\n	m_rand(A);\n	m_save(fp, A, name);\n	fclose(fp);\n	if ( (fp=fopen(SAVE_FILE,""r"")) == (FILE *)NULL )\n	    printf(""Cannot open save file \""%s\""\n"",SAVE_FILE);\n	else\n	{\n	    M_FREE(B);\n	    B = m_load(fp,&cp);\n	    if ( strcmp(name,cp) || m_norm1(m_sub(A,B,B)) >= MACHEPS*A->m )\n		errmesg(""mload()/m_save()"");\n	}\n    }\n\n    MEMCHK();\n\n    /* Now, onto matrix factorisations */\n    A = m_resize(A,10,10);\n    B = m_resize(B,A->m,A->n);\n    m_copy(A,B);\n    x = v_resize(x,A->n);\n    y = v_resize(y,A->m);\n    z = v_resize(z,A->n);\n    u = v_resize(u,A->m);\n    v_rand(x);\n    mv_mlt(B,x,y);\n    z = v_copy(x,z);\n\n    notice(""LU factor/solve"");\n    pivot = px_get(A->m);\n    LUfactor(A,pivot);\n    tracecatch(LUsolve(A,pivot,y,x),""main"");\n    tracecatch(cond_est = LUcondest(A,pivot),""main"");\n    printf(""# cond(A) approx= %g\n"", cond_est);\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est)\n    {\n	errmesg(""LUfactor()/LUsolve()"");\n	printf(""# LU solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n\n    v_copy(y,x);\n    tracecatch(LUsolve(A,pivot,x,x),""main"");\n    tracecatch(cond_est = LUcondest(A,pivot),""main"");\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est)\n    {\n	errmesg(""LUfactor()/LUsolve()"");\n	printf(""# LU solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n\n    vm_mlt(B,z,y);\n    v_copy(y,x);\n    tracecatch(LUTsolve(A,pivot,x,x),""main"");\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est)\n    {\n	errmesg(""LUfactor()/LUTsolve()"");\n	printf(""# LU solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n \n    MEMCHK();\n\n    /* QR factorisation */\n    m_copy(B,A);\n    mv_mlt(B,z,y);\n    notice(""QR factor/solve:"");\n    diag = v_get(A->m);\n    beta = v_get(A->m);\n    QRfactor(A,diag);\n    QRsolve(A,diag,y,x);\n    if ( v_norm2(v_sub(x,z,u)) >= MACHEPS*v_norm2(x)*cond_est )\n    {\n	errmesg(""QRfactor()/QRsolve()"");\n	printf(""# QR solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v_sub(x,z,u)), MACHEPS);\n    }\n    Q = m_get(A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_mlt(Q,A,C);\n    m_sub(B,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(Q)*m_norm1(B) )\n    {\n	errmesg(""QRfactor()/makeQ()/makeR()"");\n	printf(""# QR reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(C), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now try with a non-square matrix */\n    A = m_resize(A,15,7);\n    m_rand(A);\n    B = m_copy(A,B);\n    diag = v_resize(diag,A->n);\n    beta = v_resize(beta,A->n);\n    x = v_resize(x,A->n);\n    y = v_resize(y,A->m);\n    v_rand(y);\n    QRfactor(A,diag);\n    x = QRsolve(A,diag,y,x);\n    /* z is the residual vector */\n    mv_mlt(B,x,z);	v_sub(z,y,z);\n    /* check B^T.z = 0 */\n    vm_mlt(B,z,u);\n    if ( v_norm2(u) >= MACHEPS*m_norm1(B)*v_norm2(y) )\n    {\n	errmesg(""QRfactor()/QRsolve()"");\n	printf(""# QR solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(u), MACHEPS);\n    }\n    Q = m_resize(Q,A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_mlt(Q,A,C);\n    m_sub(B,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(Q)*m_norm1(B) )\n    {\n	errmesg(""QRfactor()/makeQ()/makeR()"");\n	printf(""# QR reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(C), MACHEPS);\n    }\n    D = m_get(A->m,Q->m);\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q) )\n    {\n	errmesg(""QRfactor()/makeQ()/makeR()"");\n	printf(""# QR orthogonality error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* QRCP factorisation */\n    m_copy(B,A);\n    notice(""QR factor/solve with column pivoting"");\n    pivot = px_resize(pivot,A->n);\n    QRCPfactor(A,diag,pivot);\n    z = v_resize(z,A->n);\n    QRCPsolve(A,diag,pivot,y,z);\n    /* pxinv_vec(pivot,z,x); */\n    /* now compute residual (z) vector */\n    mv_mlt(B,x,z);	v_sub(z,y,z);\n    /* check B^T.z = 0 */\n    vm_mlt(B,z,u);\n    if ( v_norm2(u) >= MACHEPS*m_norm1(B)*v_norm2(y) )\n    {\n	errmesg(""QRCPfactor()/QRsolve()"");\n	printf(""# QR solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(u), MACHEPS);\n    }\n\n    Q = m_resize(Q,A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_mlt(Q,A,C);\n    M_FREE(D);\n    D = m_get(B->m,B->n);\n    px_cols(pivot,C,D);\n    m_sub(B,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm1(B) )\n    {\n	errmesg(""QRCPfactor()/makeQ()/makeR()"");\n	printf(""# QR reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* Cholesky and LDL^T factorisation */\n    /* Use these for normal equations approach */\n    notice(""Cholesky factor/solve"");\n    mtrm_mlt(B,B,A);\n    CHfactor(A);\n    u = v_resize(u,B->n);\n    vm_mlt(B,y,u);\n    z = v_resize(z,B->n);\n    CHsolve(A,u,z);\n    v_sub(x,z,z);\n    if ( v_norm2(z) >= MACHEPS*v_norm2(x)*100 )\n    {\n	errmesg(""CHfactor()/CHsolve()"");\n	printf(""# Cholesky solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(z), MACHEPS);\n    }\n    /* modified Cholesky factorisation should be identical with Cholesky\n       factorisation provided the matrix is ""sufficiently positive definite"" */\n    mtrm_mlt(B,B,C);\n    MCHfactor(C,MACHEPS);\n    m_sub(A,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(A) )\n    {\n	errmesg(""MCHfactor()"");\n	printf(""# Modified Cholesky error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(C), MACHEPS);\n    }\n    /* now test the LDL^T factorisation -- using a negative def. matrix */\n    mtrm_mlt(B,B,A);\n    sm_mlt(-1.0,A,A);\n    m_copy(A,C);\n    LDLfactor(A);\n    LDLsolve(A,u,z);\n    w = v_get(A->m);\n    mv_mlt(C,z,w);\n    v_sub(w,u,w);\n    if ( v_norm2(w) >= MACHEPS*v_norm2(u)*m_norm1(C) )\n    {\n	errmesg(""LDLfactor()/LDLsolve()"");\n	printf(""# LDL^T residual = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(w), MACHEPS);\n    }\n    v_add(x,z,z);\n    if ( v_norm2(z) >= MACHEPS*v_norm2(x)*100 )\n    {\n	errmesg(""LDLfactor()/LDLsolve()"");\n	printf(""# LDL^T solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(z), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* and now the Bunch-Kaufman-Parlett method */\n    /* set up D to be an indefinite diagonal matrix */\n    notice(""Bunch-Kaufman-Parlett factor/solve"");\n\n    D = m_resize(D,B->m,B->m);\n    m_zero(D);\n    w = v_resize(w,B->m);\n    v_rand(w);\n    for ( i = 0; i < w->dim; i++ )\n	if ( v_entry(w,i) >= 0.5 )\n	    m_set_val(D,i,i,1.0);\n	else\n	    m_set_val(D,i,i,-1.0);\n    /* set A <- B^T.D.B */\n    C = m_resize(C,B->n,B->n);\n    C = mtrm_mlt(B,D,C);\n    A = m_mlt(C,B,A);\n    C = m_resize(C,B->n,B->n);\n    C = m_copy(A,C);\n    /* ... and use BKPfactor() */\n    blocks = px_get(A->m);\n    pivot = px_resize(pivot,A->m);\n    x = v_resize(x,A->m);\n    y = v_resize(y,A->m);\n    z = v_resize(z,A->m);\n    v_rand(x);\n    mv_mlt(A,x,y);\n    BKPfactor(A,pivot,blocks);\n    printf(""# BKP pivot =\n"");	px_output(pivot);\n    printf(""# BKP blocks =\n"");	px_output(blocks);\n    BKPsolve(A,pivot,blocks,y,z);\n    /* compute & check residual */\n    mv_mlt(C,z,w);\n    v_sub(w,y,w);\n    if ( v_norm2(w) >= MACHEPS*m_norm1(C)*v_norm2(z) )\n    {\n	errmesg(""BKPfactor()/BKPsolve()"");\n	printf(""# BKP residual size = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(w), MACHEPS);\n    }\n\n    /* check update routines */\n    /* check LDLupdate() first */\n    notice(""update L.D.L^T routine"");\n    A = mtrm_mlt(B,B,A);\n    m_resize(C,A->m,A->n);\n    C = m_copy(A,C);\n    LDLfactor(A);\n    s1 = 3.7;\n    w = v_resize(w,A->m);\n    v_rand(w);\n    for ( i = 0; i < C->m; i++ )\n	for ( j = 0; j < C->n; j++ )\n	    m_set_val(C,i,j,m_entry(C,i,j)+s1*v_entry(w,i)*v_entry(w,j));\n    LDLfactor(C);\n    LDLupdate(A,w,s1);\n    /* zero out strictly upper triangular parts of A and C */\n    for ( i = 0; i < A->m; i++ )\n	for ( j = i+1; j < A->n; j++ )\n	{\n	    m_set_val(A,i,j,0.0);\n	    m_set_val(C,i,j,0.0);\n	}\n    if ( m_norm1(m_sub(A,C,C)) >= sqrt(MACHEPS)*m_norm1(A) )\n    {\n	errmesg(""LDLupdate()"");\n	printf(""# LDL update matrix error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(C), MACHEPS);\n    }\n\n\n    /* BAND MATRICES */\n\n#define COL 40\n#define UDIAG  5\n#define LDIAG  2\n\n   smrand(101);\n   bA = bd_get(LDIAG,UDIAG,COL);\n   bB = bd_get(LDIAG,UDIAG,COL);\n   bC = bd_get(LDIAG,UDIAG,COL);\n   A = m_resize(A,COL,COL);\n   B = m_resize(B,COL,COL);\n   pivot = px_resize(pivot,COL);\n   x = v_resize(x,COL);\n   w = v_resize(w,COL);\n   z = v_resize(z,COL);\n\n   m_rand(A); \n   /* generate band matrix */\n   mat2band(A,LDIAG,UDIAG,bA);\n   band2mat(bA,A);    /* now A is banded */\n   bB = bd_copy(bA,bB); \n\n   v_rand(x);  \n   mv_mlt(A,x,w);\n   /* test of bd_mv_mlt */\n   notice(""bd_mv_mlt"");\n   bd_mv_mlt(bA,x,z);\n   v_sub(z,w,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg(""incorrect vector (bd_mv_mlt)"");\n      printf("" ||exact vector. - computed vector.|| = %g [MACHEPS = %g]\n"",\n             v_norm2(z),MACHEPS);\n   }   \n\n   z = v_copy(w,z);\n\n   notice(""band LU factorization"");\n   bdLUfactor(bA,pivot);\n\n   /* pivot will be changed */\n   bdLUsolve(bA,pivot,z,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg(""incorrect solution (band LU factorization)"");\n      printf("" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n"",\n	     v_norm2(z),MACHEPS);\n   }\n\n   /* solve transpose system */\n\n   notice(""band LU factorization for transpose system"");\n   m_transp(A,B);\n   mv_mlt(B,x,w);\n\n   bd_copy(bB,bA);\n   bd_transp(bA,bA);  \n   /* transposition in situ */\n   bd_transp(bA,bB);\n   bd_transp(bB,bB);\n\n   bdLUfactor(bB,pivot);\n\n   bdLUsolve(bB,pivot,w,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg(""incorrect solution (band transposed LU factorization)"");\n      printf("" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n"",\n	     v_norm2(z),MACHEPS);\n   }\n\n\n   /* Cholesky factorization */\n\n   notice(""band Choleski LDL' factorization"");\n   m_add(A,B,A);  /* symmetric matrix */\n   for (i=0; i < COL; i++)     /* positive definite */\n     A->me[i][i] += 2*LDIAG;   \n\n   mat2band(A,LDIAG,LDIAG,bA);\n   band2mat(bA,A);              /* corresponding matrix A */\n\n   v_rand(x);\n   mv_mlt(A,x,w);\n   z = v_copy(w,z);\n   \n   bdLDLfactor(bA);\n\n   z = bdLDLsolve(bA,z,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg(""incorrect solution (band LDL' factorization)"");\n      printf("" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n"",\n	     v_norm2(z),MACHEPS);\n   }\n\n   /* new bandwidths */\n   m_rand(A);\n   bA = bd_resize(bA,UDIAG,LDIAG,COL);\n   bB = bd_resize(bB,UDIAG,LDIAG,COL);\n   mat2band(A,UDIAG,LDIAG,bA);\n   band2mat(bA,A);\n   bd_copy(bA,bB);\n\n   mv_mlt(A,x,w);\n\n   notice(""band LU factorization (resized)"");\n   bdLUfactor(bA,pivot);\n\n   /* pivot will be changed */\n   bdLUsolve(bA,pivot,w,z);\n   v_sub(x,z,z);\n   if (v_norm2(z) > v_norm2(x)*sqrt(MACHEPS)) {\n      errmesg(""incorrect solution (band LU factorization)"");\n      printf("" ||exact sol. - computed sol.|| = %g [MACHEPS = %g]\n"",\n	     v_norm2(z),MACHEPS);\n   }\n\n   /* testing transposition */\n\n   notice(""band matrix transposition"");\n   m_zero(bA->mat);\n   bd_copy(bB,bA);\n   m_zero(bB->mat);\n   bd_copy(bA,bB);\n\n   bd_transp(bB,bB);\n   bd_transp(bB,bB);\n\n   m_zero(bC->mat);\n   bd_copy(bB,bC);\n\n   m_sub(bA->mat,bC->mat,bC->mat);\n   if (m_norm_inf(bC->mat) > MACHEPS*bC->mat->n) {\n      errmesg(""band transposition"");\n      printf("" difference ||A - (A')'|| = %g\n"",m_norm_inf(bC->mat));\n   }\n \n   bd_free(bA);\n   bd_free(bB);\n   bd_free(bC);\n\n\n    MEMCHK();\n\n    /* now check QRupdate() routine */\n    notice(""update QR routine"");\n\n    B = m_resize(B,15,7);\n    A = m_resize(A,B->m,B->n);\n    m_copy(B,A);\n    diag = v_resize(diag,A->n);\n    beta = v_resize(beta,A->n);\n    QRfactor(A,diag);\n    Q = m_resize(Q,A->m,A->m);\n    makeQ(A,diag,Q);\n    makeR(A,A);\n    m_resize(C,A->m,A->n);\n    w = v_resize(w,A->m);\n    v = v_resize(v,A->n);\n    u = v_resize(u,A->m);\n    v_rand(w);\n    v_rand(v);\n    vm_mlt(Q,w,u);\n    QRupdate(Q,A,u,v);\n    m_mlt(Q,A,C);\n    for ( i = 0; i < B->m; i++ )\n	for ( j = 0; j < B->n; j++ )\n	    m_set_val(B,i,j,m_entry(B,i,j)+v_entry(w,i)*v_entry(v,j));\n    m_sub(B,C,C);\n    if ( m_norm1(C) >= MACHEPS*m_norm1(A)*m_norm1(Q)*2 )\n    {\n	errmesg(""QRupdate()"");\n	printf(""# Reconstruction error in QR update = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(C), MACHEPS);\n    }\n    m_resize(D,Q->m,Q->n);\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= 10*MACHEPS*m_norm1(Q)*m_norm_inf(Q) )\n    {\n	errmesg(""QRupdate()"");\n	printf(""# QR update orthogonality error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n\n    /* Now check eigenvalue/SVD routines */\n    notice(""eigenvalue and SVD routines"");\n    A = m_resize(A,11,11);\n    B = m_resize(B,A->m,A->n);\n    C = m_resize(C,A->m,A->n);\n    D = m_resize(D,A->m,A->n);\n    Q = m_resize(Q,A->m,A->n);\n\n    m_rand(A);\n    /* A <- A + A^T  for symmetric case */\n    m_add(A,m_transp(A,C),A);\n    u = v_resize(u,A->m);\n    u = symmeig(A,Q,u);\n    m_zero(B);\n    for ( i = 0; i < B->m; i++ )\n	m_set_val(B,i,i,v_entry(u,i));\n    m_mlt(Q,B,C);\n    mmtr_mlt(C,Q,D);\n    m_sub(A,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*v_norm_inf(u)*3 )\n    {\n	errmesg(""symmeig()"");\n	printf(""# Reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*3 )\n    {\n	errmesg(""symmeig()"");\n	printf(""# symmeig() orthogonality error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now test (real) Schur decomposition */\n    /* m_copy(A,B); */\n    M_FREE(A);\n    A = m_get(11,11);\n    m_rand(A);\n    B = m_copy(A,B);\n    MEMCHK();\n\n    B = schur(B,Q);\n    MEMCHK();\n\n    m_mlt(Q,B,C);\n    mmtr_mlt(C,Q,D);\n    MEMCHK();\n    m_sub(A,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*m_norm1(B)*5 )\n    {\n	errmesg(""schur()"");\n	printf(""# Schur reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n\n    /* orthogonality check */\n    mmtr_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*10 )\n    {\n	errmesg(""schur()"");\n	printf(""# Schur orthogonality error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now test SVD */\n    A = m_resize(A,11,7);\n    m_rand(A);\n    U = m_get(A->n,A->n);\n    Q = m_resize(Q,A->m,A->m);\n    u = v_resize(u,max(A->m,A->n));\n    svd(A,Q,U,u);\n    /* check reconstruction of A */\n    D = m_resize(D,A->m,A->n);\n    C = m_resize(C,A->m,A->n);\n    m_zero(D);\n    for ( i = 0; i < min(A->m,A->n); i++ )\n	m_set_val(D,i,i,v_entry(u,i));\n    mtrm_mlt(Q,D,C);\n    m_mlt(C,U,D);\n    m_sub(A,D,D);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(U)*m_norm_inf(Q)*m_norm1(A) )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       m_norm1(D), MACHEPS);\n    }\n    /* check orthogonality of Q and U */\n    D = m_resize(D,Q->n,Q->n);\n    mtrm_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(Q)*m_norm_inf(Q)*5 )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD orthognality error (Q) = %g [cf MACHEPS = %g\n"",\n	       m_norm1(D), MACHEPS);\n    }\n    D = m_resize(D,U->n,U->n);\n    mtrm_mlt(U,U,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( m_norm1(D) >= MACHEPS*m_norm1(U)*m_norm_inf(U)*5 )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD orthognality error (U) = %g [cf MACHEPS = %g\n"",\n	       m_norm1(D), MACHEPS);\n    }\n    for ( i = 0; i < u->dim; i++ )\n	if ( v_entry(u,i) < 0 || (i < u->dim-1 &&\n				  v_entry(u,i+1) > v_entry(u,i)) )\n	    break;\n    if ( i < u->dim )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD sorting error\n"");\n    }\n\n\n    /* test of long vectors */\n    notice(""Long vectors"");\n    x = v_resize(x,100000);\n    y = v_resize(y,100000);\n    z = v_resize(z,100000);\n    v_rand(x);\n    v_rand(y);\n    v_mltadd(x,y,3.0,z);\n    sv_mlt(1.0/3.0,z,z);\n    v_mltadd(z,x,-1.0/3.0,z);\n    v_sub(z,y,x);\n    if (v_norm2(x) >= MACHEPS*(x->dim)) {\n       errmesg(""long vectors"");\n       printf("" norm = %g\n"",v_norm2(x));\n    }\n\n    mem_stat_free(1);\n\n    MEMCHK();\n\n    /**************************************************\n    VEC		*x, *y, *z, *u, *v, *w;\n    VEC		*diag, *beta;\n    PERM	*pi1, *pi2, *pi3, *pivot, *blocks;\n    MAT		*A, *B, *C, *D, *Q, *U;\n    **************************************************/\n    V_FREE(x);		V_FREE(y);	V_FREE(z);\n    V_FREE(u);		V_FREE(v);	V_FREE(w);\n    V_FREE(diag);	V_FREE(beta);\n    PX_FREE(pi1);	PX_FREE(pi2);	PX_FREE(pi3);\n    PX_FREE(pivot);	PX_FREE(blocks);\n    M_FREE(A);		M_FREE(B);	M_FREE(C);\n    M_FREE(D);		M_FREE(Q);	M_FREE(U);\n\n    MEMCHK();\n    printf(""# Finished torture test\n"");\n    mem_info();\n\n    return 0;\n}\n\n\n"
leukocyte/meschach_lib/err.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  File with basic error-handling operations\n*/\n\nstatic	char	rcsid[] = ""$Id: err.c,v 1.6 1995/01/30 14:49:14 des Exp $"";\n\n#include	<stdio.h>\n#include	<setjmp.h>\n#include	<ctype.h>\n#include        ""err.h""\n\n\n#ifdef SYSV\n/* AT&T System V */\n#include	<sys/signal.h>\n#else\n/* something else -- assume BSD or ANSI C */\n#include	<signal.h>\n#endif\n\n\n\n#define		FALSE	0\n#define		TRUE	1\n\n#define	EF_EXIT		0\n#define	EF_ABORT	1\n#define	EF_JUMP		2\n#define	EF_SILENT	3\n\n/* The only error caught in this file! */\n#define	E_SIGNAL	16\n\nstatic	char	*err_mesg[] =\n{	  ""unknown error"",			    /* 0 */\n	  ""sizes of objects don't match"",	    /* 1 */\n	  ""index out of bounds"",		    /* 2 */\n	  ""can't allocate memory"",		    /* 3 */\n	  ""singular matrix"",			    /* 4 */\n	  ""matrix not positive definite"",	    /* 5 */\n	  ""incorrect format input"",		    /* 6 */\n	  ""bad input file/device"",		    /* 7 */\n	  ""NULL objects passed"",		    /* 8 */\n	  ""matrix not square"",			    /* 9 */\n	  ""object out of range"",		    /* 10 */\n	  ""can't do operation in situ for non-square matrix"",   /* 11 */\n	  ""can't do operation in situ"",		    /* 12 */\n	  ""excessive number of iterations"",	    /* 13 */\n	  ""convergence criterion failed"",	    /* 14 */\n	  ""bad starting value"",			    /* 15 */\n	  ""floating exception"",			    /* 16 */\n	  ""internal inconsistency (data structure)"",/* 17 */\n	  ""unexpected end-of-file"",		    /* 18 */\n	  ""shared vectors (cannot release them)"",   /* 19 */  \n	  ""negative argument"",			    /* 20 */\n	  ""cannot overwrite object"",                /* 21 */\n	  ""breakdown in iterative method""           /* 22 */\n	 };\n\n#define	MAXERR	(sizeof(err_mesg)/sizeof(char *))\n\nstatic char *warn_mesg[] = {\n   ""unknown warning"",				  /* 0 */\n   ""wrong type number (use macro TYPE_*)"",	  /* 1 */\n   ""no corresponding mem_stat_mark"",		  /* 2 */\n   ""computed norm of a residual is less than 0"",  /* 3 */\n   ""resizing a shared vector""			  /* 4 */\n};\n\n#define MAXWARN  (sizeof(warn_mesg)/sizeof(char *))\n\n\n\n#define	MAX_ERRS	100\n\njmp_buf	restart;\n\n\n/* array of pointers to lists of errors */\n\ntypedef struct {\n   char **listp;    /* pointer to a list of errors */\n   unsigned len;    /* length of the list */\n   unsigned warn;   /* =FALSE - errors, =TRUE - warnings */\n}  Err_list;\n\nstatic Err_list     err_list[ERR_LIST_MAX_LEN] = {\n {err_mesg,MAXERR,FALSE},	/* basic errors list */\n {warn_mesg,MAXWARN,TRUE}	/* basic warnings list */\n};\n\n\nstatic int err_list_end = 2;   /* number of elements in err_list */\n\n/* attach a new list of errors pointed by err_ptr\n   or change a previous one;\n   list_len is the number of elements in the list;\n   list_num is the list number;\n   warn == FALSE - errors (stop the program),\n   warn == TRUE - warnings (continue the program);\n   Note: lists numbered 0 and 1 are attached automatically,\n   you do not need to do it\n   */\n#ifndef ANSI_C\nint err_list_attach(list_num, list_len,err_ptr,warn)\nint list_num, list_len, warn;\nchar **err_ptr;\n#else\nint err_list_attach(int list_num, int list_len, char **err_ptr, int warn)\n#endif\n{\n   if (list_num < 0 || list_len <= 0 ||\n       err_ptr == (char **)NULL) \n     return -1;\n   \n   if (list_num >= ERR_LIST_MAX_LEN) {\n	fprintf(stderr,""\n file \""%s\"": %s %s\n"",\n		""err.c"",""increase the value of ERR_LIST_MAX_LEN"",\n		""in matrix.h and zmatdef.h"");\n	if ( ! isatty(fileno(stdout)) )\n	  fprintf(stderr,""\n file \""%s\"": %s %s\n"",\n		  ""err.c"",""increase the value of ERR_LIST_MAX_LEN"",\n		  ""in matrix.h and zmatdef.h"");\n	printf(""Exiting program\n"");\n	exit(0);\n     }\n\n   if (err_list[list_num].listp != (char **)NULL &&\n       err_list[list_num].listp != err_ptr)\n     free((char *)err_list[list_num].listp);\n   err_list[list_num].listp = err_ptr;\n   err_list[list_num].len = list_len;\n   err_list[list_num].warn = warn;\n   err_list_end = list_num+1;\n   \n   return list_num;\n}\n\n\n/* release the error list numbered list_num */\n#ifndef ANSI_C\nint err_list_free(list_num)\nint list_num;\n#else\nint err_list_free(int list_num)\n#endif\n{\n   if (list_num < 0 || list_num >= err_list_end) return -1;\n   if (err_list[list_num].listp != (char **)NULL) {\n      err_list[list_num].listp = (char **)NULL;\n      err_list[list_num].len = 0;\n      err_list[list_num].warn = 0;\n   }\n   return 0;\n}\n\n\n/* check if list_num is attached;\n   return FALSE if not;\n   return TRUE if yes\n   */\n#ifndef ANSI_C\nint err_is_list_attached(list_num)\nint list_num;\n#else\nint err_is_list_attached(int list_num)\n#endif\n{\n   if (list_num < 0 || list_num >= err_list_end)\n     return FALSE;\n   \n   if (err_list[list_num].listp != (char **)NULL)\n     return TRUE;\n   \n   return FALSE;\n}\n\n/* other local variables */\n\nstatic	int	err_flag = EF_EXIT, num_errs = 0, cnt_errs = 1;\n\n/* set_err_flag -- sets err_flag -- returns old err_flag */\n#ifndef ANSI_C\nint	set_err_flag(flag)\nint	flag;\n#else\nint	set_err_flag(int flag)\n#endif\n{\n   int	tmp;\n   \n   tmp = err_flag;\n   err_flag = flag;\n   return tmp;\n}\n\n/* count_errs -- sets cnt_errs (TRUE/FALSE) & returns old value */\n#ifndef ANSI_C\nint	count_errs(flag)\nint	flag;\n#else\nint	count_errs(int flag)\n#endif\n{\n   int	tmp;\n   \n   tmp = cnt_errs;\n   cnt_errs = flag;\n   return tmp;\n}\n\n/* ev_err -- reports error (err_num) in file ""file"" at line ""line_num"" and\n   returns to user error handler;\n   list_num is an error list number (0 is the basic list \n   pointed by err_mesg, 1 is the basic list of warnings)\n */\n#ifndef ANSI_C\nint	ev_err(file,err_num,line_num,fn_name,list_num)\nchar	*file, *fn_name;\nint	err_num, line_num,list_num;\n#else\nint	ev_err(const char *file, int err_num, int line_num,\n	       const char *fn_name, int list_num)\n#endif\n{\n   int	num;\n   \n   if ( err_num < 0 ) err_num = 0;\n   \n   if (list_num < 0 || list_num >= err_list_end ||\n       err_list[list_num].listp == (char **)NULL) {\n      fprintf(stderr,\n	      ""\n Not (properly) attached list of errors: list_num = %d\n"",\n	      list_num);\n      fprintf(stderr,"" Call \""err_list_attach\"" in your program\n"");\n      if ( ! isatty(fileno(stdout)) ) {\n	 fprintf(stderr,\n		 ""\n Not (properly) attached list of errors: list_num = %d\n"",\n		 list_num);\n	 fprintf(stderr,"" Call \""err_list_attach\"" in your program\n"");\n      }\n      printf(""\nExiting program\n"");\n      exit(0);\n   }\n   \n   num = err_num;\n   if ( num >= err_list[list_num].len ) num = 0;\n   \n   if ( cnt_errs && ++num_errs >= MAX_ERRS )	/* too many errors */\n   {\n      fprintf(stderr,""\n\""%s\"", line %d: %s in function %s()\n"",\n	      file,line_num,err_list[list_num].listp[num],\n	      isascii(*fn_name) ? fn_name : ""???"");\n      if ( ! isatty(fileno(stdout)) )\n	fprintf(stdout,""\n\""%s\"", line %d: %s in function %s()\n"",\n		file,line_num,err_list[list_num].listp[num],\n		isascii(*fn_name) ? fn_name : ""???"");\n      printf(""Sorry, too many errors: %d\n"",num_errs);\n      printf(""Exiting program\n"");\n      exit(0);\n   }\n   if ( err_list[list_num].warn )\n       switch ( err_flag )\n       {\n	   case EF_SILENT: break;\n	   default:\n	   fprintf(stderr,""\n\""%s\"", line %d: %s in function %s()\n\n"",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : ""???"");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,""\n\""%s\"", line %d: %s in function %s()\n\n"",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : ""???"");\n	   break;\n       }\n   else\n       switch ( err_flag )\n       {\n	   case EF_SILENT:\n	   longjmp(restart,(err_num==0)? -1 : err_num);\n	   break;\n	   case EF_ABORT:\n	   fprintf(stderr,""\n\""%s\"", line %d: %s in function %s()\n"",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : ""???"");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,""\n\""%s\"", line %d: %s in function %s()\n"",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : ""???"");\n	   abort();\n	   break;\n	   case EF_JUMP:\n	   fprintf(stderr,""\n\""%s\"", line %d: %s in function %s()\n"",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : ""???"");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,""\n\""%s\"", line %d: %s in function %s()\n"",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : ""???"");\n	   longjmp(restart,(err_num==0)? -1 : err_num);\n	   break;\n	   default:\n	   fprintf(stderr,""\n\""%s\"", line %d: %s in function %s()\n\n"",\n		   file,line_num,err_list[list_num].listp[num],\n		   isascii(*fn_name) ? fn_name : ""???"");\n	   if ( ! isatty(fileno(stdout)) )\n	       fprintf(stdout,""\n\""%s\"", line %d: %s in function %s()\n\n"",\n		       file,line_num,err_list[list_num].listp[num],\n		       isascii(*fn_name) ? fn_name : ""???"");\n	   \n	   break;\n       }\n   \n   /* ensure exit if fall through */\n   if ( ! err_list[list_num].warn )  exit(0);\n\n   return 0;\n}\n\n/* float_error -- catches floating arithmetic signals */\n#ifndef ANSI_C\nstatic void	float_error(num)\nint	num;\n#else\nstatic void	float_error(int num)\n#endif\n{\n   signal(SIGFPE,float_error);\n   /* fprintf(stderr,""SIGFPE: signal #%d\n"",num); */\n   /* fprintf(stderr,""errno = %d\n"",errno); */\n   ev_err(""???.c"",E_SIGNAL,0,""???"",0);\n}\n\n/* catch_signal -- sets up float_error() to catch SIGFPE's */\nvoid	catch_FPE()\n{\n   signal(SIGFPE,float_error);\n}\n\n\n"
leukocyte/meschach_lib/lanczos.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File containing Lanczos type routines for finding eigenvalues\n	of large, sparse, symmetic matrices\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include	""sparse.h""\n\nstatic char rcsid[] = ""$Id: lanczos.c,v 1.4 1994/01/13 05:28:24 des Exp $"";\n\n#ifdef ANSI_C\nextern	VEC	*trieig(VEC *,VEC *,MAT *);\n#else\nextern	VEC	*trieig();\n#endif\n\n/* lanczos -- raw lanczos algorithm -- no re-orthogonalisation\n	-- creates T matrix of size == m,\n		but no larger than before beta_k == 0\n	-- uses passed routine to do matrix-vector multiplies */\nvoid	lanczos(A_fn,A_params,m,x0,a,b,beta2,Q)\nVEC	*(*A_fn)();	/* VEC *(*A_fn)(void *A_params,VEC *in, VEC *out) */\nvoid	*A_params;\nint	m;\nVEC	*x0, *a, *b;\nReal	*beta2;\nMAT	*Q;\n{\n	int	j;\n	VEC	*v, *w, *tmp;\n	Real	alpha, beta;\n\n	if ( ! A_fn || ! x0 || ! a || ! b )\n		error(E_NULL,""lanczos"");\n	if ( m <= 0 )\n		error(E_BOUNDS,""lanczos"");\n	if ( Q && ( Q->m < x0->dim || Q->n < m ) )\n		error(E_SIZES,""lanczos"");\n\n	a = v_resize(a,(unsigned int)m);\n	b = v_resize(b,(unsigned int)(m-1));\n	v = v_get(x0->dim);\n	w = v_get(x0->dim);\n	tmp = v_get(x0->dim);\n\n	beta = 1.0;\n	/* normalise x0 as w */\n	sv_mlt(1.0/v_norm2(x0),x0,w);\n\n	(*A_fn)(A_params,w,v);\n\n	for ( j = 0; j < m; j++ )\n	{\n		/* store w in Q if Q not NULL */\n		if ( Q )\n		    set_col(Q,j,w);\n\n		alpha = in_prod(w,v);\n		a->ve[j] = alpha;\n		v_mltadd(v,w,-alpha,v);\n		beta = v_norm2(v);\n		if ( beta == 0.0 )\n		{\n		    v_resize(a,(unsigned int)j+1);\n		    v_resize(b,(unsigned int)j);\n		    *beta2 = 0.0;\n		    if ( Q )\n			Q = m_resize(Q,Q->m,j+1);\n		    return;\n		}\n		if ( j < m-1 )\n		    b->ve[j] = beta;\n		v_copy(w,tmp);\n		sv_mlt(1/beta,v,w);\n		sv_mlt(-beta,tmp,v);\n		(*A_fn)(A_params,w,tmp);\n		v_add(v,tmp,v);\n	}\n	*beta2 = beta;\n\n\n	V_FREE(v);	V_FREE(w);	V_FREE(tmp);\n}\n\nextern	double	frexp(), ldexp();\n\n/* product -- returns the product of a long list of numbers\n	-- answer stored in mant (mantissa) and expt (exponent) */\nstatic	double	product(a,offset,expt)\nVEC	*a;\ndouble	offset;\nint	*expt;\n{\n	Real	mant, tmp_fctr;\n	int	i, tmp_expt;\n\n	if ( ! a )\n		error(E_NULL,""product"");\n\n	mant = 1.0;\n	*expt = 0;\n	if ( offset == 0.0 )\n		for ( i = 0; i < a->dim; i++ )\n		{\n			mant *= frexp(a->ve[i],&tmp_expt);\n			*expt += tmp_expt;\n			if ( ! (i % 10) )\n			{\n			    mant = frexp(mant,&tmp_expt);\n			    *expt += tmp_expt;\n			}\n		}\n	else\n		for ( i = 0; i < a->dim; i++ )\n		{\n			tmp_fctr = a->ve[i] - offset;\n			tmp_fctr += (tmp_fctr > 0.0 ) ? -MACHEPS*offset :\n							 MACHEPS*offset;\n			mant *= frexp(tmp_fctr,&tmp_expt);\n			*expt += tmp_expt;\n			if ( ! (i % 10) )\n			{\n			    mant = frexp(mant,&tmp_expt);\n			    *expt += tmp_expt;\n			}\n		}\n\n	mant = frexp(mant,&tmp_expt);\n	*expt += tmp_expt;\n\n	return mant;\n}\n\n/* product2 -- returns the product of a long list of numbers\n	-- answer stored in mant (mantissa) and expt (exponent) */\nstatic	double	product2(a,k,expt)\nVEC	*a;\nint	k;	/* entry of a to leave out */\nint	*expt;\n{\n	Real	mant, mu, tmp_fctr;\n	int	i, tmp_expt;\n\n	if ( ! a )\n		error(E_NULL,""product2"");\n	if ( k < 0 || k >= a->dim )\n		error(E_BOUNDS,""product2"");\n\n	mant = 1.0;\n	*expt = 0;\n	mu = a->ve[k];\n	for ( i = 0; i < a->dim; i++ )\n	{\n		if ( i == k )\n			continue;\n		tmp_fctr = a->ve[i] - mu;\n		tmp_fctr += ( tmp_fctr > 0.0 ) ? -MACHEPS*mu : MACHEPS*mu;\n		mant *= frexp(tmp_fctr,&tmp_expt);\n		*expt += tmp_expt;\n		if ( ! (i % 10) )\n		{\n		    mant = frexp(mant,&tmp_expt);\n		    *expt += tmp_expt;\n		}\n	}\n	mant = frexp(mant,&tmp_expt);\n	*expt += tmp_expt;\n\n	return mant;\n}\n\n/* dbl_cmp -- comparison function to pass to qsort() */\nstatic	int	dbl_cmp(x,y)\nReal	*x, *y;\n{\n	Real	tmp;\n\n	tmp = *x - *y;\n	return (tmp > 0 ? 1 : tmp < 0 ? -1: 0);\n}\n\n/* lanczos2 -- lanczos + error estimate for every e-val\n	-- uses Cullum & Willoughby approach, Sparse Matrix Proc. 1978\n	-- returns multiple e-vals where multiple e-vals may not exist\n	-- returns evals vector */\nVEC	*lanczos2(A_fn,A_params,m,x0,evals,err_est)\nVEC	*(*A_fn)();\nvoid	*A_params;\nint	m;\nVEC	*x0;		/* initial vector */\nVEC	*evals;		/* eigenvalue vector */\nVEC	*err_est;	/* error estimates of eigenvalues */\n{\n	VEC		*a;\n	STATIC	VEC	*b=VNULL, *a2=VNULL, *b2=VNULL;\n	Real	beta, pb_mant, det_mant, det_mant1, det_mant2;\n	int	i, pb_expt, det_expt, det_expt1, det_expt2;\n\n	if ( ! A_fn || ! x0 )\n		error(E_NULL,""lanczos2"");\n	if ( m <= 0 )\n		error(E_RANGE,""lanczos2"");\n\n	a = evals;\n	a = v_resize(a,(unsigned int)m);\n	b = v_resize(b,(unsigned int)(m-1));\n	MEM_STAT_REG(b,TYPE_VEC);\n\n	lanczos(A_fn,A_params,m,x0,a,b,&beta,MNULL);\n\n	/* printf(""# beta =%g\n"",beta); */\n	pb_mant = 0.0;\n	if ( err_est )\n	{\n		pb_mant = product(b,(double)0.0,&pb_expt);\n		/* printf(""# pb_mant = %g, pb_expt = %d\n"",pb_mant, pb_expt); */\n	}\n\n	/* printf(""# diags =\n"");	out_vec(a); */\n	/* printf(""# off diags =\n"");	out_vec(b); */\n	a2 = v_resize(a2,a->dim - 1);\n	b2 = v_resize(b2,b->dim - 1);\n	MEM_STAT_REG(a2,TYPE_VEC);\n	MEM_STAT_REG(b2,TYPE_VEC);\n	for ( i = 0; i < a2->dim - 1; i++ )\n	{\n		a2->ve[i] = a->ve[i+1];\n		b2->ve[i] = b->ve[i+1];\n	}\n	a2->ve[a2->dim-1] = a->ve[a2->dim];\n\n	trieig(a,b,MNULL);\n\n	/* sort evals as a courtesy */\n	qsort((void *)(a->ve),(int)(a->dim),sizeof(Real),(int (*)())dbl_cmp);\n\n	/* error estimates */\n	if ( err_est )\n	{\n		err_est = v_resize(err_est,(unsigned int)m);\n\n		trieig(a2,b2,MNULL);\n		/* printf(""# a =\n"");	out_vec(a); */\n		/* printf(""# a2 =\n"");	out_vec(a2); */\n\n		for ( i = 0; i < a->dim; i++ )\n		{\n			det_mant1 = product2(a,i,&det_expt1);\n			det_mant2 = product(a2,(double)a->ve[i],&det_expt2);\n			/* printf(""# det_mant1=%g, det_expt1=%d\n"",\n					det_mant1,det_expt1); */\n			/* printf(""# det_mant2=%g, det_expt2=%d\n"",\n					det_mant2,det_expt2); */\n			if ( det_mant1 == 0.0 )\n			{   /* multiple e-val of T */\n			    err_est->ve[i] = 0.0;\n			    continue;\n			}\n			else if ( det_mant2 == 0.0 )\n			{\n			    err_est->ve[i] = HUGE_VAL;\n			    continue;\n			}\n			if ( (det_expt1 + det_expt2) % 2 )\n			    /* if odd... */\n			    det_mant = sqrt(2.0*fabs(det_mant1*det_mant2));\n			else /* if even... */\n			    det_mant = sqrt(fabs(det_mant1*det_mant2));\n			det_expt = (det_expt1+det_expt2)/2;\n			err_est->ve[i] = fabs(beta*\n				ldexp(pb_mant/det_mant,pb_expt-det_expt));\n		}\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(b);	V_FREE(a2);	V_FREE(b2);\n#endif\n\n	return a;\n}\n\n/* sp_lanczos -- version that uses sparse matrix data structure */\nvoid    sp_lanczos(A,m,x0,a,b,beta2,Q)\nSPMAT	*A;\nint     m;\nVEC     *x0, *a, *b;\nReal  *beta2;\nMAT     *Q;\n{	lanczos(sp_mv_mlt,A,m,x0,a,b,beta2,Q);	}\n\n/* sp_lanczos2 -- version of lanczos2() that uses sparse matrix data\n					structure */\nVEC	*sp_lanczos2(A,m,x0,evals,err_est)\nSPMAT	*A;\nint	m;\nVEC	*x0;		/* initial vector */\nVEC	*evals;		/* eigenvalue vector */\nVEC	*err_est;	/* error estimates of eigenvalues */\n{	return lanczos2(sp_mv_mlt,A,m,x0,evals,err_est);	}\n\n"
leukocyte/meschach_lib/memtort.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* \n  Tests for mem_info.c functions\n  */\n\nstatic char rcsid[] = ""$Id: $"";\n\n#include        <stdio.h>\n#include        <math.h>\n#include        ""matrix2.h""\n#include 	""sparse2.h""\n#include  	""zmatrix2.h""\n\n\n#define errmesg(mesg)   printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)    printf(""# Testing %s...\n"",mesg)\n\n\n/*  new types list */\n\nextern MEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS];\n\n/* the number of a new list */\n#define FOO_LIST 1\n\n/* numbers of types */\n#define TYPE_FOO_1    1\n#define TYPE_FOO_2    2\n\ntypedef struct {\n   int dim;\n   int fix_dim;\n   Real (*a)[10];\n} FOO_1;\n\ntypedef struct {\n  int dim;\n  int fix_dim;\n  Real (*a)[2];\n} FOO_2;\n\n\n\nFOO_1 *foo_1_get(dim)\nint dim;\n{\n   FOO_1 *f;\n   \n   if ((f = (FOO_1 *)malloc(sizeof(FOO_1))) == NULL)\n     error(E_MEM,""foo_1_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes_list(TYPE_FOO_1,0,sizeof(FOO_1),FOO_LIST);\n      mem_numvar_list(TYPE_FOO_1,1,FOO_LIST);\n   }\n   \n   f->dim = dim;\n   f->fix_dim = 10;\n   if ((f->a = (Real (*)[10])malloc(dim*sizeof(Real [10]))) == NULL)\n      error(E_MEM,""foo_1_get"");\n   else if (mem_info_is_on())\n     mem_bytes_list(TYPE_FOO_1,0,dim*sizeof(Real [10]),FOO_LIST); \n\n   return f;\n}\n\n\nFOO_2 *foo_2_get(dim)\nint dim;\n{\n   FOO_2 *f;\n   \n   if ((f = (FOO_2 *)malloc(sizeof(FOO_2))) == NULL)\n     error(E_MEM,""foo_2_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes_list(TYPE_FOO_2,0,sizeof(FOO_2),FOO_LIST);\n      mem_numvar_list(TYPE_FOO_2,1,FOO_LIST);\n   }\n\n   f->dim = dim;\n   f->fix_dim = 2;\n   if ((f->a = (Real (*)[2])malloc(dim*sizeof(Real [2]))) == NULL)\n      error(E_MEM,""foo_2_get"");\n   else if (mem_info_is_on())\n     mem_bytes_list(TYPE_FOO_2,0,dim*sizeof(Real [2]),FOO_LIST); \n\n   return f;\n}\n\n\n\nint foo_1_free(f)\nFOO_1 *f;\n{\n   if ( f != NULL) {\n      if (mem_info_is_on()) {\n	 mem_bytes_list(TYPE_FOO_1,sizeof(FOO_1)+\n			f->dim*sizeof(Real [10]),0,FOO_LIST);\n	 mem_numvar_list(TYPE_FOO_1,-1,FOO_LIST);\n      }\n\n      free(f->a);\n      free(f);\n   }\n   return 0;\n}\n\nint foo_2_free(f)\nFOO_2 *f;\n{\n   if ( f != NULL) {\n      if (mem_info_is_on()) {\n	 mem_bytes_list(TYPE_FOO_2,sizeof(FOO_2)+\n			f->dim*sizeof(Real [2]),0,FOO_LIST);\n	 mem_numvar_list(TYPE_FOO_2,-1,FOO_LIST);\n      }\n\n      free(f->a);\n      free(f);\n   }\n   return 0;\n}\n\n\n\n\nchar *foo_type_name[] = {\n   ""nothing"",\n   ""FOO_1"",\n   ""FOO_2""\n};\n\n\n#define FOO_NUM_TYPES  (sizeof(foo_type_name)/sizeof(*foo_type_name))\n\n\nint (*foo_free_func[FOO_NUM_TYPES])() = {\n   NULL, \n   foo_1_free, \n   foo_2_free\n  };\n\n\n\nstatic MEM_ARRAY foo_info_sum[FOO_NUM_TYPES];\n\n\n\n  /* px_rand -- generates sort-of random permutation */\nPERM    *px_rand(pi)\nPERM    *pi;\n{\n   int         i, j, k;\n   \n   if ( ! pi )\n     error(E_NULL,""px_rand"");\n   \n   for ( i = 0; i < 3*pi->size; i++ )\n   {\n      j = (rand() >> 8) % pi->size;\n      k = (rand() >> 8) % pi->size;\n      px_transp(pi,j,k);\n   }\n   \n   return pi;\n}\n\n#ifdef SPARSE\nSPMAT  *gen_non_symm(m,n)\nint     m, n;\n{\n    SPMAT      *A;\n    static      PERM    *px = PNULL;\n    int         i, j, k, k_max;\n    Real        s1;\n\n    A = sp_get(m,n,8);\n    px = px_resize(px,n);\n    MEM_STAT_REG(px,TYPE_PERM);\n    for ( i = 0; i < A->m; i++ )\n    {\n        k_max = 1 + ((rand() >> 8) % 10);\n        for ( k = 0; k < k_max; k++ )\n        {\n            j = (rand() >> 8) % A->n;\n            s1 = rand()/((double)MAX_RAND);\n            sp_set_val(A,i,j,s1);\n        }\n    }\n    /* to make it likely that A is nonsingular, use pivot... */\n    for ( i = 0; i < 2*A->n; i++ )\n    {\n        j = (rand() >> 8) % A->n;\n        k = (rand() >> 8) % A->n;\n        px_transp(px,j,k);\n    }\n    for ( i = 0; i < A->n; i++ )\n        sp_set_val(A,i,px->pe[i],1.0);\n\n    \n    return A;\n}\n#endif\n\nvoid stat_test1(par)\nint par;\n{\n   static MAT *AT = MNULL;\n   static VEC *xt1 = VNULL, *yt1 = VNULL;\n   static VEC *xt2 = VNULL, *yt2 = VNULL;\n   static VEC *xt3 = VNULL, *yt3 = VNULL;\n   static VEC *xt4 = VNULL, *yt4 = VNULL;\n\n   AT = m_resize(AT,10,10);\n   xt1 = v_resize(xt1,10);\n   yt1 = v_resize(yt1,10);\n   xt2 = v_resize(xt2,10);\n   yt2 = v_resize(yt2,10);\n   xt3 = v_resize(xt3,10);\n   yt3 = v_resize(yt3,10);\n   xt4 = v_resize(xt4,10);\n   yt4 = v_resize(yt4,10);\n\n   MEM_STAT_REG(AT,TYPE_MAT);\n\n#ifdef ANSI_C\n   mem_stat_reg_vars(0,TYPE_VEC,__FILE__,__LINE__,&xt1,&xt2,&xt3,&xt4,&yt1,\n		     &yt2,&yt3,&yt4,NULL);\n#else\n#ifdef VARARGS\n   mem_stat_reg_vars(0,TYPE_VEC,__FILE__,__LINE__,&xt1,&xt2,&xt3,&xt4,&yt1,\n		     &yt2,&yt3,&yt4,NULL);\n#else\n   MEM_STAT_REG(xt1,TYPE_VEC);\n   MEM_STAT_REG(yt1,TYPE_VEC);\n   MEM_STAT_REG(xt2,TYPE_VEC);\n   MEM_STAT_REG(yt2,TYPE_VEC);\n   MEM_STAT_REG(xt3,TYPE_VEC);\n   MEM_STAT_REG(yt3,TYPE_VEC);\n   MEM_STAT_REG(xt4,TYPE_VEC);\n   MEM_STAT_REG(yt4,TYPE_VEC);\n#endif\n#endif\n\n   v_rand(xt1);\n   m_rand(AT);\n   mv_mlt(AT,xt1,yt1);\n   \n}\n\n\nvoid stat_test2(par)\nint par;\n{\n   static PERM *px = PNULL;\n   static IVEC *ixt = IVNULL, *iyt = IVNULL;\n   \n   px = px_resize(px,10);\n   ixt = iv_resize(ixt,10);\n   iyt = iv_resize(iyt,10);\n\n   MEM_STAT_REG(px,TYPE_PERM);\n   MEM_STAT_REG(ixt,TYPE_IVEC);\n   MEM_STAT_REG(iyt,TYPE_IVEC);\n\n   px_rand(px);\n   px_inv(px,px);\n}\n\n#ifdef SPARSE\nvoid stat_test3(par)\nint par;\n{\n   static SPMAT *AT = (SPMAT *)NULL;\n   static VEC *xt = VNULL, *yt = VNULL;\n   static SPROW *r = (SPROW *) NULL;\n   \n   if (AT == (SPMAT *)NULL)\n     AT = gen_non_symm(100,100);\n   else\n     AT = sp_resize(AT,100,100);\n   xt = v_resize(xt,100);\n   yt = v_resize(yt,100);\n   if (r == NULL) r = sprow_get(100);\n\n   MEM_STAT_REG(AT,TYPE_SPMAT);\n   MEM_STAT_REG(xt,TYPE_VEC);\n   MEM_STAT_REG(yt,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_SPROW);\n\n   v_rand(xt);\n   sp_mv_mlt(AT,xt,yt);\n   \n}\n#endif\n\n#ifdef COMPLEX\nvoid stat_test4(par)\nint par;\n{\n   static ZMAT *AT = ZMNULL;\n   static ZVEC *xt = ZVNULL, *yt = ZVNULL;\n   \n   AT = zm_resize(AT,10,10);\n   xt = zv_resize(xt,10);\n   yt = zv_resize(yt,10);\n\n   MEM_STAT_REG(AT,TYPE_ZMAT);\n   MEM_STAT_REG(xt,TYPE_ZVEC);\n   MEM_STAT_REG(yt,TYPE_ZVEC);\n\n   zv_rand(xt);\n   zm_rand(AT);\n   zmv_mlt(AT,xt,yt);\n   \n}\n#endif\n\n\nvoid main(argc, argv)\nint     argc;\nchar    *argv[];\n{\n   VEC  *x = VNULL, *y = VNULL, *z = VNULL;\n   PERM  *pi1 = PNULL, *pi2 = PNULL, *pi3 = PNULL;\n   MAT   *A = MNULL, *B = MNULL, *C = MNULL;\n#ifdef SPARSE\n   SPMAT *sA, *sB;\n   SPROW *r;\n#endif\n   IVEC *ix = IVNULL, *iy = IVNULL, *iz = IVNULL;\n   int m,n,i,j,deg,k;\n   Real s1,s2;\n#ifdef COMPLEX\n   ZVEC        *zx = ZVNULL, *zy = ZVNULL, *zz = ZVNULL;\n   ZMAT        *zA = ZMNULL, *zB = ZMNULL, *zC = ZMNULL;\n   complex     ONE;\n#endif\n   /* variables for testing attaching new lists of types  */\n   FOO_1 *foo_1;\n   FOO_2 *foo_2;\n\n\n   mem_info_on(TRUE);\n\n#if defined(ANSI_C) || defined(VARARGS)\n\n   notice(""vector initialize, copy & resize"");\n   \n   n = v_get_vars(15,&x,&y,&z,(VEC **)NULL);\n   if (n != 3) {\n      errmesg(""v_get_vars"");\n      printf("" n = %d (should be 3)\n"",n);\n   }\n\n   v_rand(x);\n   v_rand(y);\n   z = v_copy(x,z);\n   if ( v_norm2(v_sub(x,z,z)) >= MACHEPS )\n     errmesg(""v_get_vars"");\n   v_copy(x,y);\n   n = v_resize_vars(10,&x,&y,&z,NULL);\n   if ( n != 3 || v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg(""VEC copy/resize"");\n\n   n = v_resize_vars(20,&x,&y,&z,NULL);\n   if ( n != 3 || v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg(""VEC resize""); \n\n   n = v_free_vars(&x,&y,&z,NULL);\n   if (n != 3)\n     errmesg(""v_free_vars"");\n   \n   /* IVEC */\n   notice(""int vector initialise, copy & resize"");\n   n = iv_get_vars(15,&ix,&iy,&iz,NULL);\n\n   if (n != 3) {\n      errmesg(""iv_get_vars"");\n      printf("" n = %d (should be 3)\n"",n);\n   }\n   for (i=0; i < ix->dim; i++) {\n      ix->ive[i] = 2*i-1;\n      iy->ive[i] = 3*i+2;\n   }\n   iz = iv_add(ix,iy,iz);\n   for (i=0; i < ix->dim; i++) \n     if ( iz->ive[i] != 5*i+1)\n       errmesg(""iv_get_vars"");\n   \n   n = iv_resize_vars(10,&ix,&iy,&iz,NULL);\n   if ( n != 3) errmesg(""IVEC copy/resize"");\n   \n   iv_add(ix,iy,iz);\n   for (i=0; i < ix->dim; i++)\n     if (iz->ive[i] != 5*i+1)\n       errmesg(""IVEC copy/resize"");\n   \n   n = iv_resize_vars(20,&ix,&iy,&iz,NULL);\n   if ( n != 3 ) errmesg(""IVEC resize"");\n   \n   iv_add(ix,iy,iz);\n   for (i=0; i < 10; i++)\n     if (iz->ive[i] != 5*i+1)\n       errmesg(""IVEC copy/resize"");\n   \n   n = iv_free_vars(&ix,&iy,&iz,NULL);\n   if (n != 3) \n     errmesg(""iv_free_vars"");\n   \n   /* MAT */\n   notice(""matrix initialise, copy & resize"");\n   n = m_get_vars(10,10,&A,&B,&C,NULL);\n   if (n != 3) {\n      errmesg(""m_get_vars"");\n      printf("" n = %d (should be 3)\n"",n);\n   }\n   \n   m_rand(A);\n   m_rand(B);\n   C = m_copy(A,C);\n   if ( m_norm_inf(m_sub(A,C,C)) >= MACHEPS )\n     errmesg(""MAT copy"");\n   m_copy(A,B);\n   n = m_resize_vars(5,5,&A,&B,&C,NULL);\n   if ( n != 3 || m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n     errmesg(""MAT copy/resize"");\n   \n   n = m_resize_vars(20,20,&A,&B,NULL);\n   if ( m_norm_inf(m_sub(A,B,C)) >= MACHEPS )\n     errmesg(""MAT resize""); \n   \n   k = m_free_vars(&A,&B,&C,NULL);\n   if ( k != 3 )\n     errmesg(""MAT free"");\n   \n   /* PERM */\n   notice(""permutation initialise, inverting & permuting vectors"");\n   n = px_get_vars(15,&pi1,&pi2,&pi3,NULL);\n   if (n != 3) {\n      errmesg(""px_get_vars"");\n      printf("" n = %d (should be 3)\n"",n);\n   }\n\n   v_get_vars(15,&x,&y,&z,NULL);\n   \n   px_rand(pi1);\n   v_rand(x);\n   px_vec(pi1,x,z);\n   y = v_resize(y,x->dim);\n   pxinv_vec(pi1,z,y);\n   if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg(""PERMute vector"");\n   pi2 = px_inv(pi1,pi2);\n   pi3 = px_mlt(pi1,pi2,pi3);\n   for ( i = 0; i < pi3->size; i++ )\n     if ( pi3->pe[i] != i )\n       errmesg(""PERM inverse/multiply"");\n   \n   px_resize_vars(20,&pi1,&pi2,&pi3,NULL);\n   v_resize_vars(20,&x,&y,&z,NULL);\n   \n   px_rand(pi1);\n   v_rand(x);\n   px_vec(pi1,x,z);\n   pxinv_vec(pi1,z,y);\n   if ( v_norm2(v_sub(x,y,z)) >= MACHEPS )\n     errmesg(""PERMute vector"");\n   pi2 = px_inv(pi1,pi2);\n   pi3 = px_mlt(pi1,pi2,pi3);\n   for ( i = 0; i < pi3->size; i++ )\n     if ( pi3->pe[i] != i )\n       errmesg(""PERM inverse/multiply"");\n   \n   n = px_free_vars(&pi1,&pi2,&pi3,NULL);\n   if ( n != 3 )\n     errmesg(""PERM px_free_vars""); \n\n#ifdef SPARSE   \n   /* set up two random sparse matrices */\n   m = 120;\n   n = 100;\n   deg = 5;\n   notice(""allocating sparse matrices"");\n   k = sp_get_vars(m,n,deg,&sA,&sB,NULL);\n   if (k != 2) {\n      errmesg(""sp_get_vars"");\n      printf("" n = %d (should be 2)\n"",k);\n   }\n   \n   notice(""setting and getting matrix entries"");\n   for ( k = 0; k < m*deg; k++ )\n   {\n      i = (rand() >> 8) % m;\n      j = (rand() >> 8) % n;\n      sp_set_val(sA,i,j,rand()/((Real)MAX_RAND));\n      i = (rand() >> 8) % m;\n      j = (rand() >> 8) % n;\n      sp_set_val(sB,i,j,rand()/((Real)MAX_RAND));\n   }\n   for ( k = 0; k < 10; k++ )\n   {\n      s1 = rand()/((Real)MAX_RAND);\n      i = (rand() >> 8) % m;\n      j = (rand() >> 8) % n;\n      sp_set_val(sA,i,j,s1);\n      s2 = sp_get_val(sA,i,j);\n      if ( fabs(s1 - s2) >= MACHEPS ) {\n	 printf("" s1 = %g, s2 = %g, |s1 - s2| = %g\n"", \n		s1,s2,fabs(s1-s2));\n	 break;\n      }\n   }\n   if ( k < 10 )\n     errmesg(""sp_set_val()/sp_get_val()"");\n   \n   /* check column access paths */\n   notice(""resizing and access paths"");\n   k = sp_resize_vars(sA->m+10,sA->n+10,&sA,&sB,NULL);\n   if (k != 2) {\n      errmesg(""sp_get_vars"");\n      printf("" n = %d (should be 2)\n"",k);\n   }\n   \n   for ( k = 0 ; k < 20; k++ )\n   {\n      i = sA->m - 1 - ((rand() >> 8) % 10);\n      j = sA->n - 1 - ((rand() >> 8) % 10);\n      s1 = rand()/((Real)MAX_RAND);\n      sp_set_val(sA,i,j,s1);\n      if ( fabs(s1 - sp_get_val(sA,i,j)) >= MACHEPS )\n	break;\n   }\n   if ( k < 20 )\n     errmesg(""sp_resize()"");\n   sp_col_access(sA);\n   if ( ! chk_col_access(sA) )\n   {\n      errmesg(""sp_col_access()"");\n   }\n   sp_diag_access(sA);\n   for ( i = 0; i < sA->m; i++ )\n   {\n      r = &(sA->row[i]);\n      if ( r->diag != sprow_idx(r,i) )\n	break;\n   }\n   if ( i < sA->m )\n   {\n      errmesg(""sp_diag_access()"");\n   }\n   \n   k = sp_free_vars(&sA,&sB,NULL);\n   if (k != 2)\n     errmesg(""sp_free_vars"");\n#endif  /* SPARSE */   \n\n\n#ifdef COMPLEX\n   /* complex stuff */\n   \n   ONE = zmake(1.0,0.0);\n   printf(""# ONE = ""); z_output(ONE);\n   printf(""# Check: MACHEPS = %g\n"",MACHEPS);\n   /* allocate, initialise, copy and resize operations */\n   /* ZVEC */\n   notice(""vector initialise, copy & resize"");\n   zv_get_vars(12,&zx,&zy,&zz,NULL);\n   \n   zv_rand(zx);\n   zv_rand(zy);\n   zz = zv_copy(zx,zz);\n   if ( zv_norm2(zv_sub(zx,zz,zz)) >= MACHEPS )\n     errmesg(""ZVEC copy"");\n   zv_copy(zx,zy);\n   \n   zv_resize_vars(10,&zx,&zy,NULL);\n   if ( zv_norm2(zv_sub(zx,zy,zz)) >= MACHEPS )\n     errmesg(""ZVEC copy/resize"");\n   \n   zv_resize_vars(20,&zx,&zy,NULL);\n   if ( zv_norm2(zv_sub(zx,zy,zz)) >= MACHEPS )\n     errmesg(""VZEC resize"");\n   zv_free_vars(&zx,&zy,&zz,NULL);\n\n   \n   /* ZMAT */\n   notice(""matrix initialise, copy & resize"");\n   zm_get_vars(8,5,&zA,&zB,&zC,NULL);\n   \n   zm_rand(zA);\n   zm_rand(zB);\n   zC = zm_copy(zA,zC);\n   if ( zm_norm_inf(zm_sub(zA,zC,zC)) >= MACHEPS )\n     errmesg(""ZMAT copy"");\n   \n   zm_copy(zA,zB);\n   zm_resize_vars(3,5,&zA,&zB,&zC,NULL);\n   \n   if ( zm_norm_inf(zm_sub(zA,zB,zC)) >= MACHEPS )\n     errmesg(""ZMAT copy/resize"");\n   zm_resize_vars(20,20,&zA,&zB,&zC,NULL);\n   \n   if ( zm_norm_inf(zm_sub(zA,zB,zC)) >= MACHEPS )\n     errmesg(""ZMAT resize"");\n   \n   zm_free_vars(&zA,&zB,&zC,NULL);\n#endif /* COMPLEX */\n\n#endif  /* if defined(ANSI_C) || defined(VARARGS) */\n\n   printf(""# test of mem_info_bytes and mem_info_numvar\n"");\n   printf(""  TYPE VEC: %ld bytes allocated, %d variables allocated\n"",\n	  mem_info_bytes(TYPE_VEC,0),mem_info_numvar(TYPE_VEC,0));\n\n   notice(""static memory test"");\n   mem_info_on(TRUE);\n   mem_stat_mark(1);\n   for (i=0; i < 100; i++)\n     stat_test1(i);\n   mem_stat_free(1);\n\n   mem_stat_mark(1);\n   for (i=0; i < 100; i++) {\n     stat_test1(i);\n#ifdef COMPLEX\n     stat_test4(i);\n#endif\n  }\n\n   mem_stat_mark(2);\n   for (i=0; i < 100; i++)\n     stat_test2(i);\n\n   mem_stat_mark(3);\n#ifdef SPARSE\n   for (i=0; i < 100; i++)\n     stat_test3(i);\n#endif\n\n   mem_info();\n   mem_dump_list(stdout,0);\n\n   mem_stat_free(1);\n   mem_stat_free(3);\n   mem_stat_mark(4);\n\n   for (i=0; i < 100; i++) {\n      stat_test1(i);\n#ifdef COMPLEX\n      stat_test4(i);\n#endif\n   } \n\n   mem_stat_dump(stdout,0);\n   if (mem_stat_show_mark() != 4) {\n      errmesg(""not 4 in mem_stat_show_mark()"");\n   }\n   \n   mem_stat_free(2);\n   mem_stat_free(4);\n\n   if (mem_stat_show_mark() != 0) {\n      errmesg(""not 0 in mem_stat_show_mark()"");\n   }\n\n   /* add new list of types */\n\n   mem_attach_list(FOO_LIST,FOO_NUM_TYPES,foo_type_name,\n		   foo_free_func,foo_info_sum);\n   if (!mem_is_list_attached(FOO_LIST))\n     errmesg(""list FOO_LIST is not attached"");\n\n   mem_dump_list(stdout,FOO_LIST);\n   foo_1 = foo_1_get(6);\n   foo_2 = foo_2_get(3);\n   for (i=0; i < foo_1->dim; i++)\n     for (j=0; j < foo_1->fix_dim; j++)\n       foo_1->a[i][j] = i+j;\n   for (i=0; i < foo_2->dim; i++)\n     for (j=0; j < foo_2->fix_dim; j++)\n       foo_2->a[i][j] = i+j;\n   printf("" foo_1->a[%d][%d] = %g\n"",5,9,foo_1->a[5][9]);\n   printf("" foo_2->a[%d][%d] = %g\n"",2,1,foo_2->a[2][1]);\n   \n   mem_stat_mark(5);\n   mem_stat_reg_list((void **)&foo_1,TYPE_FOO_1,FOO_LIST,__FILE__,__LINE__);\n   mem_stat_reg_list((void **)&foo_2,TYPE_FOO_2,FOO_LIST,__FILE__,__LINE__);\n   mem_stat_dump(stdout,FOO_LIST);\n   mem_info_file(stdout,FOO_LIST);\n   mem_stat_free_list(5,FOO_LIST);\n   mem_stat_dump(stdout,FOO_LIST);\n   if ( foo_1 != NULL )\n     errmesg("" foo_1 is not released"");\n   if ( foo_2 != NULL )\n     errmesg("" foo_2 is not released"");\n   mem_dump_list(stdout,FOO_LIST);\n   mem_info_file(stdout,FOO_LIST);\n\n   mem_free_vars(FOO_LIST);\n   if ( mem_is_list_attached(FOO_LIST) )\n     errmesg(""list FOO_LIST is not detached"");\n\n   mem_info();\n   \n#if REAL == FLOAT\n   printf(""# SINGLE PRECISION was used\n"");\n#elif REAL == DOUBLE\n   printf(""# DOUBLE PRECISION was used\n"");\n#endif\n\n#define ANSI_OR_VAR\n\n#ifndef ANSI_C\n#ifndef VARARGS\n#undef ANSI_OR_VAR\n#endif\n#endif\n\n#ifdef ANSI_OR_VAR\n\n   printf(""# you should get: \n"");\n#if (REAL == FLOAT)\n     printf(""#   type VEC: 276 bytes allocated, 3 variables allocated\n"");\n#elif (REAL == DOUBLE)\n     printf(""#   type VEC: 516 bytes allocated, 3 variables allocated\n"");\n#endif\n   printf(""#   and other types are zeros\n"");\n\n#endif /*#if defined(ANSI_C) || defined(VARAGS) */\n\n   printf(""# Finished memory torture test\n"");\n\n   dmalloc_shutdown();\n   return;\n}\n"
leukocyte/meschach_lib/matlab.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains routines for import/exporting data to/from\n		MATLAB. The main routines are:\n			MAT *m_save(FILE *fp,MAT *A,char *name)\n			VEC *v_save(FILE *fp,VEC *x,char *name)\n			MAT *m_load(FILE *fp,char **name)\n*/\n\n#include        <stdio.h>\n#include        ""matrix.h""\n#include	""matlab.h""\n\nstatic char rcsid[] = ""$Id: matlab.c,v 1.8 1995/02/14 20:12:36 des Exp $"";\n\n/* m_save -- save matrix in "".mat"" file for MATLAB\n	-- returns matrix to be saved */\n#ifndef ANSI_C\nMAT     *m_save(fp,A,name)\nFILE    *fp;\nMAT     *A;\nchar    *name;\n#else\nMAT     *m_save(FILE *fp, MAT *A, const char *name)\n#endif\n{\n	int     i, j;\n	matlab  mat;\n\n	if ( ! A )\n		error(E_NULL,""m_save"");\n\n	mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n	mat.m = A->m;\n	mat.n = A->n;\n	mat.imag = FALSE;\n	mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n\n	/* write header */\n	fwrite(&mat,sizeof(matlab),1,fp);\n	/* write name */\n	if ( name == (char *)NULL )\n		fwrite("""",sizeof(char),1,fp);\n	else\n		fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n	/* write actual data */\n#if ORDER == ROW_ORDER\n	for ( i = 0; i < A->m; i++ )\n		fwrite(A->me[i],sizeof(Real),(int)(A->n),fp);\n#else /* column major order: ORDER == COL_ORDER */\n	for ( j = 0; j < A->n; j++ )\n	  for ( i = 0; i < A->m; i++ )\n	    fwrite(&(A->me[i][j]),sizeof(Real),1,fp);\n#endif\n\n	return A;\n}\n\n\n/* v_save -- save vector in "".mat"" file for MATLAB\n	-- saves it as a row vector\n	-- returns vector to be saved */\n#ifndef ANSI_C\nVEC     *v_save(fp,x,name)\nFILE    *fp;\nVEC     *x;\nchar    *name;\n#else\nVEC     *v_save(FILE *fp, VEC *x, const char *name)\n#endif\n{\n	matlab  mat;\n\n	if ( ! x )\n		error(E_NULL,""v_save"");\n\n	mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n	mat.m = x->dim;\n	mat.n = 1;\n	mat.imag = FALSE;\n	mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n\n	/* write header */\n	fwrite(&mat,sizeof(matlab),1,fp);\n	/* write name */\n	if ( name == (char *)NULL )\n		fwrite("""",sizeof(char),1,fp);\n	else\n		fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n	/* write actual data */\n	fwrite(x->ve,sizeof(Real),(int)(x->dim),fp);\n\n	return x;\n}\n\n/* d_save -- save double in "".mat"" file for MATLAB\n	-- saves it as a row vector\n	-- returns vector to be saved */\n#ifndef ANSI_C\ndouble	d_save(fp,x,name)\nFILE    *fp;\ndouble	x;\nchar    *name;\n#else\ndouble	d_save(FILE *fp, double x, const char *name)\n#endif\n{\n	matlab  mat;\n	Real x1 = x;\n\n	mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n	mat.m = 1;\n	mat.n = 1;\n	mat.imag = FALSE;\n	mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n\n	/* write header */\n	fwrite(&mat,sizeof(matlab),1,fp);\n	/* write name */\n	if ( name == (char *)NULL )\n		fwrite("""",sizeof(char),1,fp);\n	else\n		fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n	/* write actual data */\n	fwrite(&x1,sizeof(Real),1,fp);\n\n	return x;\n}\n\n/* m_load -- loads in a "".mat"" file variable as produced by MATLAB\n	-- matrix returned; imaginary parts ignored */\n#ifndef ANSI_C\nMAT     *m_load(fp,name)\nFILE    *fp;\nchar    **name;\n#else\nMAT     *m_load(FILE *fp, char **name)\n#endif\n{\n	MAT     *A;\n	int     i;\n	int     m_flag, o_flag, p_flag, t_flag;\n	float   f_temp;\n	Real    d_temp;\n	matlab  mat;\n\n	if ( fread(&mat,sizeof(matlab),1,fp) != 1 )\n	    error(E_FORMAT,""m_load"");\n	if ( mat.type >= 10000 )	/* don't load a sparse matrix! */\n	    error(E_FORMAT,""m_load"");\n	m_flag = (mat.type/1000) % 10;\n	o_flag = (mat.type/100) % 10;\n	p_flag = (mat.type/10) % 10;\n	t_flag = (mat.type) % 10;\n	if ( m_flag != MACH_ID )\n		error(E_FORMAT,""m_load"");\n	if ( t_flag != 0 )\n		error(E_FORMAT,""m_load"");\n	if ( p_flag != DOUBLE_PREC && p_flag != SINGLE_PREC )\n		error(E_FORMAT,""m_load"");\n	*name = (char *)malloc((unsigned)(mat.namlen)+1);\n	if ( fread(*name,sizeof(char),(unsigned)(mat.namlen),fp) == 0 )\n		error(E_FORMAT,""m_load"");\n	A = m_get((unsigned)(mat.m),(unsigned)(mat.n));\n	for ( i = 0; i < A->m*A->n; i++ )\n	{\n		if ( p_flag == DOUBLE_PREC )\n		    fread(&d_temp,sizeof(double),1,fp);\n		else\n		{\n		    fread(&f_temp,sizeof(float),1,fp);\n		    d_temp = f_temp;\n		}\n		if ( o_flag == ROW_ORDER )\n		    A->me[i / A->n][i % A->n] = d_temp;\n		else if ( o_flag == COL_ORDER )\n		    A->me[i % A->m][i / A->m] = d_temp;\n		else\n		    error(E_FORMAT,""m_load"");\n	}\n\n	if ( mat.imag )         /* skip imaginary part */\n	for ( i = 0; i < A->m*A->n; i++ )\n	{\n		if ( p_flag == DOUBLE_PREC )\n		    fread(&d_temp,sizeof(double),1,fp);\n		else\n		    fread(&f_temp,sizeof(float),1,fp);\n	}\n\n	return A;\n}\n\n"
leukocyte/meschach_lib/lufactor.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* LUfactor.c 1.5 11/25/87 */\nstatic	char	rcsid[] = ""$Id: lufactor.c,v 1.10 1995/05/16 17:26:44 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* LUfactor -- gaussian elimination with scaled partial pivoting\n		-- Note: returns LU matrix which is A */\n#ifndef ANSI_C\nMAT	*LUfactor(A,pivot)\nMAT	*A;\nPERM	*pivot;\n#else\nMAT	*LUfactor(MAT *A, PERM *pivot)\n#endif\n{\n	unsigned int	i, j, m, n;\n	int	i_max, k, k_max;\n	Real	**A_v, *A_piv, *A_row;\n	Real	max1, temp, tiny;\n	STATIC	VEC	*scale = VNULL;\n\n	if ( A==(MAT *)NULL || pivot==(PERM *)NULL )\n		error(E_NULL,""LUfactor"");\n	if ( pivot->size != A->m )\n		error(E_SIZES,""LUfactor"");\n	m = A->m;	n = A->n;\n	scale = v_resize(scale,A->m);\n	MEM_STAT_REG(scale,TYPE_VEC);\n	A_v = A->me;\n\n	tiny = 10.0/HUGE_VAL;\n\n	/* initialise pivot with identity permutation */\n	for ( i=0; i<m; i++ )\n		pivot->pe[i] = i;\n\n	/* set scale parameters */\n	for ( i=0; i<m; i++ )\n	{\n		max1 = 0.0;\n		for ( j=0; j<n; j++ )\n		{\n			temp = fabs(A_v[i][j]);\n			max1 = max(max1,temp);\n		}\n		scale->ve[i] = max1;\n	}\n\n	/* main loop */\n	k_max = min(m,n)-1;\n	for ( k=0; k<k_max; k++ )\n	{\n	    /* find best pivot row */\n	    max1 = 0.0;	i_max = -1;\n	    for ( i=k; i<m; i++ )\n		if ( fabs(scale->ve[i]) >= tiny*fabs(A_v[i][k]) )\n		{\n		    temp = fabs(A_v[i][k])/scale->ve[i];\n		    if ( temp > max1 )\n		    { max1 = temp;	i_max = i;	}\n		}\n	    \n	    /* if no pivot then ignore column k... */\n	    if ( i_max == -1 )\n	    {\n		/* set pivot entry A[k][k] exactly to zero,\n		   rather than just ""small"" */\n		A_v[k][k] = 0.0;\n		continue;\n	    }\n	    \n	    /* do we pivot ? */\n	    if ( i_max != k )	/* yes we do... */\n	    {\n		px_transp(pivot,i_max,k);\n		for ( j=0; j<n; j++ )\n		{\n		    temp = A_v[i_max][j];\n		    A_v[i_max][j] = A_v[k][j];\n		    A_v[k][j] = temp;\n		}\n	    }\n	    \n	    /* row operations */\n	    for ( i=k+1; i<m; i++ )	/* for each row do... */\n	    {	/* Note: divide by zero should never happen */\n		temp = A_v[i][k] = A_v[i][k]/A_v[k][k];\n		A_piv = &(A_v[k][k+1]);\n		A_row = &(A_v[i][k+1]);\n		if ( k+1 < n )\n		    __mltadd__(A_row,A_piv,-temp,(int)(n-(k+1)));\n		/*********************************************\n		  for ( j=k+1; j<n; j++ )\n		  A_v[i][j] -= temp*A_v[k][j];\n		  (*A_row++) -= temp*(*A_piv++);\n		  *********************************************/\n	    }\n	    \n	}\n\n#ifdef	THREADSAFE\n	V_FREE(scale);\n#endif\n\n	return A;\n}\n\n\n/* LUsolve -- given an LU factorisation in A, solve Ax=b */\n#ifndef ANSI_C\nVEC	*LUsolve(LU,pivot,b,x)\nMAT	*LU;\nPERM	*pivot;\nVEC	*b,*x;\n#else\nVEC	*LUsolve(const MAT *LU, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	if ( ! LU || ! b || ! pivot )\n		error(E_NULL,""LUsolve"");\n	if ( LU->m != LU->n || LU->n != b->dim )\n		error(E_SIZES,""LUsolve"");\n\n	x = v_resize(x,b->dim);\n	px_vec(pivot,b,x);	/* x := P.b */\n	Lsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */\n	Usolve(LU,x,x,0.0);	/* explicit diagonal */\n\n	return (x);\n}\n\n/* LUTsolve -- given an LU factorisation in A, solve A^T.x=b */\n#ifndef ANSI_C\nVEC	*LUTsolve(LU,pivot,b,x)\nMAT	*LU;\nPERM	*pivot;\nVEC	*b,*x;\n#else\nVEC	*LUTsolve(const MAT *LU, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n	if ( ! LU || ! b || ! pivot )\n		error(E_NULL,""LUTsolve"");\n	if ( LU->m != LU->n || LU->n != b->dim )\n		error(E_SIZES,""LUTsolve"");\n\n	x = v_copy(b,x);\n	UTsolve(LU,x,x,0.0);	/* explicit diagonal */\n	LTsolve(LU,x,x,1.0);	/* implicit diagonal = 1 */\n	pxinv_vec(pivot,x,x);	/* x := P^T.tmp */\n\n	return (x);\n}\n\n/* m_inverse -- returns inverse of A, provided A is not too rank deficient\n	-- uses LU factorisation */\n#ifndef ANSI_C\nMAT	*m_inverse(A,out)\nMAT	*A, *out;\n#else\nMAT	*m_inverse(const MAT *A, MAT *out)\n#endif\n{\n	int	i;\n	STATIC VEC	*tmp = VNULL, *tmp2 = VNULL;\n	STATIC MAT	*A_cp = MNULL;\n	STATIC PERM	*pivot = PNULL;\n\n	if ( ! A )\n	    error(E_NULL,""m_inverse"");\n	if ( A->m != A->n )\n	    error(E_SQUARE,""m_inverse"");\n	if ( ! out || out->m < A->m || out->n < A->n )\n	    out = m_resize(out,A->m,A->n);\n\n	A_cp = m_resize(A_cp,A->m,A->n);\n	A_cp = m_copy(A,A_cp);\n	tmp = v_resize(tmp,A->m);\n	tmp2 = v_resize(tmp2,A->m);\n	pivot = px_resize(pivot,A->m);\n	MEM_STAT_REG(A_cp,TYPE_MAT);\n	MEM_STAT_REG(tmp, TYPE_VEC);\n	MEM_STAT_REG(tmp2,TYPE_VEC);\n	MEM_STAT_REG(pivot,TYPE_PERM);\n	tracecatch(LUfactor(A_cp,pivot),""m_inverse"");\n	for ( i = 0; i < A->n; i++ )\n	{\n	    v_zero(tmp);\n	    tmp->ve[i] = 1.0;\n	    tracecatch(LUsolve(A_cp,pivot,tmp,tmp2),""m_inverse"");\n	    set_col(out,i,tmp2);\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(tmp);	V_FREE(tmp2);\n	M_FREE(A_cp);	PX_FREE(pivot);\n#endif\n\n	return out;\n}\n\n/* LUcondest -- returns an estimate of the condition number of LU given the\n	LU factorisation in compact form */\n#ifndef ANSI_C\ndouble	LUcondest(LU,pivot)\nMAT	*LU;\nPERM	*pivot;\n#else\ndouble	LUcondest(const MAT *LU, PERM *pivot)\n#endif\n{\n    STATIC	VEC	*y = VNULL, *z = VNULL;\n    Real	cond_est, L_norm, U_norm, sum, tiny;\n    int		i, j, n;\n\n    if ( ! LU || ! pivot )\n	error(E_NULL,""LUcondest"");\n    if ( LU->m != LU->n )\n	error(E_SQUARE,""LUcondest"");\n    if ( LU->n != pivot->size )\n	error(E_SIZES,""LUcondest"");\n\n    tiny = 10.0/HUGE_VAL;\n\n    n = LU->n;\n    y = v_resize(y,n);\n    z = v_resize(z,n);\n    MEM_STAT_REG(y,TYPE_VEC);\n    MEM_STAT_REG(z,TYPE_VEC);\n\n    for ( i = 0; i < n; i++ )\n    {\n	sum = 0.0;\n	for ( j = 0; j < i; j++ )\n	    sum -= LU->me[j][i]*y->ve[j];\n	sum -= (sum < 0.0) ? 1.0 : -1.0;\n	if ( fabs(LU->me[i][i]) <= tiny*fabs(sum) )\n	    return HUGE_VAL;\n	y->ve[i] = sum / LU->me[i][i];\n    }\n\n    catch(E_SING,\n	  LTsolve(LU,y,y,1.0);\n	  LUsolve(LU,pivot,y,z);\n	  ,\n	  return HUGE_VAL);\n\n    /* now estimate norm of A (even though it is not directly available) */\n    /* actually computes ||L||_inf.||U||_inf */\n    U_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	sum = 0.0;\n	for ( j = i; j < n; j++ )\n	    sum += fabs(LU->me[i][j]);\n	if ( sum > U_norm )\n	    U_norm = sum;\n    }\n    L_norm = 0.0;\n    for ( i = 0; i < n; i++ )\n    {\n	sum = 1.0;\n	for ( j = 0; j < i; j++ )\n	    sum += fabs(LU->me[i][j]);\n	if ( sum > L_norm )\n	    L_norm = sum;\n    }\n\n    tracecatch(cond_est = U_norm*L_norm*v_norm_inf(z)/v_norm_inf(y),\n	       ""LUcondest"");\n\n#ifdef	THREADSAFE\n    V_FREE(y);    V_FREE(z);\n#endif\n\n    return cond_est;\n}\n"
leukocyte/meschach_lib/schur.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*	\n	File containing routines for computing the Schur decomposition\n	of a real non-symmetric matrix\n	See also: hessen.c\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\nstatic char rcsid[] = ""$Id: schur.c,v 1.7 1994/03/17 05:36:53 des Exp $"";\n\n\n\n#ifndef ANSI_C\nstatic	void	hhldr3(x,y,z,nu1,beta,newval)\ndouble	x, y, z;\nReal	*nu1, *beta, *newval;\n#else\nstatic	void	hhldr3(double x, double y, double z,\n		       Real *nu1, Real *beta, Real *newval)\n#endif\n{\n	Real	alpha;\n\n	if ( x >= 0.0 )\n		alpha = sqrt(x*x+y*y+z*z);\n	else\n		alpha = -sqrt(x*x+y*y+z*z);\n	*nu1 = x + alpha;\n	*beta = 1.0/(alpha*(*nu1));\n	*newval = alpha;\n}\n\n#ifndef ANSI_C\nstatic	void	hhldr3cols(A,k,j0,beta,nu1,nu2,nu3)\nMAT	*A;\nint	k, j0;\ndouble	beta, nu1, nu2, nu3;\n#else\nstatic	void	hhldr3cols(MAT *A, int k, int j0, double beta,\n			   double nu1, double nu2, double nu3)\n#endif\n{\n	Real	**A_me, ip, prod;\n	int	j, n;\n\n	if ( k < 0 || k+3 > A->m || j0 < 0 )\n		error(E_BOUNDS,""hhldr3cols"");\n	A_me = A->me;		n = A->n;\n\n	/* printf(""hhldr3cols:(l.%d) j0 = %d, k = %d, A at 0x%lx, m = %d, n = %d\n"",\n	       __LINE__, j0, k, (long)A, A->m, A->n); */\n	/* printf(""hhldr3cols: A (dumped) =\n"");	m_dump(stdout,A); */\n\n	for ( j = j0; j < n; j++ )\n	{\n	    /*****	    \n	    ip = nu1*A_me[k][j] + nu2*A_me[k+1][j] + nu3*A_me[k+2][j];\n	    prod = ip*beta;\n	    A_me[k][j]   -= prod*nu1;\n	    A_me[k+1][j] -= prod*nu2;\n	    A_me[k+2][j] -= prod*nu3;\n	    *****/\n	    /* printf(""hhldr3cols: j = %d\n"", j); */\n\n	    ip = nu1*m_entry(A,k,j)+nu2*m_entry(A,k+1,j)+nu3*m_entry(A,k+2,j);\n	    prod = ip*beta;\n	    /*****\n	    m_set_val(A,k  ,j,m_entry(A,k  ,j) - prod*nu1);\n	    m_set_val(A,k+1,j,m_entry(A,k+1,j) - prod*nu2);\n	    m_set_val(A,k+2,j,m_entry(A,k+2,j) - prod*nu3);\n	    *****/\n	    m_add_val(A,k  ,j,-prod*nu1);\n	    m_add_val(A,k+1,j,-prod*nu2);\n	    m_add_val(A,k+2,j,-prod*nu3);\n\n	}\n	/* printf(""hhldr3cols:(l.%d) j0 = %d, k = %d, m = %d, n = %d\n"",\n	       __LINE__, j0, k, A->m, A->n); */\n	/* putc('\n',stdout); */\n}\n\n#ifndef ANSI_C\nstatic	void	hhldr3rows(A,k,i0,beta,nu1,nu2,nu3)\nMAT	*A;\nint	k, i0;\ndouble	beta, nu1, nu2, nu3;\n#else\nstatic	void	hhldr3rows(MAT *A, int k, int i0, double beta,\n			   double nu1, double nu2, double nu3)\n#endif\n{\n	Real	**A_me, ip, prod;\n	int	i, m;\n\n	/* printf(""hhldr3rows:(l.%d) A at 0x%lx\n"", __LINE__, (long)A); */\n	/* printf(""hhldr3rows: k = %d\n"", k); */\n	if ( k < 0 || k+3 > A->n )\n		error(E_BOUNDS,""hhldr3rows"");\n	A_me = A->me;		m = A->m;\n	i0 = min(i0,m-1);\n\n	for ( i = 0; i <= i0; i++ )\n	{\n	    /****\n	    ip = nu1*A_me[i][k] + nu2*A_me[i][k+1] + nu3*A_me[i][k+2];\n	    prod = ip*beta;\n	    A_me[i][k]   -= prod*nu1;\n	    A_me[i][k+1] -= prod*nu2;\n	    A_me[i][k+2] -= prod*nu3;\n	    ****/\n\n	    ip = nu1*m_entry(A,i,k)+nu2*m_entry(A,i,k+1)+nu3*m_entry(A,i,k+2);\n	    prod = ip*beta;\n	    m_add_val(A,i,k  , - prod*nu1);\n	    m_add_val(A,i,k+1, - prod*nu2);\n	    m_add_val(A,i,k+2, - prod*nu3);\n\n	}\n}\n\n/* schur -- computes the Schur decomposition of the matrix A in situ\n	-- optionally, gives Q matrix such that Q^T.A.Q is upper triangular\n	-- returns upper triangular Schur matrix */\n#ifndef ANSI_C\nMAT	*schur(A,Q)\nMAT	*A, *Q;\n#else\nMAT	*schur(MAT *A, MAT *Q)\n#endif\n{\n    int		i, j, iter, k, k_min, k_max, k_tmp, n, split;\n    Real	beta2, c, discrim, dummy, nu1, s, t, tmp, x, y, z;\n    Real	**A_me;\n    Real	sqrt_macheps;\n    STATIC	VEC	*diag=VNULL, *beta=VNULL;\n    \n    if ( ! A )\n	error(E_NULL,""schur"");\n    if ( A->m != A->n || ( Q && Q->m != Q->n ) )\n	error(E_SQUARE,""schur"");\n    if ( Q != MNULL && Q->m != A->m )\n	error(E_SIZES,""schur"");\n    n = A->n;\n    diag = v_resize(diag,A->n);\n    beta = v_resize(beta,A->n);\n    MEM_STAT_REG(diag,TYPE_VEC);\n    MEM_STAT_REG(beta,TYPE_VEC);\n    /* compute Hessenberg form */\n    Hfactor(A,diag,beta);\n    \n    /* save Q if necessary */\n    if ( Q )\n	Q = makeHQ(A,diag,beta,Q);\n    makeH(A,A);\n\n    sqrt_macheps = sqrt(MACHEPS);\n\n    k_min = 0;	A_me = A->me;\n\n    while ( k_min < n )\n    {\n	Real	a00, a01, a10, a11;\n	double	scale, t, numer, denom;\n\n	/* find k_max to suit:\n	   submatrix k_min..k_max should be irreducible */\n	k_max = n-1;\n	for ( k = k_min; k < k_max; k++ )\n	    /* if ( A_me[k+1][k] == 0.0 ) */\n	    if ( m_entry(A,k+1,k) == 0.0 )\n	    {	k_max = k;	break;	}\n\n	if ( k_max <= k_min )\n	{\n	    k_min = k_max + 1;\n	    continue;		/* outer loop */\n	}\n\n	/* check to see if we have a 2 x 2 block\n	   with complex eigenvalues */\n	if ( k_max == k_min + 1 )\n	{\n	    /* tmp = A_me[k_min][k_min] - A_me[k_max][k_max]; */\n	    a00 = m_entry(A,k_min,k_min);\n	    a01 = m_entry(A,k_min,k_max);\n	    a10 = m_entry(A,k_max,k_min);\n	    a11 = m_entry(A,k_max,k_max);\n	    tmp = a00 - a11;\n	    /* discrim = tmp*tmp +\n		4*A_me[k_min][k_max]*A_me[k_max][k_min]; */\n	    discrim = tmp*tmp + 4*a01*a10;\n	    if ( discrim < 0.0 )\n	    {	/* yes -- e-vals are complex\n		   -- put 2 x 2 block in form [a b; c a];\n		   then eigenvalues have real part a & imag part sqrt(|bc|) */\n		numer = - tmp;\n		denom = ( a01+a10 >= 0.0 ) ?\n		    (a01+a10) + sqrt((a01+a10)*(a01+a10)+tmp*tmp) :\n		    (a01+a10) - sqrt((a01+a10)*(a01+a10)+tmp*tmp);\n		if ( denom != 0.0 )\n		{   /* t = s/c = numer/denom */\n		    t = numer/denom;\n		    scale = c = 1.0/sqrt(1+t*t);\n		    s = c*t;\n		}\n		else\n		{\n		    c = 1.0;\n		    s = 0.0;\n		}\n		rot_cols(A,k_min,k_max,c,s,A);\n		rot_rows(A,k_min,k_max,c,s,A);\n		if ( Q != MNULL )\n		    rot_cols(Q,k_min,k_max,c,s,Q);\n		k_min = k_max + 1;\n		continue;\n	    }\n	    else /* discrim >= 0; i.e. block has two real eigenvalues */\n	    {	/* no -- e-vals are not complex;\n		   split 2 x 2 block and continue */\n		/* s/c = numer/denom */\n		numer = ( tmp >= 0.0 ) ?\n		    - tmp - sqrt(discrim) : - tmp + sqrt(discrim);\n		denom = 2*a01;\n		if ( fabs(numer) < fabs(denom) )\n		{   /* t = s/c = numer/denom */\n		    t = numer/denom;\n		    scale = c = 1.0/sqrt(1+t*t);\n		    s = c*t;\n		}\n		else if ( numer != 0.0 )\n		{   /* t = c/s = denom/numer */\n		    t = denom/numer;\n		    scale = 1.0/sqrt(1+t*t);\n		    c = fabs(t)*scale;\n		    s = ( t >= 0.0 ) ? scale : -scale;\n		}\n		else /* numer == denom == 0 */\n		{\n		    c = 0.0;\n		    s = 1.0;\n		}\n		rot_cols(A,k_min,k_max,c,s,A);\n		rot_rows(A,k_min,k_max,c,s,A);\n		/* A->me[k_max][k_min] = 0.0; */\n		if ( Q != MNULL )\n		    rot_cols(Q,k_min,k_max,c,s,Q);\n		k_min = k_max + 1;	/* go to next block */\n		continue;\n	    }\n	}\n\n	/* now have r x r block with r >= 2:\n	   apply Francis QR step until block splits */\n	split = FALSE;		iter = 0;\n	while ( ! split )\n	{\n	    iter++;\n	    \n	    /* set up Wilkinson/Francis complex shift */\n	    k_tmp = k_max - 1;\n\n	    a00 = m_entry(A,k_tmp,k_tmp);\n	    a01 = m_entry(A,k_tmp,k_max);\n	    a10 = m_entry(A,k_max,k_tmp);\n	    a11 = m_entry(A,k_max,k_max);\n\n	    /* treat degenerate cases differently\n	       -- if there are still no splits after five iterations\n	          and the bottom 2 x 2 looks degenerate, force it to\n		  split */\n#ifdef DEBUG\n	    printf(""# schur: bottom 2 x 2 = [%lg, %lg; %lg, %lg]\n"",\n		   a00, a01, a10, a11);\n#endif\n	    if ( iter >= 5 &&\n		 fabs(a00-a11) < sqrt_macheps*(fabs(a00)+fabs(a11)) &&\n		 (fabs(a01) < sqrt_macheps*(fabs(a00)+fabs(a11)) ||\n		  fabs(a10) < sqrt_macheps*(fabs(a00)+fabs(a11))) )\n	    {\n	      if ( fabs(a01) < sqrt_macheps*(fabs(a00)+fabs(a11)) )\n		m_set_val(A,k_tmp,k_max,0.0);\n	      if ( fabs(a10) < sqrt_macheps*(fabs(a00)+fabs(a11)) )\n		{\n		  m_set_val(A,k_max,k_tmp,0.0);\n		  split = TRUE;\n		  continue;\n		}\n	    }\n\n	    s = a00 + a11;\n	    t = a00*a11 - a01*a10;\n\n	    /* break loop if a 2 x 2 complex block */\n	    if ( k_max == k_min + 1 && s*s < 4.0*t )\n	    {\n		split = TRUE;\n		continue;\n	    }\n\n	    /* perturb shift if convergence is slow */\n	    if ( (iter % 10) == 0 )\n	    {	s += iter*0.02;		t += iter*0.02;\n	    }\n\n	    /* set up Householder transformations */\n	    k_tmp = k_min + 1;\n	    /********************\n	    x = A_me[k_min][k_min]*A_me[k_min][k_min] +\n		A_me[k_min][k_tmp]*A_me[k_tmp][k_min] -\n		    s*A_me[k_min][k_min] + t;\n	    y = A_me[k_tmp][k_min]*\n		(A_me[k_min][k_min]+A_me[k_tmp][k_tmp]-s);\n	    if ( k_min + 2 <= k_max )\n		z = A_me[k_tmp][k_min]*A_me[k_min+2][k_tmp];\n	    else\n		z = 0.0;\n	    ********************/\n\n	    a00 = m_entry(A,k_min,k_min);\n	    a01 = m_entry(A,k_min,k_tmp);\n	    a10 = m_entry(A,k_tmp,k_min);\n	    a11 = m_entry(A,k_tmp,k_tmp);\n\n	    /********************\n	    a00 = A->me[k_min][k_min];\n	    a01 = A->me[k_min][k_tmp];\n	    a10 = A->me[k_tmp][k_min];\n	    a11 = A->me[k_tmp][k_tmp];\n	    ********************/\n	    x = a00*a00 + a01*a10 - s*a00 + t;\n	    y = a10*(a00+a11-s);\n	    if ( k_min + 2 <= k_max )\n		z = a10* /* m_entry(A,k_min+2,k_tmp) */ A->me[k_min+2][k_tmp];\n	    else\n		z = 0.0;\n\n	    for ( k = k_min; k <= k_max-1; k++ )\n	    {\n		if ( k < k_max - 1 )\n		{\n		    hhldr3(x,y,z,&nu1,&beta2,&dummy);\n		    tracecatch(hhldr3cols(A,k,max(k-1,0),  beta2,nu1,y,z),""schur"");\n		    tracecatch(hhldr3rows(A,k,min(n-1,k+3),beta2,nu1,y,z),""schur"");\n		    if ( Q != MNULL )\n			hhldr3rows(Q,k,n-1,beta2,nu1,y,z);\n		}\n		else\n		{\n		    givens(x,y,&c,&s);\n		    rot_cols(A,k,k+1,c,s,A);\n		    rot_rows(A,k,k+1,c,s,A);\n		    if ( Q )\n			rot_cols(Q,k,k+1,c,s,Q);\n		}\n		/* if ( k >= 2 )\n		    m_set_val(A,k,k-2,0.0); */\n		/* x = A_me[k+1][k]; */\n		x = m_entry(A,k+1,k);\n		if ( k <= k_max - 2 )\n		    /* y = A_me[k+2][k];*/\n		    y = m_entry(A,k+2,k);\n		else\n		    y = 0.0;\n		if ( k <= k_max - 3 )\n		    /* z = A_me[k+3][k]; */\n		    z = m_entry(A,k+3,k);\n		else\n		    z = 0.0;\n	    }\n	    /* if ( k_min > 0 )\n		m_set_val(A,k_min,k_min-1,0.0);\n	    if ( k_max < n - 1 )\n		m_set_val(A,k_max+1,k_max,0.0); */\n	    for ( k = k_min; k <= k_max-2; k++ )\n	    {\n		/* zero appropriate sub-diagonals */\n		m_set_val(A,k+2,k,0.0);\n		if ( k < k_max-2 )\n		    m_set_val(A,k+3,k,0.0);\n	    }\n\n	    /* test to see if matrix should split */\n	    for ( k = k_min; k < k_max; k++ )\n		if ( fabs(A_me[k+1][k]) < MACHEPS*\n		    (fabs(A_me[k][k])+fabs(A_me[k+1][k+1])) )\n		{	A_me[k+1][k] = 0.0;	split = TRUE;	}\n	}\n    }\n    \n    /* polish up A by zeroing strictly lower triangular elements\n       and small sub-diagonal elements */\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < i-1; j++ )\n	    A_me[i][j] = 0.0;\n    for ( i = 0; i < A->m - 1; i++ )\n	if ( fabs(A_me[i+1][i]) < MACHEPS*\n	    (fabs(A_me[i][i])+fabs(A_me[i+1][i+1])) )\n	    A_me[i+1][i] = 0.0;\n\n#ifdef	THREADSAFE\n    V_FREE(diag);	V_FREE(beta);\n#endif\n\n    return A;\n}\n\n/* schur_vals -- compute real & imaginary parts of eigenvalues\n	-- assumes T contains a block upper triangular matrix\n		as produced by schur()\n	-- real parts stored in real_pt, imaginary parts in imag_pt */\n#ifndef ANSI_C\nvoid	schur_evals(T,real_pt,imag_pt)\nMAT	*T;\nVEC	*real_pt, *imag_pt;\n#else\nvoid	schur_evals(MAT *T, VEC *real_pt, VEC *imag_pt)\n#endif\n{\n	int	i, n;\n	Real	discrim, **T_me;\n	Real	diff, sum, tmp;\n\n	if ( ! T || ! real_pt || ! imag_pt )\n		error(E_NULL,""schur_evals"");\n	if ( T->m != T->n )\n		error(E_SQUARE,""schur_evals"");\n	n = T->n;	T_me = T->me;\n	real_pt = v_resize(real_pt,(unsigned int)n);\n	imag_pt = v_resize(imag_pt,(unsigned int)n);\n\n	i = 0;\n	while ( i < n )\n	{\n		if ( i < n-1 && T_me[i+1][i] != 0.0 )\n		{   /* should be a complex eigenvalue */\n		    sum  = 0.5*(T_me[i][i]+T_me[i+1][i+1]);\n		    diff = 0.5*(T_me[i][i]-T_me[i+1][i+1]);\n		    discrim = diff*diff + T_me[i][i+1]*T_me[i+1][i];\n		    if ( discrim < 0.0 )\n		    {	/* yes -- complex e-vals */\n			real_pt->ve[i] = real_pt->ve[i+1] = sum;\n			imag_pt->ve[i] = sqrt(-discrim);\n			imag_pt->ve[i+1] = - imag_pt->ve[i];\n		    }\n		    else\n		    {	/* no -- actually both real */\n			tmp = sqrt(discrim);\n			real_pt->ve[i]   = sum + tmp;\n			real_pt->ve[i+1] = sum - tmp;\n			imag_pt->ve[i]   = imag_pt->ve[i+1] = 0.0;\n		    }\n		    i += 2;\n		}\n		else\n		{   /* real eigenvalue */\n		    real_pt->ve[i] = T_me[i][i];\n		    imag_pt->ve[i] = 0.0;\n		    i++;\n		}\n	}\n}\n\n/* schur_vecs -- returns eigenvectors computed from the real Schur\n		decomposition of a matrix\n	-- T is the block upper triangular Schur matrix\n	-- Q is the orthognal matrix where A = Q.T.Q^T\n	-- if Q is null, the eigenvectors of T are returned\n	-- X_re is the real part of the matrix of eigenvectors,\n		and X_im is the imaginary part of the matrix.\n	-- X_re is returned */\n#ifndef ANSI_C\nMAT	*schur_vecs(T,Q,X_re,X_im)\nMAT	*T, *Q, *X_re, *X_im;\n#else\nMAT	*schur_vecs(MAT *T, MAT *Q, MAT *X_re, MAT *X_im)\n#endif\n{\n	int	i, j, limit;\n	Real	t11_re, t11_im, t12, t21, t22_re, t22_im;\n	Real	l_re, l_im, det_re, det_im, invdet_re, invdet_im,\n		val1_re, val1_im, val2_re, val2_im,\n		tmp_val1_re, tmp_val1_im, tmp_val2_re, tmp_val2_im, **T_me;\n	Real	sum, diff, discrim, magdet, norm, scale;\n	STATIC VEC	*tmp1_re=VNULL, *tmp1_im=VNULL,\n			*tmp2_re=VNULL, *tmp2_im=VNULL;\n\n	if ( ! T || ! X_re )\n	    error(E_NULL,""schur_vecs"");\n	if ( T->m != T->n || X_re->m != X_re->n ||\n		( Q != MNULL && Q->m != Q->n ) ||\n		( X_im != MNULL && X_im->m != X_im->n ) )\n	    error(E_SQUARE,""schur_vecs"");\n	if ( T->m != X_re->m ||\n		( Q != MNULL && T->m != Q->m ) ||\n		( X_im != MNULL && T->m != X_im->m ) )\n	    error(E_SIZES,""schur_vecs"");\n\n	tmp1_re = v_resize(tmp1_re,T->m);\n	tmp1_im = v_resize(tmp1_im,T->m);\n	tmp2_re = v_resize(tmp2_re,T->m);\n	tmp2_im = v_resize(tmp2_im,T->m);\n	MEM_STAT_REG(tmp1_re,TYPE_VEC);\n	MEM_STAT_REG(tmp1_im,TYPE_VEC);\n	MEM_STAT_REG(tmp2_re,TYPE_VEC);\n	MEM_STAT_REG(tmp2_im,TYPE_VEC);\n\n	T_me = T->me;\n	i = 0;\n	while ( i < T->m )\n	{\n	    if ( i+1 < T->m && T->me[i+1][i] != 0.0 )\n	    {	/* complex eigenvalue */\n		sum  = 0.5*(T_me[i][i]+T_me[i+1][i+1]);\n		diff = 0.5*(T_me[i][i]-T_me[i+1][i+1]);\n		discrim = diff*diff + T_me[i][i+1]*T_me[i+1][i];\n		l_re = l_im = 0.0;\n		if ( discrim < 0.0 )\n		{	/* yes -- complex e-vals */\n		    l_re = sum;\n		    l_im = sqrt(-discrim);\n		}\n		else /* not correct Real Schur form */\n		    error(E_RANGE,""schur_vecs"");\n	    }\n	    else\n	    {\n		l_re = T_me[i][i];\n		l_im = 0.0;\n	    }\n\n	    v_zero(tmp1_im);\n	    v_rand(tmp1_re);\n	    sv_mlt(MACHEPS,tmp1_re,tmp1_re);\n\n	    /* solve (T-l.I)x = tmp1 */\n	    limit = ( l_im != 0.0 ) ? i+1 : i;\n	    /* printf(""limit = %d\n"",limit); */\n	    for ( j = limit+1; j < T->m; j++ )\n		tmp1_re->ve[j] = 0.0;\n	    j = limit;\n	    while ( j >= 0 )\n	    {\n		if ( j > 0 && T->me[j][j-1] != 0.0 )\n		{   /* 2 x 2 diagonal block */\n		    /* printf(""checkpoint A\n""); */\n		    val1_re = tmp1_re->ve[j-1] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf(""checkpoint B\n""); */\n		    val1_im = tmp1_im->ve[j-1] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf(""checkpoint C\n""); */\n		    val2_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint D\n""); */\n		    val2_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint E\n""); */\n		    \n		    t11_re = T_me[j-1][j-1] - l_re;\n		    t11_im = - l_im;\n		    t22_re = T_me[j][j] - l_re;\n		    t22_im = - l_im;\n		    t12 = T_me[j-1][j];\n		    t21 = T_me[j][j-1];\n\n		    scale =  fabs(T_me[j-1][j-1]) + fabs(T_me[j][j]) +\n			fabs(t12) + fabs(t21) + fabs(l_re) + fabs(l_im);\n\n		    det_re = t11_re*t22_re - t11_im*t22_im - t12*t21;\n		    det_im = t11_re*t22_im + t11_im*t22_re;\n		    magdet = det_re*det_re+det_im*det_im;\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        det_re = MACHEPS*scale;\n			magdet = det_re*det_re+det_im*det_im;\n		    }\n		    invdet_re =   det_re/magdet;\n		    invdet_im = - det_im/magdet;\n		    tmp_val1_re = t22_re*val1_re-t22_im*val1_im-t12*val2_re;\n		    tmp_val1_im = t22_im*val1_re+t22_re*val1_im-t12*val2_im;\n		    tmp_val2_re = t11_re*val2_re-t11_im*val2_im-t21*val1_re;\n		    tmp_val2_im = t11_im*val2_re+t11_re*val2_im-t21*val1_im;\n		    tmp1_re->ve[j-1] = invdet_re*tmp_val1_re -\n		    		invdet_im*tmp_val1_im;\n		    tmp1_im->ve[j-1] = invdet_im*tmp_val1_re +\n		    		invdet_re*tmp_val1_im;\n		    tmp1_re->ve[j]   = invdet_re*tmp_val2_re -\n		    		invdet_im*tmp_val2_im;\n		    tmp1_im->ve[j]   = invdet_im*tmp_val2_re +\n		    		invdet_re*tmp_val2_im;\n		    j -= 2;\n	        }\n	        else\n		{\n		    t11_re = T_me[j][j] - l_re;\n		    t11_im = - l_im;\n		    magdet = t11_re*t11_re + t11_im*t11_im;\n		    scale = fabs(T_me[j][j]) + fabs(l_re);\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        t11_re = MACHEPS*scale;\n			magdet = t11_re*t11_re + t11_im*t11_im;\n		    }\n		    invdet_re =   t11_re/magdet;\n		    invdet_im = - t11_im/magdet;\n		    /* printf(""checkpoint F\n""); */\n		    val1_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint G\n""); */\n		    val1_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint H\n""); */\n		    tmp1_re->ve[j] = invdet_re*val1_re - invdet_im*val1_im;\n		    tmp1_im->ve[j] = invdet_im*val1_re + invdet_re*val1_im;\n		    j -= 1;\n		}\n	    }\n\n	    norm = v_norm_inf(tmp1_re) + v_norm_inf(tmp1_im);\n	    sv_mlt(1/norm,tmp1_re,tmp1_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp1_im,tmp1_im);\n	    mv_mlt(Q,tmp1_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		mv_mlt(Q,tmp1_im,tmp2_im);\n	    if ( l_im != 0.0 )\n		norm = sqrt(in_prod(tmp2_re,tmp2_re)+in_prod(tmp2_im,tmp2_im));\n	    else\n		norm = v_norm2(tmp2_re);\n	    sv_mlt(1/norm,tmp2_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp2_im,tmp2_im);\n\n	    if ( l_im != 0.0 )\n	    {\n		if ( ! X_im )\n		error(E_NULL,""schur_vecs"");\n		set_col(X_re,i,tmp2_re);\n		set_col(X_im,i,tmp2_im);\n		sv_mlt(-1.0,tmp2_im,tmp2_im);\n		set_col(X_re,i+1,tmp2_re);\n		set_col(X_im,i+1,tmp2_im);\n		i += 2;\n	    }\n	    else\n	    {\n		set_col(X_re,i,tmp2_re);\n		if ( X_im != MNULL )\n		    set_col(X_im,i,tmp1_im);	/* zero vector */\n		i += 1;\n	    }\n	}\n\n#ifdef	THREADSAFE\n	V_FREE(tmp1_re);	V_FREE(tmp1_im);\n	V_FREE(tmp2_re);	V_FREE(tmp2_im);\n#endif\n\n	return X_re;\n}\n\n"
leukocyte/meschach_lib/maxint.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\nmain()\n{\n    int		i, old_i;\n\n    i = 1;\n    while ( i > 0 )\n    {\n	old_i = i;\n	i = (i << 1) | 1;\n    }\n    printf(""%d\n"", old_i);\n}\n"
leukocyte/meschach_lib/zfunc.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n	Elementary functions for complex numbers\n	-- if not already defined\n*/\n\n#include	<math.h>\n#include	""zmatrix.h""\n\nstatic char rcsid[] = ""$Id: zfunc.c,v 1.3 1995/04/07 16:27:25 des Exp $"";\n\n#ifndef COMPLEX_H\n\n#ifndef zmake\n/* zmake -- create complex number real + i*imag */\ncomplex	zmake(real,imag)\ndouble	real, imag;\n{\n    complex	w;	/* == real + i*imag */\n\n    w.re = real;	w.im = imag;\n    return w;\n}\n#endif\n\n#ifndef zneg\n/* zneg -- returns negative of z */\ncomplex	zneg(z)\ncomplex	z;\n{\n    z.re = - z.re;\n    z.im = - z.im;\n\n    return z;\n}\n#endif\n\n#ifndef zabs\n/* zabs -- returns |z| */\ndouble	zabs(z)\ncomplex	z;\n{\n    Real	x, y, tmp;\n    int		x_expt, y_expt;\n\n    /* Note: we must ensure that overflow does not occur! */\n    x = ( z.re >= 0.0 ) ? z.re : -z.re;\n    y = ( z.im >= 0.0 ) ? z.im : -z.im;\n    if ( x < y )\n    {\n	tmp = x;\n	x = y;\n	y = tmp;\n    }\n    if ( x == 0.0 ) /* then y == 0.0 as well */\n	return 0.0;\n    x = frexp(x,&x_expt);\n    y = frexp(y,&y_expt);\n    y = ldexp(y,y_expt-x_expt);\n    tmp = sqrt(x*x+y*y);\n\n    return ldexp(tmp,x_expt);\n}\n#endif\n\n#ifndef zadd\n/* zadd -- returns z1+z2 */\ncomplex zadd(z1,z2)\ncomplex	z1, z2;\n{\n    complex z;\n\n    z.re = z1.re + z2.re;\n    z.im = z1.im + z2.im;\n\n    return z;\n}\n#endif\n\n#ifndef zsub\n/* zsub -- returns z1-z2 */\ncomplex zsub(z1,z2)\ncomplex	z1, z2;\n{\n    complex z;\n\n    z.re = z1.re - z2.re;\n    z.im = z1.im - z2.im;\n\n    return z;\n}\n#endif\n\n#ifndef zmlt\n/* zmlt -- returns z1*z2 */\ncomplex	zmlt(z1,z2)\ncomplex	z1, z2;\n{\n    complex z;\n\n    z.re = z1.re * z2.re - z1.im * z2.im;\n    z.im = z1.re * z2.im + z1.im * z2.re;\n\n    return z;\n}\n#endif\n\n#ifndef zinv\n/* zmlt -- returns 1/z */\ncomplex	zinv(z)\ncomplex	z;\n{\n    Real	x, y, tmp;\n    int		x_expt, y_expt;\n\n    if ( z.re == 0.0 && z.im == 0.0 )\n	error(E_SING,""zinv"");\n    /* Note: we must ensure that overflow does not occur! */\n    x = ( z.re >= 0.0 ) ? z.re : -z.re;\n    y = ( z.im >= 0.0 ) ? z.im : -z.im;\n    if ( x < y )\n    {\n	tmp = x;\n	x = y;\n	y = tmp;\n    }\n    x = frexp(x,&x_expt);\n    y = frexp(y,&y_expt);\n    y = ldexp(y,y_expt-x_expt);\n\n    tmp = 1.0/(x*x + y*y);\n    z.re =  z.re*tmp*ldexp(1.0,-2*x_expt);\n    z.im = -z.im*tmp*ldexp(1.0,-2*x_expt);\n\n    return z;\n}\n#endif\n\n#ifndef zdiv\n/* zdiv -- returns z1/z2 */\ncomplex	zdiv(z1,z2)\ncomplex	z1, z2;\n{\n    return zmlt(z1,zinv(z2));\n}\n#endif\n\n#ifndef zsqrt\n/* zsqrt -- returns sqrt(z); uses branch with Re sqrt(z) >= 0 */\ncomplex	zsqrt(z)\ncomplex	z;\n{\n    complex	w;	/* == sqrt(z) at end */\n    Real	alpha;\n    \n    alpha = sqrt(0.5*(fabs(z.re) + zabs(z)));\n    if (alpha!=0) \n      {\n    	if (z.re>=0.0)\n	  {\n	    w.re = alpha;\n	    w.im = z.im / (2.0*alpha);\n	  }\n    	else\n	  {\n	    w.re = fabs(z.im)/(2.0*alpha);\n	    w.im = ( z.im >= 0 ) ? alpha : - alpha;\n	  }\n      }\n    else\n      w.re = w.im = 0.0;\n\n    return w;\n}\n#endif\n\n#ifndef	zexp\n/* zexp -- returns exp(z) */\ncomplex	zexp(z)\ncomplex	z;\n{\n    complex	w;	/* == exp(z) at end */\n    Real	r;\n\n    r = exp(z.re);\n    w.re = r*cos(z.im);\n    w.im = r*sin(z.im);\n\n    return w;\n}\n#endif\n\n#ifndef	zlog\n/* zlog -- returns log(z); uses principal branch with -pi <= Im log(z) <= pi */\ncomplex	zlog(z)\ncomplex	z;\n{\n    complex	w;	/* == log(z) at end */\n\n    w.re = log(zabs(z));\n    w.im = atan2(z.im,z.re);\n\n    return w;\n}\n#endif\n\n#ifndef zconj\ncomplex	zconj(z)\ncomplex	z;\n{\n    complex	w;	/* == conj(z) */\n\n    w.re =   z.re;\n    w.im = - z.im;\n    return w;\n}\n#endif\n\n#endif\n\n"
leukocyte/meschach_lib/memory.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* memory.c 1.3 11/25/87 */\n\n#include 	""matrix.h""\n\n\nstatic	char	rcsid[] = ""$Id: memory.c,v 1.13 1994/04/05 02:10:37 des Exp $"";\n\n/* m_get -- gets an mxn matrix (in MAT form) by dynamic memory allocation\n	-- normally ALL matrices should be obtained this way\n	-- if either m or n is negative this will raise an error\n	-- note that 0 x n and m x 0 matrices can be created */\n#ifndef ANSI_C\nMAT	*m_get(m,n)\nint	m,n;\n#else\nMAT	*m_get(int m, int n)\n#endif\n{\n   MAT	*matrix;\n   int	i;\n   \n   if (m < 0 || n < 0)\n     error(E_NEG,""m_get"");\n\n   if ((matrix=NEW(MAT)) == (MAT *)NULL )\n     error(E_MEM,""m_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,0,sizeof(MAT));\n      mem_numvar(TYPE_MAT,1);\n   }\n   \n   matrix->m = m;		matrix->n = matrix->max_n = n;\n   matrix->max_m = m;	matrix->max_size = m*n;\n#ifndef SEGMENTED\n   if ((matrix->base = NEW_A(m*n,Real)) == (Real *)NULL )\n   {\n      free(matrix);\n      error(E_MEM,""m_get"");\n   }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,0,m*n*sizeof(Real));\n   }\n#else\n   matrix->base = (Real *)NULL;\n#endif\n   if ((matrix->me = (Real **)calloc(m,sizeof(Real *))) == \n       (Real **)NULL )\n   {	free(matrix->base);	free(matrix);\n	error(E_MEM,""m_get"");\n     }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,0,m*sizeof(Real *));\n   }\n   \n#ifndef SEGMENTED\n   /* set up pointers */\n   for ( i=0; i<m; i++ )\n     matrix->me[i] = &(matrix->base[i*n]);\n#else\n   for ( i = 0; i < m; i++ )\n     if ( (matrix->me[i]=NEW_A(n,Real)) == (Real *)NULL )\n       error(E_MEM,""m_get"");\n     else if (mem_info_is_on()) {\n	mem_bytes(TYPE_MAT,0,n*sizeof(Real));\n       }\n#endif\n   \n   return (matrix);\n}\n\n\n/* px_get -- gets a PERM of given 'size' by dynamic memory allocation\n	-- Note: initialized to the identity permutation\n	-- the permutation is on the set {0,1,2,...,size-1} */\n#ifndef ANSI_C\nPERM	*px_get(size)\nint	size;\n#else\nPERM	*px_get(int size)\n#endif\n{\n   PERM	*permute;\n   int	i;\n\n   if (size < 0)\n     error(E_NEG,""px_get"");\n\n   if ((permute=NEW(PERM)) == (PERM *)NULL )\n     error(E_MEM,""px_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_PERM,0,sizeof(PERM));\n      mem_numvar(TYPE_PERM,1);\n   }\n   \n   permute->size = permute->max_size = size;\n   if ((permute->pe = NEW_A(size,unsigned int)) == (unsigned int *)NULL )\n     error(E_MEM,""px_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_PERM,0,size*sizeof(unsigned int));\n   }\n   \n   for ( i=0; i<size; i++ )\n     permute->pe[i] = i;\n   \n   return (permute);\n}\n\n/* v_get -- gets a VEC of dimension 'size'\n   -- Note: initialized to zero */\n#ifndef ANSI_C\nVEC	*v_get(size)\nint	size;\n#else\nVEC	*v_get(int size)\n#endif\n{\n   VEC	*vector;\n   \n   if (size < 0)\n     error(E_NEG,""v_get"");\n\n   if ((vector=NEW(VEC)) == (VEC *)NULL )\n     error(E_MEM,""v_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_VEC,0,sizeof(VEC));\n      mem_numvar(TYPE_VEC,1);\n   }\n   \n   vector->dim = vector->max_dim = size;\n   if ((vector->ve=NEW_A(size,Real)) == (Real *)NULL )\n   {\n      free(vector);\n      error(E_MEM,""v_get"");\n   }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_VEC,0,size*sizeof(Real));\n   }\n   \n   return (vector);\n}\n\n/* m_free -- returns MAT & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	m_free(mat)\nMAT	*mat;\n#else\nint	m_free(MAT *mat)\n#endif\n{\n#ifdef SEGMENTED\n   int	i;\n#endif\n   \n   if ( mat==(MAT *)NULL || (int)(mat->m) < 0 ||\n       (int)(mat->n) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n#ifndef SEGMENTED\n   if ( mat->base != (Real *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,mat->max_m*mat->max_n*sizeof(Real),0);\n      }\n      free((char *)(mat->base));\n   }\n#else\n   for ( i = 0; i < mat->max_m; i++ )\n     if ( mat->me[i] != (Real *)NULL ) {\n	if (mem_info_is_on()) {\n	   mem_bytes(TYPE_MAT,mat->max_n*sizeof(Real),0);\n	}\n	free((char *)(mat->me[i]));\n     }\n#endif\n   if ( mat->me != (Real **)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,mat->max_m*sizeof(Real *),0);\n      }\n      free((char *)(mat->me));\n   }\n   \n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_MAT,sizeof(MAT),0);\n      mem_numvar(TYPE_MAT,-1);\n   }\n   free((char *)mat);\n   \n   return (0);\n}\n\n\n\n/* px_free -- returns PERM & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	px_free(px)\nPERM	*px;\n#else\nint	px_free(PERM *px)\n#endif\n{\n   if ( px==(PERM *)NULL || (int)(px->size) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n   if ( px->pe == (unsigned int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_PERM,sizeof(PERM),0);\n	 mem_numvar(TYPE_PERM,-1);\n      }      \n      free((char *)px);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_PERM,sizeof(PERM)+px->max_size*sizeof(unsigned int),0);\n	 mem_numvar(TYPE_PERM,-1);\n      }\n      free((char *)px->pe);\n      free((char *)px);\n   }\n   \n   return (0);\n}\n\n\n\n/* v_free -- returns VEC & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	v_free(vec)\nVEC	*vec;\n#else\nint	v_free(VEC *vec)\n#endif\n{\n   if ( vec==(VEC *)NULL || (int)(vec->dim) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n   if ( vec->ve == (Real *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_VEC,sizeof(VEC),0);\n	 mem_numvar(TYPE_VEC,-1);\n      }\n      free((char *)vec);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_VEC,sizeof(VEC)+vec->max_dim*sizeof(Real),0);\n	 mem_numvar(TYPE_VEC,-1);\n      }\n      free((char *)vec->ve);\n      free((char *)vec);\n   }\n   \n   return (0);\n}\n\n\n\n/* m_resize -- returns the matrix A of size new_m x new_n; A is zeroed\n   -- if A == NULL on entry then the effect is equivalent to m_get() */\n#ifndef ANSI_C\nMAT	*m_resize(A,new_m,new_n)\nMAT	*A;\nint	new_m, new_n;\n#else\nMAT	*m_resize(MAT *A,int new_m, int new_n)\n#endif\n{\n   int	i;\n   int	new_max_m, new_max_n, new_size, old_m, old_n;\n   \n   if (new_m < 0 || new_n < 0)\n     error(E_NEG,""m_resize"");\n\n   if ( ! A )\n     return m_get(new_m,new_n);\n\n   /* nothing was changed */\n   if (new_m == A->m && new_n == A->n)\n     return A;\n\n   old_m = A->m;	old_n = A->n;\n   if ( new_m > A->max_m )\n   {	/* re-allocate A->me */\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,A->max_m*sizeof(Real *),\n		      new_m*sizeof(Real *));\n      }\n\n      A->me = RENEW(A->me,new_m,Real *);\n      if ( ! A->me )\n	error(E_MEM,""m_resize"");\n   }\n   new_max_m = max(new_m,A->max_m);\n   new_max_n = max(new_n,A->max_n);\n   \n#ifndef SEGMENTED\n   new_size = new_max_m*new_max_n;\n   if ( new_size > A->max_size )\n   {	/* re-allocate A->base */\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_MAT,A->max_m*A->max_n*sizeof(Real),\n		      new_size*sizeof(Real));\n      }\n\n      A->base = RENEW(A->base,new_size,Real);\n      if ( ! A->base )\n	error(E_MEM,""m_resize"");\n      A->max_size = new_size;\n   }\n   \n   /* now set up A->me[i] */\n   for ( i = 0; i < new_m; i++ )\n     A->me[i] = &(A->base[i*new_n]);\n   \n   /* now shift data in matrix */\n   if ( old_n > new_n )\n   {\n      for ( i = 1; i < min(old_m,new_m); i++ )\n	MEM_COPY((char *)&(A->base[i*old_n]),\n		 (char *)&(A->base[i*new_n]),\n		 sizeof(Real)*new_n);\n   }\n   else if ( old_n < new_n )\n   {\n      for ( i = (int)(min(old_m,new_m))-1; i > 0; i-- )\n      {   /* copy & then zero extra space */\n	 MEM_COPY((char *)&(A->base[i*old_n]),\n		  (char *)&(A->base[i*new_n]),\n		  sizeof(Real)*old_n);\n	 __zero__(&(A->base[i*new_n+old_n]),(new_n-old_n));\n      }\n      __zero__(&(A->base[old_n]),(new_n-old_n));\n      A->max_n = new_n;\n   }\n   /* zero out the new rows.. */\n   for ( i = old_m; i < new_m; i++ )\n     __zero__(&(A->base[i*new_n]),new_n);\n#else\n   if ( A->max_n < new_n )\n   {\n      Real	*tmp;\n      \n      for ( i = 0; i < A->max_m; i++ )\n      {\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_MAT,A->max_n*sizeof(Real),\n			 new_max_n*sizeof(Real));\n	 }	\n\n	 if ( (tmp = RENEW(A->me[i],new_max_n,Real)) == NULL )\n	   error(E_MEM,""m_resize"");\n	 else {	\n	    A->me[i] = tmp;\n	 }\n      }\n      for ( i = A->max_m; i < new_max_m; i++ )\n      {\n	 if ( (tmp = NEW_A(new_max_n,Real)) == NULL )\n	   error(E_MEM,""m_resize"");\n	 else {\n	    A->me[i] = tmp;\n\n	    if (mem_info_is_on()) {\n	       mem_bytes(TYPE_MAT,0,new_max_n*sizeof(Real));\n	    }	    \n	 }\n      }\n   }\n   else if ( A->max_m < new_m )\n   {\n      for ( i = A->max_m; i < new_m; i++ ) \n	if ( (A->me[i] = NEW_A(new_max_n,Real)) == NULL )\n	  error(E_MEM,""m_resize"");\n	else if (mem_info_is_on()) {\n	   mem_bytes(TYPE_MAT,0,new_max_n*sizeof(Real));\n	}\n      \n   }\n   \n   if ( old_n < new_n )\n   {\n      for ( i = 0; i < old_m; i++ )\n	__zero__(&(A->me[i][old_n]),new_n-old_n);\n   }\n   \n   /* zero out the new rows.. */\n   for ( i = old_m; i < new_m; i++ )\n     __zero__(A->me[i],new_n);\n#endif\n   \n   A->max_m = new_max_m;\n   A->max_n = new_max_n;\n   A->max_size = A->max_m*A->max_n;\n   A->m = new_m;	A->n = new_n;\n   \n   return A;\n}\n\n/* px_resize -- returns the permutation px with size new_size\n   -- px is set to the identity permutation */\n#ifndef ANSI_C\nPERM	*px_resize(px,new_size)\nPERM	*px;\nint	new_size;\n#else\nPERM	*px_resize(PERM *px, int new_size)\n#endif\n{\n   int	i;\n   \n   if (new_size < 0)\n     error(E_NEG,""px_resize"");\n\n   if ( ! px )\n     return px_get(new_size);\n   \n   /* nothing is changed */\n   if (new_size == px->size)\n     return px;\n\n   if ( new_size > px->max_size )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_PERM,px->max_size*sizeof(unsigned int),\n		      new_size*sizeof(unsigned int));\n      }\n      px->pe = RENEW(px->pe,new_size,unsigned int);\n      if ( ! px->pe )\n	error(E_MEM,""px_resize"");\n      px->max_size = new_size;\n   }\n   if ( px->size <= new_size )\n     /* extend permutation */\n     for ( i = px->size; i < new_size; i++ )\n       px->pe[i] = i;\n   else\n     for ( i = 0; i < new_size; i++ )\n       px->pe[i] = i;\n   \n   px->size = new_size;\n   \n   return px;\n}\n\n/* v_resize -- returns the vector x with dim new_dim\n   -- x is set to the zero vector */\n#ifndef ANSI_C\nVEC	*v_resize(x,new_dim)\nVEC	*x;\nint	new_dim;\n#else\nVEC	*v_resize(VEC *x, int new_dim)\n#endif\n{\n   \n   if (new_dim < 0)\n     error(E_NEG,""v_resize"");\n\n   if ( ! x )\n     return v_get(new_dim);\n\n   /* nothing is changed */\n   if (new_dim == x->dim)\n     return x;\n\n   if ( x->max_dim == 0 )	/* assume that it's from sub_vec */\n     return v_get(new_dim);\n   \n   if ( new_dim > x->max_dim )\n   {\n      if (mem_info_is_on()) { \n	 mem_bytes(TYPE_VEC,x->max_dim*sizeof(Real),\n			 new_dim*sizeof(Real));\n      }\n\n      x->ve = RENEW(x->ve,new_dim,Real);\n      if ( ! x->ve )\n	error(E_MEM,""v_resize"");\n      x->max_dim = new_dim;\n   }\n   \n   if ( new_dim > x->dim )\n     __zero__(&(x->ve[x->dim]),new_dim - x->dim);\n   x->dim = new_dim;\n   \n   return x;\n}\n\n\n\n\n/* Varying number of arguments */\n/* other functions of this type are in sparse.c and zmemory.c */\n\n\n\n#ifdef ANSI_C\n\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,NULL);\n   where \n     int dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     dim is the length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables\n     Other gec_... functions are similar.\n*/\n\nint v_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint iv_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   IVEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_get_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   MAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_get(m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint px_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   PERM **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n\nint v_resize_vars(int new_dim,...)\n{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint iv_resize_vars(int new_dim,...) \n{\n   va_list ap;\n   int i=0;\n   IVEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_resize_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   MAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint px_resize_vars(int new_dim,...) \n{\n   va_list ap;\n   int i=0;\n   PERM **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n\n\nint v_free_vars(VEC **pv,...)\n{\n   va_list ap;\n   int i=1;\n   VEC **par;\n   \n   v_free(*pv);\n   *pv = VNULL;\n   va_start(ap, pv);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      v_free(*par); \n      *par = VNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint iv_free_vars(IVEC **ipv,...)\n{\n   va_list ap;\n   int i=1;\n   IVEC **par;\n   \n   iv_free(*ipv);\n   *ipv = IVNULL;\n   va_start(ap, ipv);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      iv_free(*par); \n      *par = IVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint px_free_vars(PERM **vpx,...)\n{\n   va_list ap;\n   int i=1;\n   PERM **par;\n   \n   px_free(*vpx);\n   *vpx = PNULL;\n   va_start(ap, vpx);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      px_free(*par); \n      *par = PNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_free_vars(MAT **va,...)\n{\n   va_list ap;\n   int i=1;\n   MAT **par;\n   \n   m_free(*va);\n   *va = MNULL;\n   va_start(ap, va);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      m_free(*par); \n      *par = MNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#elif VARARGS\n/* old varargs is used */\n\n\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,VNULL);\n   where \n     int dim;\n     VEC *x, *y, *z,...;\n     The last argument should be VNULL ! \n     dim is the length of vectors x,y,z,...\n*/\n\nint v_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int dim,i=0;\n   VEC **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint iv_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, dim;\n   IVEC **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, n, m;\n   MAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_get(m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint px_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, dim;\n   PERM **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n\nint v_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   VEC **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      *par = v_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint iv_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   IVEC **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      *par = iv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n;\n   MAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      *par = m_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint px_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   PERM **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      *par = px_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     VEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n\n\nint v_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   VEC **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,VEC **)) {   /* NULL ends the list*/\n      v_free(*par); \n      *par = VNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint iv_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   IVEC **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,IVEC **)) {   /* NULL ends the list*/\n      iv_free(*par); \n      *par = IVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint px_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   PERM **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,PERM **)) {   /* NULL ends the list*/\n      px_free(*par); \n      *par = PNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\nint m_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   MAT **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,MAT **)) {   /* NULL ends the list*/\n      m_free(*par); \n      *par = MNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n#endif /* VARARGS */\n  \n\n"
leukocyte/meschach_lib/zmemory.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* Memory allocation and de-allocation for complex matrices and vectors */\n\n#include	<stdio.h>\n#include	""zmatrix.h""\n\nstatic	char	rcsid[] = ""$Id: zmemory.c,v 1.2 1994/04/05 02:13:14 des Exp $"";\n\n\n\n/* zv_zero -- zeros all entries of a complex vector\n   -- uses __zzero__() */\n#ifndef ANSI_C\nZVEC	*zv_zero(x)\nZVEC	*x;\n#else\nZVEC	*zv_zero(ZVEC *x)\n#endif\n{\n   if ( ! x )\n     error(E_NULL,""zv_zero"");\n   __zzero__(x->ve,x->dim);\n   \n   return x;\n}\n\n/* zm_zero -- zeros all entries of a complex matrix\n   -- uses __zzero__() */\n#ifndef ANSI_C\nZMAT	*zm_zero(A)\nZMAT	*A;\n#else\nZMAT	*zm_zero(ZMAT *A)\n#endif\n{\n   int		i;\n   \n   if ( ! A )\n     error(E_NULL,""zm_zero"");\n   for ( i = 0; i < A->m; i++ )\n     __zzero__(A->me[i],A->n);\n   \n   return A;\n}\n\n/* zm_get -- gets an mxn complex matrix (in ZMAT form) */\n#ifndef ANSI_C\nZMAT	*zm_get(m,n)\nint	m,n;\n#else\nZMAT	*zm_get(int m, int n)\n#endif\n{\n   ZMAT	*matrix;\n   unsigned int	i;\n   \n   if (m < 0 || n < 0)\n     error(E_NEG,""zm_get"");\n\n   if ((matrix=NEW(ZMAT)) == (ZMAT *)NULL )\n     error(E_MEM,""zm_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ZMAT,0,sizeof(ZMAT));\n      mem_numvar(TYPE_ZMAT,1);\n   }\n   \n   matrix->m = m;		matrix->n = matrix->max_n = n;\n   matrix->max_m = m;	matrix->max_size = m*n;\n#ifndef SEGMENTED\n   if ((matrix->base = NEW_A(m*n,complex)) == (complex *)NULL )\n   {\n      free(matrix);\n      error(E_MEM,""zm_get"");\n   }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ZMAT,0,m*n*sizeof(complex));\n   }\n#else\n   matrix->base = (complex *)NULL;\n#endif\n   if ((matrix->me = (complex **)calloc(m,sizeof(complex *))) == \n       (complex **)NULL )\n   {	free(matrix->base);	free(matrix);\n	error(E_MEM,""zm_get"");\n     }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ZMAT,0,m*sizeof(complex *));\n   }\n#ifndef SEGMENTED\n   /* set up pointers */\n   for ( i=0; i<m; i++ )\n     matrix->me[i] = &(matrix->base[i*n]);\n#else\n   for ( i = 0; i < m; i++ )\n     if ( (matrix->me[i]=NEW_A(n,complex)) == (complex *)NULL )\n       error(E_MEM,""zm_get"");\n     else if (mem_info_is_on()) {\n	mem_bytes(TYPE_ZMAT,0,n*sizeof(complex));\n     }\n#endif\n   \n   return (matrix);\n}\n\n\n/* zv_get -- gets a ZVEC of dimension 'dim'\n   -- Note: initialized to zero */\n#ifndef ANSI_C\nZVEC	*zv_get(size)\nint	size;\n#else\nZVEC	*zv_get(int size)\n#endif\n{\n   ZVEC	*vector;\n\n   if (size < 0)\n     error(E_NEG,""zv_get"");\n\n   if ((vector=NEW(ZVEC)) == (ZVEC *)NULL )\n     error(E_MEM,""zv_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ZVEC,0,sizeof(ZVEC));\n      mem_numvar(TYPE_ZVEC,1);\n   }\n   vector->dim = vector->max_dim = size;\n   if ((vector->ve=NEW_A(size,complex)) == (complex *)NULL )\n   {\n      free(vector);\n      error(E_MEM,""zv_get"");\n   }\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_ZVEC,0,size*sizeof(complex));\n   }\n   return (vector);\n}\n\n/* zm_free -- returns ZMAT & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	zm_free(mat)\nZMAT	*mat;\n#else\nint	zm_free(ZMAT *mat)\n#endif\n{\n#ifdef SEGMENTED\n   int	i;\n#endif\n   \n   if ( mat==(ZMAT *)NULL || (int)(mat->m) < 0 ||\n       (int)(mat->n) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n#ifndef SEGMENTED\n   if ( mat->base != (complex *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ZMAT,mat->max_m*mat->max_n*sizeof(complex),0);\n      }	   \n      free((char *)(mat->base));\n   }\n#else\n   for ( i = 0; i < mat->max_m; i++ )\n     if ( mat->me[i] != (complex *)NULL ) {\n	if (mem_info_is_on()) {\n	   mem_bytes(TYPE_ZMAT,mat->max_n*sizeof(complex),0);\n	}\n	free((char *)(mat->me[i]));\n     }\n#endif\n   if ( mat->me != (complex **)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ZMAT,mat->max_m*sizeof(complex *),0);\n      }	   \n      free((char *)(mat->me));\n   }\n   \n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_ZMAT,sizeof(ZMAT),0);\n      mem_numvar(TYPE_ZMAT,-1);\n   }\n   free((char *)mat);\n   \n   return (0);\n}\n\n\n/* zv_free -- returns ZVEC & asoociated memory back to memory heap */\n#ifndef ANSI_C\nint	zv_free(vec)\nZVEC	*vec;\n#else\nint	zv_free(ZVEC *vec)\n#endif\n{\n   if ( vec==(ZVEC *)NULL || (int)(vec->dim) < 0 )\n     /* don't trust it */\n     return (-1);\n   \n   if ( vec->ve == (complex *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ZVEC,sizeof(ZVEC),0);\n	 mem_numvar(TYPE_ZVEC,-1);\n      }\n      free((char *)vec);\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ZVEC,vec->max_dim*sizeof(complex)+\n		      sizeof(ZVEC),0);\n	 mem_numvar(TYPE_ZVEC,-1);\n      }\n      \n      free((char *)vec->ve);\n      free((char *)vec);\n   }\n   \n   return (0);\n}\n\n\n/* zm_resize -- returns the matrix A of size new_m x new_n; A is zeroed\n   -- if A == NULL on entry then the effect is equivalent to m_get() */\n#ifndef ANSI_C\nZMAT	*zm_resize(A,new_m,new_n)\nZMAT	*A;\nint	new_m, new_n;\n#else\nZMAT	*zm_resize(ZMAT *A, int new_m, int new_n)\n#endif\n{\n   unsigned int	i, new_max_m, new_max_n, new_size, old_m, old_n;\n   \n   if (new_m < 0 || new_n < 0)\n     error(E_NEG,""zm_resize"");\n\n   if ( ! A )\n     return zm_get(new_m,new_n);\n   \n   if (new_m == A->m && new_n == A->n)\n     return A;\n\n   old_m = A->m;	old_n = A->n;\n   if ( new_m > A->max_m )\n   {	/* re-allocate A->me */\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ZMAT,A->max_m*sizeof(complex *),\n		      new_m*sizeof(complex *));\n      }\n\n      A->me = RENEW(A->me,new_m,complex *);\n      if ( ! A->me )\n	error(E_MEM,""zm_resize"");\n   }\n   new_max_m = max(new_m,A->max_m);\n   new_max_n = max(new_n,A->max_n);\n   \n#ifndef SEGMENTED\n   new_size = new_max_m*new_max_n;\n   if ( new_size > A->max_size )\n   {	/* re-allocate A->base */\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_ZMAT,A->max_m*A->max_n*sizeof(complex),\n		new_size*sizeof(complex));      \n      }\n\n      A->base = RENEW(A->base,new_size,complex);\n      if ( ! A->base )\n	error(E_MEM,""zm_resize"");\n      A->max_size = new_size;\n   }\n   \n   /* now set up A->me[i] */\n   for ( i = 0; i < new_m; i++ )\n     A->me[i] = &(A->base[i*new_n]);\n   \n   /* now shift data in matrix */\n   if ( old_n > new_n )\n   {\n      for ( i = 1; i < min(old_m,new_m); i++ )\n	MEM_COPY((char *)&(A->base[i*old_n]),\n		 (char *)&(A->base[i*new_n]),\n		 sizeof(complex)*new_n);\n   }\n   else if ( old_n < new_n )\n   {\n      for ( i = min(old_m,new_m)-1; i > 0; i-- )\n      {   /* copy & then zero extra space */\n	 MEM_COPY((char *)&(A->base[i*old_n]),\n		  (char *)&(A->base[i*new_n]),\n		  sizeof(complex)*old_n);\n	 __zzero__(&(A->base[i*new_n+old_n]),(new_n-old_n));\n      }\n      __zzero__(&(A->base[old_n]),(new_n-old_n));\n      A->max_n = new_n;\n   }\n   /* zero out the new rows.. */\n   for ( i = old_m; i < new_m; i++ )\n     __zzero__(&(A->base[i*new_n]),new_n);\n#else\n   if ( A->max_n < new_n )\n   {\n      complex	*tmp;\n      \n      for ( i = 0; i < A->max_m; i++ )\n      {\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_ZMAT,A->max_n*sizeof(complex),\n			 new_max_n*sizeof(complex));\n	 }\n\n	 if ( (tmp = RENEW(A->me[i],new_max_n,complex)) == NULL )\n	   error(E_MEM,""zm_resize"");\n	 else {\n	    A->me[i] = tmp;\n	 }\n      }\n      for ( i = A->max_m; i < new_max_m; i++ )\n      {\n	 if ( (tmp = NEW_A(new_max_n,complex)) == NULL )\n	   error(E_MEM,""zm_resize"");\n	 else {\n	    A->me[i] = tmp;\n	    if (mem_info_is_on()) {\n	       mem_bytes(TYPE_ZMAT,0,new_max_n*sizeof(complex));\n	    }\n	 }\n      }\n   }\n   else if ( A->max_m < new_m )\n   {\n      for ( i = A->max_m; i < new_m; i++ )\n	if ( (A->me[i] = NEW_A(new_max_n,complex)) == NULL )\n	  error(E_MEM,""zm_resize"");\n	else if (mem_info_is_on()) {\n	   mem_bytes(TYPE_ZMAT,0,new_max_n*sizeof(complex));\n	}\n      \n   }\n   \n   if ( old_n < new_n )\n   {\n      for ( i = 0; i < old_m; i++ )\n	__zzero__(&(A->me[i][old_n]),new_n-old_n);\n   }\n   \n   /* zero out the new rows.. */\n   for ( i = old_m; i < new_m; i++ )\n     __zzero__(A->me[i],new_n);\n#endif\n   \n   A->max_m = new_max_m;\n   A->max_n = new_max_n;\n   A->max_size = A->max_m*A->max_n;\n   A->m = new_m;	A->n = new_n;\n   \n   return A;\n}\n\n\n/* zv_resize -- returns the (complex) vector x with dim new_dim\n   -- x is set to the zero vector */\n#ifndef ANSI_C\nZVEC	*zv_resize(x,new_dim)\nZVEC	*x;\nint	new_dim;\n#else\nZVEC	*zv_resize(ZVEC *x, int new_dim)\n#endif\n{\n   if (new_dim < 0)\n     error(E_NEG,""zv_resize"");\n\n   if ( ! x )\n     return zv_get(new_dim);\n\n   if (new_dim == x->dim)\n     return x;\n\n   if ( x->max_dim == 0 )	/* assume that it's from sub_zvec */\n     return zv_get(new_dim);\n   \n   if ( new_dim > x->max_dim )\n   {\n      if (mem_info_is_on()) { \n	 mem_bytes(TYPE_ZVEC,x->max_dim*sizeof(complex),\n		      new_dim*sizeof(complex));\n      }\n\n      x->ve = RENEW(x->ve,new_dim,complex);\n      if ( ! x->ve )\n	error(E_MEM,""zv_resize"");\n      x->max_dim = new_dim;\n   }\n   \n   if ( new_dim > x->dim )\n     __zzero__(&(x->ve[x->dim]),new_dim - x->dim);\n   x->dim = new_dim;\n   \n   return x;\n}\n\n\n/* varying arguments */\n\n#ifdef ANSI_C\n\n#include <stdarg.h>\n\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   zv_get_vars(dim,&x,&y,&z,...,NULL);\n   where \n     int dim;\n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     dim is the length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables\n     Other gec_... functions are similar.\n*/\n\nint zv_get_vars(int dim,...) \n{\n   va_list ap;\n   int i=0;\n   ZVEC **par;\n   \n   va_start(ap, dim);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      *par = zv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint zm_get_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   ZMAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,ZMAT **)) {   /* NULL ends the list*/\n      *par = zm_get(m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n\nint zv_resize_vars(int new_dim,...)\n{\n   va_list ap;\n   int i=0;\n   ZVEC **par;\n   \n   va_start(ap, new_dim);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      *par = zv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint zm_resize_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   ZMAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,ZMAT **)) {   /* NULL ends the list*/\n      *par = zm_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n\nint zv_free_vars(ZVEC **pv,...)\n{\n   va_list ap;\n   int i=1;\n   ZVEC **par;\n   \n   zv_free(*pv);\n   *pv = ZVNULL;\n   va_start(ap, pv);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      zv_free(*par); \n      *par = ZVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint zm_free_vars(ZMAT **va,...)\n{\n   va_list ap;\n   int i=1;\n   ZMAT **par;\n   \n   zm_free(*va);\n   *va = ZMNULL;\n   va_start(ap, va);\n   while (par = va_arg(ap,ZMAT **)) {   /* NULL ends the list*/\n      zm_free(*par); \n      *par = ZMNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n#elif VARARGS\n\n#include <varargs.h>\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   v_get_vars(dim,&x,&y,&z,...,NULL);\n   where \n     int dim;\n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     dim is the length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables\n     Other gec_... functions are similar.\n*/\n\nint zv_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int dim,i=0;\n   ZVEC **par;\n   \n   va_start(ap);\n   dim = va_arg(ap,int);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      *par = zv_get(dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint zm_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, n, m;\n   ZMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,ZMAT **)) {   /* NULL ends the list*/\n      *par = zm_get(m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   v_resize_vars(new_dim,&x,&y,&z,...,NULL);\n   where \n     int new_dim;\n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     rdim is the resized length of vectors x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n     Other *_resize_list() functions are similar.\n*/\n\nint zv_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, new_dim;\n   ZVEC **par;\n   \n   va_start(ap);\n   new_dim = va_arg(ap,int);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      *par = zv_resize(*par,new_dim);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\nint zm_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n;\n   ZMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,ZMAT **)) {   /* NULL ends the list*/\n      *par = zm_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   v_free_vars(&x,&y,&z,...,NULL);\n   where \n     ZVEC *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n     Other *_free_list() functions are similar.\n*/\n\nint zv_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   ZVEC **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,ZVEC **)) {   /* NULL ends the list*/\n      zv_free(*par); \n      *par = ZVNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\nint zm_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   ZMAT **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,ZMAT **)) {   /* NULL ends the list*/\n      zm_free(*par); \n      *par = ZMNULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#endif\n\n"
leukocyte/meschach_lib/zmatop.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n#include	<stdio.h>\n#include	""zmatrix.h""\n\nstatic	char	rcsid[] = ""$Id: zmatop.c,v 1.2 1995/03/27 15:49:03 des Exp $"";\n\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n\n/* zm_add -- matrix addition -- may be in-situ */\nZMAT	*zm_add(mat1,mat2,out)\nZMAT	*mat1,*mat2,*out;\n{\n    unsigned int	m,n,i;\n    \n    if ( mat1==ZMNULL || mat2==ZMNULL )\n	error(E_NULL,""zm_add"");\n    if ( mat1->m != mat2->m || mat1->n != mat2->n )\n	error(E_SIZES,""zm_add"");\n    if ( out==ZMNULL || out->m != mat1->m || out->n != mat1->n )\n	out = zm_resize(out,mat1->m,mat1->n);\n    m = mat1->m;	n = mat1->n;\n    for ( i=0; i<m; i++ )\n    {\n	__zadd__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n	/**************************************************\n	  for ( j=0; j<n; j++ )\n	  out->me[i][j] = mat1->me[i][j]+mat2->me[i][j];\n	  **************************************************/\n    }\n    \n    return (out);\n}\n\n/* zm_sub -- matrix subtraction -- may be in-situ */\nZMAT	*zm_sub(mat1,mat2,out)\nZMAT	*mat1,*mat2,*out;\n{\n    unsigned int	m,n,i;\n    \n    if ( mat1==ZMNULL || mat2==ZMNULL )\n	error(E_NULL,""zm_sub"");\n    if ( mat1->m != mat2->m || mat1->n != mat2->n )\n	error(E_SIZES,""zm_sub"");\n    if ( out==ZMNULL || out->m != mat1->m || out->n != mat1->n )\n	out = zm_resize(out,mat1->m,mat1->n);\n    m = mat1->m;	n = mat1->n;\n    for ( i=0; i<m; i++ )\n    {\n	__zsub__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n	/**************************************************\n	  for ( j=0; j<n; j++ )\n	  out->me[i][j] = mat1->me[i][j]-mat2->me[i][j];\n	**************************************************/\n    }\n    \n    return (out);\n}\n\n/*\n  Note: In the following routines, ""adjoint"" means complex conjugate\n  transpose:\n  A* = conjugate(A^T)\n  */\n\n/* zm_mlt -- matrix-matrix multiplication */\nZMAT	*zm_mlt(A,B,OUT)\nZMAT	*A,*B,*OUT;\n{\n    unsigned int	i, /* j, */ k, m, n, p;\n    complex	**A_v, **B_v /*, *B_row, *OUT_row, sum, tmp */;\n    \n    if ( A==ZMNULL || B==ZMNULL )\n	error(E_NULL,""zm_mlt"");\n    if ( A->n != B->m )\n	error(E_SIZES,""zm_mlt"");\n    if ( A == OUT || B == OUT )\n	error(E_INSITU,""zm_mlt"");\n    m = A->m;	n = A->n;	p = B->n;\n    A_v = A->me;		B_v = B->me;\n    \n    if ( OUT==ZMNULL || OUT->m != A->m || OUT->n != B->n )\n	OUT = zm_resize(OUT,A->m,B->n);\n    \n    /****************************************************************\n      for ( i=0; i<m; i++ )\n      for  ( j=0; j<p; j++ )\n      {\n      sum = 0.0;\n      for ( k=0; k<n; k++ )\n      sum += A_v[i][k]*B_v[k][j];\n      OUT->me[i][j] = sum;\n      }\n    ****************************************************************/\n    zm_zero(OUT);\n    for ( i=0; i<m; i++ )\n	for ( k=0; k<n; k++ )\n	{\n	    if ( ! is_zero(A_v[i][k]) )\n		__zmltadd__(OUT->me[i],B_v[k],A_v[i][k],(int)p,Z_NOCONJ);\n	    /**************************************************\n	      B_row = B_v[k];	OUT_row = OUT->me[i];\n	      for ( j=0; j<p; j++ )\n	      (*OUT_row++) += tmp*(*B_row++);\n	    **************************************************/\n	}\n    \n    return OUT;\n}\n\n/* zmma_mlt -- matrix-matrix adjoint multiplication\n   -- A.B* is returned, and stored in OUT */\nZMAT	*zmma_mlt(A,B,OUT)\nZMAT	*A, *B, *OUT;\n{\n    int	i, j, limit;\n    /* complex	*A_row, *B_row, sum; */\n    \n    if ( ! A || ! B )\n	error(E_NULL,""zmma_mlt"");\n    if ( A == OUT || B == OUT )\n	error(E_INSITU,""zmma_mlt"");\n    if ( A->n != B->n )\n	error(E_SIZES,""zmma_mlt"");\n    if ( ! OUT || OUT->m != A->m || OUT->n != B->m )\n	OUT = zm_resize(OUT,A->m,B->m);\n    \n    limit = A->n;\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < B->m; j++ )\n	{\n	    OUT->me[i][j] = __zip__(B->me[j],A->me[i],(int)limit,Z_CONJ);\n	    /**************************************************\n	      sum = 0.0;\n	      A_row = A->me[i];\n	      B_row = B->me[j];\n	      for ( k = 0; k < limit; k++ )\n	      sum += (*A_row++)*(*B_row++);\n	      OUT->me[i][j] = sum;\n	      **************************************************/\n	}\n    \n    return OUT;\n}\n\n/* zmam_mlt -- matrix adjoint-matrix multiplication\n   -- A*.B is returned, result stored in OUT */\nZMAT	*zmam_mlt(A,B,OUT)\nZMAT	*A, *B, *OUT;\n{\n    int	i, k, limit;\n    /* complex	*B_row, *OUT_row, multiplier; */\n    complex	tmp;\n    \n    if ( ! A || ! B )\n	error(E_NULL,""zmam_mlt"");\n    if ( A == OUT || B == OUT )\n	error(E_INSITU,""zmam_mlt"");\n    if ( A->m != B->m )\n	error(E_SIZES,""zmam_mlt"");\n    if ( ! OUT || OUT->m != A->n || OUT->n != B->n )\n	OUT = zm_resize(OUT,A->n,B->n);\n    \n    limit = B->n;\n    zm_zero(OUT);\n    for ( k = 0; k < A->m; k++ )\n	for ( i = 0; i < A->n; i++ )\n	{\n	    tmp.re =   A->me[k][i].re;\n	    tmp.im = - A->me[k][i].im;\n	    if ( ! is_zero(tmp) )\n		__zmltadd__(OUT->me[i],B->me[k],tmp,(int)limit,Z_NOCONJ);\n	}\n    \n    return OUT;\n}\n\n/* zmv_mlt -- matrix-vector multiplication \n   -- Note: b is treated as a column vector */\nZVEC	*zmv_mlt(A,b,out)\nZMAT	*A;\nZVEC	*b,*out;\n{\n    unsigned int	i, m, n;\n    complex	**A_v, *b_v /*, *A_row */;\n    /* register complex	sum; */\n    \n    if ( A==ZMNULL || b==ZVNULL )\n	error(E_NULL,""zmv_mlt"");\n    if ( A->n != b->dim )\n	error(E_SIZES,""zmv_mlt"");\n    if ( b == out )\n	error(E_INSITU,""zmv_mlt"");\n    if ( out == ZVNULL || out->dim != A->m )\n	out = zv_resize(out,A->m);\n    \n    m = A->m;		n = A->n;\n    A_v = A->me;		b_v = b->ve;\n    for ( i=0; i<m; i++ )\n    {\n	/* for ( j=0; j<n; j++ )\n	   sum += A_v[i][j]*b_v[j]; */\n	out->ve[i] = __zip__(A_v[i],b_v,(int)n,Z_NOCONJ);\n	/**************************************************\n	  A_row = A_v[i];		b_v = b->ve;\n	  for ( j=0; j<n; j++ )\n	  sum += (*A_row++)*(*b_v++);\n	  out->ve[i] = sum;\n	**************************************************/\n    }\n    \n    return out;\n}\n\n/* zsm_mlt -- scalar-matrix multiply -- may be in-situ */\nZMAT	*zsm_mlt(scalar,matrix,out)\ncomplex	scalar;\nZMAT	*matrix,*out;\n{\n    unsigned int	m,n,i;\n    \n    if ( matrix==ZMNULL )\n	error(E_NULL,""zsm_mlt"");\n    if ( out==ZMNULL || out->m != matrix->m || out->n != matrix->n )\n	out = zm_resize(out,matrix->m,matrix->n);\n    m = matrix->m;	n = matrix->n;\n    for ( i=0; i<m; i++ )\n	__zmlt__(matrix->me[i],scalar,out->me[i],(int)n);\n    /**************************************************\n      for ( j=0; j<n; j++ )\n      out->me[i][j] = scalar*matrix->me[i][j];\n      **************************************************/\n    return (out);\n}\n\n/* zvm_mlt -- vector adjoint-matrix multiplication */\nZVEC	*zvm_mlt(A,b,out)\nZMAT	*A;\nZVEC	*b,*out;\n{\n    unsigned int	j,m,n;\n    /* complex	sum,**A_v,*b_v; */\n    \n    if ( A==ZMNULL || b==ZVNULL )\n	error(E_NULL,""zvm_mlt"");\n    if ( A->m != b->dim )\n	error(E_SIZES,""zvm_mlt"");\n    if ( b == out )\n	error(E_INSITU,""zvm_mlt"");\n    if ( out == ZVNULL || out->dim != A->n )\n	out = zv_resize(out,A->n);\n    \n    m = A->m;		n = A->n;\n    \n    zv_zero(out);\n    for ( j = 0; j < m; j++ )\n	if ( b->ve[j].re != 0.0 || b->ve[j].im != 0.0  )\n	    __zmltadd__(out->ve,A->me[j],b->ve[j],(int)n,Z_CONJ);\n    /**************************************************\n      A_v = A->me;		b_v = b->ve;\n      for ( j=0; j<n; j++ )\n      {\n      sum = 0.0;\n      for ( i=0; i<m; i++ )\n      sum += b_v[i]*A_v[i][j];\n      out->ve[j] = sum;\n      }\n      **************************************************/\n    \n    return out;\n}\n\n/* zm_adjoint -- adjoint matrix */\nZMAT	*zm_adjoint(in,out)\nZMAT	*in, *out;\n{\n    int	i, j;\n    int	in_situ;\n    complex	tmp;\n    \n    if ( in == ZMNULL )\n	error(E_NULL,""zm_adjoint"");\n    if ( in == out && in->n != in->m )\n	error(E_INSITU2,""zm_adjoint"");\n    in_situ = ( in == out );\n    if ( out == ZMNULL || out->m != in->n || out->n != in->m )\n	out = zm_resize(out,in->n,in->m);\n    \n    if ( ! in_situ )\n    {\n	for ( i = 0; i < in->m; i++ )\n	    for ( j = 0; j < in->n; j++ )\n	    {\n		out->me[j][i].re =   in->me[i][j].re;\n		out->me[j][i].im = - in->me[i][j].im;\n	    }\n    }\n    else\n    {\n	for ( i = 0 ; i < in->m; i++ )\n	{\n	    for ( j = 0; j < i; j++ )\n	    {\n		tmp.re = in->me[i][j].re;\n		tmp.im = in->me[i][j].im;\n		in->me[i][j].re =   in->me[j][i].re;\n		in->me[i][j].im = - in->me[j][i].im;\n		in->me[j][i].re =   tmp.re;\n		in->me[j][i].im = - tmp.im;\n	    }\n	    in->me[i][i].im = - in->me[i][i].im;\n	}\n    }\n    \n    return out;\n}\n\n/* zswap_rows -- swaps rows i and j of matrix A upto column lim */\nZMAT	*zswap_rows(A,i,j,lo,hi)\nZMAT	*A;\nint	i, j, lo, hi;\n{\n    int	k;\n    complex	**A_me, tmp;\n    \n    if ( ! A )\n	error(E_NULL,""swap_rows"");\n    if ( i < 0 || j < 0 || i >= A->m || j >= A->m )\n	error(E_SIZES,""swap_rows"");\n    lo = max(0,lo);\n    hi = min(hi,A->n-1);\n    A_me = A->me;\n    \n    for ( k = lo; k <= hi; k++ )\n    {\n	tmp = A_me[k][i];\n	A_me[k][i] = A_me[k][j];\n	A_me[k][j] = tmp;\n    }\n    return A;\n}\n\n/* zswap_cols -- swap columns i and j of matrix A upto row lim */\nZMAT	*zswap_cols(A,i,j,lo,hi)\nZMAT	*A;\nint	i, j, lo, hi;\n{\n    int	k;\n    complex	**A_me, tmp;\n    \n    if ( ! A )\n	error(E_NULL,""swap_cols"");\n    if ( i < 0 || j < 0 || i >= A->n || j >= A->n )\n	error(E_SIZES,""swap_cols"");\n    lo = max(0,lo);\n    hi = min(hi,A->m-1);\n    A_me = A->me;\n    \n    for ( k = lo; k <= hi; k++ )\n    {\n	tmp = A_me[i][k];\n	A_me[i][k] = A_me[j][k];\n	A_me[j][k] = tmp;\n    }\n    return A;\n}\n\n/* mz_mltadd -- matrix-scalar multiply and add\n   -- may be in situ\n   -- returns out == A1 + s*A2 */\nZMAT	*mz_mltadd(A1,A2,s,out)\nZMAT	*A1, *A2, *out;\ncomplex	s;\n{\n    /* register complex	*A1_e, *A2_e, *out_e; */\n    /* register int	j; */\n    int	i, m, n;\n    \n    if ( ! A1 || ! A2 )\n	error(E_NULL,""mz_mltadd"");\n    if ( A1->m != A2->m || A1->n != A2->n )\n	error(E_SIZES,""mz_mltadd"");\n\n    if ( out != A1 && out != A2 )\n        out = zm_resize(out,A1->m,A1->n);\n    \n    if ( s.re == 0.0 && s.im == 0.0 )\n	return zm_copy(A1,out);\n    if ( s.re == 1.0 && s.im == 0.0 )\n	return zm_add(A1,A2,out);\n    \n    out = zm_copy(A1,out);\n    \n    m = A1->m;	n = A1->n;\n    for ( i = 0; i < m; i++ )\n    {\n	__zmltadd__(out->me[i],A2->me[i],s,(int)n,Z_NOCONJ);\n	/**************************************************\n	  A1_e = A1->me[i];\n	  A2_e = A2->me[i];\n	  out_e = out->me[i];\n	  for ( j = 0; j < n; j++ )\n	  out_e[j] = A1_e[j] + s*A2_e[j];\n	  **************************************************/\n    }\n    \n    return out;\n}\n\n/* zmv_mltadd -- matrix-vector multiply and add\n   -- may not be in situ\n   -- returns out == v1 + alpha*A*v2 */\nZVEC	*zmv_mltadd(v1,v2,A,alpha,out)\nZVEC	*v1, *v2, *out;\nZMAT	*A;\ncomplex	alpha;\n{\n    /* register	int	j; */\n    int	i, m, n;\n    complex	tmp, *v2_ve, *out_ve;\n    \n    if ( ! v1 || ! v2 || ! A )\n	error(E_NULL,""zmv_mltadd"");\n    if ( out == v2 )\n	error(E_INSITU,""zmv_mltadd"");\n    if ( v1->dim != A->m || v2->dim != A-> n )\n	error(E_SIZES,""zmv_mltadd"");\n    \n    tracecatch(out = zv_copy(v1,out),""zmv_mltadd"");\n    \n    v2_ve = v2->ve;	out_ve = out->ve;\n    m = A->m;	n = A->n;\n    \n    if ( alpha.re == 0.0 && alpha.im == 0.0 )\n	return out;\n    \n    for ( i = 0; i < m; i++ )\n    {\n	tmp = __zip__(A->me[i],v2_ve,(int)n,Z_NOCONJ);\n	out_ve[i].re += alpha.re*tmp.re - alpha.im*tmp.im;\n	out_ve[i].im += alpha.re*tmp.im + alpha.im*tmp.re;\n	/**************************************************\n	  A_e = A->me[i];\n	  sum = 0.0;\n	  for ( j = 0; j < n; j++ )\n	  sum += A_e[j]*v2_ve[j];\n	  out_ve[i] = v1->ve[i] + alpha*sum;\n	  **************************************************/\n    }\n    \n    return out;\n}\n\n/* zvm_mltadd -- vector-matrix multiply and add a la zvm_mlt()\n   -- may not be in situ\n   -- returns out == v1 + v2*.A */\nZVEC	*zvm_mltadd(v1,v2,A,alpha,out)\nZVEC	*v1, *v2, *out;\nZMAT	*A;\ncomplex	alpha;\n{\n    int	/* i, */ j, m, n;\n    complex	tmp, /* *A_e, */ *out_ve;\n    \n    if ( ! v1 || ! v2 || ! A )\n	error(E_NULL,""zvm_mltadd"");\n    if ( v2 == out )\n	error(E_INSITU,""zvm_mltadd"");\n    if ( v1->dim != A->n || A->m != v2->dim )\n	error(E_SIZES,""zvm_mltadd"");\n    \n    tracecatch(out = zv_copy(v1,out),""zvm_mltadd"");\n    \n    out_ve = out->ve;	m = A->m;	n = A->n;\n    for ( j = 0; j < m; j++ )\n    {\n	/* tmp = zmlt(v2->ve[j],alpha); */\n	tmp.re =   v2->ve[j].re*alpha.re - v2->ve[j].im*alpha.im;\n	tmp.im =   v2->ve[j].re*alpha.im + v2->ve[j].im*alpha.re;\n	if ( tmp.re != 0.0 || tmp.im != 0.0 )\n	    __zmltadd__(out_ve,A->me[j],tmp,(int)n,Z_CONJ);\n	/**************************************************\n	  A_e = A->me[j];\n	  for ( i = 0; i < n; i++ )\n	  out_ve[i] += A_e[i]*tmp;\n	**************************************************/\n    }\n    \n    return out;\n}\n\n/* zget_col -- gets a specified column of a matrix; returned as a vector */\nZVEC	*zget_col(mat,col,vec)\nint	col;\nZMAT	*mat;\nZVEC	*vec;\n{\n	unsigned int	i;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,""zget_col"");\n	if ( col < 0 || col >= mat->n )\n		error(E_RANGE,""zget_col"");\n	if ( vec==ZVNULL || vec->dim<mat->m )\n		vec = zv_resize(vec,mat->m);\n\n	for ( i=0; i<mat->m; i++ )\n	    vec->ve[i] = mat->me[i][col];\n\n	return (vec);\n}\n\n/* zget_row -- gets a specified row of a matrix and retruns it as a vector */\nZVEC	*zget_row(mat,row,vec)\nint	row;\nZMAT	*mat;\nZVEC	*vec;\n{\n	int	/* i, */ lim;\n\n	if ( mat==ZMNULL )\n		error(E_NULL,""zget_row"");\n	if ( row < 0 || row >= mat->m )\n		error(E_RANGE,""zget_row"");\n	if ( vec==ZVNULL || vec->dim<mat->n )\n		vec = zv_resize(vec,mat->n);\n\n	lim = min(mat->n,vec->dim);\n\n	/* for ( i=0; i<mat->n; i++ ) */\n	/*     vec->ve[i] = mat->me[row][i]; */\n	MEMCOPY(mat->me[row],vec->ve,lim,complex);\n\n	return (vec);\n}\n\n/* zset_col -- sets column of matrix to values given in vec (in situ) */\nZMAT	*zset_col(mat,col,vec)\nZMAT	*mat;\nZVEC	*vec;\nint	col;\n{\n	unsigned int	i,lim;\n\n	if ( mat==ZMNULL || vec==ZVNULL )\n		error(E_NULL,""zset_col"");\n	if ( col < 0 || col >= mat->n )\n		error(E_RANGE,""zset_col"");\n	lim = min(mat->m,vec->dim);\n	for ( i=0; i<lim; i++ )\n	    mat->me[i][col] = vec->ve[i];\n\n	return (mat);\n}\n\n/* zset_row -- sets row of matrix to values given in vec (in situ) */\nZMAT	*zset_row(mat,row,vec)\nZMAT	*mat;\nZVEC	*vec;\nint	row;\n{\n	unsigned int	/* j, */ lim;\n\n	if ( mat==ZMNULL || vec==ZVNULL )\n		error(E_NULL,""zset_row"");\n	if ( row < 0 || row >= mat->m )\n		error(E_RANGE,""zset_row"");\n	lim = min(mat->n,vec->dim);\n	/* for ( j=j0; j<lim; j++ ) */\n	/*     mat->me[row][j] = vec->ve[j]; */\n	MEMCOPY(vec->ve,mat->me[row],lim,complex);\n\n	return (mat);\n}\n\n/* zm_rand -- randomise a complex matrix; uniform in [0,1)+[0,1)*i */\nZMAT	*zm_rand(A)\nZMAT	*A;\n{\n    int		i;\n\n    if ( ! A )\n	error(E_NULL,""zm_rand"");\n\n    for ( i = 0; i < A->m; i++ )\n	mrandlist((Real *)(A->me[i]),2*A->n);\n\n    return A;\n}\n"
leukocyte/meschach_lib/zmatlab.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains routines for import/exporting complex data\n	to/from MATLAB. The main routines are:\n			ZMAT *zm_save(FILE *fp,ZMAT *A,char *name)\n			ZVEC *zv_save(FILE *fp,ZVEC *x,char *name)\n			complex z_save(FILE *fp,complex z,char *name)\n			ZMAT *zm_load(FILE *fp,char **name)\n*/\n\n#include        <stdio.h>\n#include        ""zmatrix.h""\n#include	""matlab.h""\n\nstatic char rcsid[] = ""$Id: zmatlab.c,v 1.2 1995/02/14 20:13:27 des Exp $"";\n\n/* zm_save -- save matrix in "".mat"" file for MATLAB\n   -- returns matrix to be saved */\nZMAT    *zm_save(fp,A,name)\nFILE    *fp;\nZMAT    *A;\nchar    *name;\n{\n    int     i, j;\n    matlab  mat;\n    \n    if ( ! A )\n	error(E_NULL,""zm_save"");\n    \n    mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n    mat.m = A->m;\n    mat.n = A->n;\n    mat.imag = TRUE;\n    mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n    \n    /* write header */\n    fwrite(&mat,sizeof(matlab),1,fp);\n    /* write name */\n    if ( name == (char *)NULL )\n	fwrite("""",sizeof(char),1,fp);\n    else\n	fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n    /* write actual data */\n#if ORDER == ROW_ORDER\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < A->n; j++ )\n	    fwrite(&(A->me[i][j].re),sizeof(Real),1,fp);\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < A->n; j++ )\n	    fwrite(&(A->me[i][j].im),sizeof(Real),1,fp);\n#else /* column major order: ORDER == COL_ORDER */\n    for ( j = 0; j < A->n; j++ )\n	for ( i = 0; i < A->m; i++ )\n	    fwrite(&(A->me[i][j].re),sizeof(Real),1,fp);\n    for ( j = 0; j < A->n; j++ )\n	for ( i = 0; i < A->m; i++ )\n	    fwrite(&(A->me[i][j].im),sizeof(Real),1,fp);\n#endif\n    \n    return A;\n}\n\n\n/* zv_save -- save vector in "".mat"" file for MATLAB\n   -- saves it as a row vector\n   -- returns vector to be saved */\nZVEC    *zv_save(fp,x,name)\nFILE    *fp;\nZVEC    *x;\nchar    *name;\n{\n    int	i, j;\n    matlab  mat;\n    \n    if ( ! x )\n	error(E_NULL,""zv_save"");\n    \n    mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n    mat.m = x->dim;\n    mat.n = 1;\n    mat.imag = TRUE;\n    mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n    \n    /* write header */\n    fwrite(&mat,sizeof(matlab),1,fp);\n    /* write name */\n    if ( name == (char *)NULL )\n	fwrite("""",sizeof(char),1,fp);\n    else\n	fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n    /* write actual data */\n    for ( i = 0; i < x->dim; i++ )\n	fwrite(&(x->ve[i].re),sizeof(Real),1,fp);\n    for ( i = 0; i < x->dim; i++ )\n	fwrite(&(x->ve[i].im),sizeof(Real),1,fp);\n    \n    return x;\n}\n\n/* z_save -- saves complex number in "".mat"" file for MATLAB\n	-- returns complex number to be saved */\ncomplex	z_save(fp,z,name)\nFILE	*fp;\ncomplex	z;\nchar	*name;\n{\n    matlab  mat;\n    \n    mat.type = 1000*MACH_ID + 100*ORDER + 10*PRECISION + 0;\n    mat.m = 1;\n    mat.n = 1;\n    mat.imag = TRUE;\n    mat.namlen = (name == (char *)NULL) ? 1 : strlen(name)+1;\n    \n    /* write header */\n    fwrite(&mat,sizeof(matlab),1,fp);\n    /* write name */\n    if ( name == (char *)NULL )\n	fwrite("""",sizeof(char),1,fp);\n    else\n	fwrite(name,sizeof(char),(int)(mat.namlen),fp);\n    /* write actual data */\n    fwrite(&z,sizeof(complex),1,fp);\n    \n    return z;\n}\n\n\n\n/* zm_load -- loads in a "".mat"" file variable as produced by MATLAB\n   -- matrix returned; imaginary parts ignored */\nZMAT    *zm_load(fp,name)\nFILE    *fp;\nchar    **name;\n{\n    ZMAT     *A;\n    int     i;\n    int     m_flag, o_flag, p_flag, t_flag;\n    float   f_temp;\n    double  d_temp;\n    matlab  mat;\n    \n    if ( fread(&mat,sizeof(matlab),1,fp) != 1 )\n	error(E_FORMAT,""zm_load"");\n    if ( mat.type >= 10000 )	/* don't load a sparse matrix! */\n	error(E_FORMAT,""zm_load"");\n    m_flag = (mat.type/1000) % 10;\n    o_flag = (mat.type/100) % 10;\n    p_flag = (mat.type/10) % 10;\n    t_flag = (mat.type) % 10;\n    if ( m_flag != MACH_ID )\n	error(E_FORMAT,""zm_load"");\n    if ( t_flag != 0 )\n	error(E_FORMAT,""zm_load"");\n    if ( p_flag != DOUBLE_PREC && p_flag != SINGLE_PREC )\n	error(E_FORMAT,""zm_load"");\n    *name = (char *)malloc((unsigned)(mat.namlen)+1);\n    if ( fread(*name,sizeof(char),(unsigned)(mat.namlen),fp) == 0 )\n	error(E_FORMAT,""zm_load"");\n    A = zm_get((unsigned)(mat.m),(unsigned)(mat.n));\n    for ( i = 0; i < A->m*A->n; i++ )\n    {\n	if ( p_flag == DOUBLE_PREC )\n	    fread(&d_temp,sizeof(double),1,fp);\n	else\n	{\n	    fread(&f_temp,sizeof(float),1,fp);\n	    d_temp = f_temp;\n	}\n	if ( o_flag == ROW_ORDER )\n	    A->me[i / A->n][i % A->n].re = d_temp;\n	else if ( o_flag == COL_ORDER )\n	    A->me[i % A->m][i / A->m].re = d_temp;\n	else\n	    error(E_FORMAT,""zm_load"");\n    }\n    \n    if ( mat.imag )         /* skip imaginary part */\n	for ( i = 0; i < A->m*A->n; i++ )\n	{\n	    if ( p_flag == DOUBLE_PREC )\n		fread(&d_temp,sizeof(double),1,fp);\n	    else\n	    {\n		fread(&f_temp,sizeof(float),1,fp);\n		d_temp = f_temp;\n	    }\n	    if ( o_flag == ROW_ORDER )\n		A->me[i / A->n][i % A->n].im = d_temp;\n	    else if ( o_flag == COL_ORDER )\n		A->me[i % A->m][i / A->m].im = d_temp;\n	    else\n		error(E_FORMAT,""zm_load"");\n	}\n    \n    return A;\n}\n\n"
leukocyte/meschach_lib/zcopy.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\nstatic	char	rcsid[] = ""$Id: zcopy.c,v 1.1 1994/01/13 04:28:42 des Exp $"";\n#include	<stdio.h>\n#include	""zmatrix.h""\n\n\n\n/* _zm_copy -- copies matrix into new area */\n#ifndef ANSI_C\nZMAT	*_zm_copy(in,out,i0,j0)\nZMAT	*in,*out;\nunsigned int	i0,j0;\n#else\nZMAT	*_zm_copy(const ZMAT *in, ZMAT *out, int i0, int j0)\n#endif\n{\n	unsigned int	i /* ,j */;\n\n	if ( in==ZMNULL )\n		error(E_NULL,""_zm_copy"");\n	if ( in==out )\n		return (out);\n	if ( out==ZMNULL || out->m < in->m || out->n < in->n )\n		out = zm_resize(out,in->m,in->n);\n\n	for ( i=i0; i < in->m; i++ )\n		MEM_COPY(&(in->me[i][j0]),&(out->me[i][j0]),\n				(in->n - j0)*sizeof(complex));\n		/* for ( j=j0; j < in->n; j++ )\n			out->me[i][j] = in->me[i][j]; */\n\n	return (out);\n}\n\n/* _zv_copy -- copies vector into new area */\n#ifndef ANSI_C\nZVEC	*_zv_copy(in,out,i0)\nZVEC	*in,*out;\nunsigned int	i0;\n#else\nZVEC	*_zv_copy(const ZVEC *in, ZVEC *out, int i0)\n#endif\n{\n	/* unsigned int	i,j; */\n\n	if ( in==ZVNULL )\n		error(E_NULL,""_zv_copy"");\n	if ( in==out )\n		return (out);\n	if ( out==ZVNULL || out->dim < in->dim )\n		out = zv_resize(out,in->dim);\n\n	MEM_COPY(&(in->ve[i0]),&(out->ve[i0]),(in->dim - i0)*sizeof(complex));\n	/* for ( i=i0; i < in->dim; i++ )\n		out->ve[i] = in->ve[i]; */\n\n	return (out);\n}\n\n\n/*\n	The z._move() routines are for moving blocks of memory around\n	within Meschach data structures and for re-arranging matrices,\n	vectors etc.\n*/\n\n/* zm_move -- copies selected pieces of a matrix\n	-- moves the m0 x n0 submatrix with top-left cor-ordinates (i0,j0)\n	   to the corresponding submatrix of out with top-left co-ordinates\n	   (i1,j1)\n	-- out is resized (& created) if necessary */\n#ifndef ANSI_C\nZMAT	*zm_move(in,i0,j0,m0,n0,out,i1,j1)\nZMAT	*in, *out;\nint	i0, j0, m0, n0, i1, j1;\n#else\nZMAT	*zm_move(const ZMAT *in, int i0, int j0, int m0, int n0,\n		 ZMAT *out, int i1, int j1)\n#endif\n{\n    int		i;\n\n    if ( ! in )\n	error(E_NULL,""zm_move"");\n    if ( i0 < 0 || j0 < 0 || i1 < 0 || j1 < 0 || m0 < 0 || n0 < 0 ||\n	 i0+m0 > in->m || j0+n0 > in->n )\n	error(E_BOUNDS,""zm_move"");\n\n    if ( ! out )\n	out = zm_resize(out,i1+m0,j1+n0);\n    else if ( i1+m0 > out->m || j1+n0 > out->n )\n	out = zm_resize(out,max(out->m,i1+m0),max(out->n,j1+n0));\n\n    for ( i = 0; i < m0; i++ )\n	MEM_COPY(&(in->me[i0+i][j0]),&(out->me[i1+i][j1]),\n		 n0*sizeof(complex));\n\n    return out;\n}\n\n/* zv_move -- copies selected pieces of a vector\n	-- moves the length dim0 subvector with initial index i0\n	   to the corresponding subvector of out with initial index i1\n	-- out is resized if necessary */\n#ifndef ANSI_C\nZVEC	*zv_move(in,i0,dim0,out,i1)\nZVEC	*in, *out;\nint	i0, dim0, i1;\n#else\nZVEC	*zv_move(const ZVEC *in, int i0, int dim0,\n		 ZVEC *out, int i1)\n#endif\n{\n    if ( ! in )\n	error(E_NULL,""zv_move"");\n    if ( i0 < 0 || dim0 < 0 || i1 < 0 ||\n	 i0+dim0 > in->dim )\n	error(E_BOUNDS,""zv_move"");\n\n    if ( (! out) || i1+dim0 > out->dim )\n	out = zv_resize(out,i1+dim0);\n\n    MEM_COPY(&(in->ve[i0]),&(out->ve[i1]),dim0*sizeof(complex));\n\n    return out;\n}\n\n\n/* zmv_move -- copies selected piece of matrix to a vector\n	-- moves the m0 x n0 submatrix with top-left co-ordinate (i0,j0) to\n	   the subvector with initial index i1 (and length m0*n0)\n	-- rows are copied contiguously\n	-- out is resized if necessary */\n#ifndef ANSI_C\nZVEC	*zmv_move(in,i0,j0,m0,n0,out,i1)\nZMAT	*in;\nZVEC	*out;\nint	i0, j0, m0, n0, i1;\n#else\nZVEC	*zmv_move(const ZMAT *in, int i0, int j0, int m0, int n0,\n		  ZVEC *out, int i1)\n#endif\n{\n    int		dim1, i;\n\n    if ( ! in )\n	error(E_NULL,""zmv_move"");\n    if ( i0 < 0 || j0 < 0 || m0 < 0 || n0 < 0 || i1 < 0 ||\n	 i0+m0 > in->m || j0+n0 > in->n )\n	error(E_BOUNDS,""zmv_move"");\n\n    dim1 = m0*n0;\n    if ( (! out) || i1+dim1 > out->dim )\n	out = zv_resize(out,i1+dim1);\n\n    for ( i = 0; i < m0; i++ )\n	MEM_COPY(&(in->me[i0+i][j0]),&(out->ve[i1+i*n0]),n0*sizeof(complex));\n\n    return out;\n}\n\n/* zvm_move -- copies selected piece of vector to a matrix\n	-- moves the subvector with initial index i0 and length m1*n1 to\n	   the m1 x n1 submatrix with top-left co-ordinate (i1,j1)\n        -- copying is done by rows\n	-- out is resized if necessary */\n#ifndef ANSI_C\nZMAT	*zvm_move(in,i0,out,i1,j1,m1,n1)\nZVEC	*in;\nZMAT	*out;\nint	i0, i1, j1, m1, n1;\n#else\nZMAT	*zvm_move(const ZVEC *in, int i0,\n		  ZMAT *out, int i1, int j1, int m1, int n1)\n#endif\n{\n    int		dim0, i;\n\n    if ( ! in )\n	error(E_NULL,""zvm_move"");\n    if ( i0 < 0 || i1 < 0 || j1 < 0 || m1 < 0 || n1 < 0 ||\n	 i0+m1*n1 > in->dim )\n	error(E_BOUNDS,""zvm_move"");\n\n    if ( ! out )\n	out = zm_resize(out,i1+m1,j1+n1);\n    else\n	out = zm_resize(out,max(i1+m1,out->m),max(j1+n1,out->n));\n\n    dim0 = m1*n1;\n    for ( i = 0; i < m1; i++ )\n	MEM_COPY(&(in->ve[i0+i*n1]),&(out->me[i1+i][j1]),n1*sizeof(complex));\n\n    return out;\n}\n"
leukocyte/meschach_lib/zsolve.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n	Complex case\n*/\n\nstatic	char	rcsid[] = ""$Id: zsolve.c,v 1.1 1994/01/13 04:20:33 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""zmatrix2.h""\n\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0 )\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* zUsolve -- back substitution with optional over-riding diagonal\n		-- can be in-situ but doesn't need to be */\nZVEC	*zUsolve(matrix,b,out,diag)\nZMAT	*matrix;\nZVEC	*b, *out;\ndouble	diag;\n{\n    unsigned int	dim /* , j */;\n    int	i, i_lim;\n    complex	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum;\n    \n    if ( matrix==ZMNULL || b==ZVNULL )\n	error(E_NULL,""zUsolve"");\n    dim = min(matrix->m,matrix->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""zUsolve"");\n    if ( out==ZVNULL || out->dim < dim )\n	out = zv_resize(out,matrix->n);\n    mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n    \n    for ( i=dim-1; i>=0; i-- )\n	if ( ! is_zero(b_ent[i]) )\n	    break;\n	else\n	    out_ent[i].re = out_ent[i].im = 0.0;\n    i_lim = i;\n    \n    for ( i = i_lim; i>=0; i-- )\n    {\n	sum = b_ent[i];\n	mat_row = &(mat_ent[i][i+1]);\n	out_col = &(out_ent[i+1]);\n	sum = zsub(sum,__zip__(mat_row,out_col,i_lim-i,Z_NOCONJ));\n	/******************************************************\n	  for ( j=i+1; j<=i_lim; j++ )\n	  sum -= mat_ent[i][j]*out_ent[j];\n	  sum -= (*mat_row++)*(*out_col++);\n	******************************************************/\n	if ( diag == 0.0 )\n	{\n	    if ( is_zero(mat_ent[i][i]) )\n		error(E_SING,""zUsolve"");\n	    else\n		/* out_ent[i] = sum/mat_ent[i][i]; */\n		out_ent[i] = zdiv(sum,mat_ent[i][i]);\n	}\n	else\n	{\n	    /* out_ent[i] = sum/diag; */\n	    out_ent[i].re = sum.re / diag;\n	    out_ent[i].im = sum.im / diag;\n	}\n    }\n    \n    return (out);\n}\n\n/* zLsolve -- forward elimination with (optional) default diagonal value */\nZVEC	*zLsolve(matrix,b,out,diag)\nZMAT	*matrix;\nZVEC	*b,*out;\ndouble	diag;\n{\n    unsigned int	dim, i, i_lim /* , j */;\n    complex	**mat_ent, *mat_row, *b_ent, *out_ent, *out_col, sum;\n    \n    if ( matrix==ZMNULL || b==ZVNULL )\n	error(E_NULL,""zLsolve"");\n    dim = min(matrix->m,matrix->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""zLsolve"");\n    if ( out==ZVNULL || out->dim < dim )\n	out = zv_resize(out,matrix->n);\n    mat_ent = matrix->me;	b_ent = b->ve;	out_ent = out->ve;\n    \n    for ( i=0; i<dim; i++ )\n	if ( ! is_zero(b_ent[i]) )\n	    break;\n	else\n	    out_ent[i].re = out_ent[i].im = 0.0;\n    i_lim = i;\n    \n    for ( i = i_lim; i<dim; i++ )\n    {\n	sum = b_ent[i];\n	mat_row = &(mat_ent[i][i_lim]);\n	out_col = &(out_ent[i_lim]);\n	sum = zsub(sum,__zip__(mat_row,out_col,(int)(i-i_lim),Z_NOCONJ));\n	/*****************************************************\n	  for ( j=i_lim; j<i; j++ )\n	  sum -= mat_ent[i][j]*out_ent[j];\n	  sum -= (*mat_row++)*(*out_col++);\n	******************************************************/\n	if ( diag == 0.0 )\n	{\n	    if ( is_zero(mat_ent[i][i]) )\n		error(E_SING,""zLsolve"");\n	    else\n		out_ent[i] = zdiv(sum,mat_ent[i][i]);\n	}\n	else\n	{\n	    out_ent[i].re = sum.re / diag;\n	    out_ent[i].im = sum.im / diag;\n	}\n    }\n    \n    return (out);\n}\n\n\n/* zUAsolve -- forward elimination with (optional) default diagonal value\n		using UPPER triangular part of matrix */\nZVEC	*zUAsolve(U,b,out,diag)\nZMAT	*U;\nZVEC	*b,*out;\ndouble	diag;\n{\n    unsigned int	dim, i, i_lim /* , j */;\n    complex	**U_me, *b_ve, *out_ve, tmp;\n    Real	invdiag;\n    \n    if ( ! U || ! b )\n	error(E_NULL,""zUAsolve"");\n    dim = min(U->m,U->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""zUAsolve"");\n    out = zv_resize(out,U->n);\n    U_me = U->me;	b_ve = b->ve;	out_ve = out->ve;\n    \n    for ( i=0; i<dim; i++ )\n	if ( ! is_zero(b_ve[i]) )\n	    break;\n	else\n	    out_ve[i].re = out_ve[i].im = 0.0;\n    i_lim = i;\n    if ( b != out )\n    {\n	__zzero__(out_ve,out->dim);\n	/* MEM_COPY(&(b_ve[i_lim]),&(out_ve[i_lim]),\n	   (dim-i_lim)*sizeof(complex)); */\n	MEMCOPY(&(b_ve[i_lim]),&(out_ve[i_lim]),dim-i_lim,complex);\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (    ; i<dim; i++ )\n	{\n	    tmp = zconj(U_me[i][i]);\n	    if ( is_zero(tmp) )\n		error(E_SING,""zUAsolve"");\n	    /* out_ve[i] /= tmp; */\n	    out_ve[i] = zdiv(out_ve[i],tmp);\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),tmp,dim-i-1,Z_CONJ);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (    ; i<dim; i++ )\n	{\n	    out_ve[i].re *= invdiag;\n	    out_ve[i].im *= invdiag;\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(&(out_ve[i+1]),&(U_me[i][i+1]),tmp,dim-i-1,Z_CONJ);\n	}\n    }\n    return (out);\n}\n\n/* zDsolve -- solves Dx=b where D is the diagonal of A -- may be in-situ */\nZVEC	*zDsolve(A,b,x)\nZMAT	*A;\nZVEC	*b,*x;\n{\n    unsigned int	dim, i;\n    \n    if ( ! A || ! b )\n	error(E_NULL,""zDsolve"");\n    dim = min(A->m,A->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""zDsolve"");\n    x = zv_resize(x,A->n);\n    \n    dim = b->dim;\n    for ( i=0; i<dim; i++ )\n	if ( is_zero(A->me[i][i]) )\n	    error(E_SING,""zDsolve"");\n	else\n	    x->ve[i] = zdiv(b->ve[i],A->me[i][i]);\n    \n    return (x);\n}\n\n/* zLAsolve -- back substitution with optional over-riding diagonal\n		using the LOWER triangular part of matrix\n		-- can be in-situ but doesn't need to be */\nZVEC	*zLAsolve(L,b,out,diag)\nZMAT	*L;\nZVEC	*b, *out;\ndouble	diag;\n{\n    unsigned int	dim;\n    int		i, i_lim;\n    complex	**L_me, *b_ve, *out_ve, tmp;\n    Real	invdiag;\n    \n    if ( ! L || ! b )\n	error(E_NULL,""zLAsolve"");\n    dim = min(L->m,L->n);\n    if ( b->dim < dim )\n	error(E_SIZES,""zLAsolve"");\n    out = zv_resize(out,L->n);\n    L_me = L->me;	b_ve = b->ve;	out_ve = out->ve;\n    \n    for ( i=dim-1; i>=0; i-- )\n	if ( ! is_zero(b_ve[i]) )\n	    break;\n    i_lim = i;\n\n    if ( b != out )\n    {\n	__zzero__(out_ve,out->dim);\n	/* MEM_COPY(b_ve,out_ve,(i_lim+1)*sizeof(complex)); */\n	MEMCOPY(b_ve,out_ve,i_lim+1,complex);\n    }\n\n    if ( diag == 0.0 )\n    {\n	for (        ; i>=0; i-- )\n	{\n	    tmp = zconj(L_me[i][i]);\n	    if ( is_zero(tmp) )\n		error(E_SING,""zLAsolve"");\n	    out_ve[i] = zdiv(out_ve[i],tmp);\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(out_ve,L_me[i],tmp,i,Z_CONJ);\n	}\n    }\n    else\n    {\n	invdiag = 1.0/diag;\n	for (        ; i>=0; i-- )\n	{\n	    out_ve[i].re *= invdiag;\n	    out_ve[i].im *= invdiag;\n	    tmp.re = - out_ve[i].re;\n	    tmp.im = - out_ve[i].im;\n	    __zmltadd__(out_ve,L_me[i],tmp,i,Z_CONJ);\n	}\n    }\n    \n    return (out);\n}\n"
leukocyte/meschach_lib/bkpfacto.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\nstatic	char	rcsid[] = ""$Id: bkpfacto.c,v 1.7 1994/01/13 05:45:50 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n#define	btos(x)	((x) ? ""TRUE"" : ""FALSE"")\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n#define alpha	0.6403882032022076 /* = (1+sqrt(17))/8 */\n\n/* sqr -- returns square of x -- utility function */\ndouble	sqr(x)\ndouble	x;\n{	return x*x;	}\n\n/* interchange -- a row/column swap routine */\nstatic void interchange(A,i,j)\nMAT	*A;	/* assumed != NULL & also SQUARE */\nint	i, j;	/* assumed in range */\n{\n	Real	**A_me, tmp;\n	int	k, n;\n\n	A_me = A->me;	n = A->n;\n	if ( i == j )\n		return;\n	if ( i > j )\n	{	k = i;	i = j;	j = k;	}\n	for ( k = 0; k < i; k++ )\n	{\n		/* tmp = A_me[k][i]; */\n		tmp = m_entry(A,k,i);\n		/* A_me[k][i] = A_me[k][j]; */\n		m_set_val(A,k,i,m_entry(A,k,j));\n		/* A_me[k][j] = tmp; */\n		m_set_val(A,k,j,tmp);\n	}\n	for ( k = j+1; k < n; k++ )\n	{\n		/* tmp = A_me[j][k]; */\n		tmp = m_entry(A,j,k);\n		/* A_me[j][k] = A_me[i][k]; */\n		m_set_val(A,j,k,m_entry(A,i,k));\n		/* A_me[i][k] = tmp; */\n		m_set_val(A,i,k,tmp);\n	}\n	for ( k = i+1; k < j; k++ )\n	{\n		/* tmp = A_me[k][j]; */\n		tmp = m_entry(A,k,j);\n		/* A_me[k][j] = A_me[i][k]; */\n		m_set_val(A,k,j,m_entry(A,i,k));\n		/* A_me[i][k] = tmp; */\n		m_set_val(A,i,k,tmp);\n	}\n	/* tmp = A_me[i][i]; */\n	tmp = m_entry(A,i,i);\n	/* A_me[i][i] = A_me[j][j]; */\n	m_set_val(A,i,i,m_entry(A,j,j));\n	/* A_me[j][j] = tmp; */\n	m_set_val(A,j,j,tmp);\n}\n\n/* BKPfactor -- Bunch-Kaufman-Parlett factorisation of A in-situ\n	-- A is factored into the form P'AP = MDM' where \n	P is a permutation matrix, M lower triangular and D is block\n	diagonal with blocks of size 1 or 2\n	-- P is stored in pivot; blocks[i]==i iff D[i][i] is a block */\n#ifndef ANSI_C\nMAT	*BKPfactor(A,pivot,blocks)\nMAT	*A;\nPERM	*pivot, *blocks;\n#else\nMAT	*BKPfactor(MAT *A, PERM *pivot, PERM *blocks)\n#endif\n{\n	int	i, j, k, n, onebyone, r;\n	Real	**A_me, aii, aip1, aip1i, lambda, sigma, tmp;\n	Real	det, s, t;\n\n	if ( ! A || ! pivot || ! blocks )\n		error(E_NULL,""BKPfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""BKPfactor"");\n	if ( A->m != pivot->size || pivot->size != blocks->size )\n		error(E_SIZES,""BKPfactor"");\n\n	n = A->n;\n	A_me = A->me;\n	px_ident(pivot);	px_ident(blocks);\n\n	for ( i = 0; i < n; i = onebyone ? i+1 : i+2 )\n	{\n		/* printf(""# Stage: %d\n"",i); */\n		aii = fabs(m_entry(A,i,i));\n		lambda = 0.0;	r = (i+1 < n) ? i+1 : i;\n		for ( k = i+1; k < n; k++ )\n		{\n		    tmp = fabs(m_entry(A,i,k));\n		    if ( tmp >= lambda )\n		    {\n			lambda = tmp;\n			r = k;\n		    }\n		}\n		/* printf(""# lambda = %g, r = %d\n"", lambda, r); */\n		/* printf(""# |A[%d][%d]| = %g\n"",r,r,fabs(m_entry(A,r,r))); */\n\n		/* determine if 1x1 or 2x2 block, and do pivoting if needed */\n		if ( aii >= alpha*lambda )\n		{\n		    onebyone = TRUE;\n		    goto dopivot;\n		}\n		/* compute sigma */\n		sigma = 0.0;\n		for ( k = i; k < n; k++ )\n		{\n		    if ( k == r )\n			continue;\n		    tmp = ( k > r ) ? fabs(m_entry(A,r,k)) :\n			fabs(m_entry(A,k,r));\n		    if ( tmp > sigma )\n			sigma = tmp;\n		}\n		if ( aii*sigma >= alpha*sqr(lambda) )\n		    onebyone = TRUE;\n		else if ( fabs(m_entry(A,r,r)) >= alpha*sigma )\n		{\n		    /* printf(""# Swapping rows/cols %d and %d\n"",i,r); */\n		    interchange(A,i,r);\n		    px_transp(pivot,i,r);\n		    onebyone = TRUE;\n		}\n		else\n		{\n		    /* printf(""# Swapping rows/cols %d and %d\n"",i+1,r); */\n		    interchange(A,i+1,r);\n		    px_transp(pivot,i+1,r);\n		    px_transp(blocks,i,i+1);\n		    onebyone = FALSE;\n		}\n		/* printf(""onebyone = %s\n"",btos(onebyone)); */\n		/* printf(""# Matrix so far (@checkpoint A) =\n""); */\n		/* m_output(A); */\n		/* printf(""# pivot =\n"");	px_output(pivot); */\n		/* printf(""# blocks =\n"");	px_output(blocks); */\n\ndopivot:\n		if ( onebyone )\n		{   /* do one by one block */\n		    if ( m_entry(A,i,i) != 0.0 )\n		    {\n			aii = m_entry(A,i,i);\n			for ( j = i+1; j < n; j++ )\n			{\n			    tmp = m_entry(A,i,j)/aii;\n			    for ( k = j; k < n; k++ )\n				m_sub_val(A,j,k,tmp*m_entry(A,i,k));\n			    m_set_val(A,i,j,tmp);\n			}\n		    }\n		}\n		else /* onebyone == FALSE */\n		{   /* do two by two block */\n		    det = m_entry(A,i,i)*m_entry(A,i+1,i+1)-sqr(m_entry(A,i,i+1));\n		    /* Must have det < 0 */\n		    /* printf(""# det = %g\n"",det); */\n		    aip1i = m_entry(A,i,i+1)/det;\n		    aii = m_entry(A,i,i)/det;\n		    aip1 = m_entry(A,i+1,i+1)/det;\n		    for ( j = i+2; j < n; j++ )\n		    {\n			s = - aip1i*m_entry(A,i+1,j) + aip1*m_entry(A,i,j);\n			t = - aip1i*m_entry(A,i,j) + aii*m_entry(A,i+1,j);\n			for ( k = j; k < n; k++ )\n			    m_sub_val(A,j,k,m_entry(A,i,k)*s + m_entry(A,i+1,k)*t);\n			m_set_val(A,i,j,s);\n			m_set_val(A,i+1,j,t);\n		    }\n		}\n		/* printf(""# Matrix so far (@checkpoint B) =\n""); */\n		/* m_output(A); */\n		/* printf(""# pivot =\n"");	px_output(pivot); */\n		/* printf(""# blocks =\n"");	px_output(blocks); */\n	}\n\n	/* set lower triangular half */\n	for ( i = 0; i < A->m; i++ )\n	    for ( j = 0; j < i; j++ )\n		m_set_val(A,i,j,m_entry(A,j,i));\n\n	return A;\n}\n\n/* BKPsolve -- solves A.x = b where A has been factored a la BKPfactor()\n	-- returns x, which is created if NULL */\n#ifndef ANSI_C\nVEC	*BKPsolve(A,pivot,block,b,x)\nMAT	*A;\nPERM	*pivot, *block;\nVEC	*b, *x;\n#else\nVEC	*BKPsolve(const MAT *A, PERM *pivot, const PERM *block,\n		  const VEC *b, VEC *x)\n#endif\n{\n	STATIC VEC	*tmp=VNULL;	/* dummy storage needed */\n	int	i, j, n, onebyone;\n	Real	**A_me, a11, a12, a22, b1, b2, det, sum, *tmp_ve, tmp_diag;\n\n	if ( ! A || ! pivot || ! block || ! b )\n		error(E_NULL,""BKPsolve"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""BKPsolve"");\n	n = A->n;\n	if ( b->dim != n || pivot->size != n || block->size != n )\n		error(E_SIZES,""BKPsolve"");\n	x = v_resize(x,n);\n	tmp = v_resize(tmp,n);\n	MEM_STAT_REG(tmp,TYPE_VEC);\n\n	A_me = A->me;	tmp_ve = tmp->ve;\n\n	px_vec(pivot,b,tmp);\n	/* solve for lower triangular part */\n	for ( i = 0; i < n; i++ )\n	{\n		sum = v_entry(tmp,i);\n		if ( block->pe[i] < i )\n		    for ( j = 0; j < i-1; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		else\n		    for ( j = 0; j < i; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		v_set_val(tmp,i,sum);\n	}\n	/* printf(""# BKPsolve: solving L part: tmp =\n"");	v_output(tmp); */\n	/* solve for diagonal part */\n	for ( i = 0; i < n; i = onebyone ? i+1 : i+2 )\n	{\n		onebyone = ( block->pe[i] == i );\n		if ( onebyone )\n		{\n		    tmp_diag = m_entry(A,i,i);\n		    if ( tmp_diag == 0.0 )\n			error(E_SING,""BKPsolve"");\n		    /* tmp_ve[i] /= tmp_diag; */\n		    v_set_val(tmp,i,v_entry(tmp,i) / tmp_diag);\n		}\n		else\n		{\n		    a11 = m_entry(A,i,i);\n		    a22 = m_entry(A,i+1,i+1);\n		    a12 = m_entry(A,i+1,i);\n		    b1 = v_entry(tmp,i);	b2 = v_entry(tmp,i+1);\n		    det = a11*a22-a12*a12;	/* < 0 : see BKPfactor() */\n		    if ( det == 0.0 )\n			error(E_SING,""BKPsolve"");\n		    det = 1/det;\n		    v_set_val(tmp,i,det*(a22*b1-a12*b2));\n		    v_set_val(tmp,i+1,det*(a11*b2-a12*b1));\n		}\n	}\n	/* printf(""# BKPsolve: solving D part: tmp =\n"");	v_output(tmp); */\n	/* solve for transpose of lower traingular part */\n	for ( i = n-1; i >= 0; i-- )\n	{	/* use symmetry of factored form to get stride 1 */\n		sum = v_entry(tmp,i);\n		if ( block->pe[i] > i )\n		    for ( j = i+2; j < n; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		else\n		    for ( j = i+1; j < n; j++ )\n			sum -= m_entry(A,i,j)*v_entry(tmp,j);\n		v_set_val(tmp,i,sum);\n	}\n\n	/* printf(""# BKPsolve: solving L^T part: tmp =\n"");v_output(tmp); */\n	/* and do final permutation */\n	x = pxinv_vec(pivot,tmp,x);\n\n#ifdef THREADSAFE\n	V_FREE(tmp);\n#endif\n\n	return x;\n}\n\n		\n\n"
leukocyte/meschach_lib/bdfactor.c,"\n\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  Band matrix factorisation routines\n  */\n\n/* bdfactor.c  18/11/93 */\nstatic	char	rcsid[] = ""$Id: "";\n\n#include	<stdio.h>\n#include	<math.h>\n#include        ""matrix2.h""\n\n\n/* generate band matrix \n   for a matrix  with n columns,\n   lb subdiagonals and ub superdiagonals;\n\n   Way of saving a band of a matrix:\n   first we save subdiagonals (from 0 to lb-1);\n   then main diagonal (in the lb row)\n   and then superdiagonals (from lb+1 to lb+ub)\n   in such a way that the elements which were previously\n   in one column are now also in one column\n*/\n#ifndef ANSI_C\nBAND *bd_get(lb,ub,n)\nint lb, ub, n;\n#else\nBAND *bd_get(int lb, int ub, int n)\n#endif\n{\n   BAND *A;\n\n   if (lb < 0 || ub < 0 || n <= 0)\n     error(E_NEG,""bd_get"");\n\n   if ((A = NEW(BAND)) == (BAND *)NULL)\n     error(E_MEM,""bd_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_BAND,0,sizeof(BAND));\n      mem_numvar(TYPE_BAND,1);\n   }\n\n   lb = A->lb = min(n-1,lb);\n   ub = A->ub = min(n-1,ub);\n   A->mat = m_get(lb+ub+1,n);\n   return A;\n}\n\n/* bd_free -- frees BAND matrix -- returns (-1) on error and 0 otherwise */\n#ifndef ANSI_C\nint bd_free(A)\nBAND *A;\n#else\nint bd_free(BAND *A)\n#endif\n{\n   if ( A == (BAND *)NULL || A->lb < 0 || A->ub < 0 )\n     /* don't trust it */\n     return (-1);\n\n   if (A->mat) m_free(A->mat);\n\n   if (mem_info_is_on()) {\n      mem_bytes(TYPE_BAND,sizeof(BAND),0);\n      mem_numvar(TYPE_BAND,-1);\n   }\n\n   free((char *)A);\n   return 0;\n}\n\n\n/* resize band matrix */\n#ifndef ANSI_C\nBAND *bd_resize(A,new_lb,new_ub,new_n)\nBAND *A;\nint new_lb,new_ub,new_n;\n#else\nBAND *bd_resize(BAND *A, int new_lb, int new_ub, int new_n)\n#endif\n{\n   int lb,ub,i,j,l,shift,umin;\n   Real **Av;\n\n   if (new_lb < 0 || new_ub < 0 || new_n <= 0)\n     error(E_NEG,""bd_resize"");\n   if ( ! A )\n     return bd_get(new_lb,new_ub,new_n);\n    if ( A->lb+A->ub+1 > A->mat->m )\n	error(E_INTERN,""bd_resize"");\n\n   if ( A->lb == new_lb && A->ub == new_ub && A->mat->n == new_n )\n	return A;\n\n   lb = A->lb;\n   ub = A->ub;\n   Av = A->mat->me;\n   umin = min(ub,new_ub);\n\n    /* ensure that unused triangles at edges are zero'd */\n\n   for ( i = 0; i < lb; i++ )\n      for ( j = A->mat->n - lb + i; j < A->mat->n; j++ )\n	Av[i][j] = 0.0;  \n    for ( i = lb+1,l=1; l <= umin; i++,l++ )\n      for ( j = 0; j < l; j++ )\n	Av[i][j] = 0.0; \n\n   new_lb = A->lb = min(new_lb,new_n-1);\n   new_ub = A->ub = min(new_ub,new_n-1);\n   A->mat = m_resize(A->mat,new_lb+new_ub+1,new_n);\n   Av = A->mat->me;\n\n   /* if new_lb != lb then move the rows to get the main diag \n      in the new_lb row */\n\n   if (new_lb > lb) {\n      shift = new_lb-lb;\n\n      for (i=lb+umin, l=i+shift; i >= 0; i--,l--)\n	MEM_COPY(Av[i],Av[l],new_n*sizeof(Real));\n      for (l=shift-1; l >= 0; l--)\n	__zero__(Av[l],new_n);\n   }\n   else if (new_lb < lb) { \n      shift = lb - new_lb;\n\n      for (i=shift, l=0; i <= lb+umin; i++,l++)\n	MEM_COPY(Av[i],Av[l],new_n*sizeof(Real));\n      for (i=lb+umin+1; i <= new_lb+new_ub; i++)\n	__zero__(Av[i],new_n);\n   }\n\n   return A;\n}\n\n\n/* bd_copy -- copies band matrix A to B, returning B\n	-- if B is NULL, create\n	-- B is set to the correct size */\n#ifndef ANSI_C\nBAND *bd_copy(A,B)\nBAND *A,*B;\n#else\nBAND *bd_copy(const BAND *A, BAND *B)\n#endif\n{\n   int lb,ub,i,j,n;\n   \n   if ( !A )\n     error(E_NULL,""bd_copy"");\n\n   if (A == B) return B;\n   \n   n = A->mat->n;\n   if ( !B )\n     B = bd_get(A->lb,A->ub,n);\n   else if (B->lb != A->lb || B->ub != A->ub || B->mat->n != n )\n     B = bd_resize(B,A->lb,A->ub,n);\n   \n   if (A->mat == B->mat) return B;\n   ub = B->ub = A->ub;\n   lb = B->lb = A->lb;\n\n   for ( i=0, j=n-lb; i <= lb; i++, j++ )\n     MEM_COPY(A->mat->me[i],B->mat->me[i],j*sizeof(Real));   \n\n   for ( i=lb+1, j=1; i <= lb+ub; i++, j++ )\n     MEM_COPY(A->mat->me[i]+j,B->mat->me[i]+j,(n - j)*sizeof(Real));     \n\n   return B;\n}\n\n\n/* copy band matrix bA to a square matrix A returning A */\n#ifndef ANSI_C\nMAT *band2mat(bA,A)\nBAND *bA;\nMAT *A;\n#else\nMAT *band2mat(const BAND *bA, MAT *A)\n#endif\n{\n   int i,j,l,n,n1;\n   int lb, ub;\n   Real **bmat;\n\n   if ( !bA )\n     error(E_NULL,""band2mat"");\n   if ( bA->mat == A )\n     error(E_INSITU,""band2mat"");\n\n   ub = bA->ub;\n   lb = bA->lb;\n   n = bA->mat->n;\n   n1 = n-1;\n   bmat = bA->mat->me;\n\n   A = m_resize(A,n,n);\n   m_zero(A);\n\n   for (j=0; j < n; j++)\n     for (i=min(n1,j+lb),l=lb+j-i; i >= max(0,j-ub); i--,l++)\n       A->me[i][j] = bmat[l][j];\n\n   return A;\n}\n\n/* copy a square matrix to a band matrix with \n   lb subdiagonals and ub superdiagonals */\n#ifndef ANSI_C\nBAND *mat2band(A,lb,ub,bA)\nBAND *bA;\nMAT *A;\nint lb, ub;\n#else\nBAND *mat2band(const MAT *A, int lb, int ub,BAND *bA)\n#endif\n{\n   int i, j, l, n1;\n   Real **bmat;\n   \n   if (! A )\n     error(E_NULL,""mat2band"");\n   if (ub < 0 || lb < 0)\n     error(E_SIZES,""mat2band"");\n   if ( bA != (BAND *)NULL && bA->mat == A )\n     error(E_INSITU,""mat2band"");\n\n   n1 = A->n-1;\n   lb = min(n1,lb);\n   ub = min(n1,ub);\n   bA = bd_resize(bA,lb,ub,n1+1);\n   bmat = bA->mat->me;\n\n   for (j=0; j <= n1; j++)\n     for (i=min(n1,j+lb),l=lb+j-i; i >= max(0,j-ub); i--,l++)\n       bmat[l][j] = A->me[i][j];\n\n   return bA;\n}\n\n\n\n/* transposition of matrix in;\n   out - matrix after transposition;\n   can be done in situ\n*/\n#ifndef ANSI_C\nBAND *bd_transp(in,out)\nBAND *in, *out;\n#else\nBAND *bd_transp(const BAND *in, BAND *out)\n#endif\n{\n   int i, j, jj, l, k, lb, ub, lub, n, n1;\n   int in_situ;\n   Real  **in_v, **out_v;\n   \n   if ( in == (BAND *)NULL || in->mat == (MAT *)NULL )\n     error(E_NULL,""bd_transp"");\n\n   lb = in->lb;\n   ub = in->ub;\n   lub = lb+ub;\n   n = in->mat->n;\n   n1 = n-1;\n\n   in_situ = ( in == out );\n   if ( ! in_situ )\n       out = bd_resize(out,ub,lb,n);\n   else\n   {   /* only need to swap lb and ub fields */\n       out->lb = ub;\n       out->ub = lb;\n   }\n\n   in_v = in->mat->me;\n   \n   if (! in_situ) {\n      int sh_in,sh_out; \n\n      out_v = out->mat->me;\n      for (i=0, l=lub, k=lb-i; i <= lub; i++,l--,k--) {\n	 sh_in = max(-k,0);\n	 sh_out = max(k,0);\n	 MEM_COPY(&(in_v[i][sh_in]),&(out_v[l][sh_out]),\n		  (n-sh_in-sh_out)*sizeof(Real));\n	 /**********************************\n	 for (j=n1-sh_out, jj=n1-sh_in; j >= sh_in; j--,jj--) {\n	    out_v[l][jj] = in_v[i][j];\n	 }\n	 **********************************/\n      }\n   }\n   else if (ub == lb) {\n      Real tmp;\n\n      for (i=0, l=lub, k=lb-i; i < lb; i++,l--,k--) {\n	 for (j=n1-k, jj=n1; j >= 0; j--,jj--) {\n	    tmp = in_v[l][jj];\n	    in_v[l][jj] = in_v[i][j];\n	    in_v[i][j] = tmp;\n	 }\n      }\n   }\n   else if (ub > lb) {  /* hence i-ub <= 0 & l-lb >= 0 */\n      int p,pp,lbi;\n      \n      for (i=0, l=lub; i < (lub+1)/2; i++,l--) {\n	 lbi = lb-i;\n	 for (j=l-lb, jj=0, p=max(-lbi,0), pp = max(l-ub,0); j <= n1; \n	      j++,jj++,p++,pp++) {\n	    in_v[l][pp] = in_v[i][p];\n	    in_v[i][jj] = in_v[l][j];\n	 }\n	 for (  ; p <= n1-max(lbi,0); p++,pp++)\n	   in_v[l][pp] = in_v[i][p];\n      }\n      \n      if (lub%2 == 0) { /* shift only */\n	 i = lub/2;\n	 for (j=max(i-lb,0), jj=0; jj <= n1-ub+i; j++,jj++) \n	   in_v[i][jj] = in_v[i][j];\n      }\n   }\n   else {      /* ub < lb, hence ub-l <= 0 & lb-i >= 0 */\n      int p,pp,ubi;\n\n      for (i=0, l=lub; i < (lub+1)/2; i++,l--) {\n	 ubi = i-ub;\n	 for (j=n1-max(lb-l,0), jj=n1-max(-ubi,0), p=n1-lb+i, pp=n1;\n	      p >= 0; j--, jj--, pp--, p--) {\n	    in_v[i][jj] = in_v[l][j];\n	    in_v[l][pp] = in_v[i][p];\n	 }\n	 for (  ; jj >= max(ubi,0); j--, jj--)\n	   in_v[i][jj] = in_v[l][j];\n      }\n\n      if (lub%2 == 0) {  /* shift only */\n	 i = lub/2;\n	 for (j=n1-lb+i, jj=n1-max(ub-i,0); j >= 0; j--, jj--) \n	    in_v[i][jj] = in_v[i][j];\n      }\n   }\n\n   return out;\n}\n\n/* bdv_mltadd -- band matrix-vector multiply and add\n   -- returns out <- x + s.bA.y\n   -- if y is NULL then create y (as zero vector)\n   -- error if either A or x is NULL */\n#ifndef ANSI_C\nVEC	*bdv_mltadd(x,y,bA,s,out)\n     BAND	*bA;\n     VEC	*x, *y;\n     double	s;\n     VEC *out;\n#else\nVEC	*bdv_mltadd(const VEC *x, const VEC *y, const BAND *bA,\n		    double s, VEC *out)\n#endif\n{\n  int	i, j;\n\n  if ( ! bA || ! x || ! y )\n    error(E_NULL,""bdv_mltadd"");\n  if ( bA->mat->n != x->dim || y->dim != x->dim )\n    error(E_SIZES,""bdv_mltadd"");\n  if ( ! out || out->dim != x->dim )\n    out = v_resize(out,x->dim);\n  out = v_copy(x,out);\n\n  for ( j = 0; j < x->dim; j++ )\n    for ( i = max(j-bA->ub,0); i <= j+bA->lb && i < x->dim; i++ )\n      out->ve[i] += s*bd_get_val(bA,i,j)*y->ve[j];\n\n  return out;\n}\n\n/* vbd_mltadd -- band matrix-vector multiply and add\n   -- returns out^T <- x^T + s.y^T.bA\n   -- if out is NULL then create out (as zero vector)\n   -- error if either bA or x is NULL */\n#ifndef ANSI_C\nVEC	*vbd_mltadd(x,y,bA,s,out)\n     BAND	*bA;\n     VEC	*x, *y;\n     double	s;\n     VEC *out;\n#else\nVEC	*vbd_mltadd(const VEC *x, const VEC *y, const BAND *bA,\n		    double s, VEC *out)\n#endif\n{\n  int	i, j;\n\n  if ( ! bA || ! x || ! y )\n    error(E_NULL,""vbd_mltadd"");\n  if ( bA->mat->n != x->dim || y->dim != x->dim )\n    error(E_SIZES,""vbd_mltadd"");\n  if ( ! out || out->dim != x->dim )\n    out = v_resize(out,x->dim);\n  out = v_copy(x,out);\n\n  for ( j = 0; j < x->dim; j++ )\n    for ( i = max(j-bA->ub,0); i <= j+bA->lb && i < x->dim; i++ )\n      out->ve[j] += s*bd_get_val(bA,i,j)*y->ve[i];\n\n  return out;\n}\n\n/* bd_zero -- zeros band matrix A which is returned */\n#ifndef ANSI_C\nBAND	*bd_zero(A)\nBAND	*A;\n#else\nBAND	*bd_zero(BAND *A)\n#endif\n{\n  if ( ! A )\n    error(E_NULL,""bd_zero"");\n\n  m_zero(A->mat);\n  return A;\n}\n\n/* bds_mltadd -- returns OUT <- A+alpha*B\n	-- OUT is created (as zero) if NULL\n	-- if OUT is not the correct size, it is re-sized before the operation\n	-- if A or B are null, and error is generated */\n#ifndef ANSI_C\nBAND	*bds_mltadd(A,B,alpha,OUT)\nBAND	*A, *B, *OUT;\nReal	alpha;\n#else\nBAND	*bds_mltadd(const BAND *A, const BAND *B, double alpha, BAND *OUT)\n#endif\n{\n  int	i;\n\n  if ( ! A || ! B )\n    error(E_NULL,""bds_mltadd"");\n  if ( A->mat->n != B->mat->n )\n    error(E_SIZES,""bds_mltadd"");\n  if ( A == OUT || B == OUT )\n    error(E_INSITU,""bds_mltadd"");\n\n  OUT = bd_copy(A,OUT);\n  OUT = bd_resize(OUT,max(A->lb,B->lb),max(A->ub,B->ub),A->mat->n);\n  for ( i = 0; i <= B->lb + B->ub; i++ )\n    __mltadd__(OUT->mat->me[i+OUT->lb-B->lb],B->mat->me[i],alpha,B->mat->n);\n  \n  return OUT;\n}\n\n/* sbd_mlt -- returns OUT <- s.A */\n#ifndef ANSI_C\nBAND	*sbd_mlt(Real s, BAND *A, BAND *OUT)\n#else\nBAND	*sbd_mlt(Real s, const BAND *A, BAND *OUT)\n#endif\n{\n  if ( ! A )\n    error(E_NULL,""sbd_mlt"");\n\n  OUT = bd_resize(OUT,A->lb,A->ub,A->mat->n);\n  sm_mlt(s,A->mat,OUT->mat);\n\n  return OUT;\n}\n\n/* bdLUfactor -- gaussian elimination with partial pivoting\n   -- on entry, the matrix A in band storage with elements \n      in rows 0 to lb+ub; \n      The jth column of A is stored in the jth column of \n      band A (bA) as follows:\n      bA->mat->me[lb+j-i][j] = A->me[i][j] for \n      max(0,j-lb) <= i <= min(A->n-1,j+ub);\n   -- on exit: U is stored as an upper triangular matrix\n      with lb+ub superdiagonals in rows lb to 2*lb+ub, \n      and the matrix L is stored in rows 0 to lb-1.\n      Matrix U is permuted, whereas L is not permuted !!!\n      Therefore we save some memory.\n   */\n#ifndef ANSI_C\nBAND	*bdLUfactor(bA,pivot)\nBAND	*bA;\nPERM	*pivot;\n#else\nBAND	*bdLUfactor(BAND *bA, PERM *pivot)\n#endif\n{\n   int	i, j, k, l, n, n1, lb, ub, lub, k_end, k_lub;\n   int	i_max, shift;\n   Real	**bA_v;\n   Real max1, temp;\n   \n   if ( bA==(BAND *)NULL || pivot==(PERM *)NULL )\n     error(E_NULL,""bdLUfactor"");\n\n   lb = bA->lb;\n   ub = bA->ub;\n   lub = lb+ub;\n   n = bA->mat->n;\n   n1 = n-1;\n   lub = lb+ub;\n\n   if ( pivot->size != n )\n     error(E_SIZES,""bdLUfactor"");\n\n   \n   /* initialise pivot with identity permutation */\n   for ( i=0; i < n; i++ )\n     pivot->pe[i] = i;\n\n   /* extend band matrix */\n   /* extended part is filled with zeros */\n   bA = bd_resize(bA,lb,min(n1,lub),n);\n   bA_v = bA->mat->me;\n\n\n   /* main loop */\n\n   for ( k=0; k < n1; k++ )\n   {\n      k_end = max(0,lb+k-n1);\n      k_lub = min(k+lub,n1);\n\n      /* find the best pivot row */\n      \n      max1 = 0.0;	\n      i_max = -1;\n      for ( i=lb; i >= k_end; i-- ) {\n	 temp = fabs(bA_v[i][k]);\n	 if ( temp > max1 )\n	 { max1 = temp;	i_max = i; }\n      }\n      \n      /* if no pivot then ignore column k... */\n      if ( i_max == -1 )\n	continue;\n      \n      /* do we pivot ? */\n      if ( i_max != lb )	/* yes we do... */\n      {\n	 /* save transposition using non-shifted indices */\n	 shift = lb-i_max;\n	 px_transp(pivot,k+shift,k);\n	 for ( i=lb, j=k; j <= k_lub; i++,j++ )\n	 {\n	    temp = bA_v[i][j];\n	    bA_v[i][j] = bA_v[i-shift][j];\n	    bA_v[i-shift][j] = temp;\n	 }\n      }\n      \n      /* row operations */\n      for ( i=lb-1; i >= k_end; i-- ) {\n	 temp = bA_v[i][k] /= bA_v[lb][k];\n	 shift = lb-i;\n	 for ( j=k+1,l=i+1; j <= k_lub; l++,j++ )\n	   bA_v[l][j] -= temp*bA_v[l+shift][j];\n      }\n   }\n   \n   return bA;\n}\n\n\n/* bdLUsolve -- given an LU factorisation in bA, solve bA*x=b */\n/* pivot is changed upon return  */\n#ifndef ANSI_C\nVEC	*bdLUsolve(bA,pivot,b,x)\nBAND	*bA;\nPERM	*pivot;\nVEC	*b,*x;\n#else\nVEC	*bdLUsolve(const BAND *bA, PERM *pivot, const VEC *b, VEC *x)\n#endif\n{\n   int i,j,l,n,n1,pi,lb,ub,jmin, maxj;\n   Real c;\n   Real **bA_v;\n\n   if ( bA==(BAND *)NULL || b==(VEC *)NULL || pivot==(PERM *)NULL )\n     error(E_NULL,""bdLUsolve"");\n   if ( bA->mat->n != b->dim || bA->mat->n != pivot->size)\n     error(E_SIZES,""bdLUsolve"");\n \n   lb = bA->lb;\n   ub = bA->ub;\n   n = b->dim;\n   n1 = n-1;\n   bA_v = bA->mat->me;\n\n   x = v_resize(x,b->dim);\n   px_vec(pivot,b,x);\n\n   /* solve Lx = b; implicit diagonal = 1 \n      L is not permuted, therefore it must be permuted now\n    */\n   \n   px_inv(pivot,pivot);\n   for (j=0; j < n; j++) {\n      jmin = j+1;\n      c = x->ve[j];\n      maxj = max(0,j+lb-n1);\n      for (i=jmin,l=lb-1; l >= maxj; i++,l--) {\n	 if ( (pi = pivot->pe[i]) < jmin) \n	   pi = pivot->pe[i] = pivot->pe[pi];\n	 x->ve[pi] -= bA_v[l][j]*c;\n      }\n   }\n\n   /* solve Ux = b; explicit diagonal */\n\n   x->ve[n1] /= bA_v[lb][n1];\n   for (i=n-2; i >= 0; i--) {\n      c = x->ve[i];\n      for (j=min(n1,i+ub), l=lb+j-i; j > i; j--,l--)\n	c -= bA_v[l][j]*x->ve[j];\n      x->ve[i] = c/bA_v[lb][i];\n   }\n   \n   return (x);\n}\n\n/* LDLfactor -- L.D.L' factorisation of A in-situ;\n   A is a band matrix\n   it works using only lower bandwidth & main diagonal\n   so it is possible to set A->ub = 0\n */\n#ifndef ANSI_C\nBAND *bdLDLfactor(A)\nBAND *A;\n#else\nBAND *bdLDLfactor(BAND *A)\n#endif\n{\n   int i,j,k,n,n1,lb,ki,jk,ji,lbkm,lbkp;\n   Real **Av;\n   Real c, cc;\n\n   if ( ! A )\n     error(E_NULL,""bdLDLfactor"");\n\n   if (A->lb == 0) return A;\n\n   lb = A->lb;\n   n = A->mat->n;\n   n1 = n-1;\n   Av = A->mat->me;\n   \n   for (k=0; k < n; k++) {    \n      lbkm = lb-k;\n      lbkp = lb+k;\n\n      /* matrix D */\n      c = Av[lb][k];\n      for (j=max(0,-lbkm), jk=lbkm+j; j < k; j++, jk++) {\n	 cc = Av[jk][j];\n	 c -= Av[lb][j]*cc*cc;\n      }\n      if (c == 0.0)\n	error(E_SING,""bdLDLfactor"");\n      Av[lb][k] = c;\n\n      /* matrix L */\n      \n      for (i=min(n1,lbkp), ki=lbkp-i; i > k; i--,ki++) {\n	 c = Av[ki][k];\n	 for (j=max(0,i-lb), ji=lb+j-i, jk=lbkm+j; j < k;\n	      j++, ji++, jk++)\n	   c -= Av[lb][j]*Av[ji][j]*Av[jk][j];\n	 Av[ki][k] = c/Av[lb][k];\n      }\n   }\n   \n   return A;\n}\n\n/* solve A*x = b, where A is factorized by \n   Choleski LDL^T factorization */\n#ifndef ANSI_C\nVEC    *bdLDLsolve(A,b,x)\nBAND   *A;\nVEC    *b, *x;\n#else\nVEC    *bdLDLsolve(const BAND *A, const VEC *b, VEC *x)\n#endif\n{\n   int i,j,l,n,n1,lb,ilb;\n   Real **Av, *Avlb;\n   Real c;\n\n   if ( ! A || ! b )\n     error(E_NULL,""bdLDLsolve"");\n   if ( A->mat->n != b->dim )\n     error(E_SIZES,""bdLDLsolve"");\n\n   n = A->mat->n;\n   n1 = n-1;\n   x = v_resize(x,n);\n   lb = A->lb;\n   Av = A->mat->me;  \n   Avlb = Av[lb];\n   \n   /* solve L*y = b */\n   x->ve[0] = b->ve[0];\n   for (i=1; i < n; i++) {\n      ilb = i-lb;\n      c = b->ve[i];\n      for (j=max(0,ilb), l=j-ilb; j < i; j++,l++)\n	c -= Av[l][j]*x->ve[j];\n      x->ve[i] = c;\n   }\n\n   /* solve D*z = y */\n   for (i=0; i < n; i++) \n     x->ve[i] /= Avlb[i];\n\n   /* solve L^T*x = z */\n   for (i=n-2; i >= 0; i--) {\n      ilb = i+lb;\n      c = x->ve[i];\n      for (j=min(n1,ilb), l=ilb-j; j > i; j--,l++)\n	c -= Av[l][i]*x->ve[j];\n      x->ve[i] = c;\n   }\n\n   return x;\n}\n\n\n/* ******************************************************\n  This function is a contribution from Ruediger Franke.\n   His e-mail addres is: Ruediger.Franke@rz.tu-ilmenau.de\n   \n   ******************************************************\n*/\n\n/* bd_mv_mlt --\n *   computes out = A * x\n *   may not work in situ (x != out)\n */\n\nVEC *bd_mv_mlt(A, x, out)\nBAND *A;\nVEC *x, *out;\n{\n  int i, j, j_end, k;\n  int start_idx, end_idx;\n  int n, m, lb, ub;\n  Real **A_me;\n  Real *x_ve;\n  Real sum;\n\n  if (!A || !x)\n    error(E_NULL,""bd_mv_mlt"");\n  if (x->dim != A->mat->n)\n    error(E_SIZES,""bd_mv_mlt"");\n  if (!out || out->dim != A->mat->n)\n    out = v_resize(out, A->mat->n);\n  if (out == x)\n    error(E_INSITU,""bd_mv_mlt"");\n\n  n = A->mat->n;\n  m = A->mat->m;\n  lb = A->lb;\n  ub = A->ub;\n  A_me = A->mat->me;\n  start_idx = lb;\n  end_idx = m + n-1 - ub;\n  for (i=0; i<n; i++, start_idx--, end_idx--) {\n    j = max(0, start_idx);\n    k = max(0, -start_idx);\n    j_end = min(m, end_idx);\n    x_ve = x->ve + k;\n    sum = 0.0;	     \n    for (; j < j_end; j++, k++)\n      sum += A_me[j][k] * *x_ve++;\n    out->ve[i] = sum;\n  }\n\n  return out;\n}\n\n\n\n"
leukocyte/meschach_lib/sparse.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  Sparse matrix package\n  See also: sparse.h, matrix.h\n  */\n\n#include	<stdio.h>\n#include	<math.h>\n#include        <stdlib.h>\n#include	""sparse.h""\n\n\nstatic char	rcsid[] = ""$Id: sparse.c,v 1.10 1994/03/08 05:46:07 des Exp $"";\n\n#define	MINROWLEN	10\n\n\n\n/* sp_get_val -- returns the (i,j) entry of the sparse matrix A */\n#ifndef ANSI_C\ndouble	sp_get_val(A,i,j)\nSPMAT	*A;\nint	i, j;\n#else\ndouble	sp_get_val(const SPMAT *A, int i, int j)\n#endif\n{\n   SPROW	*r;\n   int	idx;\n   \n   if ( A == SMNULL )\n     error(E_NULL,""sp_get_val"");\n   if ( i < 0 || i >= A->m || j < 0 || j >= A->n )\n     error(E_SIZES,""sp_get_val"");\n   \n   r = A->row+i;\n   idx = sprow_idx(r,j);\n   if ( idx < 0 )\n     return 0.0;\n   /* else */\n   return r->elt[idx].val;\n}\n\n/* sp_set_val -- sets the (i,j) entry of the sparse matrix A */\n#ifndef ANSI_C\ndouble	sp_set_val(A,i,j,val)\nSPMAT	*A;\nint	i, j;\ndouble	val;\n#else\ndouble	sp_set_val(SPMAT *A, int i, int j, double val)\n#endif\n{\n   SPROW	*r;\n   int	idx, idx2, new_len;\n   \n   if ( A == SMNULL )\n     error(E_NULL,""sp_set_val"");\n   if ( i < 0 || i >= A->m || j < 0 || j >= A->n )\n     error(E_SIZES,""sp_set_val"");\n   \n   r = A->row+i;\n   idx = sprow_idx(r,j);\n   /* printf(""sp_set_val: idx = %d\n"",idx); */\n   if ( idx >= 0 )\n   {	r->elt[idx].val = val;	return val;	}\n   /* else */ if ( idx < -1 )\n   {\n      /* Note: this destroys the column & diag access paths */\n      A->flag_col = A->flag_diag = FALSE;\n      /* shift & insert new value */\n      idx = -(idx+2);	/* this is the intended insertion index */\n      if ( r->len >= r->maxlen )\n      {\n	 r->len = r->maxlen;\n	 new_len = max(2*r->maxlen+1,5);\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,A->row[i].maxlen*sizeof(row_elt),\n			    new_len*sizeof(row_elt));\n	 }\n\n	 r->elt = RENEW(r->elt,new_len,row_elt);\n	 if ( ! r->elt )	/* can't allocate */\n	   error(E_MEM,""sp_set_val"");\n	 r->maxlen = 2*r->maxlen+1;\n      }\n      for ( idx2 = r->len-1; idx2 >= idx; idx2-- )\n	MEM_COPY((char *)(&(r->elt[idx2])),\n		 (char *)(&(r->elt[idx2+1])),sizeof(row_elt));\n      /************************************************************\n	if ( idx < r->len )\n	MEM_COPY((char *)(&(r->elt[idx])),(char *)(&(r->elt[idx+1])),\n	(r->len-idx)*sizeof(row_elt));\n	************************************************************/\n      r->len++;\n      r->elt[idx].col = j;\n      return r->elt[idx].val = val;\n   }\n   /* else -- idx == -1, error in index/matrix! */\n   return 0.0;\n}\n\n/* sp_mv_mlt -- sparse matrix/dense vector multiply\n   -- result is in out, which is returned unless out==NULL on entry\n   --  if out==NULL on entry then the result vector is created */\n#ifndef ANSI_C\nVEC	*sp_mv_mlt(A,x,out)\nSPMAT	*A;\nVEC	*x, *out;\n#else\nVEC	*sp_mv_mlt(const SPMAT *A, const VEC *x, VEC *out)\n#endif\n{\n   int	i, j_idx, m, n, max_idx;\n   Real	sum, *x_ve;\n   SPROW	*r;\n   row_elt	*elts;\n   \n   if ( ! A || ! x )\n     error(E_NULL,""sp_mv_mlt"");\n   if ( x->dim != A->n )\n     error(E_SIZES,""sp_mv_mlt"");\n   if ( ! out || out->dim < A->m )\n     out = v_resize(out,A->m);\n   if ( out == x )\n     error(E_INSITU,""sp_mv_mlt"");\n   m = A->m;	n = A->n;\n   x_ve = x->ve;\n   \n   for ( i = 0; i < m; i++ )\n   {\n      sum = 0.0;\n      r = &(A->row[i]);\n      max_idx = r->len;\n      elts    = r->elt;\n      for ( j_idx = 0; j_idx < max_idx; j_idx++, elts++ )\n	sum += elts->val*x_ve[elts->col];\n      out->ve[i] = sum;\n   }\n   return out;\n}\n\n/* sp_vm_mlt -- sparse matrix/dense vector multiply from left\n   -- result is in out, which is returned unless out==NULL on entry\n   -- if out==NULL on entry then result vector is created & returned */\n#ifndef ANSI_C\nVEC	*sp_vm_mlt(A,x,out)\nSPMAT	*A;\nVEC	*x, *out;\n#else\nVEC	*sp_vm_mlt(const SPMAT *A, const VEC *x, VEC *out)\n#endif\n{\n   int	i, j_idx, m, n, max_idx;\n   Real	tmp, *x_ve, *out_ve;\n   SPROW	*r;\n   row_elt	*elts;\n   \n   if ( ! A || ! x )\n     error(E_NULL,""sp_vm_mlt"");\n   if ( x->dim != A->m )\n     error(E_SIZES,""sp_vm_mlt"");\n   if ( ! out || out->dim < A->n )\n     out = v_resize(out,A->n);\n   if ( out == x )\n     error(E_INSITU,""sp_vm_mlt"");\n   \n   m = A->m;	n = A->n;\n   v_zero(out);\n   x_ve = x->ve;	out_ve = out->ve;\n   \n   for ( i = 0; i < m; i++ )\n   {\n      r = A->row+i;\n      max_idx = r->len;\n      elts    = r->elt;\n      tmp = x_ve[i];\n      for ( j_idx = 0; j_idx < max_idx; j_idx++, elts++ )\n	out_ve[elts->col] += elts->val*tmp;\n   }\n   \n   return out;\n}\n\n\n/* sp_get -- get sparse matrix\n   -- len is number of elements available for each row without\n   allocating further memory */\n#ifndef ANSI_C\nSPMAT	*sp_get(m,n,maxlen)\nint	m, n, maxlen;\n#else\nSPMAT	*sp_get(int m, int n, int maxlen)\n#endif\n{\n   SPMAT	*A;\n   SPROW	*rows;\n   int	i;\n   \n   if ( m < 0 || n < 0 )\n     error(E_NEG,""sp_get"");\n\n   maxlen = max(maxlen,1);\n   \n   A = NEW(SPMAT);\n   if ( ! A )		/* can't allocate */\n     error(E_MEM,""sp_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,sizeof(SPMAT));\n      mem_numvar(TYPE_SPMAT,1);\n   }\n   /* fprintf(stderr,""Have SPMAT structure\n""); */\n   \n   A->row = rows = NEW_A(m,SPROW);\n   if ( ! A->row )		/* can't allocate */\n     error(E_MEM,""sp_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,m*sizeof(SPROW));\n   }\n   /* fprintf(stderr,""Have row structure array\n""); */\n   \n   A->start_row = NEW_A(n,int);\n   A->start_idx = NEW_A(n,int);\n   if ( ! A->start_row || ! A->start_idx )	/* can't allocate */\n     error(E_MEM,""sp_get"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,2*n*sizeof(int));\n   }\n   for ( i = 0; i < n; i++ )\n     A->start_row[i] = A->start_idx[i] = -1;\n   /* fprintf(stderr,""Have start_row array\n""); */\n   \n   A->m = A->max_m = m;\n   A->n = A->max_n = n;\n   \n   for ( i = 0; i < m; i++, rows++ )\n   {\n      rows->elt = NEW_A(maxlen,row_elt);\n      if ( ! rows->elt )\n	error(E_MEM,""sp_get"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,0,maxlen*sizeof(row_elt));\n      }\n      /* fprintf(stderr,""Have row %d element array\n"",i); */\n      rows->len = 0;\n      rows->maxlen = maxlen;\n      rows->diag = -1;\n   }\n   \n   return A;\n}\n\n\n/* sp_free -- frees up the memory for a sparse matrix */\n#ifndef ANSI_C\nint	sp_free(A)\nSPMAT	*A;\n#else\nint	sp_free(SPMAT *A)\n#endif\n{\n   SPROW	*r;\n   int	i;\n   \n   if ( ! A )\n     return -1;\n   if ( A->start_row != (int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_n*sizeof(int),0);\n      }\n      free((char *)(A->start_row));\n   }\n   if ( A->start_idx != (int *)NULL ) {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_n*sizeof(int),0);\n      }\n      \n      free((char *)(A->start_idx));\n   }\n   if ( ! A->row )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,sizeof(SPMAT),0);\n	 mem_numvar(TYPE_SPMAT,-1);\n      }\n      \n      free((char *)A);\n      return 0;\n   }\n   for ( i = 0; i < A->m; i++ )\n   {\n      r = &(A->row[i]);\n      if ( r->elt != (row_elt *)NULL ) {\n	 if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,A->row[i].maxlen*sizeof(row_elt),0);\n	 }\n	 free((char *)(r->elt));\n      }\n   }\n   \n   if (mem_info_is_on()) {\n      if (A->row) \n	mem_bytes(TYPE_SPMAT,A->max_m*sizeof(SPROW),0);\n      mem_bytes(TYPE_SPMAT,sizeof(SPMAT),0);\n      mem_numvar(TYPE_SPMAT,-1);\n   }\n   \n   free((char *)(A->row));\n   free((char *)A);\n\n   return 0;\n}\n\n\n/* sp_copy -- constructs a copy of a given matrix\n   -- note that the max_len fields (etc) are no larger in the copy\n   than necessary\n   -- result is returned */\n#ifndef ANSI_C\nSPMAT	*sp_copy(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_copy(const SPMAT *A)\n#endif\n{\n   SPMAT	*out;\n   SPROW	*row1, *row2;\n   int	i;\n   \n   if ( A == SMNULL )\n     error(E_NULL,""sp_copy"");\n   if ( ! (out=NEW(SPMAT)) )\n     error(E_MEM,""sp_copy"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,sizeof(SPMAT));\n      mem_numvar(TYPE_SPMAT,1);\n   }\n   out->m = out->max_m = A->m;	out->n = out->max_n = A->n;\n   \n   /* set up rows */\n   if ( ! (out->row=NEW_A(A->m,SPROW)) )\n     error(E_MEM,""sp_copy"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,A->m*sizeof(SPROW));\n   }\n   for ( i = 0; i < A->m; i++ )\n   {\n      row1 = &(A->row[i]);\n      row2 = &(out->row[i]);\n      if ( ! (row2->elt=NEW_A(max(row1->len,3),row_elt)) )\n	error(E_MEM,""sp_copy"");\n      else if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,0,max(row1->len,3)*sizeof(row_elt));\n      }\n      row2->len = row1->len;\n      row2->maxlen = max(row1->len,3);\n      row2->diag = row1->diag;\n      MEM_COPY((char *)(row1->elt),(char *)(row2->elt),\n	       row1->len*sizeof(row_elt));\n   }\n   \n   /* set up start arrays -- for column access */\n   if ( ! (out->start_idx=NEW_A(A->n,int)) ||\n       ! (out->start_row=NEW_A(A->n,int)) )\n     error(E_MEM,""sp_copy"");\n   else if (mem_info_is_on()) {\n      mem_bytes(TYPE_SPMAT,0,2*A->n*sizeof(int));\n   }\n   MEM_COPY((char *)(A->start_idx),(char *)(out->start_idx),\n	    A->n*sizeof(int));\n   MEM_COPY((char *)(A->start_row),(char *)(out->start_row),\n	    A->n*sizeof(int));\n   \n   return out;\n}\n\n/* sp_col_access -- set column access path; i.e. nxt_row, nxt_idx fields\n   -- returns A */\n#ifndef ANSI_C\nSPMAT	*sp_col_access(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_col_access(SPMAT *A)\n#endif\n{\n   int	i, j, j_idx, len, m, n;\n   SPROW	*row;\n   row_elt	*r_elt;\n   int	*start_row, *start_idx;\n   \n   if ( A == SMNULL )\n     error(E_NULL,""sp_col_access"");\n   \n   m = A->m;	n = A->n;\n   \n   /* initialise start_row and start_idx */\n   start_row = A->start_row;	start_idx = A->start_idx;\n   for ( j = 0; j < n; j++ )\n   {	*start_row++ = -1;	*start_idx++ = -1;	}\n   \n   start_row = A->start_row;	start_idx = A->start_idx;\n   \n   /* now work UP the rows, setting nxt_row, nxt_idx fields */\n   for ( i = m-1; i >= 0; i-- )\n   {\n      row = &(A->row[i]);\n      r_elt = row->elt;\n      len   = row->len;\n      for ( j_idx = 0; j_idx < len; j_idx++, r_elt++ )\n      {\n	 j = r_elt->col;\n	 r_elt->nxt_row = start_row[j];\n	 r_elt->nxt_idx = start_idx[j];\n	 start_row[j] = i;\n	 start_idx[j] = j_idx;\n      }\n   }\n   \n   A->flag_col = TRUE;\n   return A;\n}\n\n/* sp_diag_access -- set diagonal access path(s) */\n#ifndef ANSI_C\nSPMAT	*sp_diag_access(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_diag_access(SPMAT *A)\n#endif\n{\n   int	i, m;\n   SPROW	*row;\n   \n   if ( A == SMNULL )\n     error(E_NULL,""sp_diag_access"");\n   \n   m = A->m;\n   \n   row = A->row;\n   for ( i = 0; i < m; i++, row++ )\n     row->diag = sprow_idx(row,i);\n   \n   A->flag_diag = TRUE;\n   \n   return A;\n}\n\n/* sp_m2dense -- convert a sparse matrix to a dense one */\n#ifndef ANSI_C\nMAT	*sp_m2dense(A,out)\nSPMAT	*A;\nMAT	*out;\n#else\nMAT	*sp_m2dense(const SPMAT *A, MAT *out)\n#endif\n{\n   int	i, j_idx;\n   SPROW	*row;\n   row_elt	*elt;\n   \n   if ( ! A )\n     error(E_NULL,""sp_m2dense"");\n   if ( ! out || out->m < A->m || out->n < A->n )\n     out = m_get(A->m,A->n);\n   \n   m_zero(out);\n   for ( i = 0; i < A->m; i++ )\n   {\n      row = &(A->row[i]);\n      elt = row->elt;\n      for ( j_idx = 0; j_idx < row->len; j_idx++, elt++ )\n	out->me[i][elt->col] = elt->val;\n   }\n   \n   return out;\n}\n\n\n/*  C = A+B, can be in situ */\n#ifndef ANSI_C\nSPMAT *sp_add(A,B,C)\nSPMAT *A, *B, *C;\n#else\nSPMAT *sp_add(const SPMAT *A, const SPMAT *B, SPMAT *C)\n#endif\n{\n   int i, in_situ;\n   SPROW *rc;\n   STATIC SPROW *tmp = NULL;\n\n   if ( ! A || ! B )\n     error(E_NULL,""sp_add"");\n   if ( A->m != B->m || A->n != B->n )\n     error(E_SIZES,""sp_add"");\n   if (C == A || C == B)\n     in_situ = TRUE;\n   else in_situ = FALSE;\n\n   if ( ! C )\n     C = sp_get(A->m,A->n,5);\n   else {\n      if ( C->m != A->m || C->n != A->n  )\n	error(E_SIZES,""sp_add"");\n      if (!in_situ) sp_zero(C);\n   }\n\n   if (tmp == (SPROW *)NULL && in_situ) {\n      tmp = sprow_get(MINROWLEN);\n      MEM_STAT_REG(tmp,TYPE_SPROW);\n   }\n\n   if (in_situ)\n     for (i=0; i < A->m; i++) {\n	rc = &(C->row[i]);\n	sprow_add(&(A->row[i]),&(B->row[i]),0,tmp,TYPE_SPROW);\n	sprow_resize(rc,tmp->len,TYPE_SPMAT);\n	MEM_COPY(tmp->elt,rc->elt,tmp->len*sizeof(row_elt));\n	rc->len = tmp->len;\n     }\n   else\n     for (i=0; i < A->m; i++) {\n	sprow_add(&(A->row[i]),&(B->row[i]),0,&(C->row[i]),TYPE_SPMAT);\n     }\n\n   C->flag_col = C->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n   sprow_free(tmp);\n#endif\n\n   return C;\n}\n\n/*  C = A-B, cannot be in situ */\n#ifndef ANSI_C\nSPMAT *sp_sub(A,B,C)\nSPMAT *A, *B, *C;\n#else\nSPMAT *sp_sub(const SPMAT *A, const SPMAT *B, SPMAT *C)\n#endif\n{\n   int i, in_situ;\n   SPROW *rc;\n   STATIC SPROW *tmp = NULL;\n   \n   if ( ! A || ! B )\n     error(E_NULL,""sp_sub"");\n   if ( A->m != B->m || A->n != B->n )\n     error(E_SIZES,""sp_sub"");\n   if (C == A || C == B)\n     in_situ = TRUE;\n   else in_situ = FALSE;\n\n   if ( ! C )\n     C = sp_get(A->m,A->n,5);\n   else {\n      if ( C->m != A->m || C->n != A->n  )\n	error(E_SIZES,""sp_sub"");\n      if (!in_situ) sp_zero(C);\n   }\n\n   if (tmp == (SPROW *)NULL && in_situ) {\n      tmp = sprow_get(MINROWLEN);\n      MEM_STAT_REG(tmp,TYPE_SPROW);\n   }\n\n   if (in_situ)\n     for (i=0; i < A->m; i++) {\n	rc = &(C->row[i]);\n	sprow_sub(&(A->row[i]),&(B->row[i]),0,tmp,TYPE_SPROW);\n	sprow_resize(rc,tmp->len,TYPE_SPMAT);\n	MEM_COPY(tmp->elt,rc->elt,tmp->len*sizeof(row_elt));\n	rc->len = tmp->len;\n     }\n   else\n     for (i=0; i < A->m; i++) {\n	sprow_sub(&(A->row[i]),&(B->row[i]),0,&(C->row[i]),TYPE_SPMAT);\n     }\n\n   C->flag_col = C->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n   sprow_free(tmp);\n#endif\n\n   return C;\n}\n\n/*  C = A+alpha*B, cannot be in situ */\n#ifndef ANSI_C\nSPMAT *sp_mltadd(A,B,alpha,C)\nSPMAT *A, *B, *C;\ndouble alpha;\n#else\nSPMAT *sp_mltadd(const SPMAT *A, const SPMAT *B, double alpha, SPMAT *C)\n#endif\n{\n   int i, in_situ;\n   SPROW *rc;\n   STATIC SPROW *tmp = NULL;\n\n   if ( ! A || ! B )\n     error(E_NULL,""sp_mltadd"");\n   if ( A->m != B->m || A->n != B->n )\n     error(E_SIZES,""sp_mltadd"");\n   if (C == A || C == B)\n     in_situ = TRUE;\n   else in_situ = FALSE;\n\n   if ( ! C )\n     C = sp_get(A->m,A->n,5);\n   else {\n      if ( C->m != A->m || C->n != A->n  )\n	error(E_SIZES,""sp_mltadd"");\n      if (!in_situ) sp_zero(C);\n   }\n\n   if (tmp == (SPROW *)NULL && in_situ) {\n      tmp = sprow_get(MINROWLEN);\n      MEM_STAT_REG(tmp,TYPE_SPROW);\n   }\n\n   if (in_situ)\n     for (i=0; i < A->m; i++) {\n	rc = &(C->row[i]);\n	sprow_mltadd(&(A->row[i]),&(B->row[i]),alpha,0,tmp,TYPE_SPROW);\n	sprow_resize(rc,tmp->len,TYPE_SPMAT);\n	MEM_COPY(tmp->elt,rc->elt,tmp->len*sizeof(row_elt));\n	rc->len = tmp->len;\n     }\n   else\n     for (i=0; i < A->m; i++) {\n	sprow_mltadd(&(A->row[i]),&(B->row[i]),alpha,0,\n		     &(C->row[i]),TYPE_SPMAT);\n     }\n   \n   C->flag_col = C->flag_diag = FALSE;\n\n#ifdef	THREADSAFE\n   sprow_free(tmp);\n#endif\n   \n   return C;\n}\n\n\n\n/*  B = alpha*A, can be in situ */\n#ifndef ANSI_C\nSPMAT *sp_smlt(A,alpha,B)\nSPMAT *A, *B;\ndouble alpha;\n#else\nSPMAT *sp_smlt(const SPMAT *A, double alpha, SPMAT *B)\n#endif\n{\n   int i;\n\n   if ( ! A )\n     error(E_NULL,""sp_smlt"");\n   if ( ! B )\n     B = sp_get(A->m,A->n,5);\n   else\n     if ( A->m != B->m || A->n != B->n )\n       error(E_SIZES,""sp_smlt"");\n\n   for (i=0; i < A->m; i++) {\n      sprow_smlt(&(A->row[i]),alpha,0,&(B->row[i]),TYPE_SPMAT);\n   }\n   return B;\n}\n\n\n\n/* sp_zero -- zero all the (represented) elements of a sparse matrix */\n#ifndef ANSI_C\nSPMAT	*sp_zero(A)\nSPMAT	*A;\n#else\nSPMAT	*sp_zero(SPMAT *A)\n#endif\n{\n   int	i, idx, len;\n   row_elt	*elt;\n   \n   if ( ! A )\n     error(E_NULL,""sp_zero"");\n   \n   for ( i = 0; i < A->m; i++ )\n   {\n      elt = A->row[i].elt;\n      len = A->row[i].len;\n      for ( idx = 0; idx < len; idx++ )\n	(*elt++).val = 0.0;\n   }\n   \n   return A;\n}\n\n/* sp_copy2 -- copy sparse matrix (type 2) \n   -- keeps structure of the OUT matrix */\n#ifndef ANSI_C\nSPMAT	*sp_copy2(A,OUT)\nSPMAT	*A, *OUT;\n#else\nSPMAT	*sp_copy2(const SPMAT *A, SPMAT *OUT)\n#endif\n{\n   int	i /* , idx, len1, len2 */;\n   SPROW	*r1, *r2;\n   STATIC SPROW	*scratch = (SPROW *)NULL;\n   /* row_elt	*e1, *e2; */\n   \n   if ( ! A )\n     error(E_NULL,""sp_copy2"");\n   if ( ! OUT )\n     OUT = sp_get(A->m,A->n,10);\n   if ( ! scratch ) {\n      scratch = sprow_xpd(scratch,MINROWLEN,TYPE_SPROW);\n      MEM_STAT_REG(scratch,TYPE_SPROW);\n   }\n\n   if ( OUT->m < A->m )\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_m*sizeof(SPROW),\n		      A->m*sizeof(SPROW));\n      }\n\n      OUT->row = RENEW(OUT->row,A->m,SPROW);\n      if ( ! OUT->row )\n	error(E_MEM,""sp_copy2"");\n      \n      for ( i = OUT->m; i < A->m; i++ )\n      {\n	 OUT->row[i].elt = NEW_A(MINROWLEN,row_elt);\n	 if ( ! OUT->row[i].elt )\n	   error(E_MEM,""sp_copy2"");\n	 else if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,0,MINROWLEN*sizeof(row_elt));\n	 }\n	 \n	 OUT->row[i].maxlen = MINROWLEN;\n	 OUT->row[i].len = 0;\n      }\n      OUT->m = A->m;\n   }\n   \n   OUT->flag_col = OUT->flag_diag = FALSE;\n   /* sp_zero(OUT); */\n\n   for ( i = 0; i < A->m; i++ )\n   {\n      r1 = &(A->row[i]);	r2 = &(OUT->row[i]);\n      sprow_copy(r1,r2,scratch,TYPE_SPROW);\n      if ( r2->maxlen < scratch->len )\n	sprow_xpd(r2,scratch->len,TYPE_SPMAT);\n      MEM_COPY((char *)(scratch->elt),(char *)(r2->elt),\n	       scratch->len*sizeof(row_elt));\n      r2->len = scratch->len;\n      /*******************************************************\n	e1 = r1->elt;		e2 = r2->elt;\n	len1 = r1->len;		len2 = r2->len;\n	for ( idx = 0; idx < len2; idx++, e2++ )\n	e2->val = 0.0;\n	for ( idx = 0; idx < len1; idx++, e1++ )\n	sprow_set_val(r2,e1->col,e1->val);\n	*******************************************************/\n   }\n\n   sp_col_access(OUT);\n\n#ifdef	THREADSAFE\n   sprow_free(scratch);\n#endif\n\n   return OUT;\n}\n\n/* sp_resize -- resize a sparse matrix\n   -- don't destroying any contents if possible\n   -- returns resized matrix */\n#ifndef ANSI_C\nSPMAT	*sp_resize(A,m,n)\nSPMAT	*A;\nint	m, n;\n#else\nSPMAT	*sp_resize(SPMAT *A, int m, int n)\n#endif\n{\n   int	i, len;\n   SPROW	*r;\n   \n   if (m < 0 || n < 0)\n     error(E_NEG,""sp_resize"");\n\n   if ( ! A )\n     return sp_get(m,n,10);\n\n   if (m == A->m && n == A->n)\n     return A;\n\n   if ( m <= A->max_m )\n   {\n      for ( i = A->m; i < m; i++ )\n	A->row[i].len = 0;\n      A->m = m;\n   }\n   else\n   {\n      if (mem_info_is_on()) {\n	 mem_bytes(TYPE_SPMAT,A->max_m*sizeof(SPROW),\n			 m*sizeof(SPROW));\n      }\n\n      A->row = RENEW(A->row,(unsigned)m,SPROW);\n      if ( ! A->row )\n	error(E_MEM,""sp_resize"");\n      for ( i = A->m; i < m; i++ )\n      {\n	 if ( ! (A->row[i].elt = NEW_A(MINROWLEN,row_elt)) )\n	   error(E_MEM,""sp_resize"");\n	 else if (mem_info_is_on()) {\n	    mem_bytes(TYPE_SPMAT,0,MINROWLEN*sizeof(row_elt));\n	 }\n	 A->row[i].len = 0;	A->row[i].maxlen = MINROWLEN;\n      }\n      A->m = A->max_m = m;\n   }\n\n   /* update number of rows */\n   A->n = n;\n\n   /* do we need to increase the size of start_idx[] and start_row[] ? */\n   if ( n > A->max_n )\n   {	/* only have to update the start_idx & start_row arrays */\n      if (mem_info_is_on())\n      {\n	  mem_bytes(TYPE_SPMAT,2*A->max_n*sizeof(int),\n		    2*n*sizeof(int));\n      }\n\n      A->start_row = RENEW(A->start_row,(unsigned)n,int);\n      A->start_idx = RENEW(A->start_idx,(unsigned)n,int);\n      if ( ! A->start_row || ! A->start_idx )\n	error(E_MEM,""sp_resize"");\n      A->max_n = n;	/* ...and update max_n */\n\n      return A;\n   }\n\n   if ( n <= A->n )\n       /* make sure that all rows are truncated just before column n */\n       for ( i = 0; i < A->m; i++ )\n       {\n	   r = &(A->row[i]);\n	   len = sprow_idx(r,n);\n	   if ( len < 0 )\n	       len = -(len+2);\n	   if ( len < 0 )\n	       error(E_MEM,""sp_resize"");\n	   r->len = len;\n       }\n   \n   return A;\n}\n\n\n/* sp_compact -- removes zeros and near-zeros from a sparse matrix */\n#ifndef ANSI_C\nSPMAT	*sp_compact(A,tol)\nSPMAT	*A;\ndouble	tol;\n#else\nSPMAT	*sp_compact(SPMAT *A, double tol)\n#endif\n{\n   int	i, idx1, idx2;\n   SPROW	*r;\n   row_elt	*elt1, *elt2;\n   \n   if (  ! A )\n     error(E_NULL,""sp_compact"");\n   if ( tol < 0.0 )\n     error(E_RANGE,""sp_compact"");\n   \n   A->flag_col = A->flag_diag = FALSE;\n   \n   for ( i = 0; i < A->m; i++ )\n   {\n      r = &(A->row[i]);\n      elt1 = elt2 = r->elt;\n      idx1 = idx2 = 0;\n      while ( idx1 < r->len )\n      {\n	 /* printf(""# sp_compact: idx1 = %d, idx2 = %d\n"",idx1,idx2); */\n	 if ( fabs(elt1->val) <= tol )\n	 {	idx1++;	elt1++;	continue;	}\n	 if ( elt1 != elt2 )\n	   MEM_COPY(elt1,elt2,sizeof(row_elt));\n	 idx1++;	elt1++;\n	 idx2++;	elt2++;\n      }\n      r->len = idx2;\n   }\n   \n   return A;\n}\n\n/* sp_mlt (C) Copyright David Stewart and Fabrizio Novalis <novalis@mars.elet.polimi.it> */\n/* sp_mlt -- computes out = A*B and returns out */\nSPMAT   *sp_mlt(const SPMAT *A, const SPMAT *B, SPMAT *out)\n{\n  int     i, j, k, idx, cp;\n  SPROW   *rA, *rB, *rout, *rtemp;\n  double  valA;\n\n  if ( ! A || ! B )\n    error(E_NULL,""sp_mlt"");\n  if ( A->n != B->m )\n    error(E_SIZES,""sp_mlt"");\n  out = sp_resize(out,A->m,B->n);\n  sp_zero(out);\n  rtemp = sprow_get(B->n);\n  for ( i = 0; i < A->m; i++ ) /* per ogni riga */\n    {\n      rtemp = sprow_resize(rtemp,0,TYPE_SPROW);\n      rA = &(A->row[i]);\n      rout = &(out->row[i]);\n      for ( idx = 0; idx < rA->len; idx++ ) /* per ogni elemento != 0\n					       della riga corrente */\n	{\n	  j = rA->elt[idx].col;\n	  valA = rA->elt[idx].val;\n	  rB = &(B->row[j]);\n	  sprow_mltadd(rtemp,rB,valA,0,rout,TYPE_SPMAT);\n\n	  for ( cp = 0; cp < rout->len; cp++ )\n	    {\n	      rtemp->elt[cp].col = rout->elt[cp].col;\n	      rtemp->elt[cp].val = rout->elt[cp].val;\n	    }\n	  rtemp->len=rout->len;\n	}\n    }\n  return out;\n}\n\n/* varying number of arguments */\n\n#ifdef ANSI_C\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   sp_get_vars(m,n,deg,&x,&y,&z,...,NULL);\n   where \n     int m,n,deg;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m x n is the dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables\n*/\n\nint sp_get_vars(int m,int n,int deg,...) \n{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap, deg);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_get(m,n,deg);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   sp_resize_vars(m,n,&x,&y,&z,...,NULL);\n   where \n     int m,n;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m X n is the resized dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n*/\n  \nint sp_resize_vars(int m,int n,...) \n{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap, n);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   sp_free_vars(&x,&y,&z,...,NULL);\n   where \n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n*/\n\nint sp_free_vars(SPMAT **va,...)\n{\n   va_list ap;\n   int i=1;\n   SPMAT **par;\n   \n   sp_free(*va);\n   *va = (SPMAT *) NULL;\n   va_start(ap, va);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      sp_free(*par); \n      *par = (SPMAT *)NULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#elif VARARGS\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   sp_get_vars(m,n,deg,&x,&y,&z,...,NULL);\n   where \n     int m,n,deg;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m x n is the dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables\n*/\n\nint sp_get_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n, deg;\n   SPMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   deg = va_arg(ap,int);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_get(m,n,deg);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n/* To resize memory for many arguments. \n   The function should be called:\n   sp_resize_vars(m,n,&x,&y,&z,...,NULL);\n   where \n     int m,n;\n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     m X n is the resized dimension of matrices x,y,z,...\n     returned value is equal to the number of allocated variables.\n     If one of x,y,z,.. arguments is NULL then memory is allocated to this \n     argument. \n*/\n\nint sp_resize_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0, m, n;\n   SPMAT **par;\n   \n   va_start(ap);\n   m = va_arg(ap,int);\n   n = va_arg(ap,int);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      *par = sp_resize(*par,m,n);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n/* To deallocate memory for many arguments. \n   The function should be called:\n   sp_free_vars(&x,&y,&z,...,NULL);\n   where \n     SPMAT *x, *y, *z,...;\n     The last argument should be NULL ! \n     There must be at least one not NULL argument.\n     returned value is equal to the number of allocated variables.\n     Returned value of x,y,z,.. is VNULL.\n*/\n\nint sp_free_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int i=0;\n   SPMAT **par;\n   \n   va_start(ap);\n   while (par = va_arg(ap,SPMAT **)) {   /* NULL ends the list*/\n      sp_free(*par); \n      *par = (SPMAT *)NULL;\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n\n#endif\n\n"
leukocyte/meschach_lib/hsehldr.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n		Files for matrix computations\n\n	Householder transformation file. Contains routines for calculating\n	householder transformations, applying them to vectors and matrices\n	by both row & column.\n*/\n\n/* hsehldr.c 1.3 10/8/87 */\nstatic	char	rcsid[] = ""$Id: hsehldr.c,v 1.2 1994/01/13 05:36:29 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\n/* hhvec -- calulates Householder vector to eliminate all entries after the\n	i0 entry of the vector vec. It is returned as out. May be in-situ */\n#ifndef ANSI_C\nVEC	*hhvec(vec,i0,beta,out,newval)\nVEC	*vec,*out;\nunsigned int	i0;\nReal	*beta,*newval;\n#else\nVEC	*hhvec(const VEC *vec, unsigned int i0, Real *beta,\n	       VEC *out, Real *newval)\n#endif\n{\n	Real	norm;\n\n	out = _v_copy(vec,out,i0);\n	norm = sqrt(_in_prod(out,out,i0));\n	if ( norm <= 0.0 )\n	{\n		*beta = 0.0;\n		return (out);\n	}\n	*beta = 1.0/(norm * (norm+fabs(out->ve[i0])));\n	if ( out->ve[i0] > 0.0 )\n		*newval = -norm;\n	else\n		*newval = norm;\n	out->ve[i0] -= *newval;\n\n	return (out);\n}\n\n/* hhtrvec -- apply Householder transformation to vector \n	-- that is, out <- (I-beta.hh(i0:n).hh(i0:n)^T).in\n	-- may be in-situ */\n#ifndef ANSI_C\nVEC	*hhtrvec(hh,beta,i0,in,out)\nVEC	*hh,*in,*out;	/* hh = Householder vector */\nunsigned int	i0;\ndouble	beta;\n#else\nVEC	*hhtrvec(const VEC *hh, double beta, unsigned int i0,\n		 const VEC *in, VEC *out)\n#endif\n{\n	Real	scale;\n	/* unsigned int	i; */\n\n	if ( hh==VNULL || in==VNULL )\n		error(E_NULL,""hhtrvec"");\n	if ( in->dim != hh->dim )\n		error(E_SIZES,""hhtrvec"");\n	if ( i0 > in->dim )\n		error(E_BOUNDS,""hhtrvec"");\n\n	scale = beta*_in_prod(hh,in,i0);\n	out = v_copy(in,out);\n	__mltadd__(&(out->ve[i0]),&(hh->ve[i0]),-scale,(int)(in->dim-i0));\n	/************************************************************\n	for ( i=i0; i<in->dim; i++ )\n		out->ve[i] = in->ve[i] - scale*hh->ve[i];\n	************************************************************/\n\n	return (out);\n}\n\n/* hhtrrows -- transform a matrix by a Householder vector by rows\n	starting at row i0 from column j0 -- in-situ\n	-- that is, M(i0:m,j0:n) <- M(i0:m,j0:n)(I-beta.hh(j0:n).hh(j0:n)^T) */\n#ifndef ANSI_C\nMAT	*hhtrrows(M,i0,j0,hh,beta)\nMAT	*M;\nunsigned int	i0, j0;\nVEC	*hh;\ndouble	beta;\n#else\nMAT	*hhtrrows(MAT *M, unsigned int i0, unsigned int j0,\n		  const VEC *hh, double beta)\n#endif\n{\n	Real	ip, scale;\n	int	i /*, j */;\n\n	if ( M==MNULL || hh==VNULL )\n		error(E_NULL,""hhtrrows"");\n	if ( M->n != hh->dim )\n		error(E_RANGE,""hhtrrows"");\n	if ( i0 > M->m || j0 > M->n )\n		error(E_BOUNDS,""hhtrrows"");\n\n	if ( beta == 0.0 )	return (M);\n\n	/* for each row ... */\n	for ( i = i0; i < M->m; i++ )\n	{	/* compute inner product */\n		ip = __ip__(&(M->me[i][j0]),&(hh->ve[j0]),(int)(M->n-j0));\n		/**************************************************\n		ip = 0.0;\n		for ( j = j0; j < M->n; j++ )\n			ip += M->me[i][j]*hh->ve[j];\n		**************************************************/\n		scale = beta*ip;\n		if ( scale == 0.0 )\n		    continue;\n\n		/* do operation */\n		__mltadd__(&(M->me[i][j0]),&(hh->ve[j0]),-scale,\n							(int)(M->n-j0));\n		/**************************************************\n		for ( j = j0; j < M->n; j++ )\n			M->me[i][j] -= scale*hh->ve[j];\n		**************************************************/\n	}\n\n	return (M);\n}\n\n/* hhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- calls _hhtrcols() with the scratch vector w\n	-- Meschach internal routines should call _hhtrcols() to\n	avoid excessive memory allocation/de-allocation\n*/\n#ifndef ANSI_C\nMAT	*hhtrcols(M,i0,j0,hh,beta)\nMAT	*M;\nunsigned int	i0, j0;\nVEC	*hh;\ndouble	beta;\n#else\nMAT	*hhtrcols(MAT *M, unsigned int i0, unsigned int j0,\n		  const VEC *hh, double beta)\n#endif\n{\n  STATIC VEC	*w = VNULL;\n\n  if ( M == MNULL || hh == VNULL || w == VNULL )\n    error(E_NULL,""hhtrcols"");\n  if ( M->m != hh->dim )\n    error(E_SIZES,""hhtrcols"");\n  if ( i0 > M->m || j0 > M->n )\n    error(E_BOUNDS,""hhtrcols"");\n\n  if ( ! w || w->dim < M->n )\n    w = v_resize(w,M->n);\n  MEM_STAT_REG(w,TYPE_VEC);\n\n  M = _hhtrcols(M,i0,j0,hh,beta,w);\n\n#ifdef THREADSAFE\n  V_FREE(w);\n#endif\n\n  return M;\n}\n\n/* _hhtrcols -- transform a matrix by a Householder vector by columns\n	starting at row i0 from column j0 \n	-- that is, M(i0:m,j0:n) <- (I-beta.hh(i0:m).hh(i0:m)^T)M(i0:m,j0:n)\n	-- in-situ\n	-- scratch vector w passed as argument\n	-- raises error if w == NULL\n*/\n#ifndef ANSI_C\nMAT	*_hhtrcols(M,i0,j0,hh,beta,w)\nMAT	*M;\nunsigned int	i0, j0;\nVEC	*hh;\ndouble	beta;\nVEC	*w;\n#else\nMAT	*_hhtrcols(MAT *M, unsigned int i0, unsigned int j0,\n		   const VEC *hh, double beta, VEC *w)\n#endif\n{\n	/* Real	ip, scale; */\n	int	i /*, k */;\n	/*  STATIC	VEC	*w = VNULL; */\n\n	if ( M == MNULL || hh == VNULL || w == VNULL )\n		error(E_NULL,""_hhtrcols"");\n	if ( M->m != hh->dim )\n		error(E_SIZES,""_hhtrcols"");\n	if ( i0 > M->m || j0 > M->n )\n		error(E_BOUNDS,""_hhtrcols"");\n\n	if ( beta == 0.0 )	return (M);\n\n	if ( w->dim < M->n )\n	  w = v_resize(w,M->n);\n	/*  MEM_STAT_REG(w,TYPE_VEC); */\n	v_zero(w);\n\n	for ( i = i0; i < M->m; i++ )\n	    if ( hh->ve[i] != 0.0 )\n		__mltadd__(&(w->ve[j0]),&(M->me[i][j0]),hh->ve[i],\n							(int)(M->n-j0));\n	for ( i = i0; i < M->m; i++ )\n	    if ( hh->ve[i] != 0.0 )\n		__mltadd__(&(M->me[i][j0]),&(w->ve[j0]),-beta*hh->ve[i],\n							(int)(M->n-j0));\n	return (M);\n}\n\n"
leukocyte/meschach_lib/zvecop.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n#include	<stdio.h>\n#include	""matrix.h""\n#include	""zmatrix.h""\nstatic	char	rcsid[] = ""$Id: zvecop.c,v 1.3 1997/10/07 16:13:54 stewart Exp stewart $"";\n\n\n\n/* _zin_prod -- inner product of two vectors from i0 downwards\n	-- flag != 0 means compute sum_i a[i]*.b[i];\n	-- flag == 0 means compute sum_i a[i].b[i] */\n#ifndef ANSI_C\ncomplex	_zin_prod(a,b,i0,flag)\nZVEC	*a,*b;\nunsigned int	i0, flag;\n#else\ncomplex	_zin_prod(const ZVEC *a, const ZVEC *b, \n		  unsigned int i0, unsigned int flag)\n#endif\n{\n	unsigned int	limit;\n\n	if ( a==ZVNULL || b==ZVNULL )\n		error(E_NULL,""_zin_prod"");\n	limit = min(a->dim,b->dim);\n	if ( i0 > limit )\n		error(E_BOUNDS,""_zin_prod"");\n\n	return __zip__(&(a->ve[i0]),&(b->ve[i0]),(int)(limit-i0),flag);\n}\n\n/* zv_mlt -- scalar-vector multiply -- may be in-situ */\n#ifndef ANSI_C\nZVEC	*zv_mlt(scalar,vector,out)\ncomplex	scalar;\nZVEC	*vector,*out;\n#else\nZVEC	*zv_mlt(complex scalar, const ZVEC *vector, ZVEC *out)\n#endif\n{\n	/* unsigned int	dim, i; */\n	/* complex	*out_ve, *vec_ve; */\n\n	if ( vector==ZVNULL )\n		error(E_NULL,""zv_mlt"");\n	if ( out==ZVNULL || out->dim != vector->dim )\n		out = zv_resize(out,vector->dim);\n	if ( scalar.re == 0.0 && scalar.im == 0.0 )\n		return zv_zero(out);\n	if ( scalar.re == 1.0 && scalar.im == 0.0 )\n		return zv_copy(vector,out);\n\n	__zmlt__(vector->ve,scalar,out->ve,(int)(vector->dim));\n\n	return (out);\n}\n\n/* zv_add -- vector addition -- may be in-situ */\n#ifndef ANSI_C\nZVEC	*zv_add(vec1,vec2,out)\nZVEC	*vec1,*vec2,*out;\n#else\nZVEC	*zv_add(const ZVEC *vec1, const ZVEC *vec2, ZVEC *out)\n#endif\n{\n	unsigned int	dim;\n\n	if ( vec1==ZVNULL || vec2==ZVNULL )\n		error(E_NULL,""zv_add"");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,""zv_add"");\n	if ( out==ZVNULL || out->dim != vec1->dim )\n		out = zv_resize(out,vec1->dim);\n	dim = vec1->dim;\n	__zadd__(vec1->ve,vec2->ve,out->ve,(int)dim);\n\n	return (out);\n}\n\n/* zv_mltadd -- scalar/vector multiplication and addition\n		-- out = v1 + scale.v2		*/\n#ifndef ANSI_C\nZVEC	*zv_mltadd(v1,v2,scale,out)\nZVEC	*v1,*v2,*out;\ncomplex	scale;\n#else\nZVEC	*zv_mltadd(const ZVEC *v1, const ZVEC *v2, complex scale, ZVEC *out)\n#endif\n{\n	/* register unsigned int	dim, i; */\n	/* complex	*out_ve, *v1_ve, *v2_ve; */\n\n	if ( v1==ZVNULL || v2==ZVNULL )\n		error(E_NULL,""zv_mltadd"");\n	if ( v1->dim != v2->dim )\n		error(E_SIZES,""zv_mltadd"");\n	if ( scale.re == 0.0 && scale.im == 0.0 )\n		return zv_copy(v1,out);\n	if ( scale.re == 1.0 && scale.im == 0.0 )\n		return zv_add(v1,v2,out);\n\n	if ( v2 != out )\n	{\n	    tracecatch(out = zv_copy(v1,out),""zv_mltadd"");\n\n	    /* dim = v1->dim; */\n	    __zmltadd__(out->ve,v2->ve,scale,(int)(v1->dim),0);\n	}\n	else\n	{\n	    tracecatch(out = zv_mlt(scale,v2,out),""zv_mltadd"");\n	    out = zv_add(v1,out,out);\n	}\n\n	return (out);\n}\n\n/* zv_sub -- vector subtraction -- may be in-situ */\n#ifndef ANSI_C\nZVEC	*zv_sub(vec1,vec2,out)\nZVEC	*vec1,*vec2,*out;\n#else\nZVEC	*zv_sub(const ZVEC *vec1, const ZVEC *vec2, ZVEC *out)\n#endif\n{\n	/* unsigned int	i, dim; */\n	/* complex	*out_ve, *vec1_ve, *vec2_ve; */\n\n	if ( vec1==ZVNULL || vec2==ZVNULL )\n		error(E_NULL,""zv_sub"");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,""zv_sub"");\n	if ( out==ZVNULL || out->dim != vec1->dim )\n		out = zv_resize(out,vec1->dim);\n\n	__zsub__(vec1->ve,vec2->ve,out->ve,(int)(vec1->dim));\n\n	return (out);\n}\n\n/* zv_map -- maps function f over components of x: out[i] = f(x[i])\n	-- _zv_map sets out[i] = f(x[i],params) */\n#ifndef ANSI_C\nZVEC	*zv_map(f,x,out)\n#ifdef PROTOYPES_IN_STRUCT\ncomplex	(*f)(complex);\n#else\ncomplex (*f)();\n#endif\nZVEC	*x, *out;\n#else\nZVEC	*zv_map(complex (*f)(complex), const ZVEC *x, ZVEC *out)\n#endif\n{\n	complex	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,""zv_map"");\n	if ( ! out || out->dim != x->dim )\n		out = zv_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		out_ve[i] = (*f)(x_ve[i]);\n\n	return out;\n}\n\n#ifndef ANSI_C\nZVEC	*_zv_map(f,params,x,out)\n#ifdef PROTOTYPES_IN_STRUCT\ncomplex	(*f)(void *,complex);\n#else\ncomplex	(*f)();\n#endif\nZVEC	*x, *out;\nvoid	*params;\n#else\nZVEC	*_zv_map(complex (*f)(void *,complex), void *params,\n		 const ZVEC *x, ZVEC *out)\n#endif\n{\n	complex	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,""_zv_map"");\n	if ( ! out || out->dim != x->dim )\n		out = zv_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		out_ve[i] = (*f)(params,x_ve[i]);\n\n	return out;\n}\n\n/* zv_lincomb -- returns sum_i a[i].v[i], a[i] real, v[i] vectors */\n#ifndef ANSI_C\nZVEC	*zv_lincomb(n,v,a,out)\nint	n;	/* number of a's and v's */\ncomplex	a[];\nZVEC	*v[], *out;\n#else\nZVEC	*zv_lincomb(int n, const ZVEC *v[], const complex a[], ZVEC *out)\n#endif\n{\n	int	i;\n\n	if ( ! a || ! v )\n		error(E_NULL,""zv_lincomb"");\n	if ( n <= 0 )\n		return ZVNULL;\n\n	for ( i = 1; i < n; i++ )\n		if ( out == v[i] )\n		    error(E_INSITU,""zv_lincomb"");\n\n	out = zv_mlt(a[0],v[0],out);\n	for ( i = 1; i < n; i++ )\n	{\n		if ( ! v[i] )\n			error(E_NULL,""zv_lincomb"");\n		if ( v[i]->dim != out->dim )\n			error(E_SIZES,""zv_lincomb"");\n		out = zv_mltadd(out,v[i],a[i],out);\n	}\n\n	return out;\n}\n\n\n#ifdef ANSI_C\n\n\n/* zv_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      zv_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (ZVEC *) and ai are numbers (complex)\n*/\n\nZVEC	*zv_linlist(ZVEC *out,ZVEC *v1,complex a1,...)\n{\n   va_list ap;\n   ZVEC *par;\n   complex a_par;\n\n   if ( ! v1 )\n     return ZVNULL;\n   \n   va_start(ap, a1);\n   out = zv_mlt(a1,v1,out);\n   \n   while (par = va_arg(ap,ZVEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,complex);\n      if (a_par.re == 0.0 && a_par.im == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,""zv_linlist"");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,""zv_linlist"");\n\n      if (a_par.re == 1.0 && a_par.im == 0.0)\n	out = zv_add(out,par,out);\n      else if (a_par.re == -1.0 && a_par.im == 0.0)\n	out = zv_sub(out,par,out);\n      else\n	out = zv_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n\n\n#elif VARARGS\n\n/* zv_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      zv_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (ZVEC *) and ai are numbers (complex)\n*/\nZVEC  *zv_linlist(va_alist) va_dcl\n{\n   va_list ap;\n   ZVEC *par, *out;\n   complex a_par;\n\n   va_start(ap);\n   out = va_arg(ap,ZVEC *);\n   par = va_arg(ap,ZVEC *);\n   if ( ! par ) {\n      va_end(ap);\n      return ZVNULL;\n   }\n   \n   a_par = va_arg(ap,complex);\n   out = zv_mlt(a_par,par,out);\n   \n   while (par = va_arg(ap,ZVEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,complex);\n      if (a_par.re == 0.0 && a_par.im == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,""zv_linlist"");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,""zv_linlist"");\n\n      if (a_par.re == 1.0 && a_par.im == 0.0)\n	out = zv_add(out,par,out);\n      else if (a_par.re == -1.0 && a_par.im == 0.0)\n	out = zv_sub(out,par,out);\n      else\n	out = zv_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n\n\n#endif\n\n\n\n/* zv_star -- computes componentwise (Hadamard) product of x1 and x2\n	-- result out is returned */\n#ifndef ANSI_C\nZVEC	*zv_star(x1, x2, out)\nZVEC	*x1, *x2, *out;\n#else\nZVEC	*zv_star(const ZVEC *x1, const ZVEC *x2, ZVEC *out)\n#endif\n{\n    int		i;\n    Real	t_re, t_im;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,""zv_star"");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,""zv_star"");\n    out = zv_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	/* out->ve[i] = x1->ve[i] * x2->ve[i]; */\n	t_re = x1->ve[i].re*x2->ve[i].re - x1->ve[i].im*x2->ve[i].im;\n	t_im = x1->ve[i].re*x2->ve[i].im + x1->ve[i].im*x2->ve[i].re;\n	out->ve[i].re = t_re;\n	out->ve[i].im = t_im;\n    }\n\n    return out;\n}\n\n/* zv_slash -- computes componentwise ratio of x2 and x1\n	-- out[i] = x2[i] / x1[i]\n	-- if x1[i] == 0 for some i, then raise E_SING error\n	-- result out is returned */\n#ifndef ANSI_C\nZVEC	*zv_slash(x1, x2, out)\nZVEC	*x1, *x2, *out;\n#else\nZVEC	*zv_slash(const ZVEC *x1, const ZVEC *x2, ZVEC *out)\n#endif\n{\n    int		i;\n    Real	r2, t_re, t_im;\n    complex	tmp;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,""zv_slash"");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,""zv_slash"");\n    out = zv_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	r2 = x1->ve[i].re*x1->ve[i].re + x1->ve[i].im*x1->ve[i].im;\n	if ( r2 == 0.0 )\n	    error(E_SING,""zv_slash"");\n	tmp.re =   x1->ve[i].re / r2;\n	tmp.im = - x1->ve[i].im / r2;\n	t_re = tmp.re*x2->ve[i].re - tmp.im*x2->ve[i].im;\n	t_im = tmp.re*x2->ve[i].im + tmp.im*x2->ve[i].re;\n	out->ve[i].re = t_re;\n	out->ve[i].im = t_im;\n    }\n\n    return out;\n}\n\n/* zv_sum -- returns sum of entries of a vector */\n#ifndef ANSI_C\ncomplex	zv_sum(x)\nZVEC	*x;\n#else\ncomplex	zv_sum(const ZVEC *x)\n#endif\n{\n    int		i;\n    complex	sum;\n\n    if ( ! x )\n	error(E_NULL,""zv_sum"");\n\n    sum.re = sum.im = 0.0;\n    for ( i = 0; i < x->dim; i++ )\n    {\n	sum.re += x->ve[i].re;\n	sum.im += x->ve[i].im;\n    }\n\n    return sum;\n}\n\n/* px_zvec -- permute vector */\n#ifndef ANSI_C\nZVEC	*px_zvec(px,vector,out)\nPERM	*px;\nZVEC	*vector,*out;\n#else\nZVEC	*px_zvec(PERM *px, ZVEC *vector, ZVEC *out)\n#endif\n{\n    unsigned int	old_i, i, size, start;\n    complex	tmp;\n    \n    if ( px==PNULL || vector==ZVNULL )\n	error(E_NULL,""px_zvec"");\n    if ( px->size > vector->dim )\n	error(E_SIZES,""px_zvec"");\n    if ( out==ZVNULL || out->dim < vector->dim )\n	out = zv_resize(out,vector->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return zv_copy(vector,out);\n    \n    if ( out != vector )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,""px_vec"");\n	    else\n		out->ve[i] = vector->ve[px->pe[i]];\n    }\n    else\n    {	/* in situ algorithm */\n	start = 0;\n	while ( start < size )\n	{\n	    old_i = start;\n	    i = px->pe[old_i];\n	    if ( i >= size )\n	    {\n		start++;\n		continue;\n	    }\n	    tmp = vector->ve[start];\n	    while ( TRUE )\n	    {\n		vector->ve[old_i] = vector->ve[i];\n		px->pe[old_i] = i+size;\n		old_i = i;\n		i = px->pe[old_i];\n		if ( i >= size )\n		    break;\n		if ( i == start )\n		{\n		    vector->ve[old_i] = tmp;\n		    px->pe[old_i] = i+size;\n		    break;\n		}\n	    }\n	    start++;\n	}\n	\n	for ( i = 0; i < size; i++ )\n	    if ( px->pe[i] < size )\n		error(E_BOUNDS,""px_vec"");\n	    else\n		px->pe[i] = px->pe[i]-size;\n    }\n    \n    return out;\n}\n\n/* pxinv_zvec -- apply the inverse of px to x, returning the result in out\n		-- may NOT be in situ */\n#ifndef ANSI_C\nZVEC	*pxinv_zvec(px,x,out)\nPERM	*px;\nZVEC	*x, *out;\n#else\nZVEC	*pxinv_zvec(PERM *px, ZVEC *x, ZVEC *out)\n#endif\n{\n    unsigned int	i, size;\n    \n    if ( ! px || ! x )\n	error(E_NULL,""pxinv_zvec"");\n    if ( px->size > x->dim )\n	error(E_SIZES,""pxinv_zvec"");\n    if ( ! out || out->dim < x->dim )\n	out = zv_resize(out,x->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return zv_copy(x,out);\n    if ( out != x )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,""pxinv_vec"");\n	    else\n		out->ve[px->pe[i]] = x->ve[i];\n    }\n    else\n    {	/* in situ algorithm --- cheat's way out */\n	px_inv(px,px);\n	px_zvec(px,x,out);\n	px_inv(px,px);\n    }\n    \n    \n    return out;\n}\n\n/* zv_rand -- randomise a complex vector; uniform in [0,1)+[0,1)*i */\n#ifndef ANSI_C\nZVEC	*zv_rand(x)\nZVEC	*x;\n#else\nZVEC	*zv_rand(ZVEC *x)\n#endif\n{\n    if ( ! x )\n	error(E_NULL,""zv_rand"");\n\n    mrandlist((Real *)(x->ve),2*x->dim);\n\n    return x;\n}\n"
leukocyte/meschach_lib/givens.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n\n/*\n		Files for matrix computations\n\n	Givens operations file. Contains routines for calculating and\n	applying givens rotations for/to vectors and also to matrices by\n	row and by column.\n*/\n\n/* givens.c 1.2 11/25/87 */\nstatic	char	rcsid[] = ""$Id: givens.c,v 1.3 1995/03/27 15:41:15 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n/* givens -- returns c,s parameters for Givens rotation to\n		eliminate y in the vector [ x y ]' */\n#ifndef ANSI_C\nvoid	givens(x,y,c,s)\ndouble  x,y;\nReal	*c,*s;\n#else\nvoid	givens(double x, double y, Real *c, Real *s)\n#endif\n{\n	Real	norm;\n\n	norm = sqrt(x*x+y*y);\n	if ( norm == 0.0 )\n	{	*c = 1.0;	*s = 0.0;	}	/* identity */\n	else\n	{	*c = x/norm;	*s = y/norm;	}\n}\n\n/* rot_vec -- apply Givens rotation to x's i & k components */\n#ifndef ANSI_C\nVEC	*rot_vec(x,i,k,c,s,out)\nVEC	*x,*out;\nunsigned int	i,k;\ndouble	c,s;\n#else\nVEC	*rot_vec(const VEC *x,unsigned int i,unsigned int k, double c,double s,\n		 VEC *out)\n#endif\n{\n	Real	temp;\n\n	if ( x==VNULL )\n		error(E_NULL,""rot_vec"");\n	if ( i >= x->dim || k >= x->dim )\n		error(E_RANGE,""rot_vec"");\n	out = v_copy(x,out);\n\n	/* temp = c*out->ve[i] + s*out->ve[k]; */\n	temp = c*v_entry(out,i) + s*v_entry(out,k);\n	/* out->ve[k] = -s*out->ve[i] + c*out->ve[k]; */\n	v_set_val(out,k,-s*v_entry(out,i)+c*v_entry(out,k));\n	/* out->ve[i] = temp; */\n	v_set_val(out,i,temp);\n\n	return (out);\n}\n\n/* rot_rows -- premultiply mat by givens rotation described by c,s */\n#ifndef ANSI_C\nMAT	*rot_rows(mat,i,k,c,s,out)\nMAT	*mat,*out;\nunsigned int	i,k;\ndouble	c,s;\n#else\nMAT	*rot_rows(const MAT *mat, unsigned int i, unsigned int k,\n		  double c, double s, MAT *out)\n#endif\n{\n	unsigned int	j;\n	Real	temp;\n\n	if ( mat==(MAT *)NULL )\n		error(E_NULL,""rot_rows"");\n	if ( i >= mat->m || k >= mat->m )\n		error(E_RANGE,""rot_rows"");\n	if ( mat != out )\n		out = m_copy(mat,m_resize(out,mat->m,mat->n));\n\n	for ( j=0; j<mat->n; j++ )\n	{\n		/* temp = c*out->me[i][j] + s*out->me[k][j]; */\n		temp = c*m_entry(out,i,j) + s*m_entry(out,k,j);\n		/* out->me[k][j] = -s*out->me[i][j] + c*out->me[k][j]; */\n		m_set_val(out,k,j, -s*m_entry(out,i,j) + c*m_entry(out,k,j));\n		/* out->me[i][j] = temp; */\n		m_set_val(out,i,j, temp);\n	}\n\n	return (out);\n}\n\n/* rot_cols -- postmultiply mat by givens rotation described by c,s */\n#ifndef ANSI_C\nMAT	*rot_cols(mat,i,k,c,s,out)\nMAT	*mat,*out;\nunsigned int	i,k;\ndouble	c,s;\n#else\nMAT	*rot_cols(const MAT *mat,unsigned int i,unsigned int k,\n		  double c, double s, MAT *out)\n#endif\n{\n	unsigned int	j;\n	Real	temp;\n\n	if ( mat==(MAT *)NULL )\n		error(E_NULL,""rot_cols"");\n	if ( i >= mat->n || k >= mat->n )\n		error(E_RANGE,""rot_cols"");\n	if ( mat != out )\n		out = m_copy(mat,m_resize(out,mat->m,mat->n));\n\n	for ( j=0; j<mat->m; j++ )\n	{\n		/* temp = c*out->me[j][i] + s*out->me[j][k]; */\n		temp = c*m_entry(out,j,i) + s*m_entry(out,j,k);\n		/* out->me[j][k] = -s*out->me[j][i] + c*out->me[j][k]; */\n		m_set_val(out,j,k, -s*m_entry(out,j,i) + c*m_entry(out,j,k));\n		/* out->me[j][i] = temp; */\n		m_set_val(out,j,i,temp);\n	}\n\n	return (out);\n}\n\n"
leukocyte/meschach_lib/version.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*			Version routine			*/\n/*	This routine must be modified whenever modifications are made to\n	Meschach by persons other than the original authors\n	(David E. Stewart & Zbigniew Leyk); \n	when new releases of Meschach are made the\n	version number will also be updated\n*/\n\n#include	<stdio.h>\n\nvoid	m_version()\n{\n	static char rcsid[] = ""$Id: version.c,v 1.9 1994/03/24 00:04:05 des Exp $"";\n\n	printf(""Meshach matrix library version 1.2b\n"");\n	printf(""RCS id: %s\n"",rcsid);\n	printf(""Changes since 1.2a:\n"");\n	printf(""\t Fixed bug in schur() for 2x2 blocks with real e-vals\n"");\n	printf(""\t Fixed bug in schur() reading beyond end of array\n"");\n	printf(""\t Fixed some installation bugs\n"");\n	printf(""\t Fixed bugs & improved efficiency in spILUfactor()\n"");\n	printf(""\t px_inv() doesn't crash inverting non-permutations\n"");\n	printf(""\t Fixed bug in ifft()\n"");\n	/**** List of modifications ****/\n	/* Example below is for illustration only */\n	/* printf(""Modified by %s, routine(s) %s, file %s on date %s\n"",\n			""Joe Bloggs"",\n			""m_version"",\n			""version.c"",\n			""Fri Apr  5 16:00:38 EST 1994""); */\n	/* printf(""Purpose: %s\n"",\n			""To update the version number""); */\n}\n\n/* $Log: version.c,v $\n * Revision 1.9  1994/03/24  00:04:05  des\n * Added notes on changes to spILUfactor() and px_inv().\n *\n * Revision 1.8  1994/02/21  04:32:25  des\n * Set version to 1.2b with bug fixes in schur() and installation.\n *\n * Revision 1.7  1994/01/13  05:43:57  des\n * Version 1.2 update\n *\n\n * */\n"
leukocyte/meschach_lib/meminfo.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* meminfo.c  revised  22/11/93 */\n\n/* \n  contains basic functions, types and arrays \n  to keep track of memory allocation/deallocation\n*/\n\n#include <stdio.h>\n#include  ""matrix.h""\n#include  ""meminfo.h""\n#ifdef COMPLEX   \n#include  ""zmatrix.h""\n#endif\n#ifdef SPARSE\n#include  ""sparse.h""\n#include  ""iter.h""\n#endif\n\nstatic char rcsid[] = ""$Id: meminfo.c,v 1.1 1994/01/13 05:31:39 des Exp $"";\n\n/* this array is defined further in this file */\nextern MEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS];\n\n\n/* names of types */\nstatic char *mem_type_names[] = {\n   ""MAT"",\n   ""BAND"",\n   ""PERM"",\n   ""VEC"",\n   ""IVEC""\n#ifdef SPARSE\n     ,""ITER"",\n     ""SPROW"",\n     ""SPMAT""\n#endif\n#ifdef COMPLEX   \n       ,""ZVEC"",\n       ""ZMAT""\n#endif\n      };\n\n\n#define MEM_NUM_STD_TYPES  (sizeof(mem_type_names)/sizeof(mem_type_names[0]))\n\n\n/* local array for keeping track of memory */\nstatic MEM_ARRAY   mem_info_sum[MEM_NUM_STD_TYPES];  \n\n\n/* for freeing various types */\nstatic int (*mem_free_funcs[MEM_NUM_STD_TYPES])() = {\n   m_free,\n   bd_free,\n   px_free,    \n   v_free,	\n   iv_free\n#ifdef SPARSE\n     ,iter_free,	\n     sprow_free, \n     sp_free\n#endif\n#ifdef COMPLEX\n       ,zv_free,	\n       zm_free\n#endif\n      };\n\n\n\n/* it is a global variable for passing \n   pointers to local arrays defined here */\nMEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS] = {\n { mem_type_names, mem_free_funcs, MEM_NUM_STD_TYPES, \n     mem_info_sum } \n};\n\n\n/* attach a new list of types */\n#ifndef ANSI_C\nint mem_attach_list(list, ntypes, type_names, free_funcs, info_sum)\nint list,ntypes;         /* number of a list and number of types there */\nchar *type_names[];      /* list of names of types */\nint (*free_funcs[])();   /* list of releasing functions */\nMEM_ARRAY info_sum[];    /* local table */\n#else\nint mem_attach_list(int list, int ntypes, \n		    char *type_names[], \n		    int (*free_funcs[])(void *), \n		    MEM_ARRAY info_sum[])\n#endif\n{\n   if (list < 0 || list >= MEM_CONNECT_MAX_LISTS)\n     return -1;\n\n   if (type_names == NULL || free_funcs == NULL \n       || info_sum == NULL || ntypes < 0)\n     return -1;\n   \n   /* if a list exists do not overwrite */\n   if ( mem_connect[list].ntypes != 0 )\n     error(E_OVERWRITE,""mem_attach_list"");\n   \n   mem_connect[list].ntypes = ntypes;\n   mem_connect[list].type_names = type_names;\n   mem_connect[list].free_funcs = free_funcs;\n   mem_connect[list].info_sum = info_sum;\n   return 0;\n}\n\n\n/* release a list of types */\n#ifndef ANSI_C\nint mem_free_vars(list)\nint list;\n#else\nint mem_free_vars(int list)\n#endif\n{	\n   if (list < 0 || list >= MEM_CONNECT_MAX_LISTS)\n     return -1;\n   \n   mem_connect[list].ntypes = 0;\n   mem_connect[list].type_names = NULL;\n   mem_connect[list].free_funcs = NULL;\n   mem_connect[list].info_sum = NULL;\n   \n   return 0;\n}\n\n\n\n/* check if list is attached */\n#ifndef ANSI_C\nint mem_is_list_attached(list)\nint list;\n#else\nint mem_is_list_attached(int list)\n#endif\n{\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n   return FALSE;\n\n   if ( mem_connect[list].type_names != NULL &&\n        mem_connect[list].free_funcs != NULL &&\n        mem_connect[list].info_sum != NULL)\n     return TRUE;\n   else return FALSE;\n}\n\n/* to print out the contents of mem_connect[list] */\n#ifndef MEX\n\n#ifndef ANSI_C\nvoid mem_dump_list(fp,list)\nFILE *fp;\nint list;\n#else\nvoid mem_dump_list(FILE *fp, int list)\n#endif\n{\n   int i;\n   MEM_CONNECT *mlist;\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n\n   mlist = &mem_connect[list];\n   fprintf(fp,"" %15s[%d]:\n"",""CONTENTS OF mem_connect"",list);\n   fprintf(fp,"" %-7s   %-12s   %-9s   %s\n"",\n	   ""name of"",\n	   ""alloc."", ""# alloc."",\n	   ""address""\n	   );\n   fprintf(fp,"" %-7s   %-12s   %-9s   %s\n"",\n	   "" type"",\n	   ""bytes"", ""variables"",\n	   ""of *_free()""\n	   );\n\n   for (i=0; i < mlist->ntypes; i++) \n     fprintf(fp,""  %-7s   %-12ld   %-9d   %p\n"",\n	     mlist->type_names[i], mlist->info_sum[i].bytes,\n	     mlist->info_sum[i].numvar, mlist->free_funcs[i]\n	     );\n   \n   fprintf(fp,""\n"");\n}\n#endif /* MEX */\n\n\n\n/*=============================================================*/\n\n\n/* local variables */\n\nstatic int	mem_switched_on = MEM_SWITCH_ON_DEF;  /* on/off */\n\n\n/* switch on/off memory info */\n#ifndef ANSI_C\nint mem_info_on(sw)\nint sw;\n#else\nint mem_info_on(int sw)\n#endif\n{\n   int old = mem_switched_on;\n   \n   mem_switched_on = sw;\n   return old;\n}\n\n#ifdef ANSI_C\nint mem_info_is_on(void)\n#else\nint mem_info_is_on()\n#endif\n{\n   return mem_switched_on;\n}\n\n\n/* information about allocated memory */\n\n/* return the number of allocated bytes for type 'type' */\n#ifndef ANSI_C\nlong mem_info_bytes(type,list)\nint type,list;\n#else\nlong mem_info_bytes(int type, int list)\n#endif\n{\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return 0l;\n   if ( !mem_switched_on || type < 0 \n       || type >= mem_connect[list].ntypes\n       || mem_connect[list].free_funcs[type] == NULL )\n     return 0l;\n   \n   return mem_connect[list].info_sum[type].bytes;\n}\n\n/* return the number of allocated variables for type 'type' */\n#ifndef ANSI_C\nint mem_info_numvar(type,list)\nint type,list;\n#else\nint mem_info_numvar(int type, int list)\n#endif\n{\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return 0l;\n   if ( !mem_switched_on || type < 0 \n       || type >= mem_connect[list].ntypes\n       || mem_connect[list].free_funcs[type] == NULL )\n     return 0l;\n   \n   return mem_connect[list].info_sum[type].numvar;\n}\n\n\n#ifndef MEX\n\n/* print out memory info to the file fp */\n#ifndef ANSI_C\nvoid mem_info_file(fp,list)\nFILE *fp;\nint list;\n#else\nvoid mem_info_file(FILE *fp, int list)\n#endif\n{\n   unsigned int type;\n   long t = 0l, d;\n   int n = 0, nt = 0;\n   MEM_CONNECT *mlist;\n   \n   if (!mem_switched_on) return;\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n   \n   if (list == 0)\n     fprintf(fp,"" MEMORY INFORMATION (standard types):\n"");\n   else\n     fprintf(fp,"" MEMORY INFORMATION (list no. %d):\n"",list);\n\n   mlist = &mem_connect[list];\n\n   for (type=0; type < mlist->ntypes; type++) {\n      if (mlist->type_names[type] == NULL ) continue;\n      d = mlist->info_sum[type].bytes;\n      t += d;\n      n = mlist->info_sum[type].numvar;\n      nt += n;\n      fprintf(fp,"" type %-7s %10ld alloc. byte%c  %6d alloc. variable%c\n"",\n	      mlist->type_names[type], d, (d!=1 ? 's' : ' '),\n	      n, (n!=1 ? 's' : ' '));\n   }\n\n   fprintf(fp,"" %-12s %10ld alloc. byte%c  %6d alloc. variable%c\n\n"",\n	   ""total:"",t, (t!=1 ? 's' : ' '),\n	   nt, (nt!=1 ? 's' : ' '));\n}\n#endif\n\n\n/* function for memory information */\n\n\n/* mem_bytes_list\n   \n   Arguments:\n   type - the number of type;\n   old_size - old size of allocated memory (in bytes);\n   new_size - new size of allocated memory (in bytes);\n   list - list of types\n   */\n#ifndef ANSI_C\nvoid mem_bytes_list(type,old_size,new_size,list)\nint type,list;\nint old_size,new_size;\n#else\nvoid mem_bytes_list(int type, int old_size, int new_size, int list)\n#endif\n{\n   MEM_CONNECT *mlist;\n   \n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n   \n   mlist = &mem_connect[list];\n   if (  type < 0 || type >= mlist->ntypes\n       || mlist->free_funcs[type] == NULL )\n     return;\n\n   if ( old_size < 0 || new_size < 0 )\n     error(E_NEG,""mem_bytes_list"");\n\n   mlist->info_sum[type].bytes += new_size - old_size;\n   \n   /* check if the number of bytes is non-negative */\n   if ( old_size > 0 ) {\n\n      if (mlist->info_sum[type].bytes < 0)\n      {\n#ifndef MEX\n	 fprintf(stderr,\n	   ""\n WARNING !! memory info: allocated memory is less than 0\n"");\n	 fprintf(stderr,""\t TYPE %s \n\n"", mlist->type_names[type]);\n\n	 if ( !isatty(fileno(stdout)) ) {\n	    fprintf(stdout,\n	      ""\n WARNING !! memory info: allocated memory is less than 0\n"");\n	    fprintf(stdout,""\t TYPE %s \n\n"", mlist->type_names[type]);\n	 }\n#else\n	 mexPrintf(""\n WARNING !! memory info: allocated memory < 0\n"");\n	 mexPrintf(""\t TYPE %s \n\n"", mlist->type_names[type]);\n#endif\n      }\n   }\n}\n\n\n\n/* mem_numvar_list\n   \n   Arguments:\n   type - the number of type;\n   num - # of variables allocated (> 0) or deallocated ( < 0)\n   list - list of types\n   */\n\n#ifndef ANSI_C\nvoid mem_numvar_list(type,num,list)\nint type,list,num;\n#else\nvoid mem_numvar_list(int type, int num, int list)\n#endif\n{\n   MEM_CONNECT *mlist;\n   \n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return;\n   \n   mlist = &mem_connect[list];\n   if (  type < 0 || type >= mlist->ntypes\n       || mlist->free_funcs[type] == NULL )\n     return;\n\n   mlist->info_sum[type].numvar += num;\n   \n   /* check if the number of variables is non-negative */\n   if ( num < 0 ) {\n\n      if (mlist->info_sum[type].numvar < 0)\n      {\n#ifndef MEX\n	 fprintf(stderr,\n       ""\n WARNING !! memory info: allocated # of variables is less than 0\n"");\n	 fprintf(stderr,""\t TYPE %s \n\n"", mlist->type_names[type]);\n	 if ( !isatty(fileno(stdout)) ) {\n	    fprintf(stdout,\n      ""\n WARNING !! memory info: allocated # of variables is less than 0\n"");\n	    fprintf(stdout,""\t TYPE %s \n\n"", mlist->type_names[type]);\n	 }\n#else\n	 mexPrintf(""\n WARNING !! memory info: allocated # of variables < 0\n"");\n	 mexPrintf(stderr,""\t TYPE %s \n\n"", mlist->type_names[type]);\n#endif\n      }\n   }\n}\n\n"
leukocyte/meschach_lib/symmeig.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File containing routines for symmetric eigenvalue problems\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\nstatic char rcsid[] = ""$Id: symmeig.c,v 1.6 1995/03/27 15:45:55 des Exp $"";\n\n\n\n#define	SQRT2	1.4142135623730949\n#define	sgn(x)	( (x) >= 0 ? 1 : -1 )\n\n/* trieig -- finds eigenvalues of symmetric tridiagonal matrices\n	-- matrix represented by a pair of vectors a (diag entries)\n		and b (sub- & super-diag entries)\n	-- eigenvalues in a on return */\n#ifndef ANSI_C\nVEC	*trieig(a,b,Q)\nVEC	*a, *b;\nMAT	*Q;\n#else\nVEC	*trieig(VEC *a, VEC *b, MAT *Q)\n#endif\n{\n	int	i, i_min, i_max, n, split;\n	Real	*a_ve, *b_ve;\n	Real	b_sqr, bk, ak1, bk1, ak2, bk2, z;\n	Real	c, c2, cs, s, s2, d, mu;\n\n	if ( ! a || ! b )\n		error(E_NULL,""trieig"");\n	if ( a->dim != b->dim + 1 || ( Q && Q->m != a->dim ) )\n		error(E_SIZES,""trieig"");\n	if ( Q && Q->m != Q->n )\n		error(E_SQUARE,""trieig"");\n\n	n = a->dim;\n	a_ve = a->ve;		b_ve = b->ve;\n\n	i_min = 0;\n	while ( i_min < n )		/* outer while loop */\n	{\n		/* find i_max to suit;\n			submatrix i_min..i_max should be irreducible */\n		i_max = n-1;\n		for ( i = i_min; i < n-1; i++ )\n		    if ( b_ve[i] == 0.0 )\n		    {	i_max = i;	break;	}\n		if ( i_max <= i_min )\n		{\n		    /* printf(""# i_min = %d, i_max = %d\n"",i_min,i_max); */\n		    i_min = i_max + 1;\n		    continue;	/* outer while loop */\n		}\n\n		/* printf(""# i_min = %d, i_max = %d\n"",i_min,i_max); */\n\n		/* repeatedly perform QR method until matrix splits */\n		split = FALSE;\n		while ( ! split )		/* inner while loop */\n		{\n\n		    /* find Wilkinson shift */\n		    d = (a_ve[i_max-1] - a_ve[i_max])/2;\n		    b_sqr = b_ve[i_max-1]*b_ve[i_max-1];\n		    mu = a_ve[i_max] - b_sqr/(d + sgn(d)*sqrt(d*d+b_sqr));\n		    /* printf(""# Wilkinson shift = %g\n"",mu); */\n\n		    /* initial Givens' rotation */\n		    givens(a_ve[i_min]-mu,b_ve[i_min],&c,&s);\n		    s = -s;\n		    /* printf(""# c = %g, s = %g\n"",c,s); */\n		    if ( fabs(c) < SQRT2 )\n		    {	c2 = c*c;	s2 = 1-c2;	}\n		    else\n		    {	s2 = s*s;	c2 = 1-s2;	}\n		    cs = c*s;\n		    ak1 = c2*a_ve[i_min]+s2*a_ve[i_min+1]-2*cs*b_ve[i_min];\n		    bk1 = cs*(a_ve[i_min]-a_ve[i_min+1]) +\n						(c2-s2)*b_ve[i_min];\n		    ak2 = s2*a_ve[i_min]+c2*a_ve[i_min+1]+2*cs*b_ve[i_min];\n		    bk2 = ( i_min < i_max-1 ) ? c*b_ve[i_min+1] : 0.0;\n		    z  = ( i_min < i_max-1 ) ? -s*b_ve[i_min+1] : 0.0;\n		    a_ve[i_min] = ak1;\n		    a_ve[i_min+1] = ak2;\n		    b_ve[i_min] = bk1;\n		    if ( i_min < i_max-1 )\n			b_ve[i_min+1] = bk2;\n		    if ( Q )\n			rot_cols(Q,i_min,i_min+1,c,-s,Q);\n		    /* printf(""# z = %g\n"",z); */\n		    /* printf(""# a [temp1] =\n"");	v_output(a); */\n		    /* printf(""# b [temp1] =\n"");	v_output(b); */\n\n		    for ( i = i_min+1; i < i_max; i++ )\n		    {\n			/* get Givens' rotation for sub-block -- k == i-1 */\n			givens(b_ve[i-1],z,&c,&s);\n			s = -s;\n			/* printf(""# c = %g, s = %g\n"",c,s); */\n\n			/* perform Givens' rotation on sub-block */\n		        if ( fabs(c) < SQRT2 )\n		        {	c2 = c*c;	s2 = 1-c2;	}\n		        else\n		        {	s2 = s*s;	c2 = 1-s2;	}\n		        cs = c*s;\n			bk  = c*b_ve[i-1] - s*z;\n			ak1 = c2*a_ve[i]+s2*a_ve[i+1]-2*cs*b_ve[i];\n			bk1 = cs*(a_ve[i]-a_ve[i+1]) +\n						(c2-s2)*b_ve[i];\n			ak2 = s2*a_ve[i]+c2*a_ve[i+1]+2*cs*b_ve[i];\n			bk2 = ( i+1 < i_max ) ? c*b_ve[i+1] : 0.0;\n			z  = ( i+1 < i_max ) ? -s*b_ve[i+1] : 0.0;\n			a_ve[i] = ak1;	a_ve[i+1] = ak2;\n			b_ve[i] = bk1;\n			if ( i < i_max-1 )\n			    b_ve[i+1] = bk2;\n			if ( i > i_min )\n			    b_ve[i-1] = bk;\n			if ( Q )\n			    rot_cols(Q,i,i+1,c,-s,Q);\n		        /* printf(""# a [temp2] =\n"");	v_output(a); */\n		        /* printf(""# b [temp2] =\n"");	v_output(b); */\n		    }\n\n		    /* test to see if matrix should be split */\n		    for ( i = i_min; i < i_max; i++ )\n			if ( fabs(b_ve[i]) < MACHEPS*\n					(fabs(a_ve[i])+fabs(a_ve[i+1])) )\n			{   b_ve[i] = 0.0;	split = TRUE;	}\n\n		    /* printf(""# a =\n"");	v_output(a); */\n		    /* printf(""# b =\n"");	v_output(b); */\n		}\n	}\n\n	return a;\n}\n\n/* symmeig -- computes eigenvalues of a dense symmetric matrix\n	-- A **must** be symmetric on entry\n	-- eigenvalues stored in out\n	-- Q contains orthogonal matrix of eigenvectors\n	-- returns vector of eigenvalues */\n#ifndef ANSI_C\nVEC	*symmeig(A,Q,out)\nMAT	*A, *Q;\nVEC	*out;\n#else\nVEC	*symmeig(const MAT *A, MAT *Q, VEC *out)\n#endif\n{\n	int	i;\n	STATIC MAT	*tmp = MNULL;\n	STATIC VEC	*b   = VNULL, *diag = VNULL, *beta = VNULL;\n\n	if ( ! A )\n		error(E_NULL,""symmeig"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""symmeig"");\n	if ( ! out || out->dim != A->m )\n		out = v_resize(out,A->m);\n\n	tmp  = m_resize(tmp,A->m,A->n);\n	tmp  = m_copy(A,tmp);\n	b    = v_resize(b,A->m - 1);\n	diag = v_resize(diag,(unsigned int)A->m);\n	beta = v_resize(beta,(unsigned int)A->m);\n	MEM_STAT_REG(tmp,TYPE_MAT);\n	MEM_STAT_REG(b,TYPE_VEC);\n	MEM_STAT_REG(diag,TYPE_VEC);\n	MEM_STAT_REG(beta,TYPE_VEC);\n\n	Hfactor(tmp,diag,beta);\n	if ( Q )\n		makeHQ(tmp,diag,beta,Q);\n\n	for ( i = 0; i < A->m - 1; i++ )\n	{\n		out->ve[i] = tmp->me[i][i];\n		b->ve[i] = tmp->me[i][i+1];\n	}\n	out->ve[i] = tmp->me[i][i];\n	trieig(out,b,Q);\n\n#ifdef	THREADSAFE\n	M_FREE(tmp);	V_FREE(b);	V_FREE(diag);	V_FREE(beta);\n#endif\n	return out;\n}\n\n"
leukocyte/meschach_lib/chfactor.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* CHfactor.c 1.2 11/25/87 */\nstatic	char	rcsid[] = ""$Id: chfactor.c,v 1.2 1994/01/13 05:36:36 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* CHfactor -- Cholesky L.L' factorisation of A in-situ */\n#ifndef ANSI_C\nMAT	*CHfactor(A)\nMAT	*A;\n#else\nMAT	*CHfactor(MAT *A)\n#endif\n{\n	unsigned int	i, j, k, n;\n	Real	**A_ent, *A_piv, *A_row, sum, tmp;\n\n	if ( A==(MAT *)NULL )\n		error(E_NULL,""CHfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""CHfactor"");\n	n = A->n;	A_ent = A->me;\n\n	for ( k=0; k<n; k++ )\n	{	\n		/* do diagonal element */\n		sum = A_ent[k][k];\n		A_piv = A_ent[k];\n		for ( j=0; j<k; j++ )\n		{\n			/* tmp = A_ent[k][j]; */\n			tmp = *A_piv++;\n			sum -= tmp*tmp;\n		}\n		if ( sum <= 0.0 )\n			error(E_POSDEF,""CHfactor"");\n		A_ent[k][k] = sqrt(sum);\n\n		/* set values of column k */\n		for ( i=k+1; i<n; i++ )\n		{\n			sum = A_ent[i][k];\n			A_piv = A_ent[k];\n			A_row = A_ent[i];\n			sum -= __ip__(A_row,A_piv,(int)k);\n			/************************************************\n			for ( j=0; j<k; j++ )\n				sum -= A_ent[i][j]*A_ent[k][j];\n				sum -= (*A_row++)*(*A_piv++);\n			************************************************/\n			A_ent[j][i] = A_ent[i][j] = sum/A_ent[k][k];\n		}\n	}\n\n	return (A);\n}\n\n\n/* CHsolve -- given a CHolesky factorisation in A, solve A.x=b */\n#ifndef ANSI_C\nVEC	*CHsolve(A,b,x)\nMAT	*A;\nVEC	*b,*x;\n#else\nVEC	*CHsolve(const MAT *A, const VEC *b, VEC *x)\n#endif\n{\n	if ( A==MNULL || b==VNULL )\n		error(E_NULL,""CHsolve"");\n	if ( A->m != A->n || A->n != b->dim )\n		error(E_SIZES,""CHsolve"");\n	x = v_resize(x,b->dim);\n	Lsolve(A,b,x,0.0);\n	Usolve(A,x,x,0.0);\n\n	return (x);\n}\n\n/* LDLfactor -- L.D.L' factorisation of A in-situ */\n#ifndef ANSI_C\nMAT	*LDLfactor(A)\nMAT	*A;\n#else\nMAT	*LDLfactor(MAT *A)\n#endif\n{\n	unsigned int	i, k, n, p;\n	Real	**A_ent;\n	Real d, sum;\n	STATIC VEC	*r = VNULL;\n\n	if ( ! A )\n		error(E_NULL,""LDLfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""LDLfactor"");\n	n = A->n;	A_ent = A->me;\n	r = v_resize(r,n);\n	MEM_STAT_REG(r,TYPE_VEC);\n\n	for ( k = 0; k < n; k++ )\n	{\n		sum = 0.0;\n		for ( p = 0; p < k; p++ )\n		{\n		    r->ve[p] = A_ent[p][p]*A_ent[k][p];\n		    sum += r->ve[p]*A_ent[k][p];\n		}\n		d = A_ent[k][k] -= sum;\n\n		if ( d == 0.0 )\n		    error(E_SING,""LDLfactor"");\n		for ( i = k+1; i < n; i++ )\n		{\n		    sum = __ip__(A_ent[i],r->ve,(int)k);\n		    /****************************************\n		    sum = 0.0;\n		    for ( p = 0; p < k; p++ )\n			sum += A_ent[i][p]*r->ve[p];\n		    ****************************************/\n		    A_ent[i][k] = (A_ent[i][k] - sum)/d;\n		}\n	}\n\n#ifdef THREADSAFE\n	V_FREE(r);\n#endif\n\n	return A;\n}\n\n/* LDLsolve -- solves linear system A.x = b with A factored by LDLfactor()\n   -- returns x, which is created if it is NULL on entry */\n#ifndef ANSI_C\nVEC	*LDLsolve(LDL,b,x)\nMAT	*LDL;\nVEC	*b, *x;\n#else\nVEC	*LDLsolve(const MAT *LDL, const VEC *b, VEC *x)\n#endif\n{\n	if ( ! LDL || ! b )\n		error(E_NULL,""LDLsolve"");\n	if ( LDL->m != LDL->n )\n		error(E_SQUARE,""LDLsolve"");\n	if ( LDL->m != b->dim )\n		error(E_SIZES,""LDLsolve"");\n	x = v_resize(x,b->dim);\n\n	Lsolve(LDL,b,x,1.0);\n	Dsolve(LDL,x,x);\n	LTsolve(LDL,x,x,1.0);\n\n	return x;\n}\n\n/* MCHfactor -- Modified Cholesky L.L' factorisation of A in-situ */\n#ifndef ANSI_C\nMAT	*MCHfactor(A,tol)\nMAT	*A;\ndouble  tol;\n#else\nMAT	*MCHfactor(MAT *A, double tol)\n#endif\n{\n	unsigned int	i, j, k, n;\n	Real	**A_ent, *A_piv, *A_row, sum, tmp;\n\n	if ( A==(MAT *)NULL )\n		error(E_NULL,""MCHfactor"");\n	if ( A->m != A->n )\n		error(E_SQUARE,""MCHfactor"");\n	if ( tol <= 0.0 )\n	        error(E_RANGE,""MCHfactor"");\n	n = A->n;	A_ent = A->me;\n\n	for ( k=0; k<n; k++ )\n	{	\n		/* do diagonal element */\n		sum = A_ent[k][k];\n		A_piv = A_ent[k];\n		for ( j=0; j<k; j++ )\n		{\n			/* tmp = A_ent[k][j]; */\n			tmp = *A_piv++;\n			sum -= tmp*tmp;\n		}\n		if ( sum <= tol )\n			sum = tol;\n		A_ent[k][k] = sqrt(sum);\n\n		/* set values of column k */\n		for ( i=k+1; i<n; i++ )\n		{\n			sum = A_ent[i][k];\n			A_piv = A_ent[k];\n			A_row = A_ent[i];\n			sum -= __ip__(A_row,A_piv,(int)k);\n			/************************************************\n			for ( j=0; j<k; j++ )\n				sum -= A_ent[i][j]*A_ent[k][j];\n				sum -= (*A_row++)*(*A_piv++);\n			************************************************/\n			A_ent[j][i] = A_ent[i][j] = sum/A_ent[k][k];\n		}\n	}\n\n	return (A);\n}\n"
leukocyte/meschach_lib/fmacheps.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n#include	<stdio.h>\n\ndouble	fclean(x)\ndouble	x;\n{\n    static float	y;\n    y = x;\n    return y;	/* prevents optimisation */\n}\n\nmain()\n{\n    static float	feps, feps1, ftmp;\n\n    feps = 1.0;\n    while ( fclean(1.0+feps) > 1.0 )\n	feps = 0.5*feps;\n\n    printf(""%g\n"", 2.0*feps);\n}\n"
leukocyte/meschach_lib/matop.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* matop.c 1.3 11/25/87 */\n\n\n#include	<stdio.h>\n#include	""matrix.h""\n\nstatic	char	rcsid[] = ""$Id: matop.c,v 1.4 1995/03/27 15:43:57 des Exp $"";\n\n\n/* m_add -- matrix addition -- may be in-situ */\n#ifndef ANSI_C\nMAT	*m_add(mat1,mat2,out)\nMAT	*mat1,*mat2,*out;\n#else\nMAT	*m_add(const MAT *mat1, const MAT *mat2, MAT *out)\n#endif\n{\n	unsigned int	m,n,i;\n\n	if ( mat1==(MAT *)NULL || mat2==(MAT *)NULL )\n		error(E_NULL,""m_add"");\n	if ( mat1->m != mat2->m || mat1->n != mat2->n )\n		error(E_SIZES,""m_add"");\n	if ( out==(MAT *)NULL || out->m != mat1->m || out->n != mat1->n )\n		out = m_resize(out,mat1->m,mat1->n);\n	m = mat1->m;	n = mat1->n;\n	for ( i=0; i<m; i++ )\n	{\n		__add__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n		/**************************************************\n		for ( j=0; j<n; j++ )\n			out->me[i][j] = mat1->me[i][j]+mat2->me[i][j];\n		**************************************************/\n	}\n\n	return (out);\n}\n\n/* m_sub -- matrix subtraction -- may be in-situ */\n#ifndef ANSI_C\nMAT	*m_sub(mat1,mat2,out)\nMAT	*mat1,*mat2,*out;\n#else\nMAT	*m_sub(const MAT *mat1, const MAT *mat2, MAT *out)\n#endif\n{\n	unsigned int	m,n,i;\n\n	if ( mat1==(MAT *)NULL || mat2==(MAT *)NULL )\n		error(E_NULL,""m_sub"");\n	if ( mat1->m != mat2->m || mat1->n != mat2->n )\n		error(E_SIZES,""m_sub"");\n	if ( out==(MAT *)NULL || out->m != mat1->m || out->n != mat1->n )\n		out = m_resize(out,mat1->m,mat1->n);\n	m = mat1->m;	n = mat1->n;\n	for ( i=0; i<m; i++ )\n	{\n		__sub__(mat1->me[i],mat2->me[i],out->me[i],(int)n);\n		/**************************************************\n		for ( j=0; j<n; j++ )\n			out->me[i][j] = mat1->me[i][j]-mat2->me[i][j];\n		**************************************************/\n	}\n\n	return (out);\n}\n\n/* m_mlt -- matrix-matrix multiplication */\n#ifndef ANSI_C\nMAT	*m_mlt(A,B,OUT)\nMAT	*A,*B,*OUT;\n#else\nMAT	*m_mlt(const MAT *A, const MAT *B, MAT *OUT)\n#endif\n{\n	unsigned int	i, /* j, */ k, m, n, p;\n	Real	**A_v, **B_v /*, *B_row, *OUT_row, sum, tmp */;\n\n	if ( A==(MAT *)NULL || B==(MAT *)NULL )\n		error(E_NULL,""m_mlt"");\n	if ( A->n != B->m )\n		error(E_SIZES,""m_mlt"");\n	if ( A == OUT || B == OUT )\n		error(E_INSITU,""m_mlt"");\n	m = A->m;	n = A->n;	p = B->n;\n	A_v = A->me;		B_v = B->me;\n\n	if ( OUT==(MAT *)NULL || OUT->m != A->m || OUT->n != B->n )\n		OUT = m_resize(OUT,A->m,B->n);\n\n/****************************************************************\n	for ( i=0; i<m; i++ )\n		for  ( j=0; j<p; j++ )\n		{\n			sum = 0.0;\n			for ( k=0; k<n; k++ )\n				sum += A_v[i][k]*B_v[k][j];\n			OUT->me[i][j] = sum;\n		}\n****************************************************************/\n	m_zero(OUT);\n	for ( i=0; i<m; i++ )\n		for ( k=0; k<n; k++ )\n		{\n		    if ( A_v[i][k] != 0.0 )\n		        __mltadd__(OUT->me[i],B_v[k],A_v[i][k],(int)p);\n		    /**************************************************\n		    B_row = B_v[k];	OUT_row = OUT->me[i];\n		    for ( j=0; j<p; j++ )\n			(*OUT_row++) += tmp*(*B_row++);\n		    **************************************************/\n		}\n\n	return OUT;\n}\n\n/* mmtr_mlt -- matrix-matrix transposed multiplication\n	-- A.B^T is returned, and stored in OUT */\n#ifndef ANSI_C\nMAT	*mmtr_mlt(A,B,OUT)\nMAT	*A, *B, *OUT;\n#else\nMAT	*mmtr_mlt(const MAT *A, const MAT *B, MAT *OUT)\n#endif\n{\n	int	i, j, limit;\n	/* Real	*A_row, *B_row, sum; */\n\n	if ( ! A || ! B )\n		error(E_NULL,""mmtr_mlt"");\n	if ( A == OUT || B == OUT )\n		error(E_INSITU,""mmtr_mlt"");\n	if ( A->n != B->n )\n		error(E_SIZES,""mmtr_mlt"");\n	if ( ! OUT || OUT->m != A->m || OUT->n != B->m )\n		OUT = m_resize(OUT,A->m,B->m);\n\n	limit = A->n;\n	for ( i = 0; i < A->m; i++ )\n		for ( j = 0; j < B->m; j++ )\n		{\n		    OUT->me[i][j] = __ip__(A->me[i],B->me[j],(int)limit);\n		    /**************************************************\n		    sum = 0.0;\n		    A_row = A->me[i];\n		    B_row = B->me[j];\n		    for ( k = 0; k < limit; k++ )\n			sum += (*A_row++)*(*B_row++);\n		    OUT->me[i][j] = sum;\n		    **************************************************/\n		}\n\n	return OUT;\n}\n\n/* mtrm_mlt -- matrix transposed-matrix multiplication\n	-- A^T.B is returned, result stored in OUT */\n#ifndef ANSI_C\nMAT	*mtrm_mlt(A,B,OUT)\nMAT	*A, *B, *OUT;\n#else\nMAT	*mtrm_mlt(const MAT *A, const MAT *B, MAT *OUT)\n#endif\n{\n	int	i, k, limit;\n	/* Real	*B_row, *OUT_row, multiplier; */\n\n	if ( ! A || ! B )\n		error(E_NULL,""mmtr_mlt"");\n	if ( A == OUT || B == OUT )\n		error(E_INSITU,""mtrm_mlt"");\n	if ( A->m != B->m )\n		error(E_SIZES,""mmtr_mlt"");\n	if ( ! OUT || OUT->m != A->n || OUT->n != B->n )\n		OUT = m_resize(OUT,A->n,B->n);\n\n	limit = B->n;\n	m_zero(OUT);\n	for ( k = 0; k < A->m; k++ )\n		for ( i = 0; i < A->n; i++ )\n		{\n		    if ( A->me[k][i] != 0.0 )\n			__mltadd__(OUT->me[i],B->me[k],A->me[k][i],(int)limit);\n		    /**************************************************\n		    multiplier = A->me[k][i];\n		    OUT_row = OUT->me[i];\n		    B_row   = B->me[k];\n		    for ( j = 0; j < limit; j++ )\n			*(OUT_row++) += multiplier*(*B_row++);\n		    **************************************************/\n		}\n\n	return OUT;\n}\n\n/* mv_mlt -- matrix-vector multiplication \n		-- Note: b is treated as a column vector */\n#ifndef ANSI_C\nVEC	*mv_mlt(A,b,out)\nMAT	*A;\nVEC	*b,*out;\n#else\nVEC	*mv_mlt(const MAT *A, const VEC *b, VEC *out)\n#endif\n{\n	unsigned int	i, m, n;\n	Real	**A_v, *b_v /*, *A_row */;\n	/* register Real	sum; */\n\n	if ( A==(MAT *)NULL || b==(VEC *)NULL )\n		error(E_NULL,""mv_mlt"");\n	if ( A->n != b->dim )\n		error(E_SIZES,""mv_mlt"");\n	if ( b == out )\n		error(E_INSITU,""mv_mlt"");\n	if ( out == (VEC *)NULL || out->dim != A->m )\n		out = v_resize(out,A->m);\n\n	m = A->m;		n = A->n;\n	A_v = A->me;		b_v = b->ve;\n	for ( i=0; i<m; i++ )\n	{\n		/* for ( j=0; j<n; j++ )\n			sum += A_v[i][j]*b_v[j]; */\n		out->ve[i] = __ip__(A_v[i],b_v,(int)n);\n		/**************************************************\n		A_row = A_v[i];		b_v = b->ve;\n		for ( j=0; j<n; j++ )\n			sum += (*A_row++)*(*b_v++);\n		out->ve[i] = sum;\n		**************************************************/\n	}\n\n	return out;\n}\n\n/* sm_mlt -- scalar-matrix multiply -- may be in-situ */\n#ifndef ANSI_C\nMAT	*sm_mlt(scalar,matrix,out)\ndouble	scalar;\nMAT	*matrix,*out;\n#else\nMAT	*sm_mlt(double scalar, const MAT *matrix, MAT *out)\n#endif\n{\n	unsigned int	m,n,i;\n\n	if ( matrix==(MAT *)NULL )\n		error(E_NULL,""sm_mlt"");\n	if ( out==(MAT *)NULL || out->m != matrix->m || out->n != matrix->n )\n		out = m_resize(out,matrix->m,matrix->n);\n	m = matrix->m;	n = matrix->n;\n	for ( i=0; i<m; i++ )\n		__smlt__(matrix->me[i],(double)scalar,out->me[i],(int)n);\n		/**************************************************\n		for ( j=0; j<n; j++ )\n			out->me[i][j] = scalar*matrix->me[i][j];\n		**************************************************/\n	return (out);\n}\n\n/* vm_mlt -- vector-matrix multiplication \n		-- Note: b is treated as a row vector */\n#ifndef ANSI_C\nVEC	*vm_mlt(A,b,out)\nMAT	*A;\nVEC	*b,*out;\n#else\nVEC	*vm_mlt(const MAT *A, const VEC *b, VEC *out)\n#endif\n{\n	unsigned int	j,m,n;\n	/* Real	sum,**A_v,*b_v; */\n\n	if ( A==(MAT *)NULL || b==(VEC *)NULL )\n		error(E_NULL,""vm_mlt"");\n	if ( A->m != b->dim )\n		error(E_SIZES,""vm_mlt"");\n	if ( b == out )\n		error(E_INSITU,""vm_mlt"");\n	if ( out == (VEC *)NULL || out->dim != A->n )\n		out = v_resize(out,A->n);\n\n	m = A->m;		n = A->n;\n\n	v_zero(out);\n	for ( j = 0; j < m; j++ )\n		if ( b->ve[j] != 0.0 )\n		    __mltadd__(out->ve,A->me[j],b->ve[j],(int)n);\n	/**************************************************\n	A_v = A->me;		b_v = b->ve;\n	for ( j=0; j<n; j++ )\n	{\n		sum = 0.0;\n		for ( i=0; i<m; i++ )\n			sum += b_v[i]*A_v[i][j];\n		out->ve[j] = sum;\n	}\n	**************************************************/\n\n	return out;\n}\n\n/* m_transp -- transpose matrix */\n#ifndef ANSI_C\nMAT	*m_transp(in,out)\nMAT	*in, *out;\n#else\nMAT	*m_transp(const MAT *in, MAT *out)\n#endif\n{\n	int	i, j;\n	int	in_situ;\n	Real	tmp;\n\n	if ( in == (MAT *)NULL )\n		error(E_NULL,""m_transp"");\n	if ( in == out && in->n != in->m )\n		error(E_INSITU2,""m_transp"");\n	in_situ = ( in == out );\n	if ( out == (MAT *)NULL || out->m != in->n || out->n != in->m )\n		out = m_resize(out,in->n,in->m);\n\n	if ( ! in_situ )\n		for ( i = 0; i < in->m; i++ )\n			for ( j = 0; j < in->n; j++ )\n				out->me[j][i] = in->me[i][j];\n	else\n		for ( i = 1; i < in->m; i++ )\n			for ( j = 0; j < i; j++ )\n			{	tmp = in->me[i][j];\n				in->me[i][j] = in->me[j][i];\n				in->me[j][i] = tmp;\n			}\n\n	return out;\n}\n\n/* swap_rows -- swaps rows i and j of matrix A for cols lo through hi */\n#ifndef ANSI_C\nMAT	*swap_rows(A,i,j,lo,hi)\nMAT	*A;\nint	i, j, lo, hi;\n#else\nMAT	*swap_rows(MAT *A, int i, int j, int lo, int hi)\n#endif\n{\n	int	k;\n	Real	**A_me, tmp;\n\n	if ( ! A )\n		error(E_NULL,""swap_rows"");\n	if ( i < 0 || j < 0 || i >= A->m || j >= A->m )\n		error(E_SIZES,""swap_rows"");\n	lo = max(0,lo);\n	hi = min(hi,A->n-1);\n	A_me = A->me;\n\n	for ( k = lo; k <= hi; k++ )\n	{\n		tmp = A_me[k][i];\n		A_me[k][i] = A_me[k][j];\n		A_me[k][j] = tmp;\n	}\n	return A;\n}\n\n/* swap_cols -- swap columns i and j of matrix A for cols lo through hi */\n#ifndef ANSI_C\nMAT	*swap_cols(A,i,j,lo,hi)\nMAT	*A;\nint	i, j, lo, hi;\n#else\nMAT	*swap_cols(MAT *A, int i, int j, int lo, int hi)\n#endif\n{\n	int	k;\n	Real	**A_me, tmp;\n\n	if ( ! A )\n		error(E_NULL,""swap_cols"");\n	if ( i < 0 || j < 0 || i >= A->n || j >= A->n )\n		error(E_SIZES,""swap_cols"");\n	lo = max(0,lo);\n	hi = min(hi,A->m-1);\n	A_me = A->me;\n\n	for ( k = lo; k <= hi; k++ )\n	{\n		tmp = A_me[i][k];\n		A_me[i][k] = A_me[j][k];\n		A_me[j][k] = tmp;\n	}\n	return A;\n}\n\n/* ms_mltadd -- matrix-scalar multiply and add\n	-- may be in situ\n	-- returns out == A1 + s*A2 */\n#ifndef ANSI_C\nMAT	*ms_mltadd(A1,A2,s,out)\nMAT	*A1, *A2, *out;\ndouble	s;\n#else\nMAT	*ms_mltadd(const MAT *A1, const MAT *A2, double s, MAT *out)\n#endif\n{\n	/* register Real	*A1_e, *A2_e, *out_e; */\n	/* register int	j; */\n	int	i, m, n;\n\n	if ( ! A1 || ! A2 )\n		error(E_NULL,""ms_mltadd"");\n	if ( A1->m != A2->m || A1->n != A2->n )\n		error(E_SIZES,""ms_mltadd"");\n\n	if ( out != A1 && out != A2 )\n		out = m_resize(out,A1->m,A1->n);\n\n	if ( s == 0.0 )\n		return m_copy(A1,out);\n	if ( s == 1.0 )\n		return m_add(A1,A2,out);\n\n	tracecatch(out = m_copy(A1,out),""ms_mltadd"");\n\n	m = A1->m;	n = A1->n;\n	for ( i = 0; i < m; i++ )\n	{\n		__mltadd__(out->me[i],A2->me[i],s,(int)n);\n		/**************************************************\n		A1_e = A1->me[i];\n		A2_e = A2->me[i];\n		out_e = out->me[i];\n		for ( j = 0; j < n; j++ )\n		    out_e[j] = A1_e[j] + s*A2_e[j];\n		**************************************************/\n	}\n\n	return out;\n}\n\n/* mv_mltadd -- matrix-vector multiply and add\n	-- may not be in situ\n	-- returns out == v1 + alpha*A*v2 */\n#ifndef ANSI_C\nVEC	*mv_mltadd(v1,v2,A,alpha,out)\nVEC	*v1, *v2, *out;\nMAT	*A;\ndouble	alpha;\n#else\nVEC	*mv_mltadd(const VEC *v1, const VEC *v2, const MAT *A,\n		   double alpha, VEC *out)\n#endif\n{\n	/* register	int	j; */\n	int	i, m, n;\n	Real	*v2_ve, *out_ve;\n\n	if ( ! v1 || ! v2 || ! A )\n		error(E_NULL,""mv_mltadd"");\n	if ( out == v2 )\n		error(E_INSITU,""mv_mltadd"");\n	if ( v1->dim != A->m || v2->dim != A->n )\n		error(E_SIZES,""mv_mltadd"");\n\n	tracecatch(out = v_copy(v1,out),""mv_mltadd"");\n\n	v2_ve = v2->ve;	out_ve = out->ve;\n	m = A->m;	n = A->n;\n\n	if ( alpha == 0.0 )\n	    return out;\n\n	for ( i = 0; i < m; i++ )\n	{\n		out_ve[i] += alpha*__ip__(A->me[i],v2_ve,(int)n);\n		/**************************************************\n		A_e = A->me[i];\n		sum = 0.0;\n		for ( j = 0; j < n; j++ )\n		    sum += A_e[j]*v2_ve[j];\n		out_ve[i] = v1->ve[i] + alpha*sum;\n		**************************************************/\n	}\n\n	return out;\n}\n\n/* vm_mltadd -- vector-matrix multiply and add\n	-- may not be in situ\n	-- returns out' == v1' + v2'*A */\n#ifndef ANSI_C\nVEC	*vm_mltadd(v1,v2,A,alpha,out)\nVEC	*v1, *v2, *out;\nMAT	*A;\ndouble	alpha;\n#else\nVEC	*vm_mltadd(const VEC *v1, const VEC *v2, const MAT *A,\n		   double alpha, VEC *out)\n#endif\n{\n	int	/* i, */ j, m, n;\n	Real	tmp, /* *A_e, */ *out_ve;\n\n	if ( ! v1 || ! v2 || ! A )\n		error(E_NULL,""vm_mltadd"");\n	if ( v2 == out )\n		error(E_INSITU,""vm_mltadd"");\n	if ( v1->dim != A->n || A->m != v2->dim )\n		error(E_SIZES,""vm_mltadd"");\n\n	tracecatch(out = v_copy(v1,out),""vm_mltadd"");\n\n	out_ve = out->ve;	m = A->m;	n = A->n;\n	for ( j = 0; j < m; j++ )\n	{\n		tmp = v2->ve[j]*alpha;\n		if ( tmp != 0.0 )\n		    __mltadd__(out_ve,A->me[j],tmp,(int)n);\n		/**************************************************\n		A_e = A->me[j];\n		for ( i = 0; i < n; i++ )\n		    out_ve[i] += A_e[i]*tmp;\n		**************************************************/\n	}\n\n	return out;\n}\n\n"
leukocyte/meschach_lib/memstat.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*  mem_stat.c    6/09/93  */\n\n/* Deallocation of static arrays */\n\n\n#include <stdio.h>\n#include  ""matrix.h""\n#include  ""meminfo.h""\n#ifdef COMPLEX   \n#include  ""zmatrix.h""\n#endif\n#ifdef SPARSE\n#include  ""sparse.h""\n#include  ""iter.h""\n#endif\n\nstatic char rcsid[] = ""$Id: memstat.c,v 1.1 1994/01/13 05:32:44 des Exp $"";\n\n/* global variable */\n\nextern MEM_CONNECT mem_connect[MEM_CONNECT_MAX_LISTS];\n\n\n/* local type */\n\ntypedef struct {\n  void	**var;	/* for &A, where A is a pointer */\n  int	type;	/* type of A */\n  int	mark;	/* what mark is chosen */\n  char	*fname;	/* source file name where last registered */\n  int	line;	/* line # of file where last registered */\n} MEM_STAT_STRUCT;\n\n\n/* local variables */\n\n/* how many marks are used */\nstatic int mem_stat_mark_many = 0;\n\n/* current mark */\nstatic int mem_stat_mark_curr = 0;\n\n\nstatic MEM_STAT_STRUCT mem_stat_var[MEM_HASHSIZE];\n\n/* array of indices (+1) to mem_stat_var */\nstatic unsigned int mem_hash_idx[MEM_HASHSIZE];\n\n/* points to the first unused element in mem_hash_idx */\nstatic unsigned int mem_hash_idx_end = 0;\n\n\n\n/* hashing function */\n#ifndef ANSI_C\nstatic unsigned int mem_hash(ptr)\nvoid **ptr;\n#else\nstatic unsigned int mem_hash(void **ptr)\n#endif\n{\n   unsigned long lp = (unsigned long)ptr;\n\n   return (lp % MEM_HASHSIZE);\n}\n\n\n/* look for a place in mem_stat_var */\n#ifndef ANSI_C\nstatic int mem_lookup(var)\nvoid **var;\n#else\nstatic int mem_lookup(void **var)\n#endif\n{\n   int k, j;\n\n   k = mem_hash(var);\n\n   if (mem_stat_var[k].var == var) {\n      return -1;\n   }\n   else if (mem_stat_var[k].var == NULL) {\n      return k;\n   }\n   else {  /* look for an empty place */\n      j = k;\n      while (mem_stat_var[j].var != var && j < MEM_HASHSIZE\n	     && mem_stat_var[j].var != NULL) \n	j++;\n\n      if (mem_stat_var[j].var == NULL) return j;\n      else if (mem_stat_var[j].var == var) return -1; \n      else { /* if (j == MEM_HASHSIZE) */\n	 j = 0;\n	 while (mem_stat_var[j].var != var && j < k\n		&& mem_stat_var[j].var != NULL) \n	   j++;\n	 if (mem_stat_var[j].var == NULL) return j;\n	 else if (mem_stat_var[j].var == var) return -1; \n	 else { /* if (j == k) */\n	    fprintf(stderr,\n              ""\n WARNING !!! static memory: mem_stat_var is too small\n"");\n	    fprintf(stderr,\n	      "" Increase MEM_HASHSIZE in file: %s (currently = %d)\n\n"",\n		    MEM_HASHSIZE_FILE, MEM_HASHSIZE);\n	    if ( !isatty(fileno(stdout)) ) {\n	       fprintf(stdout,\n                ""\n WARNING !!! static memory: mem_stat_var is too small\n"");\n	       fprintf(stdout,\n	        "" Increase MEM_HASHSIZE in file: %s (currently = %d)\n\n"",\n		    MEM_HASHSIZE_FILE, MEM_HASHSIZE);\n	    }\n	    error(E_MEM,""mem_lookup"");\n	 }\n      }\n   }\n\n   return -1;\n}\n\n\n/* register static variables;\n   Input arguments:\n     var - variable to be registered,\n     type - type of this variable; \n     list - list of types\n     fname - source file name where last registered\n     line - line number of source file\n\n   returned value < 0  --> error,\n   returned value == 0 --> not registered,\n   returned value >= 0 --> registered with this mark;\n*/\n#ifndef ANSI_C\nint mem_stat_reg_list(var,type,list,fname,line)\nvoid	**var;\nint	type,list;\nchar	*fname;\nint	line;\n#else\nint mem_stat_reg_list(void **var, int type, int list,\n		      char *fname, int line)\n#endif\n{\n   int n;\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS )\n     return -1;\n\n   if (mem_stat_mark_curr == 0) return 0;  /* not registered */\n   if (var == NULL) return -1;             /* error */\n\n   if ( type < 0 || type >= mem_connect[list].ntypes || \n       mem_connect[list].free_funcs[type] == NULL )\n   {\n      warning(WARN_WRONG_TYPE,""mem_stat_reg_list"");\n      return -1;\n   }\n   \n   if ((n = mem_lookup(var)) >= 0) {\n      mem_stat_var[n].var = var;\n      mem_stat_var[n].mark = mem_stat_mark_curr;\n      mem_stat_var[n].type = type;\n      mem_stat_var[n].fname = fname;\n      mem_stat_var[n].line = line;\n      /* save n+1, not n */\n      mem_hash_idx[mem_hash_idx_end++] = n+1;\n   }\n\n   return mem_stat_mark_curr;\n}\n\n\n/* set a mark;\n   Input argument:\n   mark - positive number denoting a mark;\n   returned: \n             mark if mark > 0,\n             0 if mark == 0,\n	     -1 if mark is negative.\n*/\n#ifndef ANSI_C\nint mem_stat_mark(mark)\nint mark;\n#else\nint mem_stat_mark(int mark)\n#endif\n{\n   if (mark < 0) {\n      mem_stat_mark_curr = 0;\n      return -1;   /* error */\n   }\n   else if (mark == 0) {\n      mem_stat_mark_curr = 0; \n      return 0; \n   }\n\n   mem_stat_mark_curr = mark;\n   mem_stat_mark_many++;\n\n   return mark;\n}\n\n\n\n/* deallocate static variables;\n   Input argument:\n   mark - a positive number denoting the mark;\n\n   Returned:\n     -1 if mark < 0 (error);\n     0  if mark == 0;\n*/\n#ifndef ANSI_C\nint mem_stat_free_list(mark,list)\nint mark,list;\n#else\nint mem_stat_free_list(int mark, int list)\n#endif\n{\n   unsigned int i,j;\n   int	 (*free_fn)();\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS \n       || mem_connect[list].free_funcs == NULL )\n     return -1;\n\n   if (mark < 0) {\n      mem_stat_mark_curr = 0;\n      return -1;\n   }\n   else if (mark == 0) {\n      mem_stat_mark_curr = 0;\n      return 0;\n   }\n   \n   if (mem_stat_mark_many <= 0) {\n      warning(WARN_NO_MARK,""mem_stat_free"");\n      return -1;\n   }\n\n#ifdef DEBUG\n   printf(""mem_stat_free: Freeing variables registered for mark %d\n"", mark);\n#endif /* DEBUG */\n   /* deallocate the marked variables */\n   for (i=0; i < mem_hash_idx_end; i++) {\n      j = mem_hash_idx[i];\n      if (j == 0) continue;\n      else {\n	 j--;\n	 if (mem_stat_var[j].mark == mark) {\n	     free_fn = mem_connect[list].free_funcs[mem_stat_var[j].type];\n#ifdef DEBUG\n	     printf(""# Freeing variable(s) registered in file \""%s\"", line %d\n"",\n		    mem_stat_var[j].fname, mem_stat_var[j].line);\n#endif /* DEBUG */\n	     if ( free_fn != NULL )\n		 (*free_fn)(*mem_stat_var[j].var);\n	     else\n		 warning(WARN_WRONG_TYPE,""mem_stat_free"");\n	    \n	    *(mem_stat_var[j].var) = NULL;\n	    mem_stat_var[j].var = NULL;\n	    mem_stat_var[j].mark = 0;\n	    mem_stat_var[j].fname = NULL;\n	    mem_stat_var[j].line = 0;\n	    mem_hash_idx[i] = 0;\n	 }\n      }\n   }\n\n   while (mem_hash_idx_end > 0 && mem_hash_idx[mem_hash_idx_end-1] == 0)\n     mem_hash_idx_end--;\n\n   mem_stat_mark_curr = 0;\n   mem_stat_mark_many--;\n   return 0;\n}\n\n\n/* only for diagnostic purposes */\n#ifndef ANSI_C\nvoid mem_stat_dump(fp,list)\nFILE *fp;\nint list;\n#else\nvoid mem_stat_dump(FILE *fp, int list)\n#endif\n{\n   unsigned int i,j,k=1;\n\n   if ( list < 0 || list >= MEM_CONNECT_MAX_LISTS \n       || mem_connect[list].free_funcs == NULL )\n     return;\n\n   fprintf(fp,"" Array mem_stat_var (list no. %d):\n"",list);\n   for (i=0; i < mem_hash_idx_end; i++) {\n      j = mem_hash_idx[i];\n      if (j == 0) continue;\n      else {\n	 j--;\n	 fprintf(fp,"" %d.  var = 0x%p, type = %s, mark = %d\n"",\n		 k,mem_stat_var[j].var,\n		 mem_stat_var[j].type < mem_connect[list].ntypes &&\n		 mem_connect[list].free_funcs[mem_stat_var[j].type] != NULL ?\n		 mem_connect[list].type_names[(int)mem_stat_var[j].type] : \n		 ""???"",\n		 mem_stat_var[j].mark);\n	 k++;\n      }\n   }\n   \n   fprintf(fp,""\n"");\n}\n\n\n/* query function about the current mark */\n#ifdef ANSI_C\nint mem_stat_show_mark(void)\n#else\nint mem_stat_show_mark()\n#endif\n{\n   return mem_stat_mark_curr;\n}\n\n\n/* Varying number of arguments */\n\n\n#ifdef ANSI_C\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   mem_stat_vars(list,type,&v1,&v2,&v3,...,VNULL);\n   where \n     int list,type;\n     void **v1, **v2, **v3,...;\n     The last argument should be VNULL ! \n     type is the type of variables v1,v2,v3,...\n     (of course they must be of the same type)\n*/\n\nint mem_stat_reg_vars(int list,int type,char *fname,int line, ...)\n{\n   va_list ap;\n   int i=0;\n   void **par;\n   \n   /* va_start(ap, type); */\n   va_start(ap,line);	/* Changed for Linux 7th Oct, 2003 */\n   while (par = va_arg(ap,void **)) {   /* NULL ends the list*/\n      mem_stat_reg_list(par,type,list,fname,line);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n#elif VARARGS\n/* old varargs is used */\n\n/* To allocate memory to many arguments. \n   The function should be called:\n   mem_stat_vars(list,type,&v1,&v2,&v3,...,VNULL);\n   where \n     int list,type;\n     void **v1, **v2, **v3,...;\n     The last argument should be VNULL ! \n     type is the type of variables v1,v2,v3,...\n     (of course they must be of the same type)\n*/\n\nint mem_stat_reg_vars(va_alist) va_dcl\n{\n   va_list ap;\n   int type,list,i=0;\n   void **par;\n   \n   va_start(ap);\n   list = va_arg(ap,int);\n   type = va_arg(ap,int);\n   while (par = va_arg(ap,void **)) {   /* NULL ends the list*/\n      mem_stat_reg_list(par,type,list);\n      i++;\n   } \n\n   va_end(ap);\n   return i;\n}\n\n\n#endif\n"
leukocyte/meschach_lib/mfunc.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n  This file contains routines for computing functions of matrices\n  especially polynomials and exponential functions\n  Copyright (C) Teresa Leyk and David Stewart, 1993\n  */\n\n#include <stdio.h>\n#include <math.h>\n#include ""matrix.h""\n#include ""matrix2.h""\n\nstatic char	rcsid[] = ""$Id: mfunc.c,v 1.2 1994/11/01 05:57:56 des Exp $"";\n\n\n\n/* _m_pow -- computes integer powers of a square matrix A, A^p\n   -- uses tmp as temporary workspace */\n#ifndef ANSI_C\nMAT	*_m_pow(A, p, tmp, out)\nMAT	*A, *tmp, *out;\nint	p;\n#else\nMAT	*_m_pow(const MAT *A, int p, MAT *tmp, MAT *out)\n#endif\n{\n   int		it_cnt, k, max_bit;\n   \n   /*\n     File containing routines for evaluating matrix functions\n     esp. the exponential function\n     */\n\n#define	Z(k)	(((k) & 1) ? tmp : out)\n   \n   if ( ! A )\n     error(E_NULL,""_m_pow"");\n   if ( A->m != A->n )\n     error(E_SQUARE,""_m_pow"");\n   if ( p < 0 )\n     error(E_NEG,""_m_pow"");\n   out = m_resize(out,A->m,A->n);\n   tmp = m_resize(tmp,A->m,A->n);\n   \n   if ( p == 0 )\n     m_ident(out);\n   else if ( p > 0 )\n   {\n      it_cnt = 1;\n      for ( max_bit = 0; ; max_bit++ )\n	if ( (p >> (max_bit+1)) == 0 )\n	  break;\n      tmp = m_copy(A,tmp);\n      \n      for ( k = 0; k < max_bit; k++ )\n      {\n	 m_mlt(Z(it_cnt),Z(it_cnt),Z(it_cnt+1));\n	 it_cnt++;\n	 if ( p & (1 << (max_bit-1)) )\n	 {\n	    m_mlt(A,Z(it_cnt),Z(it_cnt+1));\n	    /* m_copy(Z(it_cnt),out); */\n	    it_cnt++;\n	 }\n	 p <<= 1;\n      }\n      if (it_cnt & 1)\n	out = m_copy(Z(it_cnt),out);\n   }\n\n   return out;\n\n#undef Z   \n}\n\n/* m_pow -- computes integer powers of a square matrix A, A^p */\n#ifndef ANSI_C\nMAT	*m_pow(A, p, out)\nMAT	*A, *out;\nint	p;\n#else\nMAT	*m_pow(const MAT *A, int p, MAT *out)\n#endif\n{\n   STATIC MAT	*wkspace=MNULL, *tmp=MNULL;\n   \n   if ( ! A )\n     error(E_NULL,""m_pow"");\n   if ( A->m != A->n )\n     error(E_SQUARE,""m_pow"");\n   \n   wkspace = m_resize(wkspace,A->m,A->n);\n   MEM_STAT_REG(wkspace,TYPE_MAT);\n   if ( p < 0 )\n   {\n       tmp = m_resize(tmp,A->m,A->n);\n       MEM_STAT_REG(tmp,TYPE_MAT);\n       tracecatch(m_inverse(A,tmp),""m_pow"");\n       out = _m_pow(tmp, -p, wkspace, out);\n   }\n   else\n       out = _m_pow(A, p, wkspace, out);\n\n#ifdef	THREADSAFE\n   M_FREE(wkspace);	M_FREE(tmp);\n#endif\n\n   return out;\n}\n\n/**************************************************/\n\n/* _m_exp -- compute matrix exponential of A and save it in out\n   -- uses Pade approximation followed by repeated squaring\n   -- eps is the tolerance used for the Pade approximation \n   -- A is not changed\n   -- q_out - degree of the Pade approximation (q_out,q_out)\n   -- j_out - the power of 2 for scaling the matrix A\n              such that ||A/2^j_out|| <= 0.5\n*/\n#ifndef ANSI_C\nMAT *_m_exp(A,eps,out,q_out,j_out)\nMAT *A,*out;\ndouble eps;\nint *q_out, *j_out;\n#else\nMAT *_m_exp(MAT *A, double eps, MAT *out, int *q_out, int *j_out)\n#endif\n{\n   STATIC MAT *D = MNULL, *Apow = MNULL, *N = MNULL, *Y = MNULL;\n   STATIC VEC *c1 = VNULL, *tmp = VNULL;\n   VEC y0, y1;  /* additional structures */\n   STATIC PERM *pivot = PNULL;\n   int j, k, l, q, r, s, j2max, t;\n   double inf_norm, eqq, power2, c, sign;\n   \n   if ( ! A )\n     error(E_SIZES,""_m_exp"");\n   if ( A->m != A->n )\n     error(E_SIZES,""_m_exp"");\n   if ( A == out )\n     error(E_INSITU,""_m_exp"");\n   if ( eps < 0.0 )\n     error(E_RANGE,""_m_exp"");\n   else if (eps == 0.0)\n     eps = MACHEPS;\n      \n   N = m_resize(N,A->m,A->n);\n   D = m_resize(D,A->m,A->n);\n   Apow = m_resize(Apow,A->m,A->n);\n   out = m_resize(out,A->m,A->n);\n\n   MEM_STAT_REG(N,TYPE_MAT);\n   MEM_STAT_REG(D,TYPE_MAT);\n   MEM_STAT_REG(Apow,TYPE_MAT);\n   \n   /* normalise A to have ||A||_inf <= 1 */\n   inf_norm = m_norm_inf(A);\n   if (inf_norm <= 0.0) {\n      m_ident(out);\n      *q_out = -1;\n      *j_out = 0;\n      return out;\n   }\n   else {\n      j2max = floor(1+log(inf_norm)/log(2.0));\n      j2max = max(0, j2max);\n   }\n   \n   power2 = 1.0;\n   for ( k = 1; k <= j2max; k++ )\n     power2 *= 2;\n   power2 = 1.0/power2;\n   if ( j2max > 0 )\n     sm_mlt(power2,A,A);\n   \n   /* compute order for polynomial approximation */\n   eqq = 1.0/6.0;\n   for ( q = 1; eqq > eps; q++ )\n     eqq /= 16.0*(2.0*q+1.0)*(2.0*q+3.0);\n   \n   /* construct vector of coefficients */\n   c1 = v_resize(c1,q+1);\n   MEM_STAT_REG(c1,TYPE_VEC);\n   c1->ve[0] = 1.0;\n   for ( k = 1; k <= q; k++ ) \n     c1->ve[k] = c1->ve[k-1]*(q-k+1)/((2*q-k+1)*(double)k);\n   \n   tmp = v_resize(tmp,A->n);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n   \n   s = (int)floor(sqrt((double)q/2.0));\n   if ( s <= 0 )  s = 1;\n   _m_pow(A,s,out,Apow);\n   r = q/s;\n   \n   Y = m_resize(Y,s,A->n);\n   MEM_STAT_REG(Y,TYPE_MAT);\n   /* y0 and y1 are pointers to rows of Y, N and D */\n   y0.dim = y0.max_dim = A->n;   \n   y1.dim = y1.max_dim = A->n;\n   \n   m_zero(Y);\n   m_zero(N);\n   m_zero(D);\n   \n   for( j = 0; j < A->n; j++ )\n   {\n      if (j > 0)\n	Y->me[0][j-1] = 0.0;\n      y0.ve = Y->me[0];\n      y0.ve[j] = 1.0;\n      for ( k = 0; k < s-1; k++ )\n      {\n	 y1.ve = Y->me[k+1];\n	 mv_mlt(A,&y0,&y1);\n	 y0.ve = y1.ve;\n      }\n\n      y0.ve = N->me[j];\n      y1.ve = D->me[j];\n      t = s*r;\n      for ( l = 0; l <= q-t; l++ )\n      {\n	 c = c1->ve[t+l];\n	 sign = ((t+l) & 1) ? -1.0 : 1.0;\n	 __mltadd__(y0.ve,Y->me[l],c,     Y->n);\n	 __mltadd__(y1.ve,Y->me[l],c*sign,Y->n);\n      }\n      \n      for (k=1; k <= r; k++)\n      {\n	 v_copy(mv_mlt(Apow,&y0,tmp),&y0);\n	 v_copy(mv_mlt(Apow,&y1,tmp),&y1);\n	 t = s*(r-k);\n	 for (l=0; l < s; l++)\n	 {\n	    c = c1->ve[t+l];\n	    sign = ((t+l) & 1) ? -1.0 : 1.0;\n	    __mltadd__(y0.ve,Y->me[l],c,     Y->n);\n	    __mltadd__(y1.ve,Y->me[l],c*sign,Y->n);\n	 }\n      }\n   }\n\n   pivot = px_resize(pivot,A->m);\n   MEM_STAT_REG(pivot,TYPE_PERM);\n   \n   /* note that N and D are transposed,\n      therefore we use LUTsolve;\n      out is saved row-wise, and must be transposed \n      after this */\n\n   LUfactor(D,pivot);\n   for (k=0; k < A->n; k++)\n   {\n      y0.ve = N->me[k];\n      y1.ve = out->me[k];\n      LUTsolve(D,pivot,&y0,&y1);\n   }\n   m_transp(out,out); \n\n\n   /* Use recursive squaring to turn the normalised exponential to the\n      true exponential */\n\n#define Z(k)    ((k) & 1 ? Apow : out)\n\n   for( k = 1; k <= j2max; k++)\n      m_mlt(Z(k-1),Z(k-1),Z(k));\n\n   if (Z(k) == out)\n     m_copy(Apow,out);\n   \n   /* output parameters */\n   *j_out = j2max;\n   *q_out = q;\n\n   /* restore the matrix A */\n   sm_mlt(1.0/power2,A,A);\n\n#ifdef	THREADSAFE\n   M_FREE(D);	M_FREE(Apow);	M_FREE(N);	M_FREE(Y);\n   V_FREE(c1); 	V_FREE(tmp);\n   PX_FREE(pivot);\n#endif\n\n   return out;\n\n#undef Z\n}\n\n\n/* simple interface for _m_exp */\n#ifndef ANSI_C\nMAT *m_exp(A,eps,out)\nMAT *A,*out;\ndouble eps;\n#else\nMAT *m_exp(MAT *A, double eps, MAT *out)\n#endif\n{\n   int q_out, j_out;\n\n   return _m_exp(A,eps,out,&q_out,&j_out);\n}\n\n\n/*--------------------------------*/\n\n/* m_poly -- computes sum_i a[i].A^i, where i=0,1,...dim(a);\n   -- uses C. Van Loan's fast and memory efficient method  */\n#ifndef ANSI_C\nMAT *m_poly(A,a,out)\nMAT *A,*out;\nVEC *a;\n#else\nMAT *m_poly(const MAT *A, const VEC *a, MAT *out)\n#endif\n{\n   STATIC MAT	*Apow = MNULL, *Y = MNULL;\n   STATIC VEC   *tmp = VNULL;\n   VEC y0, y1;  /* additional vectors */\n   int j, k, l, q, r, s, t;\n   \n   if ( ! A || ! a )\n     error(E_NULL,""m_poly"");\n   if ( A->m != A->n )\n     error(E_SIZES,""m_poly"");\n   if ( A == out )\n     error(E_INSITU,""m_poly"");\n   \n   out = m_resize(out,A->m,A->n);\n   Apow = m_resize(Apow,A->m,A->n);\n   MEM_STAT_REG(Apow,TYPE_MAT);\n   tmp = v_resize(tmp,A->n);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n\n   q = a->dim - 1;\n   if ( q == 0 ) {\n      m_zero(out);\n      for (j=0; j < out->n; j++)\n	out->me[j][j] = a->ve[0];\n      return out;\n   }\n   else if ( q == 1) {\n      sm_mlt(a->ve[1],A,out);\n      for (j=0; j < out->n; j++)\n	out->me[j][j] += a->ve[0];\n      return out;\n   }\n   \n   s = (int)floor(sqrt((double)q/2.0));\n   if ( s <= 0 ) s = 1;\n   _m_pow(A,s,out,Apow);\n   r = q/s;\n   \n   Y = m_resize(Y,s,A->n);\n   MEM_STAT_REG(Y,TYPE_MAT);\n   /* pointers to rows of Y */\n   y0.dim = y0.max_dim = A->n;\n   y1.dim = y1.max_dim = A->n;\n\n   m_zero(Y);\n   m_zero(out);\n   \n#define Z(k)     ((k) & 1 ? tmp : &y0)\n#define ZZ(k)    ((k) & 1 ? tmp->ve : y0.ve)\n\n   for( j = 0; j < A->n; j++)\n   {\n      if( j > 0 )\n	Y->me[0][j-1] = 0.0;\n      Y->me[0][j] = 1.0;\n\n      y0.ve = Y->me[0];\n      for (k = 0; k < s-1; k++)\n      {\n	 y1.ve = Y->me[k+1];\n	 mv_mlt(A,&y0,&y1);\n	 y0.ve = y1.ve;\n      }\n      \n      y0.ve = out->me[j];\n\n      t = s*r;\n      for ( l = 0; l <= q-t; l++ )\n	__mltadd__(y0.ve,Y->me[l],a->ve[t+l],Y->n);\n      \n      for (k=1; k <= r; k++)\n      {\n	 mv_mlt(Apow,Z(k-1),Z(k)); \n	 t = s*(r-k);\n	 for (l=0; l < s; l++)\n	   __mltadd__(ZZ(k),Y->me[l],a->ve[t+l],Y->n);\n      }\n      if (Z(k) == &y0) v_copy(tmp,&y0);\n   }\n\n   m_transp(out,out);\n\n#ifdef	THREADSAFE\n   M_FREE(Apow);	M_FREE(Y);	V_FREE(tmp);	\n#endif\n   \n   return out;\n}\n\n\n"
leukocyte/meschach_lib/update.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	Matrix factorisation routines to work with the other matrix files.\n*/\n\n/* update.c 1.3 11/25/87 */\nstatic	char	rcsid[] = ""$Id: update.c,v 1.2 1994/01/13 05:26:06 des Exp $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix.h""\n#include        ""matrix2.h""\n\n\n\n\n/* Most matrix factorisation routines are in-situ unless otherwise specified */\n\n/* LDLupdate -- updates a CHolesky factorisation, replacing LDL' by\n	MD~M' = LDL' + alpha.w.w' Note: w is overwritten\n	Ref: Gill et al Math Comp 28, p516 Algorithm C1 */\n#ifndef ANSI_C\nMAT	*LDLupdate(CHmat,w,alpha)\nMAT	*CHmat;\nVEC	*w;\ndouble	alpha;\n#else\nMAT	*LDLupdate(MAT *CHmat, VEC *w, double alpha)\n#endif\n{\n	unsigned int	i,j;\n	Real	diag,new_diag,beta,p;\n\n	if ( CHmat==(MAT *)NULL || w==(VEC *)NULL )\n		error(E_NULL,""LDLupdate"");\n	if ( CHmat->m != CHmat->n || w->dim != CHmat->m )\n		error(E_SIZES,""LDLupdate"");\n\n	for ( j=0; j < w->dim; j++ )\n	{\n		p = w->ve[j];\n		diag = CHmat->me[j][j];\n		new_diag = CHmat->me[j][j] = diag + alpha*p*p;\n		if ( new_diag <= 0.0 )\n			error(E_POSDEF,""LDLupdate"");\n		beta = p*alpha/new_diag;\n		alpha *= diag/new_diag;\n\n		for ( i=j+1; i < w->dim; i++ )\n		{\n			w->ve[i] -= p*CHmat->me[i][j];\n			CHmat->me[i][j] += beta*w->ve[i];\n			CHmat->me[j][i] = CHmat->me[i][j];\n		}\n	}\n\n	return (CHmat);\n}\n\n\n/* QRupdate -- updates QR factorisation in expanded form (seperate matrices)\n	Finds Q+, R+ s.t. Q+.R+ = Q.(R+u.v') and Q+ orthogonal, R+ upper triang\n	Ref: Golub & van Loan Matrix Computations pp437-443\n	-- does not update Q if it is NULL */\n#ifndef ANSI_C\nMAT	*QRupdate(Q,R,u,v)\nMAT	*Q,*R;\nVEC	*u,*v;\n#else\nMAT	*QRupdate(MAT *Q, MAT *R, VEC *u, VEC *v)\n#endif\n{\n	int	i,j,k;\n	Real	c,s,temp;\n\n	if ( ! R || ! u || ! v )\n		error(E_NULL,""QRupdate"");\n	if ( ( Q && ( Q->m != Q->n || R->m != Q->n ) ) ||\n					u->dim != R->m || v->dim != R->n )\n		error(E_SIZES,""QRupdate"");\n\n	/* find largest k s.t. u[k] != 0 */\n	for ( k=R->m-1; k>=0; k-- )\n		if ( u->ve[k] != 0.0 )\n			break;\n\n	/* transform R+u.v' to Hessenberg form */\n	for ( i=k-1; i>=0; i-- )\n	{\n		/* get Givens rotation */\n		givens(u->ve[i],u->ve[i+1],&c,&s);\n		rot_rows(R,i,i+1,c,s,R);\n		if ( Q )\n			rot_cols(Q,i,i+1,c,s,Q);\n		rot_vec(u,i,i+1,c,s,u);\n	}\n\n	/* add into R */\n	temp = u->ve[0];\n	for ( j=0; j<R->n; j++ )\n		R->me[0][j] += temp*v->ve[j];\n\n	/* transform Hessenberg to upper triangular */\n	for ( i=0; i<k; i++ )\n	{\n		givens(R->me[i][i],R->me[i+1][i],&c,&s);\n		rot_rows(R,i,i+1,c,s,R);\n		if ( Q )\n			rot_cols(Q,i,i+1,c,s,Q);\n	}\n\n	return R;\n}\n\n"
leukocyte/meschach_lib/ztorture.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains a series of tests for the Meschach matrix\n	library, complex routines\n*/\n\nstatic char rcsid[] = ""$Id: $"";\n\n#include	<stdio.h>\n#include	<math.h>\n#include 	""zmatrix2.h""\n#include        ""matlab.h""\n\n\n#define	errmesg(mesg)	printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)	printf(""# Testing %s...\n"",mesg);\n\n/* extern	int	malloc_chain_check(); */\n/* #define MEMCHK() if ( malloc_chain_check(0) ) \\n{ printf(""Error in malloc chain: \""%s\"", line %d\n"", \\n	 __FILE__, __LINE__); exit(0); } */\n#define	MEMCHK()\n\n#define	checkpt()	printf(""At line %d in file \""%s\""\n"",__LINE__,__FILE__)\n\n/* cmp_perm -- returns 1 if pi1 == pi2, 0 otherwise */\nint	cmp_perm(pi1, pi2)\nPERM	*pi1, *pi2;\n{\n    int		i;\n\n    if ( ! pi1 || ! pi2 )\n	error(E_NULL,""cmp_perm"");\n    if ( pi1->size != pi2->size )\n	return 0;\n    for ( i = 0; i < pi1->size; i++ )\n	if ( pi1->pe[i] != pi2->pe[i] )\n	    return 0;\n    return 1;\n}\n\n/* px_rand -- generates sort-of random permutation */\nPERM	*px_rand(pi)\nPERM	*pi;\n{\n    int		i, j, k;\n\n    if ( ! pi )\n	error(E_NULL,""px_rand"");\n\n    for ( i = 0; i < 3*pi->size; i++ )\n    {\n	j = (rand() >> 8) % pi->size;\n	k = (rand() >> 8) % pi->size;\n	px_transp(pi,j,k);\n    }\n\n    return pi;\n}\n\n#define	SAVE_FILE	""asx5213a.mat""\n#define	MATLAB_NAME	""alpha""\nchar	name[81] = MATLAB_NAME;\n\nvoid	main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n    ZVEC 	*x = ZVNULL, *y = ZVNULL, *z = ZVNULL, *u = ZVNULL;\n    ZVEC	*diag = ZVNULL;\n    PERM	*pi1 = PNULL, *pi2 = PNULL, *pivot = PNULL;\n    ZMAT	*A = ZMNULL, *B = ZMNULL, *C = ZMNULL, *D = ZMNULL,\n	*Q = ZMNULL;\n    complex	ONE;\n    complex	z1, z2, z3;\n    Real	cond_est, s1, s2, s3;\n    int		i, seed;\n    FILE	*fp;\n    char	*cp;\n\n\n    mem_info_on(TRUE);\n\n    setbuf(stdout,(char *)NULL);\n\n    seed = 1111;\n    if ( argc > 2 )\n    {\n	printf(""usage: %s [seed]\n"",argv[0]);\n	exit(0);\n    }\n    else if ( argc == 2 )\n	sscanf(argv[1], ""%d"", &seed);\n\n    /* set seed for rand() */\n    smrand(seed);\n\n    /* print out version information */\n    m_version();\n\n    printf(""# Meschach Complex numbers & vectors torture test\n\n"");\n    printf(""# grep \""^Error\"" the output for a listing of errors\n"");\n    printf(""# Don't panic if you see \""Error\"" appearing; \n"");\n    printf(""# Also check the reported size of error\n"");\n    printf(""# This program uses randomly generated problems and therefore\n"");\n    printf(""# may occasionally produce ill-conditioned problems\n"");\n    printf(""# Therefore check the size of the error compared with MACHEPS\n"");\n    printf(""# If the error is within 1000*MACHEPS then don't worry\n"");\n    printf(""# If you get an error of size 0.1 or larger there is \n"");\n    printf(""# probably a bug in the code or the compilation procedure\n\n"");\n    printf(""# seed = %d\n"",seed);\n\n    printf(""\n"");\n\n    mem_stat_mark(1);\n\n    notice(""complex arithmetic & special functions"");\n\n    ONE = zmake(1.0,0.0);\n    printf(""# ONE = "");	z_output(ONE);\n    z1.re = mrand();	z1.im = mrand();\n    z2.re = mrand();	z2.im = mrand();\n    z3 = zadd(z1,z2);\n    if ( fabs(z1.re+z2.re-z3.re) + fabs(z1.im+z2.im-z3.im) > 10*MACHEPS )\n	errmesg(""zadd"");\n    z3 = zsub(z1,z2);\n    if ( fabs(z1.re-z2.re-z3.re) + fabs(z1.im-z2.im-z3.im) > 10*MACHEPS )\n	errmesg(""zadd"");\n    z3 = zmlt(z1,z2);\n    if ( fabs(z1.re*z2.re - z1.im*z2.im - z3.re) +\n	 fabs(z1.im*z2.re + z1.re*z2.im - z3.im) > 10*MACHEPS )\n	errmesg(""zmlt"");\n    s1 = zabs(z1);\n    if ( fabs(s1*s1 - (z1.re*z1.re+z1.im*z1.im)) > 10*MACHEPS )\n	errmesg(""zabs"");\n    if ( zabs(zsub(z1,zmlt(z2,zdiv(z1,z2)))) > 10*MACHEPS ||\n	 zabs(zsub(ONE,zdiv(z1,zmlt(z2,zdiv(z1,z2))))) > 10*MACHEPS )\n	errmesg(""zdiv"");\n\n    z3 = zsqrt(z1);\n    if ( zabs(zsub(z1,zmlt(z3,z3))) > 10*MACHEPS )\n	errmesg(""zsqrt"");\n    if ( zabs(zsub(z1,zlog(zexp(z1)))) > 10*MACHEPS )\n	errmesg(""zexp/zlog"");\n    \n\n    printf(""# Check: MACHEPS = %g\n"",MACHEPS);\n    /* allocate, initialise, copy and resize operations */\n    /* ZVEC */\n    notice(""vector initialise, copy & resize"");\n    x = zv_get(12);\n    y = zv_get(15);\n    z = zv_get(12);\n    zv_rand(x);\n    zv_rand(y);\n    z = zv_copy(x,z);\n    if ( zv_norm2(zv_sub(x,z,z)) >= MACHEPS )\n	errmesg(""ZVEC copy"");\n    zv_copy(x,y);\n    x = zv_resize(x,10);\n    y = zv_resize(y,10);\n    if ( zv_norm2(zv_sub(x,y,z)) >= MACHEPS )\n	errmesg(""ZVEC copy/resize"");\n    x = zv_resize(x,15);\n    y = zv_resize(y,15);\n    if ( zv_norm2(zv_sub(x,y,z)) >= MACHEPS )\n	errmesg(""VZEC resize"");\n\n    /* ZMAT */\n    notice(""matrix initialise, copy & resize"");\n    A = zm_get(8,5);\n    B = zm_get(3,9);\n    C = zm_get(8,5);\n    zm_rand(A);\n    zm_rand(B);\n    C = zm_copy(A,C);\n    if ( zm_norm_inf(zm_sub(A,C,C)) >= MACHEPS )\n	errmesg(""ZMAT copy"");\n    zm_copy(A,B);\n    A = zm_resize(A,3,5);\n    B = zm_resize(B,3,5);\n    if ( zm_norm_inf(zm_sub(A,B,C)) >= MACHEPS )\n	errmesg(""ZMAT copy/resize"");\n    A = zm_resize(A,10,10);\n    B = zm_resize(B,10,10);\n    if ( zm_norm_inf(zm_sub(A,B,C)) >= MACHEPS )\n	errmesg(""ZMAT resize"");\n\n    MEMCHK();\n\n    /* PERM */\n    notice(""permutation initialise, inverting & permuting vectors"");\n    pi1 = px_get(15);\n    pi2 = px_get(12);\n    px_rand(pi1);\n    zv_rand(x);\n    px_zvec(pi1,x,z);\n    y = zv_resize(y,x->dim);\n    pxinv_zvec(pi1,z,y);\n    if ( zv_norm2(zv_sub(x,y,z)) >= MACHEPS )\n	errmesg(""PERMute vector"");\n\n    /* testing catch() etc */\n    notice(""error handling routines"");\n    catch(E_NULL,\n	  catchall(zv_add(ZVNULL,ZVNULL,ZVNULL);\n		     errmesg(""tracecatch() failure""),\n		     printf(""# tracecatch() caught error\n"");\n		     error(E_NULL,""main""));\n	             errmesg(""catch() failure""),\n	  printf(""# catch() caught E_NULL error\n""));\n\n    /* testing inner products and v_mltadd() etc */\n    notice(""inner products and linear combinations"");\n    u = zv_get(x->dim);\n    zv_rand(u);\n    zv_rand(x);\n    zv_resize(y,x->dim);\n    zv_rand(y);\n    zv_mltadd(y,x,zneg(zdiv(zin_prod(x,y),zin_prod(x,x))),z);\n    if ( zabs(zin_prod(x,z)) >= 5*MACHEPS*x->dim )\n    {\n	errmesg(""zv_mltadd()/zin_prod()"");\n	printf(""# error norm = %g\n"", zabs(zin_prod(x,z)));\n    }\n\n    z1 = zneg(zdiv(zin_prod(x,y),zmake(zv_norm2(x)*zv_norm2(x),0.0)));\n    zv_mlt(z1,x,u);\n    zv_add(y,u,u);\n    if ( zv_norm2(zv_sub(u,z,u)) >= MACHEPS*x->dim )\n    {\n	errmesg(""zv_mlt()/zv_norm2()"");\n	printf(""# error norm = %g\n"", zv_norm2(u));\n    }\n\n#ifdef ANSI_C\n    zv_linlist(u,x,z1,y,ONE,VNULL);\n    if ( zv_norm2(zv_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg(""zv_linlist()"");\n#endif\n#ifdef VARARGS\n    zv_linlist(u,x,z1,y,ONE,VNULL);\n    if ( zv_norm2(zv_sub(u,z,u)) >= MACHEPS*x->dim )\n	errmesg(""zv_linlist()"");\n#endif\n\n    MEMCHK();\n\n    /* vector norms */\n    notice(""vector norms"");\n    x = zv_resize(x,12);\n    zv_rand(x);\n    for ( i = 0; i < x->dim; i++ )\n	if ( zabs(zv_entry(x,i)) >= 0.7 )\n	    zv_set_val(x,i,ONE);\n        else\n	    zv_set_val(x,i,zneg(ONE));\n    s1 = zv_norm1(x);\n    s2 = zv_norm2(x);	\n    s3 = zv_norm_inf(x);\n    if ( fabs(s1 - x->dim) >= MACHEPS*x->dim ||\n	 fabs(s2 - sqrt((double)(x->dim))) >= MACHEPS*x->dim ||\n	 fabs(s3 - 1.0) >= MACHEPS )\n	errmesg(""zv_norm1/2/_inf()"");\n\n    /* test matrix multiply etc */\n    notice(""matrix multiply and invert"");\n    A = zm_resize(A,10,10);\n    B = zm_resize(B,10,10);\n    zm_rand(A);\n    zm_inverse(A,B);\n    zm_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_sub_val(C,i,i,ONE);\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""zm_inverse()/zm_mlt()"");\n\n    MEMCHK();\n\n    /* ... and adjoints */\n    notice(""adjoints and adjoint-multiplies"");\n    zm_adjoint(A,A);	/* can do square matrices in situ */\n    zmam_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),ONE));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""zm_adjoint()/zmam_mlt()"");\n    zm_adjoint(A,A);\n    zm_adjoint(B,B);\n    zmma_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),ONE));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""zm_adjoint()/zmma_mlt()"");\n    zsm_mlt(zmake(3.71,2.753),B,B);\n    zmma_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),zmake(3.71,-2.753)));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""szm_mlt()/zmma_mlt()"");\n    zm_adjoint(B,B);\n    zsm_mlt(zdiv(ONE,zmake(3.71,-2.753)),B,B);\n\n    MEMCHK();\n\n    /* ... and matrix-vector multiplies */\n    notice(""matrix-vector multiplies"");\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,A->m);\n    z = zv_resize(z,A->m);\n    u = zv_resize(u,A->n);\n    zv_rand(x);\n    zv_rand(y);\n    zmv_mlt(A,x,z);\n    z1 = zin_prod(y,z);\n    zvm_mlt(A,y,u);\n    z2 = zin_prod(u,x);\n    if ( zabs(zsub(z1,z2)) >= (MACHEPS*x->dim)*x->dim )\n    {\n	errmesg(""zmv_mlt()/zvm_mlt()"");\n	printf(""# difference between inner products is %g\n"",\n	       zabs(zsub(z1,z2)));\n    }\n    zmv_mlt(B,z,u);\n    if ( zv_norm2(zv_sub(u,x,u)) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""zmv_mlt()/zvm_mlt()"");\n\n    MEMCHK();\n\n    /* get/set row/col */\n    notice(""getting and setting rows and cols"");\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,B->m);\n    x = zget_row(A,3,x);\n    y = zget_col(B,3,y);\n    if ( zabs(zsub(_zin_prod(x,y,0,Z_NOCONJ),ONE)) >=\n	MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""zget_row()/zget_col()"");\n    zv_mlt(zmake(-1.0,0.0),x,x);\n    zv_mlt(zmake(-1.0,0.0),y,y);\n    zset_row(A,3,x);\n    zset_col(B,3,y);\n    zm_mlt(A,B,C);\n    for ( i = 0; i < C->m; i++ )\n	zm_set_val(C,i,i,zsub(zm_entry(C,i,i),ONE));\n    if ( zm_norm_inf(C) >= MACHEPS*zm_norm_inf(A)*zm_norm_inf(B)*5 )\n	errmesg(""zset_row()/zset_col()"");\n\n    MEMCHK();\n\n    /* matrix norms */\n    notice(""matrix norms"");\n    A = zm_resize(A,11,15);\n    zm_rand(A);\n    s1 = zm_norm_inf(A);\n    B = zm_adjoint(A,B);\n    s2 = zm_norm1(B);\n    if ( fabs(s1 - s2) >= MACHEPS*A->m )\n	errmesg(""zm_norm1()/zm_norm_inf()"");\n    C = zmam_mlt(A,A,C);\n    z1.re = z1.im = 0.0;\n    for ( i = 0; i < C->m && i < C->n; i++ )\n	z1 = zadd(z1,zm_entry(C,i,i));\n    if ( fabs(sqrt(z1.re) - zm_norm_frob(A)) >= MACHEPS*A->m*A->n )\n	errmesg(""zm_norm_frob"");\n\n    MEMCHK();\n    \n    /* permuting rows and columns */\n    /******************************\n    notice(""permuting rows & cols"");\n    A = zm_resize(A,11,15);\n    B = zm_resize(B,11,15);\n    pi1 = px_resize(pi1,A->m);\n    px_rand(pi1);\n    x = zv_resize(x,A->n);\n    y = zmv_mlt(A,x,y);\n    px_rows(pi1,A,B);\n    px_zvec(pi1,y,z);\n    zmv_mlt(B,x,u);\n    if ( zv_norm2(zv_sub(z,u,u)) >= MACHEPS*A->m )\n	errmesg(""px_rows()"");\n    pi1 = px_resize(pi1,A->n);\n    px_rand(pi1);\n    px_cols(pi1,A,B);\n    pxinv_zvec(pi1,x,z);\n    zmv_mlt(B,z,u);\n    if ( zv_norm2(zv_sub(y,u,u)) >= MACHEPS*A->n )\n	errmesg(""px_cols()"");\n    ******************************/\n\n    MEMCHK();\n\n    /* MATLAB save/load */\n    notice(""MATLAB save/load"");\n    A = zm_resize(A,12,11);\n    if ( (fp=fopen(SAVE_FILE,""w"")) == (FILE *)NULL )\n	printf(""Cannot perform MATLAB save/load test\n"");\n    else\n    {\n	zm_rand(A);\n	zm_save(fp, A, name);\n	fclose(fp);\n	if ( (fp=fopen(SAVE_FILE,""r"")) == (FILE *)NULL )\n	    printf(""Cannot open save file \""%s\""\n"",SAVE_FILE);\n	else\n	{\n	    ZM_FREE(B);\n	    B = zm_load(fp,&cp);\n	    if ( strcmp(name,cp) || zm_norm1(zm_sub(A,B,C)) >=\n		 MACHEPS*A->m )\n	    {\n		errmesg(""zm_load()/zm_save()"");\n		printf(""# orig. name = %s, restored name = %s\n"", name, cp);\n		printf(""# orig. A =\n"");	zm_output(A);\n		printf(""# restored A =\n"");	zm_output(B);\n	    }\n	}\n    }\n\n    MEMCHK();\n\n    /* Now, onto matrix factorisations */\n    A = zm_resize(A,10,10);\n    B = zm_resize(B,A->m,A->n);\n    zm_copy(A,B);\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,A->m);\n    z = zv_resize(z,A->n);\n    u = zv_resize(u,A->m);\n    zv_rand(x);\n    zmv_mlt(B,x,y);\n    z = zv_copy(x,z);\n\n    notice(""LU factor/solve"");\n    pivot = px_get(A->m);\n    zLUfactor(A,pivot);\n    tracecatch(zLUsolve(A,pivot,y,x),""main"");\n    tracecatch(cond_est = zLUcondest(A,pivot),""main"");\n    printf(""# cond(A) approx= %g\n"", cond_est);\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est)\n    {\n	errmesg(""zLUfactor()/zLUsolve()"");\n	printf(""# LU solution error = %g [cf MACHEPS = %g]\n"",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n\n\n    zv_copy(y,x);\n    tracecatch(zLUsolve(A,pivot,x,x),""main"");\n    tracecatch(cond_est = zLUcondest(A,pivot),""main"");\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est)\n    {\n	errmesg(""zLUfactor()/zLUsolve()"");\n	printf(""# LU solution error = %g [cf MACHEPS = %g]\n"",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n\n    zvm_mlt(B,z,y);\n    zv_copy(y,x);\n    tracecatch(zLUAsolve(A,pivot,x,x),""main"");\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est)\n    {\n	errmesg(""zLUfactor()/zLUAsolve()"");\n	printf(""# LU solution error = %g [cf MACHEPS = %g]\n"",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* QR factorisation */\n    zm_copy(B,A);\n    zmv_mlt(B,z,y);\n    notice(""QR factor/solve:"");\n    diag = zv_get(A->m);\n    zQRfactor(A,diag);\n    zQRsolve(A,diag,y,x);\n    if ( zv_norm2(zv_sub(x,z,u)) >= MACHEPS*zv_norm2(x)*cond_est )\n    {\n	errmesg(""zQRfactor()/zQRsolve()"");\n	printf(""# QR solution error = %g [cf MACHEPS = %g]\n"",\n	       zv_norm2(zv_sub(x,z,u)), MACHEPS);\n    }\n    printf(""# QR cond(A) approx= %g\n"", zQRcondest(A));\n    Q = zm_get(A->m,A->m);\n    zmakeQ(A,diag,Q);\n    zmakeR(A,A);\n    zm_mlt(Q,A,C);\n    zm_sub(B,C,C);\n    if ( zm_norm1(C) >= MACHEPS*zm_norm1(Q)*zm_norm1(B) )\n    {\n	errmesg(""zQRfactor()/zmakeQ()/zmakeR()"");\n	printf(""# QR reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(C), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now try with a non-square matrix */\n    A = zm_resize(A,15,7);\n    zm_rand(A);\n    B = zm_copy(A,B);\n    diag = zv_resize(diag,A->n);\n    x = zv_resize(x,A->n);\n    y = zv_resize(y,A->m);\n    zv_rand(y);\n    zQRfactor(A,diag);\n    x = zQRsolve(A,diag,y,x);\n    /* z is the residual vector */\n    zmv_mlt(B,x,z);	zv_sub(z,y,z);\n    /* check B*.z = 0 */\n    zvm_mlt(B,z,u);\n    if ( zv_norm2(u) >= 100*MACHEPS*zm_norm1(B)*zv_norm2(y) )\n    {\n	errmesg(""zQRfactor()/zQRsolve()"");\n	printf(""# QR solution error = %g [cf MACHEPS = %g]\n"",\n	       zv_norm2(u), MACHEPS);\n    }\n    Q = zm_resize(Q,A->m,A->m);\n    zmakeQ(A,diag,Q);\n    zmakeR(A,A);\n    zm_mlt(Q,A,C);\n    zm_sub(B,C,C);\n    if ( zm_norm1(C) >= MACHEPS*zm_norm1(Q)*zm_norm1(B) )\n    {\n	errmesg(""zQRfactor()/zmakeQ()/zmakeR()"");\n	printf(""# QR reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(C), MACHEPS);\n    }\n    D = zm_get(A->m,Q->m);\n    zmam_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	zm_set_val(D,i,i,zsub(zm_entry(D,i,i),ONE));\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q) )\n    {\n	errmesg(""QRfactor()/makeQ()/makeR()"");\n	printf(""# QR orthogonality error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* QRCP factorisation */\n    zm_copy(B,A);\n    notice(""QR factor/solve with column pivoting"");\n    pivot = px_resize(pivot,A->n);\n    zQRCPfactor(A,diag,pivot);\n    z = zv_resize(z,A->n);\n    zQRCPsolve(A,diag,pivot,y,z);\n    /* pxinv_zvec(pivot,z,x); */\n    /* now compute residual (z) vector */\n    zmv_mlt(B,x,z);	zv_sub(z,y,z);\n    /* check B^T.z = 0 */\n    zvm_mlt(B,z,u);\n    if ( zv_norm2(u) >= MACHEPS*zm_norm1(B)*zv_norm2(y) )\n    {\n	errmesg(""QRCPfactor()/QRsolve()"");\n	printf(""# QR solution error = %g [cf MACHEPS = %g]\n"",\n	       zv_norm2(u), MACHEPS);\n    }\n\n    Q = zm_resize(Q,A->m,A->m);\n    zmakeQ(A,diag,Q);\n    zmakeR(A,A);\n    zm_mlt(Q,A,C);\n    ZM_FREE(D);\n    D = zm_get(B->m,B->n);\n    /******************************\n    px_cols(pivot,C,D);\n    zm_sub(B,D,D);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm1(B) )\n    {\n	errmesg(""QRCPfactor()/makeQ()/makeR()"");\n	printf(""# QR reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n    ******************************/\n\n    /* Now check eigenvalue/SVD routines */\n    notice(""complex Schur routines"");\n    A = zm_resize(A,11,11);\n    B = zm_resize(B,A->m,A->n);\n    C = zm_resize(C,A->m,A->n);\n    D = zm_resize(D,A->m,A->n);\n    Q = zm_resize(Q,A->m,A->n);\n\n    MEMCHK();\n\n    /* now test complex Schur decomposition */\n    /* zm_copy(A,B); */\n    ZM_FREE(A);\n    A = zm_get(11,11);\n    zm_rand(A);\n    B = zm_copy(A,B);\n    MEMCHK();\n\n    B = zschur(B,Q);\n    checkpt();\n\n    zm_mlt(Q,B,C);\n    zmma_mlt(C,Q,D);\n    MEMCHK();\n    zm_sub(A,D,D);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q)*zm_norm1(B)*5 )\n    {\n	errmesg(""zschur()"");\n	printf(""# Schur reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n\n    /* orthogonality check */\n    zmma_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	zm_set_val(D,i,i,zsub(zm_entry(D,i,i),ONE));\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q)*10 )\n    {\n	errmesg(""zschur()"");\n	printf(""# Schur orthogonality error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n\n    MEMCHK();\n\n    /* now test SVD */\n    /******************************\n    A = zm_resize(A,11,7);\n    zm_rand(A);\n    U = zm_get(A->n,A->n);\n    Q = zm_resize(Q,A->m,A->m);\n    u = zv_resize(u,max(A->m,A->n));\n    svd(A,Q,U,u);\n    ******************************/\n    /* check reconstruction of A */\n    /******************************\n    D = zm_resize(D,A->m,A->n);\n    C = zm_resize(C,A->m,A->n);\n    zm_zero(D);\n    for ( i = 0; i < min(A->m,A->n); i++ )\n	zm_set_val(D,i,i,v_entry(u,i));\n    zmam_mlt(Q,D,C);\n    zm_mlt(C,U,D);\n    zm_sub(A,D,D);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(U)*zm_norm_inf(Q)*zm_norm1(A) )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD reconstruction error = %g [cf MACHEPS = %g]\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n    ******************************/\n    /* check orthogonality of Q and U */\n    /******************************\n    D = zm_resize(D,Q->n,Q->n);\n    zmam_mlt(Q,Q,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(Q)*zm_norm_inf(Q)*5 )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD orthognality error (Q) = %g [cf MACHEPS = %g\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n    D = zm_resize(D,U->n,U->n);\n    zmam_mlt(U,U,D);\n    for ( i = 0; i < D->m; i++ )\n	m_set_val(D,i,i,m_entry(D,i,i)-1.0);\n    if ( zm_norm1(D) >= MACHEPS*zm_norm1(U)*zm_norm_inf(U)*5 )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD orthognality error (U) = %g [cf MACHEPS = %g\n"",\n	       zm_norm1(D), MACHEPS);\n    }\n    for ( i = 0; i < u->dim; i++ )\n	if ( v_entry(u,i) < 0 || (i < u->dim-1 &&\n				  v_entry(u,i+1) > v_entry(u,i)) )\n	    break;\n    if ( i < u->dim )\n    {\n	errmesg(""svd()"");\n	printf(""# SVD sorting error\n"");\n    }\n    ******************************/\n\n    ZV_FREE(x);	ZV_FREE(y);	ZV_FREE(z);\n    ZV_FREE(u);	ZV_FREE(diag);\n    PX_FREE(pi1);	PX_FREE(pi2);	PX_FREE(pivot);\n    ZM_FREE(A);	ZM_FREE(B);	ZM_FREE(C);\n    ZM_FREE(D);	ZM_FREE(Q);\n\n    mem_stat_free(1);\n\n    MEMCHK();\n    printf(""# Finished torture test for complex numbers/vectors/matrices\n"");\n    mem_info();\n}\n\n"
leukocyte/meschach_lib/zschur.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*	\n	File containing routines for computing the Schur decomposition\n	of a complex non-symmetric matrix\n	See also: hessen.c\n	Complex version\n*/\n\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""zmatrix.h""\n#include        ""zmatrix2.h""\n\nstatic char rcsid[] = ""$Id: zschur.c,v 1.4 1995/04/07 16:28:58 des Exp $"";\n\n#define	is_zero(z)	((z).re == 0.0 && (z).im == 0.0)\n#define	b2s(t_or_f)	((t_or_f) ? ""TRUE"" : ""FALSE"")\n\n\n/* zschur -- computes the Schur decomposition of the matrix A in situ\n	-- optionally, gives Q matrix such that Q^*.A.Q is upper triangular\n	-- returns upper triangular Schur matrix */\nZMAT	*zschur(A,Q)\nZMAT	*A, *Q;\n{\n    int		i, j, iter, k, k_min, k_max, k_tmp, n, split;\n    Real	c;\n    complex	det, discrim, lambda, lambda0, lambda1, s, sum, ztmp;\n    complex	x, y;	/* for chasing algorithm */\n    complex	**A_me;\n    STATIC	ZVEC	*diag=ZVNULL;\n    \n    if ( ! A )\n	error(E_NULL,""zschur"");\n    if ( A->m != A->n || ( Q && Q->m != Q->n ) )\n	error(E_SQUARE,""zschur"");\n    if ( Q != ZMNULL && Q->m != A->m )\n	error(E_SIZES,""zschur"");\n    n = A->n;\n    diag = zv_resize(diag,A->n);\n    MEM_STAT_REG(diag,TYPE_ZVEC);\n    /* compute Hessenberg form */\n    zHfactor(A,diag);\n    \n    /* save Q if necessary, and make A explicitly Hessenberg */\n    zHQunpack(A,diag,Q,A);\n\n    k_min = 0;	A_me = A->me;\n\n    while ( k_min < n )\n    {\n	/* find k_max to suit:\n	   submatrix k_min..k_max should be irreducible */\n	k_max = n-1;\n	for ( k = k_min; k < k_max; k++ )\n	    if ( is_zero(A_me[k+1][k]) )\n	    {	k_max = k;	break;	}\n\n	if ( k_max <= k_min )\n	{\n	    k_min = k_max + 1;\n	    continue;		/* outer loop */\n	}\n\n	/* now have r x r block with r >= 2:\n	   apply Francis QR step until block splits */\n	split = FALSE;		iter = 0;\n	while ( ! split )\n	{\n	    complex	a00, a01, a10, a11;\n	    iter++;\n	    \n	    /* set up Wilkinson/Francis complex shift */\n	    /* use the smallest eigenvalue of the bottom 2 x 2 submatrix */\n	    k_tmp = k_max - 1;\n\n	    a00 = A_me[k_tmp][k_tmp];\n	    a01 = A_me[k_tmp][k_max];\n	    a10 = A_me[k_max][k_tmp];\n	    a11 = A_me[k_max][k_max];\n	    ztmp.re = 0.5*(a00.re - a11.re);\n	    ztmp.im = 0.5*(a00.im - a11.im);\n	    discrim = zsqrt(zadd(zmlt(ztmp,ztmp),zmlt(a01,a10)));\n	    sum.re  = 0.5*(a00.re + a11.re);\n	    sum.im  = 0.5*(a00.im + a11.im);\n	    lambda0 = zadd(sum,discrim);\n	    lambda1 = zsub(sum,discrim);\n	    det = zsub(zmlt(a00,a11),zmlt(a01,a10)); \n	    \n	    if ( is_zero(lambda0) && is_zero(lambda1) )\n	      {                                                          \n		lambda.re = lambda.im = 0.0;\n	      } \n	    else if ( zabs(lambda0) > zabs(lambda1) )\n		lambda = zdiv(det,lambda0);\n	    else\n		lambda = zdiv(det,lambda1);\n\n	    /* perturb shift if convergence is slow */\n	    if ( (iter % 10) == 0 )\n	    {\n		lambda.re += iter*0.02;\n		lambda.im += iter*0.02;\n	    }\n\n	    /* set up Householder transformations */\n	    k_tmp = k_min + 1;\n\n	    x = zsub(A->me[k_min][k_min],lambda);\n	    y = A->me[k_min+1][k_min];\n\n	    /* use Givens' rotations to ""chase"" off-Hessenberg entry */\n	    for ( k = k_min; k <= k_max-1; k++ )\n	    {\n		zgivens(x,y,&c,&s);\n		zrot_cols(A,k,k+1,c,s,A);\n		zrot_rows(A,k,k+1,c,s,A);\n		if ( Q != ZMNULL )\n		    zrot_cols(Q,k,k+1,c,s,Q);\n\n		/* zero things that should be zero */\n		if ( k > k_min )\n		    A->me[k+1][k-1].re = A->me[k+1][k-1].im = 0.0;\n\n		/* get next entry to chase along sub-diagonal */\n		x = A->me[k+1][k];\n		if ( k <= k_max - 2 )\n		    y = A->me[k+2][k];\n		else\n		    y.re = y.im = 0.0;\n	    }\n\n	    for ( k = k_min; k <= k_max-2; k++ )\n	    {\n		/* zero appropriate sub-diagonals */\n		A->me[k+2][k].re = A->me[k+2][k].im = 0.0;\n	    }\n\n	    /* test to see if matrix should split */\n	    for ( k = k_min; k < k_max; k++ )\n		if ( zabs(A_me[k+1][k]) < MACHEPS*\n		    (zabs(A_me[k][k])+zabs(A_me[k+1][k+1])) )\n		{\n		    A_me[k+1][k].re = A_me[k+1][k].im = 0.0;\n		    split = TRUE;\n		}\n\n	}\n    }\n    \n    /* polish up A by zeroing strictly lower triangular elements\n       and small sub-diagonal elements */\n    for ( i = 0; i < A->m; i++ )\n	for ( j = 0; j < i-1; j++ )\n	    A_me[i][j].re = A_me[i][j].im = 0.0;\n    for ( i = 0; i < A->m - 1; i++ )\n	if ( zabs(A_me[i+1][i]) < MACHEPS*\n	    (zabs(A_me[i][i])+zabs(A_me[i+1][i+1])) )\n	    A_me[i+1][i].re = A_me[i+1][i].im = 0.0;\n\n#ifdef	THREADSAFE\n    ZV_FREE(diag);\n#endif\n\n    return A;\n}\n\n\n#if 0\n/* schur_vecs -- returns eigenvectors computed from the real Schur\n		decomposition of a matrix\n	-- T is the block upper triangular Schur matrix\n	-- Q is the orthognal matrix where A = Q.T.Q^T\n	-- if Q is null, the eigenvectors of T are returned\n	-- X_re is the real part of the matrix of eigenvectors,\n		and X_im is the imaginary part of the matrix.\n	-- X_re is returned */\nMAT	*schur_vecs(T,Q,X_re,X_im)\nMAT	*T, *Q, *X_re, *X_im;\n{\n	int	i, j, limit;\n	Real	t11_re, t11_im, t12, t21, t22_re, t22_im;\n	Real	l_re, l_im, det_re, det_im, invdet_re, invdet_im,\n		val1_re, val1_im, val2_re, val2_im,\n		tmp_val1_re, tmp_val1_im, tmp_val2_re, tmp_val2_im, **T_me;\n	Real	sum, diff, discrim, magdet, norm, scale;\n	STATIC VEC	*tmp1_re=VNULL, *tmp1_im=VNULL,\n			*tmp2_re=VNULL, *tmp2_im=VNULL;\n\n	if ( ! T || ! X_re )\n	    error(E_NULL,""schur_vecs"");\n	if ( T->m != T->n || X_re->m != X_re->n ||\n		( Q != MNULL && Q->m != Q->n ) ||\n		( X_im != MNULL && X_im->m != X_im->n ) )\n	    error(E_SQUARE,""schur_vecs"");\n	if ( T->m != X_re->m ||\n		( Q != MNULL && T->m != Q->m ) ||\n		( X_im != MNULL && T->m != X_im->m ) )\n	    error(E_SIZES,""schur_vecs"");\n\n	tmp1_re = v_resize(tmp1_re,T->m);\n	tmp1_im = v_resize(tmp1_im,T->m);\n	tmp2_re = v_resize(tmp2_re,T->m);\n	tmp2_im = v_resize(tmp2_im,T->m);\n	MEM_STAT_REG(tmp1_re,TYPE_VEC);\n	MEM_STAT_REG(tmp1_im,TYPE_VEC);\n	MEM_STAT_REG(tmp2_re,TYPE_VEC);\n	MEM_STAT_REG(tmp2_im,TYPE_VEC);\n\n	T_me = T->me;\n	i = 0;\n	while ( i < T->m )\n	{\n	    if ( i+1 < T->m && T->me[i+1][i] != 0.0 )\n	    {	/* complex eigenvalue */\n		sum  = 0.5*(T_me[i][i]+T_me[i+1][i+1]);\n		diff = 0.5*(T_me[i][i]-T_me[i+1][i+1]);\n		discrim = diff*diff + T_me[i][i+1]*T_me[i+1][i];\n		l_re = l_im = 0.0;\n		if ( discrim < 0.0 )\n		{	/* yes -- complex e-vals */\n		    l_re = sum;\n		    l_im = sqrt(-discrim);\n		}\n		else /* not correct Real Schur form */\n		    error(E_RANGE,""schur_vecs"");\n	    }\n	    else\n	    {\n		l_re = T_me[i][i];\n		l_im = 0.0;\n	    }\n\n	    v_zero(tmp1_im);\n	    v_rand(tmp1_re);\n	    sv_mlt(MACHEPS,tmp1_re,tmp1_re);\n\n	    /* solve (T-l.I)x = tmp1 */\n	    limit = ( l_im != 0.0 ) ? i+1 : i;\n	    /* printf(""limit = %d\n"",limit); */\n	    for ( j = limit+1; j < T->m; j++ )\n		tmp1_re->ve[j] = 0.0;\n	    j = limit;\n	    while ( j >= 0 )\n	    {\n		if ( j > 0 && T->me[j][j-1] != 0.0 )\n		{   /* 2 x 2 diagonal block */\n		    /* printf(""checkpoint A\n""); */\n		    val1_re = tmp1_re->ve[j-1] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf(""checkpoint B\n""); */\n		    val1_im = tmp1_im->ve[j-1] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j-1][j+1]),limit-j);\n		    /* printf(""checkpoint C\n""); */\n		    val2_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint D\n""); */\n		    val2_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint E\n""); */\n		    \n		    t11_re = T_me[j-1][j-1] - l_re;\n		    t11_im = - l_im;\n		    t22_re = T_me[j][j] - l_re;\n		    t22_im = - l_im;\n		    t12 = T_me[j-1][j];\n		    t21 = T_me[j][j-1];\n\n		    scale =  fabs(T_me[j-1][j-1]) + fabs(T_me[j][j]) +\n			fabs(t12) + fabs(t21) + fabs(l_re) + fabs(l_im);\n\n		    det_re = t11_re*t22_re - t11_im*t22_im - t12*t21;\n		    det_im = t11_re*t22_im + t11_im*t22_re;\n		    magdet = det_re*det_re+det_im*det_im;\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        det_re = MACHEPS*scale;\n			magdet = det_re*det_re+det_im*det_im;\n		    }\n		    invdet_re =   det_re/magdet;\n		    invdet_im = - det_im/magdet;\n		    tmp_val1_re = t22_re*val1_re-t22_im*val1_im-t12*val2_re;\n		    tmp_val1_im = t22_im*val1_re+t22_re*val1_im-t12*val2_im;\n		    tmp_val2_re = t11_re*val2_re-t11_im*val2_im-t21*val1_re;\n		    tmp_val2_im = t11_im*val2_re+t11_re*val2_im-t21*val1_im;\n		    tmp1_re->ve[j-1] = invdet_re*tmp_val1_re -\n		    		invdet_im*tmp_val1_im;\n		    tmp1_im->ve[j-1] = invdet_im*tmp_val1_re +\n		    		invdet_re*tmp_val1_im;\n		    tmp1_re->ve[j]   = invdet_re*tmp_val2_re -\n		    		invdet_im*tmp_val2_im;\n		    tmp1_im->ve[j]   = invdet_im*tmp_val2_re +\n		    		invdet_re*tmp_val2_im;\n		    j -= 2;\n	        }\n	        else\n		{\n		    t11_re = T_me[j][j] - l_re;\n		    t11_im = - l_im;\n		    magdet = t11_re*t11_re + t11_im*t11_im;\n		    scale = fabs(T_me[j][j]) + fabs(l_re);\n		    if ( sqrt(magdet) < MACHEPS*scale )\n		    {\n		        t11_re = MACHEPS*scale;\n			magdet = t11_re*t11_re + t11_im*t11_im;\n		    }\n		    invdet_re =   t11_re/magdet;\n		    invdet_im = - t11_im/magdet;\n		    /* printf(""checkpoint F\n""); */\n		    val1_re = tmp1_re->ve[j] -\n		      __ip__(&(tmp1_re->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint G\n""); */\n		    val1_im = tmp1_im->ve[j] -\n		      __ip__(&(tmp1_im->ve[j+1]),&(T->me[j][j+1]),limit-j);\n		    /* printf(""checkpoint H\n""); */\n		    tmp1_re->ve[j] = invdet_re*val1_re - invdet_im*val1_im;\n		    tmp1_im->ve[j] = invdet_im*val1_re + invdet_re*val1_im;\n		    j -= 1;\n		}\n	    }\n\n	    norm = v_norm_inf(tmp1_re) + v_norm_inf(tmp1_im);\n	    sv_mlt(1/norm,tmp1_re,tmp1_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp1_im,tmp1_im);\n	    mv_mlt(Q,tmp1_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		mv_mlt(Q,tmp1_im,tmp2_im);\n	    if ( l_im != 0.0 )\n		norm = sqrt(in_prod(tmp2_re,tmp2_re)+in_prod(tmp2_im,tmp2_im));\n	    else\n		norm = v_norm2(tmp2_re);\n	    sv_mlt(1/norm,tmp2_re,tmp2_re);\n	    if ( l_im != 0.0 )\n		sv_mlt(1/norm,tmp2_im,tmp2_im);\n\n	    if ( l_im != 0.0 )\n	    {\n		if ( ! X_im )\n		error(E_NULL,""schur_vecs"");\n		set_col(X_re,i,tmp2_re);\n		set_col(X_im,i,tmp2_im);\n		sv_mlt(-1.0,tmp2_im,tmp2_im);\n		set_col(X_re,i+1,tmp2_re);\n		set_col(X_im,i+1,tmp2_im);\n		i += 2;\n	    }\n	    else\n	    {\n		set_col(X_re,i,tmp2_re);\n		if ( X_im != MNULL )\n		    set_col(X_im,i,tmp1_im);	/* zero vector */\n		i += 1;\n	    }\n	}\n\n	return X_re;\n}\n\n#endif\n\n"
leukocyte/meschach_lib/vecop.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* vecop.c 1.3 8/18/87 */\n\n#include	<stdio.h>\n#include	""matrix.h""\n\nstatic	char	rcsid[] = ""$Id: vecop.c,v 1.5 1996/08/20 18:18:10 stewart Exp $"";\n\n\n/* _in_prod -- inner product of two vectors from i0 downwards\n	-- that is, returns a(i0:dim)^T.b(i0:dim) */\n#ifndef ANSI_C\ndouble	_in_prod(a,b,i0)\nVEC	*a,*b;\nunsigned int	i0;\n#else\ndouble	_in_prod(const VEC *a, const VEC *b, unsigned int i0)\n#endif\n{\n	unsigned int	limit;\n	/* Real	*a_v, *b_v; */\n	/* register Real	sum; */\n\n	if ( a==(VEC *)NULL || b==(VEC *)NULL )\n		error(E_NULL,""_in_prod"");\n	limit = min(a->dim,b->dim);\n	if ( i0 > limit )\n		error(E_BOUNDS,""_in_prod"");\n\n	return __ip__(&(a->ve[i0]),&(b->ve[i0]),(int)(limit-i0));\n	/*****************************************\n	a_v = &(a->ve[i0]);		b_v = &(b->ve[i0]);\n	for ( i=i0; i<limit; i++ )\n		sum += a_v[i]*b_v[i];\n		sum += (*a_v++)*(*b_v++);\n\n	return (double)sum;\n	******************************************/\n}\n\n/* sv_mlt -- scalar-vector multiply -- out <- scalar*vector \n	-- may be in-situ */\n#ifndef ANSI_C\nVEC	*sv_mlt(scalar,vector,out)\ndouble	scalar;\nVEC	*vector,*out;\n#else\nVEC	*sv_mlt(double scalar, const VEC *vector, VEC *out)\n#endif\n{\n	/* unsigned int	dim, i; */\n	/* Real	*out_ve, *vec_ve; */\n\n	if ( vector==(VEC *)NULL )\n		error(E_NULL,""sv_mlt"");\n	if ( out==(VEC *)NULL || out->dim != vector->dim )\n		out = v_resize(out,vector->dim);\n	if ( scalar == 0.0 )\n		return v_zero(out);\n	if ( scalar == 1.0 )\n		return v_copy(vector,out);\n\n	__smlt__(vector->ve,(double)scalar,out->ve,(int)(vector->dim));\n	/**************************************************\n	dim = vector->dim;\n	out_ve = out->ve;	vec_ve = vector->ve;\n	for ( i=0; i<dim; i++ )\n		out->ve[i] = scalar*vector->ve[i];\n		(*out_ve++) = scalar*(*vec_ve++);\n	**************************************************/\n	return (out);\n}\n\n/* v_add -- vector addition -- out <- v1+v2 -- may be in-situ */\n#ifndef ANSI_C\nVEC	*v_add(vec1,vec2,out)\nVEC	*vec1,*vec2,*out;\n#else\nVEC	*v_add(const VEC *vec1, const VEC *vec2, VEC *out)\n#endif\n{\n	unsigned int	dim;\n	/* Real	*out_ve, *vec1_ve, *vec2_ve; */\n\n	if ( vec1==(VEC *)NULL || vec2==(VEC *)NULL )\n		error(E_NULL,""v_add"");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,""v_add"");\n	if ( out==(VEC *)NULL || out->dim != vec1->dim )\n		out = v_resize(out,vec1->dim);\n	dim = vec1->dim;\n	__add__(vec1->ve,vec2->ve,out->ve,(int)dim);\n	/************************************************************\n	out_ve = out->ve;	vec1_ve = vec1->ve;	vec2_ve = vec2->ve;\n	for ( i=0; i<dim; i++ )\n		out->ve[i] = vec1->ve[i]+vec2->ve[i];\n		(*out_ve++) = (*vec1_ve++) + (*vec2_ve++);\n	************************************************************/\n\n	return (out);\n}\n\n/* v_mltadd -- scalar/vector multiplication and addition\n		-- out = v1 + scale.v2		*/\n#ifndef ANSI_C\nVEC	*v_mltadd(v1,v2,scale,out)\nVEC	*v1,*v2,*out;\ndouble	scale;\n#else\nVEC	*v_mltadd(const VEC *v1, const VEC *v2, double scale, VEC *out)\n#endif\n{\n	/* register unsigned int	dim, i; */\n	/* Real	*out_ve, *v1_ve, *v2_ve; */\n\n	if ( v1==(VEC *)NULL || v2==(VEC *)NULL )\n		error(E_NULL,""v_mltadd"");\n	if ( v1->dim != v2->dim )\n		error(E_SIZES,""v_mltadd"");\n	if ( scale == 0.0 )\n		return v_copy(v1,out);\n	if ( scale == 1.0 )\n		return v_add(v1,v2,out);\n\n	if ( v2 != out )\n	{\n	    tracecatch(out = v_copy(v1,out),""v_mltadd"");\n\n	    /* dim = v1->dim; */\n	    __mltadd__(out->ve,v2->ve,scale,(int)(v1->dim));\n	}\n	else\n	{\n	    tracecatch(out = sv_mlt(scale,v2,out),""v_mltadd"");\n	    out = v_add(v1,out,out);\n	}\n	/************************************************************\n	out_ve = out->ve;	v1_ve = v1->ve;		v2_ve = v2->ve;\n	for ( i=0; i < dim ; i++ )\n		out->ve[i] = v1->ve[i] + scale*v2->ve[i];\n		(*out_ve++) = (*v1_ve++) + scale*(*v2_ve++);\n	************************************************************/\n\n	return (out);\n}\n\n/* v_sub -- vector subtraction -- may be in-situ */\n#ifndef ANSI_C\nVEC	*v_sub(vec1,vec2,out)\nVEC	*vec1,*vec2,*out;\n#else\nVEC	*v_sub(const VEC *vec1, const VEC *vec2, VEC *out)\n#endif\n{\n	/* unsigned int	i, dim; */\n	/* Real	*out_ve, *vec1_ve, *vec2_ve; */\n\n	if ( vec1==(VEC *)NULL || vec2==(VEC *)NULL )\n		error(E_NULL,""v_sub"");\n	if ( vec1->dim != vec2->dim )\n		error(E_SIZES,""v_sub"");\n	if ( out==(VEC *)NULL || out->dim != vec1->dim )\n		out = v_resize(out,vec1->dim);\n\n	__sub__(vec1->ve,vec2->ve,out->ve,(int)(vec1->dim));\n	/************************************************************\n	dim = vec1->dim;\n	out_ve = out->ve;	vec1_ve = vec1->ve;	vec2_ve = vec2->ve;\n	for ( i=0; i<dim; i++ )\n		out->ve[i] = vec1->ve[i]-vec2->ve[i];\n		(*out_ve++) = (*vec1_ve++) - (*vec2_ve++);\n	************************************************************/\n\n	return (out);\n}\n\n/* v_map -- maps function f over components of x: out[i] = f(x[i])\n	-- v_map sets out[i] = f(params,x[i]) */\n#ifndef ANSI_C\nVEC	*v_map(f,x,out)\ndouble	(*f)();\nVEC	*x, *out;\n#else\n#ifdef PROTOTYPES_IN_STRUCT\nVEC	*v_map(double (*f)(double), const VEC *x, VEC *out)\n#else\nVEC	*v_map(double (*f)(), const VEC *x, VEC *out)\n#endif\n#endif\n{\n	Real	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,""v_map"");\n	if ( ! out || out->dim != x->dim )\n		out = v_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		*out_ve++ = (*f)(*x_ve++);\n\n	return out;\n}\n\n/* _v_map -- sets out[i] <- f(params, x[i]), i = 0, 1, .., dim-1 */\n#ifndef ANSI_C\nVEC	*_v_map(f,params,x,out)\ndouble	(*f)();\nvoid	*params;\nVEC	*x, *out;\n#else\n#ifdef PROTOTYPES_IN_STRUCT\nVEC	*_v_map(double (*f)(void *,double), void *params, const VEC *x, VEC *out)\n#else\nVEC	*_v_map(double (*f)(), void *params, const VEC *x, VEC *out)\n#endif\n#endif\n{\n	Real	*x_ve, *out_ve;\n	int	i, dim;\n\n	if ( ! x || ! f )\n		error(E_NULL,""_v_map"");\n	if ( ! out || out->dim != x->dim )\n		out = v_resize(out,x->dim);\n\n	dim = x->dim;	x_ve = x->ve;	out_ve = out->ve;\n	for ( i = 0; i < dim; i++ )\n		*out_ve++ = (*f)(params,*x_ve++);\n\n	return out;\n}\n\n/* v_lincomb -- returns sum_i a[i].v[i], a[i] real, v[i] vectors */\n#ifndef ANSI_C\nVEC	*v_lincomb(n,v,a,out)\nint	n;	/* number of a's and v's */\nReal	a[];\nVEC	*v[], *out;\n#else\nVEC	*v_lincomb(int n, const VEC *v[], const Real a[], VEC *out)\n#endif\n{\n	int	i;\n\n	if ( ! a || ! v )\n		error(E_NULL,""v_lincomb"");\n	if ( n <= 0 )\n		return VNULL;\n\n	for ( i = 1; i < n; i++ )\n		if ( out == v[i] )\n		    error(E_INSITU,""v_lincomb"");\n\n	out = sv_mlt(a[0],v[0],out);\n	for ( i = 1; i < n; i++ )\n	{\n		if ( ! v[i] )\n			error(E_NULL,""v_lincomb"");\n		if ( v[i]->dim != out->dim )\n			error(E_SIZES,""v_lincomb"");\n		out = v_mltadd(out,v[i],a[i],out);\n	}\n\n	return out;\n}\n\n\n\n#ifdef ANSI_C\n\n/* v_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      v_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (VEC *) and ai are numbers (double)\n*/\nVEC  *v_linlist(VEC *out,VEC *v1,double a1,...)\n{\n   va_list ap;\n   VEC *par;\n   double a_par;\n\n   if ( ! v1 )\n     return VNULL;\n   \n   va_start(ap, a1);\n   out = sv_mlt(a1,v1,out);\n   \n   while (par = va_arg(ap,VEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,double);\n      if (a_par == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,""v_linlist"");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,""v_linlist"");\n\n      if (a_par == 1.0)\n	out = v_add(out,par,out);\n      else if (a_par == -1.0)\n	out = v_sub(out,par,out);\n      else\n	out = v_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n \n#elif VARARGS\n\n\n/* v_linlist -- linear combinations taken from a list of arguments;\n   calling:\n      v_linlist(out,v1,a1,v2,a2,...,vn,an,NULL);\n   where vi are vectors (VEC *) and ai are numbers (double)\n*/\nVEC  *v_linlist(va_alist) va_dcl\n{\n   va_list ap;\n   VEC *par, *out;\n   double a_par;\n\n   va_start(ap);\n   out = va_arg(ap,VEC *);\n   par = va_arg(ap,VEC *);\n   if ( ! par ) {\n      va_end(ap);\n      return VNULL;\n   }\n   \n   a_par = va_arg(ap,double);\n   out = sv_mlt(a_par,par,out);\n   \n   while (par = va_arg(ap,VEC *)) {   /* NULL ends the list*/\n      a_par = va_arg(ap,double);\n      if (a_par == 0.0) continue;\n      if ( out == par )		\n	error(E_INSITU,""v_linlist"");\n      if ( out->dim != par->dim )	\n	error(E_SIZES,""v_linlist"");\n\n      if (a_par == 1.0)\n	out = v_add(out,par,out);\n      else if (a_par == -1.0)\n	out = v_sub(out,par,out);\n      else\n	out = v_mltadd(out,par,a_par,out); \n   } \n   \n   va_end(ap);\n   return out;\n}\n\n#endif\n  \n\n\n\n\n/* v_star -- computes componentwise (Hadamard) product of x1 and x2\n	-- result out is returned */\n#ifndef ANSI_C\nVEC	*v_star(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_star(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,""v_star"");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,""v_star"");\n    out = v_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n	out->ve[i] = x1->ve[i] * x2->ve[i];\n\n    return out;\n}\n\n/* v_slash -- computes componentwise ratio of x2 and x1\n	-- out[i] = x2[i] / x1[i]\n	-- if x1[i] == 0 for some i, then raise E_SING error\n	-- result out is returned */\n#ifndef ANSI_C\nVEC	*v_slash(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_slash(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n    Real	tmp;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,""v_slash"");\n    if ( x1->dim != x2->dim )\n	error(E_SIZES,""v_slash"");\n    out = v_resize(out,x1->dim);\n\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	tmp = x1->ve[i];\n	if ( tmp == 0.0 )\n	    error(E_SING,""v_slash"");\n	out->ve[i] = x2->ve[i] / tmp;\n    }\n\n    return out;\n}\n\n/* v_min -- computes minimum component of x, which is returned\n	-- also sets min_idx to the index of this minimum */\n#ifndef ANSI_C\ndouble	v_min(x, min_idx)\nVEC	*x;\nint	*min_idx;\n#else\ndouble	v_min(const VEC *x, int *min_idx)\n#endif\n{\n    int		i, i_min;\n    Real	min_val, tmp;\n\n    if ( ! x )\n	error(E_NULL,""v_min"");\n    if ( x->dim <= 0 )\n	error(E_SIZES,""v_min"");\n    i_min = 0;\n    min_val = x->ve[0];\n    for ( i = 1; i < x->dim; i++ )\n    {\n	tmp = x->ve[i];\n	if ( tmp < min_val )\n	{\n	    min_val = tmp;\n	    i_min = i;\n	}\n    }\n\n    if ( min_idx != NULL )\n	*min_idx = i_min;\n    return min_val;\n}\n\n/* v_max -- computes maximum component of x, which is returned\n	-- also sets max_idx to the index of this maximum */\n#ifndef ANSI_C\ndouble	v_max(x, max_idx)\nVEC	*x;\nint	*max_idx;\n#else\ndouble	v_max(const VEC *x, int *max_idx)\n#endif\n{\n    int		i, i_max;\n    Real	max_val, tmp;\n\n    if ( ! x )\n	error(E_NULL,""v_max"");\n    if ( x->dim <= 0 )\n	error(E_SIZES,""v_max"");\n    i_max = 0;\n    max_val = x->ve[0];\n    for ( i = 1; i < x->dim; i++ )\n    {\n	tmp = x->ve[i];\n	if ( tmp > max_val )\n	{\n	    max_val = tmp;\n	    i_max = i;\n	}\n    }\n\n    if ( max_idx != NULL )\n	*max_idx = i_max;\n    return max_val;\n}\n\n#define	MAX_STACK	60\n\n\n/* v_sort -- sorts vector x, and generates permutation that gives the order\n	of the components; x = [1.3, 3.7, 0.5] -> [0.5, 1.3, 3.7] and\n	the permutation is order = [2, 0, 1].\n	-- if order is NULL on entry then it is ignored\n	-- the sorted vector x is returned */\n#ifndef ANSI_C\nVEC	*v_sort(x, order)\nVEC	*x;\nPERM	*order;\n#else\nVEC	*v_sort(VEC *x, PERM *order)\n#endif\n{\n    Real	*x_ve, tmp, v;\n    /* int		*order_pe; */\n    int		dim, i, j, l, r, tmp_i;\n    int		stack[MAX_STACK], sp;\n\n    if ( ! x )\n	error(E_NULL,""v_sort"");\n    if ( order != PNULL && order->size != x->dim )\n	order = px_resize(order, x->dim);\n\n    x_ve = x->ve;\n    dim = x->dim;\n    if ( order != PNULL )\n	px_ident(order);\n\n    if ( dim <= 1 )\n	return x;\n\n    /* using quicksort algorithm in Sedgewick,\n       ""Algorithms in C"", Ch. 9, pp. 118--122 (1990) */\n    sp = 0;\n    l = 0;	r = dim-1;	v = x_ve[0];\n    for ( ; ; )\n    {\n	while ( r > l )\n	{\n	    /* ""i = partition(x_ve,l,r);"" */\n	    v = x_ve[r];\n	    i = l-1;\n	    j = r;\n	    for ( ; ; )\n	    {\n		while ( x_ve[++i] < v )\n		    ;\n		--j;\n		while ( x_ve[j] > v && j != 0 )\n		    --j;\n		if ( i >= j )	break;\n		\n		tmp = x_ve[i];\n		x_ve[i] = x_ve[j];\n		x_ve[j] = tmp;\n		if ( order != PNULL )\n		{\n		    tmp_i = order->pe[i];\n		    order->pe[i] = order->pe[j];\n		    order->pe[j] = tmp_i;\n		}\n	    }\n	    tmp = x_ve[i];\n	    x_ve[i] = x_ve[r];\n	    x_ve[r] = tmp;\n	    if ( order != PNULL )\n	    {\n		tmp_i = order->pe[i];\n		order->pe[i] = order->pe[r];\n		order->pe[r] = tmp_i;\n	    }\n\n	    if ( i-l > r-i )\n	    {   stack[sp++] = l;   stack[sp++] = i-1;   l = i+1;   }\n	    else\n	    {   stack[sp++] = i+1;   stack[sp++] = r;   r = i-1;   }\n	}\n\n	/* recursion elimination */\n	if ( sp == 0 )\n	    break;\n	r = stack[--sp];\n	l = stack[--sp];\n    }\n\n    return x;\n}\n\n/* v_sum -- returns sum of entries of a vector */\n#ifndef ANSI_C\ndouble	v_sum(x)\nVEC	*x;\n#else\ndouble	v_sum(const VEC *x)\n#endif\n{\n    int		i;\n    Real	sum;\n\n    if ( ! x )\n	error(E_NULL,""v_sum"");\n\n    sum = 0.0;\n    for ( i = 0; i < x->dim; i++ )\n	sum += x->ve[i];\n\n    return sum;\n}\n\n/* v_conv -- computes convolution product of two vectors */\n#ifndef ANSI_C\nVEC	*v_conv(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_conv(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,""v_conv"");\n    if ( x1 == out || x2 == out )\n	error(E_INSITU,""v_conv"");\n    if ( x1->dim == 0 || x2->dim == 0 )\n	return out = v_resize(out,0);\n\n    out = v_resize(out,x1->dim + x2->dim - 1);\n    v_zero(out);\n    for ( i = 0; i < x1->dim; i++ )\n	__mltadd__(&(out->ve[i]),x2->ve,x1->ve[i],x2->dim);\n\n    return out;\n}\n\n/* v_pconv -- computes a periodic convolution product\n	-- the period is the dimension of x2 */\n#ifndef ANSI_C\nVEC	*v_pconv(x1, x2, out)\nVEC	*x1, *x2, *out;\n#else\nVEC	*v_pconv(const VEC *x1, const VEC *x2, VEC *out)\n#endif\n{\n    int		i;\n\n    if ( ! x1 || ! x2 )\n	error(E_NULL,""v_pconv"");\n    if ( x1 == out || x2 == out )\n	error(E_INSITU,""v_pconv"");\n    out = v_resize(out,x2->dim);\n    if ( x2->dim == 0 )\n	return out;\n\n    v_zero(out);\n    for ( i = 0; i < x1->dim; i++ )\n    {\n	__mltadd__(&(out->ve[i]),x2->ve,x1->ve[i],x2->dim - i);\n	if ( i > 0 )\n	    __mltadd__(out->ve,&(x2->ve[x2->dim - i]),x1->ve[i],i);\n    }\n\n    return out;\n}\n"
leukocyte/meschach_lib/pxop.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* pxop.c 1.5 12/03/87 */\n\n\n#include	<stdio.h>\n#include	""matrix.h""\n\nstatic	char	rcsid[] = ""$Id: pxop.c,v 1.6 1995/06/08 14:57:11 des Exp $"";\n\n/**********************************************************************\nNote: A permutation is often interpreted as a matrix\n		(i.e. a permutation matrix).\n	A permutation px represents a permutation matrix P where\n		P[i][j] == 1 if and only if px->pe[i] == j\n**********************************************************************/\n\n\n/* px_inv -- invert permutation -- in situ\n	-- taken from ACM Collected Algorithms #250 */\n#ifndef ANSI_C\nPERM	*px_inv(px,out)\nPERM	*px, *out;\n#else\nPERM	*px_inv(const PERM *px, PERM *out)\n#endif\n{\n    int	i, j, k, n, *p;\n    \n    out = px_copy(px, out);\n    n = out->size;\n    p = (int *)(out->pe);\n    for ( n--; n>=0; n-- )\n    {\n	i = p[n];\n	if ( i < 0 )	p[n] = -1 - i;\n	else if ( i != n )\n	{\n	    k = n;\n	    while (TRUE)\n	    {\n		if ( i < 0 || i >= out->size )\n		    error(E_BOUNDS,""px_inv"");\n		j = p[i];	p[i] = -1 - k;\n		if ( j == n )\n		{	p[n] = i;	break;		}\n		k = i;		i = j;\n	    }\n	}\n    }\n    return out;\n}\n\n/* px_mlt -- permutation multiplication (composition) */\n#ifndef ANSI_C\nPERM	*px_mlt(px1,px2,out)\nPERM	*px1,*px2,*out;\n#else\nPERM	*px_mlt(const PERM *px1, const PERM *px2, PERM *out)\n#endif\n{\n    unsigned int	i,size;\n    \n    if ( px1==(PERM *)NULL || px2==(PERM *)NULL )\n	error(E_NULL,""px_mlt"");\n    if ( px1->size != px2->size )\n	error(E_SIZES,""px_mlt"");\n    if ( px1 == out || px2 == out )\n	error(E_INSITU,""px_mlt"");\n    if ( out==(PERM *)NULL || out->size < px1->size )\n	out = px_resize(out,px1->size);\n    \n    size = px1->size;\n    for ( i=0; i<size; i++ )\n	if ( px2->pe[i] >= size )\n	    error(E_BOUNDS,""px_mlt"");\n	else\n	    out->pe[i] = px1->pe[px2->pe[i]];\n    \n    return out;\n}\n\n/* px_vec -- permute vector */\n#ifndef ANSI_C\nVEC	*px_vec(px,vector,out)\nPERM	*px;\nVEC	*vector,*out;\n#else\nVEC	*px_vec(PERM *px, const VEC *vector, VEC *out)\n#endif\n{\n    unsigned int	old_i, i, size, start;\n    Real	tmp;\n    \n    if ( px==PNULL || vector==VNULL )\n	error(E_NULL,""px_vec"");\n    if ( px->size > vector->dim )\n	error(E_SIZES,""px_vec"");\n    if ( out==VNULL || out->dim < vector->dim )\n	out = v_resize(out,vector->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return v_copy(vector,out);\n    if ( out != vector )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,""px_vec"");\n	    else\n		out->ve[i] = vector->ve[px->pe[i]];\n    }\n    else\n    {	/* in situ algorithm */\n	start = 0;\n	while ( start < size )\n	{\n	    old_i = start;\n	    i = px->pe[old_i];\n	    if ( i >= size )\n	    {\n		start++;\n		continue;\n	    }\n	    tmp = vector->ve[start];\n	    while ( TRUE )\n	    {\n		vector->ve[old_i] = vector->ve[i];\n		px->pe[old_i] = i+size;\n		old_i = i;\n		i = px->pe[old_i];\n		if ( i >= size )\n		    break;\n		if ( i == start )\n		{\n		    vector->ve[old_i] = tmp;\n		    px->pe[old_i] = i+size;\n		    break;\n		}\n	    }\n	    start++;\n	}\n\n	for ( i = 0; i < size; i++ )\n	    if ( px->pe[i] < size )\n		error(E_BOUNDS,""px_vec"");\n	    else\n		px->pe[i] = px->pe[i]-size;\n    }\n    \n    return out;\n}\n\n/* pxinv_vec -- apply the inverse of px to x, returning the result in out */\n#ifndef ANSI_C\nVEC	*pxinv_vec(px,x,out)\nPERM	*px;\nVEC	*x, *out;\n#else\nVEC	*pxinv_vec(PERM *px, const VEC *x, VEC *out)\n#endif\n{\n    unsigned int	i, size;\n    \n    if ( ! px || ! x )\n	error(E_NULL,""pxinv_vec"");\n    if ( px->size > x->dim )\n	error(E_SIZES,""pxinv_vec"");\n    /* if ( x == out )\n	error(E_INSITU,""pxinv_vec""); */\n    if ( ! out || out->dim < x->dim )\n	out = v_resize(out,x->dim);\n    \n    size = px->size;\n    if ( size == 0 )\n	return v_copy(x,out);\n    if ( out != x )\n    {\n	for ( i=0; i<size; i++ )\n	    if ( px->pe[i] >= size )\n		error(E_BOUNDS,""pxinv_vec"");\n	    else\n		out->ve[px->pe[i]] = x->ve[i];\n    }\n    else\n    {	/* in situ algorithm --- cheat's way out */\n	px_inv(px,px);\n	px_vec(px,x,out);\n	px_inv(px,px);\n    }\n\n    return out;\n}\n\n\n\n/* px_transp -- transpose elements of permutation\n		-- Really multiplying a permutation by a transposition */\n#ifndef ANSI_C\nPERM	*px_transp(px,i1,i2)\nPERM	*px;		/* permutation to transpose */\nunsigned int	i1,i2;		/* elements to transpose */\n#else\nPERM	*px_transp(PERM *px, unsigned int i1, unsigned int i2)\n#endif\n{\n	unsigned int	temp;\n\n	if ( px==(PERM *)NULL )\n		error(E_NULL,""px_transp"");\n\n	if ( i1 < px->size && i2 < px->size )\n	{\n		temp = px->pe[i1];\n		px->pe[i1] = px->pe[i2];\n		px->pe[i2] = temp;\n	}\n\n	return px;\n}\n\n/* myqsort -- a cheap implementation of Quicksort on integers\n		-- returns number of swaps */\n#ifndef ANSI_C\nstatic int myqsort(a,num)\nint	*a, num;\n#else\nstatic int myqsort(int *a, int num)\n#endif\n{\n	int	i, j, tmp, v;\n	int	numswaps;\n\n	numswaps = 0;\n	if ( num <= 1 )\n		return 0;\n\n	i = 0;	j = num;	v = a[0];\n	for ( ; ; )\n	{\n		while ( a[++i] < v )\n			;\n		while ( a[--j] > v )\n			;\n		if ( i >= j )	break;\n\n		tmp = a[i];\n		a[i] = a[j];\n		a[j] = tmp;\n		numswaps++;\n	}\n\n	tmp = a[0];\n	a[0] = a[j];\n	a[j] = tmp;\n	if ( j != 0 )\n		numswaps++;\n\n	numswaps += myqsort(&a[0],j);\n	numswaps += myqsort(&a[j+1],num-(j+1));\n\n	return numswaps;\n}\n\n\n/* px_sign -- compute the ``sign'' of a permutation = +/-1 where\n		px is the product of an even/odd # transpositions */\n#ifndef ANSI_C\nint	px_sign(px)\nPERM	*px;\n#else\nint	px_sign(const PERM *px)\n#endif\n{\n	int	numtransp;\n	PERM	*px2;\n\n	if ( px==(PERM *)NULL )\n		error(E_NULL,""px_sign"");\n	px2 = px_copy(px,PNULL);\n	numtransp = myqsort((int *)px2->pe,px2->size);\n	px_free(px2);\n\n	return ( numtransp % 2 ) ? -1 : 1;\n}\n\n\n/* px_cols -- permute columns of matrix A; out = A.px'\n	-- May NOT be in situ */\n#ifndef ANSI_C\nMAT	*px_cols(px,A,out)\nPERM	*px;\nMAT	*A, *out;\n#else\nMAT	*px_cols(const PERM *px, const MAT *A, MAT *out)\n#endif\n{\n	int	i, j, m, n, px_j;\n	Real	**A_me, **out_me;\n#ifdef ANSI_C\n	MAT	*m_get(int, int);\n#else\n	extern MAT	*m_get();\n#endif\n\n	if ( ! A || ! px )\n		error(E_NULL,""px_cols"");\n	if ( px->size != A->n )\n		error(E_SIZES,""px_cols"");\n	if ( A == out )\n		error(E_INSITU,""px_cols"");\n	m = A->m;	n = A->n;\n	if ( ! out || out->m != m || out->n != n )\n		out = m_get(m,n);\n	A_me = A->me;	out_me = out->me;\n\n	for ( j = 0; j < n; j++ )\n	{\n		px_j = px->pe[j];\n		if ( px_j >= n )\n		    error(E_BOUNDS,""px_cols"");\n		for ( i = 0; i < m; i++ )\n		    out_me[i][px_j] = A_me[i][j];\n	}\n\n	return out;\n}\n\n/* px_rows -- permute columns of matrix A; out = px.A\n	-- May NOT be in situ */\n#ifndef ANSI_C\nMAT	*px_rows(px,A,out)\nPERM	*px;\nMAT	*A, *out;\n#else\nMAT	*px_rows(const PERM *px, const MAT *A, MAT *out)\n#endif\n{\n	int	i, j, m, n, px_i;\n	Real	**A_me, **out_me;\n#ifdef ANSI_C\n	MAT	*m_get(int, int);\n#else\n	extern MAT	*m_get();\n#endif\n\n	if ( ! A || ! px )\n		error(E_NULL,""px_rows"");\n	if ( px->size != A->m )\n		error(E_SIZES,""px_rows"");\n	if ( A == out )\n		error(E_INSITU,""px_rows"");\n	m = A->m;	n = A->n;\n	if ( ! out || out->m != m || out->n != n )\n		out = m_get(m,n);\n	A_me = A->me;	out_me = out->me;\n\n	for ( i = 0; i < m; i++ )\n	{\n		px_i = px->pe[i];\n		if ( px_i >= m )\n		    error(E_BOUNDS,""px_rows"");\n		for ( j = 0; j < n; j++ )\n		    out_me[i][j] = A_me[px_i][j];\n	}\n\n	return out;\n}\n\n"
leukocyte/meschach_lib/iternsym.c,"\n\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/* iter.c 17/09/93 */\n\n/* \n  ITERATIVE METHODS - implementation of several iterative methods;\n  see also iter0.c\n*/\n\n#include        <stdio.h>\n#include	<math.h>\n#include        ""matrix.h""\n#include        ""matrix2.h""\n#include	""sparse.h""\n#include        ""iter.h""\n\nstatic char rcsid[] = ""$Header: iternsym.c,v 1.6 1995/01/30 14:53:01 des Exp $"";\n\n\n#ifdef ANSI_C\nVEC	*spCHsolve(SPMAT *,VEC *,VEC *);\n#else\nVEC	*spCHsolve();\n#endif\n\n\n/* \n  iter_cgs -- uses CGS to compute a solution x to A.x=b\n*/\n#ifndef ANSI_C\nVEC	*iter_cgs(ip,r0)\nITER *ip;\nVEC *r0;\n#else\nVEC	*iter_cgs(ITER *ip, VEC *r0)\n#endif\n{\n   STATIC VEC  *p = VNULL, *q = VNULL, *r = VNULL, *u = VNULL;\n   STATIC VEC  *v = VNULL, *z = VNULL;\n   VEC  *tmp;\n   Real	alpha, beta, nres, rho, old_rho, sigma, inner;\n\n   if (ip == INULL)\n     error(E_NULL,""iter_cgs"");\n   if (!ip->Ax || !ip->b || !r0)\n     error(E_NULL,""iter_cgs"");\n   if ( ip->x == ip->b )\n     error(E_INSITU,""iter_cgs"");\n   if (!ip->stop_crit)\n     error(E_NULL,""iter_cgs"");\n   if ( r0->dim != ip->b->dim )\n     error(E_SIZES,""iter_cgs"");\n   \n   if ( ip->eps <= 0.0 ) ip->eps = MACHEPS;\n   \n   p = v_resize(p,ip->b->dim);\n   q = v_resize(q,ip->b->dim);\n   r = v_resize(r,ip->b->dim);\n   u = v_resize(u,ip->b->dim);\n   v = v_resize(v,ip->b->dim);\n\n   MEM_STAT_REG(p,TYPE_VEC);\n   MEM_STAT_REG(q,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(v,TYPE_VEC);\n\n   if (ip->Bx) {\n      z = v_resize(z,ip->b->dim);\n      MEM_STAT_REG(z,TYPE_VEC); \n   }\n\n   if (ip->x != VNULL) {\n      if (ip->x->dim != ip->b->dim)\n	error(E_SIZES,""iter_cgs"");\n      ip->Ax(ip->A_par,ip->x,v);    		/* v = A*x */\n      if (ip->Bx) {\n	 v_sub(ip->b,v,v);			/* v = b - A*x */\n	 (ip->Bx)(ip->B_par,v,r);		/* r = B*(b-A*x) */\n      }\n      else v_sub(ip->b,v,r);			/* r = b-A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);		/* x == 0 */\n      ip->shared_x = FALSE;\n      if (ip->Bx) (ip->Bx)(ip->B_par,ip->b,r);    /* r = B*b */\n      else v_copy(ip->b,r);                       /* r = b */\n   }\n\n   v_zero(p);	\n   v_zero(q);\n   old_rho = 1.0;\n   \n   for (ip->steps = 0; ip->steps <= ip->limit; ip->steps++) {\n\n      inner = in_prod(r,r);\n      nres = sqrt(fabs(inner));\n      if (ip->steps == 0) ip->init_res = nres;\n\n      if (ip->info) ip->info(ip,nres,r,VNULL);\n      if ( ip->stop_crit(ip,nres,r,VNULL) ) break;\n\n      rho = in_prod(r0,r);\n      if ( old_rho == 0.0 )\n	error(E_BREAKDOWN,""iter_cgs"");\n      beta = rho/old_rho;\n      v_mltadd(r,q,beta,u);\n      v_mltadd(q,p,beta,v);\n      v_mltadd(u,v,beta,p);\n      \n      (ip->Ax)(ip->A_par,p,q);\n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,q,z);\n	 tmp = z;\n      }\n      else tmp = q;\n      \n      sigma = in_prod(r0,tmp);\n      if ( sigma == 0.0 )\n	error(E_BREAKDOWN,""iter_cgs"");\n      alpha = rho/sigma;\n      v_mltadd(u,tmp,-alpha,q);\n      v_add(u,q,v);\n      \n      (ip->Ax)(ip->A_par,v,u);\n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,u,z);\n	 tmp = z;\n      }\n      else tmp = u;\n      \n      v_mltadd(r,tmp,-alpha,r);\n      v_mltadd(ip->x,v,alpha,ip->x);\n      \n      old_rho = rho;\n   }\n\n#ifdef THREADSAFE\n   V_FREE(p);	V_FREE(q);	V_FREE(r);	V_FREE(u);\n   V_FREE(v);	V_FREE(z);\n#endif\n\n   return ip->x;\n}\n\n\n\n/* iter_spcgs -- simple interface for SPMAT data structures \n   use always as follows:\n      x = iter_spcgs(A,B,b,r0,tol,x,limit,steps);\n   or \n      x = iter_spcgs(A,B,b,r0,tol,VNULL,limit,steps);\n   In the second case the solution vector is created.  \n   If B is not NULL then it is a preconditioner. \n*/\n#ifndef ANSI_C\nVEC	*iter_spcgs(A,B,b,r0,tol,x,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *r0, *x;\ndouble	tol;\nint     *steps,limit;\n#else\nVEC	*iter_spcgs(SPMAT *A, SPMAT *B, VEC *b, VEC *r0, double tol,\n		    VEC *x, int limit, int *steps)\n#endif\n{	\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *) B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n   ip->info = (Fun_info) NULL;\n   ip->limit = limit;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_cgs(ip,r0);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;   \n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n\n}\n\n/*\n  Routine for performing LSQR -- the least squares QR algorithm\n  of Paige and Saunders:\n  ""LSQR: an algorithm for sparse linear equations and\n  sparse least squares"", ACM Trans. Math. Soft., v. 8\n  pp. 43--71 (1982)\n  */\n/* iter_lsqr -- sparse CG-like least squares routine:\n   -- finds min_x ||A.x-b||_2 using A defined through A & AT\n   -- returns x (if x != NULL) */\n#ifndef ANSI_C\nVEC	*iter_lsqr(ip)\nITER *ip;\n#else\nVEC	*iter_lsqr(ITER *ip)\n#endif\n{\n   STATIC VEC	*u = VNULL, *v = VNULL, *w = VNULL, *tmp = VNULL;\n   Real	alpha, beta, phi, phi_bar;\n   Real rho, rho_bar, rho_max, theta, nres;\n   Real	s, c;	/* for Givens' rotations */\n   int  m, n;\n   \n   if ( ! ip || ! ip->b || !ip->Ax || !ip->ATx )\n     error(E_NULL,""iter_lsqr"");\n   if ( ip->x == ip->b )\n     error(E_INSITU,""iter_lsqr"");\n   if (!ip->stop_crit || !ip->x)\n     error(E_NULL,""iter_lsqr"");\n\n   if ( ip->eps <= 0.0 ) ip->eps = MACHEPS;\n   \n   m = ip->b->dim;	\n   n = ip->x->dim;\n\n   u = v_resize(u,(unsigned int)m);\n   v = v_resize(v,(unsigned int)n);\n   w = v_resize(w,(unsigned int)n);\n   tmp = v_resize(tmp,(unsigned int)n);\n\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(v,TYPE_VEC);\n   MEM_STAT_REG(w,TYPE_VEC);\n   MEM_STAT_REG(tmp,TYPE_VEC);  \n\n   if (ip->x != VNULL) {\n      ip->Ax(ip->A_par,ip->x,u);    		/* u = A*x */\n      v_sub(ip->b,u,u);				/* u = b-A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n      v_copy(ip->b,u);                       /* u = b */\n   }\n \n   beta = v_norm2(u); \n   if ( beta == 0.0 ) return ip->x;\n\n   sv_mlt(1.0/beta,u,u);\n   (ip->ATx)(ip->AT_par,u,v);\n   alpha = v_norm2(v);\n   if ( alpha == 0.0 ) return ip->x;\n\n   sv_mlt(1.0/alpha,v,v);\n   v_copy(v,w);\n   phi_bar = beta;\n   rho_bar = alpha;\n   \n   rho_max = 1.0;\n   for (ip->steps = 0; ip->steps <= ip->limit; ip->steps++) {\n\n      tmp = v_resize(tmp,m);\n      (ip->Ax)(ip->A_par,v,tmp);\n      \n      v_mltadd(tmp,u,-alpha,u);\n      beta = v_norm2(u);	\n      sv_mlt(1.0/beta,u,u);\n      \n      tmp = v_resize(tmp,n);\n      (ip->ATx)(ip->AT_par,u,tmp);\n      v_mltadd(tmp,v,-beta,v);\n      alpha = v_norm2(v);	\n      sv_mlt(1.0/alpha,v,v);\n      \n      rho = sqrt(rho_bar*rho_bar+beta*beta);\n      if ( rho > rho_max )\n	rho_max = rho;\n      c   = rho_bar/rho;\n      s   = beta/rho;\n      theta   =  s*alpha;\n      rho_bar = -c*alpha;\n      phi     =  c*phi_bar;\n      phi_bar =  s*phi_bar;\n      \n      /* update ip->x & w */\n      if ( rho == 0.0 )\n	error(E_BREAKDOWN,""iter_lsqr"");\n      v_mltadd(ip->x,w,phi/rho,ip->x);\n      v_mltadd(v,w,-theta/rho,w);\n\n      nres = fabs(phi_bar*alpha*c)*rho_max;\n\n      if (ip->info) ip->info(ip,nres,w,VNULL);\n      if (ip->steps == 0) ip->init_res = nres;\n      if ( ip->stop_crit(ip,nres,w,VNULL) ) break;\n   } \n\n#ifdef THREADSAFE\n   V_FREE(u);	V_FREE(v);	V_FREE(w);	V_FREE(tmp);\n#endif\n\n   return ip->x;\n}\n\n/* iter_splsqr -- simple interface for SPMAT data structures */\n#ifndef ANSI_C\nVEC	*iter_splsqr(A,b,tol,x,limit,steps)\nSPMAT	*A;\nVEC	*b, *x;\ndouble	tol;\nint *steps,limit;\n#else\nVEC	*iter_splsqr(SPMAT *A, VEC *b, double tol, \n		     VEC *x, int limit, int *steps)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   ip->ATx = (Fun_Ax) sp_vm_mlt;\n   ip->AT_par = (void *) A;\n   ip->Bx = (Fun_Ax) NULL;\n   ip->B_par = NULL;\n\n   ip->info = (Fun_info) NULL;\n   ip->limit = limit;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_lsqr(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n\n/* iter_arnoldi -- an implementation of the Arnoldi method;\n   iterative refinement is applied.\n*/\n#ifndef ANSI_C\nMAT	*iter_arnoldi_iref(ip,h_rem,Q,H)\nITER  *ip;\nReal  *h_rem;\nMAT   *Q, *H;\n#else\nMAT	*iter_arnoldi_iref(ITER *ip, Real *h_rem, MAT *Q, MAT *H)\n#endif\n{\n   STATIC VEC *u=VNULL, *r=VNULL, *s=VNULL, *tmp=VNULL;\n   VEC v;     /* auxiliary vector */\n   int	i,j;\n   Real	h_val, c;\n   \n   if (ip == INULL)\n     error(E_NULL,""iter_arnoldi_iref"");\n   if ( ! ip->Ax || ! Q || ! ip->x )\n     error(E_NULL,""iter_arnoldi_iref"");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,""iter_arnoldi_iref"");\n   if ( Q->n != ip->x->dim ||	Q->m != ip->k )\n     error(E_SIZES,""iter_arnoldi_iref"");\n   \n   m_zero(Q);\n   H = m_resize(H,ip->k,ip->k);\n   m_zero(H);\n\n   u = v_resize(u,ip->x->dim);\n   r = v_resize(r,ip->k);\n   s = v_resize(s,ip->k);\n   tmp = v_resize(tmp,ip->x->dim);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(s,TYPE_VEC);\n   MEM_STAT_REG(tmp,TYPE_VEC);\n\n   v.dim = v.max_dim = ip->x->dim;\n\n   c = v_norm2(ip->x);\n   if ( c <= 0.0)\n     return H;\n   else {\n      v.ve = Q->me[0];\n      sv_mlt(1.0/c,ip->x,&v);\n   }\n\n   v_zero(r);\n   v_zero(s);\n   for ( i = 0; i < ip->k; i++ )\n   {\n      v.ve = Q->me[i];\n      u = (ip->Ax)(ip->A_par,&v,u);\n      for (j = 0; j <= i; j++) {\n	 v.ve = Q->me[j];\n	 /* modified Gram-Schmidt */\n	 r->ve[j] = in_prod(&v,u);\n	 v_mltadd(u,&v,-r->ve[j],u);\n      }\n      h_val = v_norm2(u);\n      /* if u == 0 then we have an exact subspace */\n      if ( h_val <= 0.0 )\n      {\n	 *h_rem = h_val;\n	 return H;\n      }\n      /* iterative refinement -- ensures near orthogonality */\n      do {\n	 v_zero(tmp);\n	 for (j = 0; j <= i; j++) {\n	    v.ve = Q->me[j];\n	    s->ve[j] = in_prod(&v,u);\n	    v_mltadd(tmp,&v,s->ve[j],tmp);\n	 }\n	 v_sub(u,tmp,u);\n         v_add(r,s,r);\n      } while ( v_norm2(s) > 0.1*(h_val = v_norm2(u)) );\n      /* now that u is nearly orthogonal to Q, update H */\n      set_col(H,i,r);\n      /* check once again if h_val is zero */\n      if ( h_val <= 0.0 )\n      {\n	 *h_rem = h_val;\n	 return H;\n      }\n      if ( i == ip->k-1 )\n      {\n	 *h_rem = h_val;\n	 continue;\n      }\n      /* H->me[i+1][i] = h_val; */\n      m_set_val(H,i+1,i,h_val);\n      v.ve = Q->me[i+1];\n      sv_mlt(1.0/h_val,u,&v);\n   }\n\n#ifdef THREADSAFE\n   V_FREE(u);   V_FREE(r);   V_FREE(s);   V_FREE(tmp);\n#endif\n\n   return H;\n}\n\n/* iter_arnoldi -- an implementation of the Arnoldi method;\n   modified Gram-Schmidt algorithm\n*/\n#ifndef ANSI_C\nMAT	*iter_arnoldi(ip,h_rem,Q,H)\nITER  *ip;\nReal  *h_rem;\nMAT   *Q, *H;\n#else\nMAT	*iter_arnoldi(ITER *ip, Real *h_rem, MAT *Q, MAT *H)\n#endif\n{\n   STATIC VEC *u=VNULL, *r=VNULL;\n   VEC v;     /* auxiliary vector */\n   int	i,j;\n   Real	h_val, c;\n   \n   if (ip == INULL)\n     error(E_NULL,""iter_arnoldi"");\n   if ( ! ip->Ax || ! Q || ! ip->x )\n     error(E_NULL,""iter_arnoldi"");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,""iter_arnoldi"");\n   if ( Q->n != ip->x->dim ||	Q->m != ip->k )\n     error(E_SIZES,""iter_arnoldi"");\n   \n   m_zero(Q);\n   H = m_resize(H,ip->k,ip->k);\n   m_zero(H);\n\n   u = v_resize(u,ip->x->dim);\n   r = v_resize(r,ip->k);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(r,TYPE_VEC);\n\n   v.dim = v.max_dim = ip->x->dim;\n\n   c = v_norm2(ip->x);\n   if ( c <= 0.0)\n     return H;\n   else {\n      v.ve = Q->me[0];\n      sv_mlt(1.0/c,ip->x,&v);\n   }\n\n   v_zero(r);\n   for ( i = 0; i < ip->k; i++ )\n   {\n      v.ve = Q->me[i];\n      u = (ip->Ax)(ip->A_par,&v,u);\n      for (j = 0; j <= i; j++) {\n	 v.ve = Q->me[j];\n	 /* modified Gram-Schmidt */\n	 r->ve[j] = in_prod(&v,u);\n	 v_mltadd(u,&v,-r->ve[j],u);\n      }\n      h_val = v_norm2(u);\n      /* if u == 0 then we have an exact subspace */\n      if ( h_val <= 0.0 )\n      {\n	 *h_rem = h_val;\n	 return H;\n      }\n      set_col(H,i,r);\n      if ( i == ip->k-1 )\n      {\n	 *h_rem = h_val;\n	 continue;\n      }\n      /* H->me[i+1][i] = h_val; */\n      m_set_val(H,i+1,i,h_val);\n      v.ve = Q->me[i+1];\n      sv_mlt(1.0/h_val,u,&v);\n   }\n\n#ifdef THREADSAFE\n   V_FREE(u);	V_FREE(r);\n#endif\n   \n   return H;\n}\n\n\n\n/* iter_sparnoldi -- uses arnoldi() with an explicit representation of A */\n#ifndef ANSI_C\nMAT	*iter_sparnoldi(A,x0,m,h_rem,Q,H)\nSPMAT	*A;\nVEC	*x0;\nint	m;\nReal	*h_rem;\nMAT	*Q, *H;\n#else\nMAT	*iter_sparnoldi(SPMAT *A, VEC *x0, int m, Real *h_rem, MAT *Q, MAT *H)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   ip->x = x0;\n   ip->k = m;\n   iter_arnoldi_iref(ip,h_rem,Q,H);\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return H;	\n}\n\n\n/* for testing gmres */\n#ifndef ANSI_C\nstatic void test_gmres(ip,i,Q,R,givc,givs,h_val)\nITER *ip;\nint i;\nMAT *Q, *R;\nVEC *givc, *givs;\ndouble h_val;\n#else\nstatic void test_gmres(ITER *ip, int i, MAT *Q, MAT *R,\n		       VEC *givc, VEC *givs, double h_val)\n#endif\n{\n   VEC vt, vt1;\n   STATIC MAT *Q1=MNULL, *R1=MNULL;\n   int j;\n   \n   /* test Q*A*Q^T = R  */\n\n   Q = m_resize(Q,i+1,ip->b->dim);\n   Q1 = m_resize(Q1,i+1,ip->b->dim);\n   R1 = m_resize(R1,i+1,i+1);\n   MEM_STAT_REG(Q1,TYPE_MAT);\n   MEM_STAT_REG(R1,TYPE_MAT);\n\n   vt.dim = vt.max_dim = ip->b->dim;\n   vt1.dim = vt1.max_dim = ip->b->dim;\n   for (j=0; j <= i; j++) {\n      vt.ve = Q->me[j];\n      vt1.ve = Q1->me[j];\n      ip->Ax(ip->A_par,&vt,&vt1);\n   }\n\n   mmtr_mlt(Q,Q1,R1);\n   R1 = m_resize(R1,i+2,i+1);\n   for (j=0; j < i; j++)\n     R1->me[i+1][j] = 0.0;\n   R1->me[i+1][i] = h_val;\n   \n   for (j = 0; j <= i; j++) {\n      rot_rows(R1,j,j+1,givc->ve[j],givs->ve[j],R1);\n   }\n\n   R1 = m_resize(R1,i+1,i+1);\n   m_sub(R,R1,R1);\n   /* if (m_norm_inf(R1) > MACHEPS*ip->b->dim)  */\n#ifndef MEX\n   printf("" %d. ||Q*A*Q^T - H|| = %g [cf. MACHEPS = %g]\n"",\n	  ip->steps,m_norm_inf(R1),MACHEPS);\n#endif\n   \n   /* check Q*Q^T = I */\n   \n   Q = m_resize(Q,i+1,ip->b->dim);\n   mmtr_mlt(Q,Q,R1);\n   for (j=0; j <= i; j++)\n     R1->me[j][j] -= 1.0;\n#ifndef MEX\n   if (m_norm_inf(R1) > MACHEPS*ip->b->dim)\n     printf("" ! m_norm_inf(Q*Q^T) = %g\n"",m_norm_inf(R1));  \n#endif\n#ifdef THREADSAFE\n   M_FREE(Q1);	M_FREE(R1);\n#endif\n}\n\n\n/* gmres -- generalised minimum residual algorithm of Saad & Schultz\n   SIAM J. Sci. Stat. Comp. v.7, pp.856--869 (1986)\n*/\n#ifndef ANSI_C\nVEC	*iter_gmres(ip)\nITER *ip;\n#else\nVEC	*iter_gmres(ITER *ip)\n#endif\n{\n   STATIC VEC *u=VNULL, *r=VNULL, *rhs = VNULL;\n   STATIC VEC *givs=VNULL, *givc=VNULL, *z = VNULL;\n   STATIC MAT *Q = MNULL, *R = MNULL;\n   VEC *rr, v, v1;   /* additional pointers (not real vectors) */\n   int	i,j, done;\n   Real	nres;\n/*   Real last_h;  */\n   \n   if (ip == INULL)\n     error(E_NULL,""iter_gmres"");\n   if ( ! ip->Ax || ! ip->b )\n     error(E_NULL,""iter_gmres"");\n   if ( ! ip->stop_crit )\n     error(E_NULL,""iter_gmres"");\n   if ( ip->k <= 0 )\n     error(E_BOUNDS,""iter_gmres"");\n   if (ip->x != VNULL && ip->x->dim != ip->b->dim)\n     error(E_SIZES,""iter_gmres"");\n   if (ip->eps <= 0.0) ip->eps = MACHEPS;\n\n   r = v_resize(r,ip->k+1);\n   u = v_resize(u,ip->b->dim);\n   rhs = v_resize(rhs,ip->k+1);\n   givs = v_resize(givs,ip->k);  /* Givens rotations */\n   givc = v_resize(givc,ip->k); \n   \n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(u,TYPE_VEC);\n   MEM_STAT_REG(rhs,TYPE_VEC);\n   MEM_STAT_REG(givs,TYPE_VEC);\n   MEM_STAT_REG(givc,TYPE_VEC);\n   \n   R = m_resize(R,ip->k+1,ip->k);\n   Q = m_resize(Q,ip->k,ip->b->dim);\n   MEM_STAT_REG(R,TYPE_MAT);\n   MEM_STAT_REG(Q,TYPE_MAT);		\n\n   if (ip->x == VNULL) {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n   }   \n\n   v.dim = v.max_dim = ip->b->dim;      /* v and v1 are pointers to rows */\n   v1.dim = v1.max_dim = ip->b->dim;  	/* of matrix Q */\n   \n   if (ip->Bx != (Fun_Ax)NULL) {    /* if precondition is defined */\n      z = v_resize(z,ip->b->dim);\n      MEM_STAT_REG(z,TYPE_VEC);\n   }\n   \n   done = FALSE;\n   for (ip->steps = 0; ip->steps < ip->limit; ) {\n\n      /* restart */\n\n      ip->Ax(ip->A_par,ip->x,u);    		/* u = A*x */\n      v_sub(ip->b,u,u);		 		/* u = b - A*x */\n      rr = u;				/* rr is a pointer only */\n      \n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,u,z);            /* tmp = B*(b-A*x)  */\n	 rr = z;\n      }\n      \n      nres = v_norm2(rr);\n      if (ip->steps == 0) {\n	 if (ip->info) ip->info(ip,nres,VNULL,VNULL);\n	 ip->init_res = nres;\n      }\n\n      if ( nres == 0.0 ) {\n	 done = TRUE;\n	 break;\n      }\n\n      v.ve = Q->me[0];\n      sv_mlt(1.0/nres,rr,&v);\n      \n      v_zero(r);\n      v_zero(rhs);\n      rhs->ve[0] = nres;\n\n      for ( i = 0; i < ip->k && ip->steps < ip->limit; i++ ) {\n	 ip->steps++;\n	 v.ve = Q->me[i];	\n	 (ip->Ax)(ip->A_par,&v,u);\n	 rr = u;\n	 if (ip->Bx) {\n	    (ip->Bx)(ip->B_par,u,z);\n	    rr = z;\n	 }\n	 \n	 if (i < ip->k - 1) {\n	    v1.ve = Q->me[i+1];\n	    v_copy(rr,&v1);\n	    for (j = 0; j <= i; j++) {\n	       v.ve = Q->me[j];\n	       /* r->ve[j] = in_prod(&v,rr); */\n	       /* modified Gram-Schmidt algorithm */\n	       r->ve[j] = in_prod(&v,&v1);\n	       v_mltadd(&v1,&v,-r->ve[j],&v1);\n	    }\n	    \n	    r->ve[i+1] = nres = v_norm2(&v1);\n	    if (nres <= MACHEPS*ip->init_res) {\n	       for (j = 0; j < i; j++) \n		 rot_vec(r,j,j+1,givc->ve[j],givs->ve[j],r);\n	       set_col(R,i,r);\n	       done = TRUE;\n	       break;\n	    }\n	    sv_mlt(1.0/nres,&v1,&v1);\n	 }\n	 else {  /* i == ip->k - 1 */\n	    /* Q->me[ip->k] need not be computed */\n\n	    for (j = 0; j <= i; j++) {\n	       v.ve = Q->me[j];\n	       r->ve[j] = in_prod(&v,rr);\n	    }\n	    \n	    nres = in_prod(rr,rr) - in_prod(r,r);\n	    if (sqrt(fabs(nres)) <= MACHEPS*ip->init_res) { \n	       for (j = 0; j < i; j++) \n		 rot_vec(r,j,j+1,givc->ve[j],givs->ve[j],r);\n	       set_col(R,i,r);\n	       done = TRUE;\n	       break;\n	    }\n	    if (nres < 0.0) { /* do restart */\n	       i--; \n	       ip->steps--;\n	       break;\n	    } \n	    r->ve[i+1] = sqrt(nres);\n	 }\n\n	 /* QR update */\n\n	 /* last_h = r->ve[i+1]; */ /* for test only */\n	 for (j = 0; j < i; j++) \n	   rot_vec(r,j,j+1,givc->ve[j],givs->ve[j],r);\n	 givens(r->ve[i],r->ve[i+1],&givc->ve[i],&givs->ve[i]);\n	 rot_vec(r,i,i+1,givc->ve[i],givs->ve[i],r);\n	 rot_vec(rhs,i,i+1,givc->ve[i],givs->ve[i],rhs);\n	 \n	 set_col(R,i,r);\n\n	 nres = fabs((double) rhs->ve[i+1]);\n	 if (ip->info) ip->info(ip,nres,VNULL,VNULL);\n	 if ( ip->stop_crit(ip,nres,VNULL,VNULL) ) {\n	    done = TRUE;\n	    break;\n	 }\n      }\n      \n      /* use ixi submatrix of R */\n\n      if (i >= ip->k) i = ip->k - 1;\n\n      R = m_resize(R,i+1,i+1);\n      rhs = v_resize(rhs,i+1);\n      \n      /* test only */\n      /* test_gmres(ip,i,Q,R,givc,givs,last_h);  */\n      \n      Usolve(R,rhs,rhs,0.0); 	 /* solve a system: R*x = rhs */\n\n      /* new approximation */\n\n      for (j = 0; j <= i; j++) {\n	 v.ve = Q->me[j]; \n	 v_mltadd(ip->x,&v,rhs->ve[j],ip->x);\n      }\n\n      if (done) break;\n\n      /* back to old dimensions */\n\n      rhs = v_resize(rhs,ip->k+1);\n      R = m_resize(R,ip->k+1,ip->k);\n\n   }\n\n#ifdef THREADSAFE\n   V_FREE(u);		V_FREE(r);	V_FREE(rhs);\n   V_FREE(givs);	V_FREE(givc);	V_FREE(z);\n   M_FREE(Q);		M_FREE(R);\n#endif\n\n   return ip->x;\n}\n\n/* iter_spgmres - a simple interface to iter_gmres */\n#ifndef ANSI_C\nVEC	*iter_spgmres(A,B,b,tol,x,k,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *x;\ndouble	tol;\nint *steps,k,limit;\n#else\nVEC	*iter_spgmres(SPMAT *A, SPMAT *B, VEC *b, double tol,\n		      VEC *x, int k, int limit, int *steps)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *) B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n   ip->k = k;\n   ip->limit = limit;\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_gmres(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n/* for testing mgcr */\n#ifndef ANSI_C\nstatic void test_mgcr(ip,i,Q,R)\nITER *ip;\nint i;\nMAT *Q, *R;\n#else\nstatic void test_mgcr(ITER *ip, int i, MAT *Q, MAT *R)\n#endif\n{\n   VEC vt, vt1;\n   static MAT *R1=MNULL;\n   static VEC *r=VNULL, *r1=VNULL;\n   VEC *rr;\n   int k,j;\n   Real sm;\n   \n   \n   /* check Q*Q^T = I */\n   vt.dim = vt.max_dim = ip->b->dim;\n   vt1.dim = vt1.max_dim = ip->b->dim;\n   \n   Q = m_resize(Q,i+1,ip->b->dim);\n   R1 = m_resize(R1,i+1,i+1);\n   r = v_resize(r,ip->b->dim);\n   r1 = v_resize(r1,ip->b->dim);\n   MEM_STAT_REG(R1,TYPE_MAT);\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(r1,TYPE_VEC);\n\n   m_zero(R1);\n   for (k=1; k <= i; k++)\n     for (j=1; j <= i; j++) {\n	vt.ve = Q->me[k];\n	vt1.ve = Q->me[j];\n	R1->me[k][j] = in_prod(&vt,&vt1);\n     }\n   for (j=1; j <= i; j++)\n     R1->me[j][j] -= 1.0;\n#ifndef MEX\n   if (m_norm_inf(R1) > MACHEPS*ip->b->dim)\n     printf("" ! (mgcr:) m_norm_inf(Q*Q^T) = %g\n"",m_norm_inf(R1));  \n#endif\n\n   /* check (r_i,Ap_j) = 0 for j <= i */\n   \n   ip->Ax(ip->A_par,ip->x,r);\n   v_sub(ip->b,r,r);\n   rr = r;\n   if (ip->Bx) {\n      ip->Bx(ip->B_par,r,r1);\n      rr = r1;\n   }\n   \n#ifndef MEX\n   printf("" ||r|| = %g\n"",v_norm2(rr));\n#endif\n   sm = 0.0;\n   for (j = 1; j <= i; j++) {\n      vt.ve = Q->me[j];\n      sm = max(sm,in_prod(&vt,rr));\n   }\n#ifndef MEX\n   if (sm >= MACHEPS*ip->b->dim)\n     printf("" ! (mgcr:) max_j (r,Ap_j) = %g\n"",sm);\n#endif\n\n}\n\n\n\n\n/* \n  iter_mgcr -- modified generalized conjugate residual algorithm;\n  fast version of GCR;\n*/\n#ifndef ANSI_C\nVEC *iter_mgcr(ip)\nITER *ip;\n#else\nVEC *iter_mgcr(ITER *ip)\n#endif\n{\n   STATIC VEC *As=VNULL, *beta=VNULL, *alpha=VNULL, *z=VNULL;\n   STATIC MAT *N=MNULL, *H=MNULL;\n   \n   VEC *rr, v, s;  /* additional pointer and structures */\n   Real nres;      /* norm of a residual */\n   Real dd;        /* coefficient d_i */\n   int i,j;\n   int done;      /* if TRUE then stop the iterative process */\n   int dim;       /* dimension of the problem */\n   \n   /* ip cannot be NULL */\n   if (ip == INULL) error(E_NULL,""mgcr"");\n   /* Ax, b and stopping criterion must be given */\n   if (! ip->Ax || ! ip->b || ! ip->stop_crit) \n     error(E_NULL,""mgcr"");\n   /* at least one direction vector must exist */\n   if ( ip->k <= 0) error(E_BOUNDS,""mgcr"");\n   /* if the vector x is given then b and x must have the same dimension */\n   if ( ip->x && ip->x->dim != ip->b->dim)\n     error(E_SIZES,""mgcr"");\n   if (ip->eps <= 0.0) ip->eps = MACHEPS;\n   \n   dim = ip->b->dim;\n   As = v_resize(As,dim);\n   alpha = v_resize(alpha,ip->k);\n   beta = v_resize(beta,ip->k);\n   \n   MEM_STAT_REG(As,TYPE_VEC);\n   MEM_STAT_REG(alpha,TYPE_VEC);\n   MEM_STAT_REG(beta,TYPE_VEC);\n   \n   H = m_resize(H,ip->k,ip->k);\n   N = m_resize(N,ip->k,dim);\n   \n   MEM_STAT_REG(H,TYPE_MAT);\n   MEM_STAT_REG(N,TYPE_MAT);\n   \n   /* if a preconditioner is defined */\n   if (ip->Bx) {\n      z = v_resize(z,dim);\n      MEM_STAT_REG(z,TYPE_VEC);\n   }\n   \n   /* if x is NULL then it is assumed that x has \n      entries with value zero */\n   if ( ! ip->x ) {\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n   }\n   \n   /* v and s are additional pointers to rows of N */\n   /* they must have the same dimension as rows of N */\n   v.dim = v.max_dim = s.dim = s.max_dim = dim;\n   \n   \n   done = FALSE;\n   for (ip->steps = 0; ip->steps < ip->limit; ) {\n      (*ip->Ax)(ip->A_par,ip->x,As);         /* As = A*x */\n      v_sub(ip->b,As,As);                    /* As = b - A*x */\n      rr = As;                               /* rr is an additional pointer */\n      \n      /* if a preconditioner is defined */\n      if (ip->Bx) {\n	 (*ip->Bx)(ip->B_par,As,z);               /* z = B*(b-A*x)  */\n	 rr = z;                                  \n      }\n      \n      /* norm of the residual */\n      nres = v_norm2(rr);\n      dd = nres;                            /* dd = ||r_i||  */\n      \n      /* check if the norm of the residual is zero */\n      if (ip->steps == 0) {                \n	 /* information for a user */\n	 if (ip->info) (*ip->info)(ip,nres,As,rr); \n	 ip->init_res = fabs(nres);\n      }\n\n      if (nres == 0.0) { \n	 /* iterative process is finished */\n	 done = TRUE; \n	 break;\n      }\n      \n      /* save this residual in the first row of N */\n      v.ve = N->me[0];\n      v_copy(rr,&v);\n      \n      for (i = 0; i < ip->k && ip->steps < ip->limit; i++) {\n	 ip->steps++;\n	 v.ve = N->me[i];                /* pointer to a row of N (=s_i) */\n	 /* note that we must use here &v, not v */\n	 (*ip->Ax)(ip->A_par,&v,As); \n	 rr = As;                        /* As = A*s_i */\n	 if (ip->Bx) {\n	    (*ip->Bx)(ip->B_par,As,z);    /* z = B*A*s_i  */\n	    rr = z;\n	 }\n	 \n	 if (i < ip->k - 1) {\n	    s.ve = N->me[i+1];         /* pointer to a row of N (=s_{i+1}) */\n	    v_copy(rr,&s);                   /* s_{i+1} = B*A*s_i */\n	    for (j = 0; j <= i-1; j++) {\n	       v.ve = N->me[j+1];      /* pointer to a row of N (=s_{j+1}) */\n	       /* beta->ve[j] = in_prod(&v,rr); */      /* beta_{j,i} */\n	       /* modified Gram-Schmidt algorithm */\n	       beta->ve[j] = in_prod(&v,&s);  	         /* beta_{j,i} */\n	                                 /* s_{i+1} -= beta_{j,i}*s_{j+1} */\n	       v_mltadd(&s,&v,- beta->ve[j],&s);    \n	    }\n	    \n	     /* beta_{i,i} = ||s_{i+1}||_2 */\n	    beta->ve[i] = nres = v_norm2(&s);     \n	    if ( nres <= MACHEPS*ip->init_res) { \n	       /* s_{i+1} == 0 */\n	       i--;\n	       done = TRUE;\n	       break;\n	    }\n	    sv_mlt(1.0/nres,&s,&s);           /* normalize s_{i+1} */\n	    \n	    v.ve = N->me[0];\n	    alpha->ve[i] = in_prod(&v,&s);     /* alpha_i = (s_0 , s_{i+1}) */\n	    \n	 }\n	 else {\n	    for (j = 0; j <= i-1; j++) {\n	       v.ve = N->me[j+1];      /* pointer to a row of N (=s_{j+1}) */\n	       beta->ve[j] = in_prod(&v,rr);       /* beta_{j,i} */\n	    }\n	    \n	    nres = in_prod(rr,rr);                 /* rr = B*A*s_{k-1} */\n	    for (j = 0; j <= i-1; j++)\n              nres -= beta->ve[j]*beta->ve[j];\n\n	    if (sqrt(fabs(nres)) <= MACHEPS*ip->init_res)  {\n	       /* s_k is zero */\n	       i--;\n	       done = TRUE;\n	       break;\n	    }\n	    if (nres < 0.0) { /* do restart */\n	       i--; \n	       ip->steps--;\n	       break; \n	    }   \n	    beta->ve[i] = sqrt(nres);         /* beta_{k-1,k-1} */\n	    \n	    v.ve = N->me[0];\n	    alpha->ve[i] = in_prod(&v,rr); \n	    for (j = 0; j <= i-1; j++)\n              alpha->ve[i] -= beta->ve[j]*alpha->ve[j];\n	    alpha->ve[i] /= beta->ve[i];                /* alpha_{k-1} */\n	    \n	 }\n	 \n	 set_col(H,i,beta);\n\n	 /* other method of computing dd */\n	/* if (fabs((double)alpha->ve[i]) > dd)  {     \n	    nres = - dd*dd + alpha->ve[i]*alpha->ve[i];\n	    nres = sqrt((double) nres); \n	    if (ip->info) (*ip->info)(ip,-nres,VNULL,VNULL);  	\n	    break;     \n	 }  */\n	 /* to avoid overflow/underflow in computing dd */\n	 /* dd *= cos(asin((double)(alpha->ve[i]/dd))); */\n	 \n	 nres = alpha->ve[i]/dd;\n	 if (fabs(nres-1.0) <= MACHEPS*ip->init_res) \n	   dd = 0.0;\n	 else {\n	    nres = 1.0 - nres*nres;\n	    if (nres < 0.0) {\n	       nres = sqrt((double) -nres); \n	       if (ip->info) (*ip->info)(ip,-dd*nres,VNULL,VNULL);  	\n	       break;\n	    }\n	    dd *= sqrt((double) nres);  \n	 }\n\n	 if (ip->info) (*ip->info)(ip,dd,VNULL,VNULL);     \n	 if ( ip->stop_crit(ip,dd,VNULL,VNULL) ) {\n	    /* stopping criterion is satisfied */\n	    done = TRUE;\n	    break;\n	 }\n	 \n      } /* end of for */\n      \n      if (i >= ip->k) i = ip->k - 1;\n      \n      /* use (i+1) by (i+1) submatrix of H */\n      H = m_resize(H,i+1,i+1);\n      alpha = v_resize(alpha,i+1);\n      Usolve(H,alpha,alpha,0.0);       /* c_i is saved in alpha */\n      \n      for (j = 0; j <= i; j++) {\n	 v.ve = N->me[j];\n	 v_mltadd(ip->x,&v,alpha->ve[j],ip->x);\n      }\n      \n      \n      if (done) break;              /* stop the iterative process */\n      alpha = v_resize(alpha,ip->k);\n      H = m_resize(H,ip->k,ip->k);\n      \n   }  /* end of while */\n\n#ifdef THREADSAFE\n   V_FREE(As);		V_FREE(beta);	V_FREE(alpha);	V_FREE(z);\n   M_FREE(N);		M_FREE(H);\n#endif\n\n   return ip->x;                    /* return the solution */\n}\n\n\n\n/* iter_spmgcr - a simple interface to iter_mgcr */\n/* no preconditioner */\n#ifndef ANSI_C\nVEC	*iter_spmgcr(A,B,b,tol,x,k,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *x;\ndouble	tol;\nint *steps,k,limit;\n#else\nVEC	*iter_spmgcr(SPMAT *A, SPMAT *B, VEC *b, double tol,\n		     VEC *x, int k, int limit, int *steps)\n#endif\n{\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *) A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *) B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n\n   ip->k = k;\n   ip->limit = limit;\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = tol;\n   ip->x = x;\n   iter_mgcr(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n\n/* \n  Conjugate gradients method for a normal equation\n  a preconditioner B must be symmetric !!\n*/\n#ifndef ANSI_C\nVEC  *iter_cgne(ip)\nITER *ip;\n#else\nVEC  *iter_cgne(ITER *ip)\n#endif\n{\n   STATIC VEC *r = VNULL, *p = VNULL, *q = VNULL, *z = VNULL;\n   Real	alpha, beta, inner, old_inner, nres;\n   VEC *rr1;   /* pointer only */\n   \n   if (ip == INULL)\n     error(E_NULL,""iter_cgne"");\n   if (!ip->Ax || ! ip->ATx || !ip->b)\n     error(E_NULL,""iter_cgne"");\n   if ( ip->x == ip->b )\n     error(E_INSITU,""iter_cgne"");\n   if (!ip->stop_crit)\n     error(E_NULL,""iter_cgne"");\n   \n   if ( ip->eps <= 0.0 ) ip->eps = MACHEPS;\n   \n   r = v_resize(r,ip->b->dim);\n   p = v_resize(p,ip->b->dim);\n   q = v_resize(q,ip->b->dim);\n\n   MEM_STAT_REG(r,TYPE_VEC);\n   MEM_STAT_REG(p,TYPE_VEC);\n   MEM_STAT_REG(q,TYPE_VEC);\n\n   z = v_resize(z,ip->b->dim);\n   MEM_STAT_REG(z,TYPE_VEC);\n\n   if (ip->x) {\n      if (ip->x->dim != ip->b->dim)\n	error(E_SIZES,""iter_cgne"");\n      ip->Ax(ip->A_par,ip->x,p);    		/* p = A*x */\n      v_sub(ip->b,p,z);		 		/* z = b - A*x */\n   }\n   else {  /* ip->x == 0 */\n      ip->x = v_get(ip->b->dim);\n      ip->shared_x = FALSE;\n      v_copy(ip->b,z);\n   }\n   rr1 = z;\n   if (ip->Bx) {\n      (ip->Bx)(ip->B_par,rr1,p);\n      rr1 = p;\n   }\n   (ip->ATx)(ip->AT_par,rr1,r);		/* r = A^T*B*(b-A*x)  */\n\n\n   old_inner = 0.0;\n   for ( ip->steps = 0; ip->steps <= ip->limit; ip->steps++ )\n   {\n      rr1 = r;\n      if ( ip->Bx ) {\n	 (ip->Bx)(ip->B_par,r,z);		/* rr = B*r */\n	 rr1 = z;\n      }\n\n      inner = in_prod(r,rr1);\n      nres = sqrt(fabs(inner));\n      if (ip->info) ip->info(ip,nres,r,rr1);\n      if (ip->steps == 0) ip->init_res = nres;\n      if ( ip->stop_crit(ip,nres,r,rr1) ) break;\n\n      if ( ip->steps )	/* if ( ip->steps > 0 ) ... */\n      {\n	 beta = inner/old_inner;\n	 p = v_mltadd(rr1,p,beta,p);\n      }\n      else		/* if ( ip->steps == 0 ) ... */\n      {\n	 beta = 0.0;\n	 p = v_copy(rr1,p);\n	 old_inner = 0.0;\n      }\n      (ip->Ax)(ip->A_par,p,q);     /* q = A*p */\n      if (ip->Bx) {\n	 (ip->Bx)(ip->B_par,q,z);\n	 (ip->ATx)(ip->AT_par,z,q);\n	 rr1 = q;			/* q = A^T*B*A*p */\n      }\n      else {\n	 (ip->ATx)(ip->AT_par,q,z);	/* z = A^T*A*p */\n	 rr1 = z;\n      }\n\n      alpha = inner/in_prod(rr1,p);\n      v_mltadd(ip->x,p,alpha,ip->x);\n      v_mltadd(r,rr1,-alpha,r);\n      old_inner = inner;\n   }\n\n#ifdef THREADSAFE\n   V_FREE(r);   V_FREE(p);   V_FREE(q);   V_FREE(z);\n#endif\n\n   return ip->x;\n}\n\n/* iter_spcgne -- a simple interface to iter_cgne() which \n   uses sparse matrix data structures\n   -- assumes that B contains an actual preconditioner (or NULL)\n   use always as follows:\n      x = iter_spcgne(A,B,b,eps,x,limit,steps);\n   or \n      x = iter_spcgne(A,B,b,eps,VNULL,limit,steps);\n   In the second case the solution vector is created.\n*/\n#ifndef ANSI_C\nVEC  *iter_spcgne(A,B,b,eps,x,limit,steps)\nSPMAT	*A, *B;\nVEC	*b, *x;\ndouble	eps;\nint *steps, limit;\n#else\nVEC  *iter_spcgne(SPMAT *A,SPMAT *B, VEC *b, double eps,\n		  VEC *x, int limit, int *steps)\n#endif\n{	\n   ITER *ip;\n   \n   ip = iter_get(0,0);\n   ip->Ax = (Fun_Ax) sp_mv_mlt;\n   ip->A_par = (void *)A;\n   ip->ATx = (Fun_Ax) sp_vm_mlt;\n   ip->AT_par = (void *)A;\n   if (B) {\n      ip->Bx = (Fun_Ax) sp_mv_mlt;\n      ip->B_par = (void *)B;\n   }\n   else {\n      ip->Bx = (Fun_Ax) NULL;\n      ip->B_par = NULL;\n   }\n   ip->info = (Fun_info) NULL;\n   ip->b = b;\n   ip->eps = eps;\n   ip->limit = limit;\n   ip->x = x;\n   iter_cgne(ip);\n   x = ip->x;\n   if (steps) *steps = ip->steps;\n   ip->shared_x = ip->shared_b = TRUE;\n   iter_free(ip);   /* release only ITER structure */\n   return x;		\n}\n\n\n\n"
leukocyte/meschach_lib/otherio.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	File for doing assorted I/O operations not invlolving\n	MAT/VEC/PERM objects\n*/\nstatic	char	rcsid[] = ""$Id: otherio.c,v 1.2 1994/01/13 05:34:52 des Exp $"";\n\n#include	<stdio.h>\n#include	<ctype.h>\n#include	""matrix.h""\n\n\n\n/* scratch area -- enough for a single line */\nstatic	char	scratch[MAXLINE+1];\n\n/* default value for fy_or_n */\nstatic	int	y_n_dflt = TRUE;\n\n/* fy_or_n -- yes-or-no to question is string s\n	-- question written to stderr, input from fp \n	-- if fp is NOT a tty then return y_n_dflt */\n#ifndef ANSI_C\nint	fy_or_n(fp,s)\nFILE	*fp;\nchar	*s;\n#else\nint	fy_or_n(FILE *fp, const char *s)\n#endif\n{\n	char	*cp;\n\n	if ( ! isatty(fileno(fp)) )\n		return y_n_dflt;\n\n	for ( ; ; )\n	{\n		fprintf(stderr,""%s (y/n) ? "",s);\n		if ( fgets(scratch,MAXLINE,fp)==NULL )\n			error(E_INPUT,""fy_or_n"");\n		cp = scratch;\n		while ( isspace(*cp) )\n			cp++;\n		if ( *cp == 'y' || *cp == 'Y' )\n			return TRUE;\n		if ( *cp == 'n' || *cp == 'N' )\n			return FALSE;\n		fprintf(stderr,""Please reply with 'y' or 'Y' for yes "");\n		fprintf(stderr,""and 'n' or 'N' for no.\n"");\n	}\n}\n\n/* yn_dflt -- sets the value of y_n_dflt to val */\n#ifndef ANSI_C\nint	yn_dflt(val)\nint	val;\n#else\nint	yn_dflt(int val)\n#endif\n{	return y_n_dflt = val;		}\n\n/* fin_int -- return integer read from file/stream fp\n	-- prompt s on stderr if fp is a tty\n	-- check that x lies between low and high: re-prompt if\n		fp is a tty, error exit otherwise\n	-- ignore check if low > high		*/\n#ifndef ANSI_C\nint	fin_int(fp,s,low,high)\nFILE	*fp;\nchar	*s;\nint	low, high;\n#else\nint	fin_int(FILE *fp, const char *s, int low, int high)\n#endif\n{\n	int	retcode, x;\n\n	if ( ! isatty(fileno(fp)) )\n	{\n		skipjunk(fp);\n		if ( (retcode=fscanf(fp,""%d"",&x)) == EOF )\n			error(E_INPUT,""fin_int"");\n		if ( retcode <= 0 )\n			error(E_FORMAT,""fin_int"");\n		if ( low <= high && ( x < low || x > high ) )\n			error(E_BOUNDS,""fin_int"");\n		return x;\n	}\n\n	for ( ; ; )\n	{\n		fprintf(stderr,""%s: "",s);\n		if ( fgets(scratch,MAXLINE,stdin)==NULL )\n			error(E_INPUT,""fin_int"");\n		retcode = sscanf(scratch,""%d"",&x);\n		if ( ( retcode==1 && low > high ) ||\n					( x >= low && x <= high ) )\n			return x;\n		fprintf(stderr,""Please type an integer in range [%d,%d].\n"",\n							low,high);\n	}\n}\n\n\n/* fin_double -- return double read from file/stream fp\n	-- prompt s on stderr if fp is a tty\n	-- check that x lies between low and high: re-prompt if\n		fp is a tty, error exit otherwise\n	-- ignore check if low > high		*/\n#ifndef ANSI_C\ndouble	fin_double(fp,s,low,high)\nFILE	*fp;\nchar	*s;\ndouble	low, high;\n#else\ndouble	fin_double(FILE *fp, const char *s, double low, double high)\n#endif\n{\n	Real	retcode, x;\n\n	if ( ! isatty(fileno(fp)) )\n	{\n		skipjunk(fp);\n#if REAL == DOUBLE\n		if ( (retcode=fscanf(fp,""%lf"",&x)) == EOF )\n#elif REAL == FLOAT\n		if ( (retcode=fscanf(fp,""%f"",&x)) == EOF )\n#endif\n			error(E_INPUT,""fin_double"");\n		if ( retcode <= 0 )\n			error(E_FORMAT,""fin_double"");\n		if ( low <= high && ( x < low || x > high ) )\n			error(E_BOUNDS,""fin_double"");\n		return (double)x;\n	}\n\n	for ( ; ; )\n	{\n		fprintf(stderr,""%s: "",s);\n		if ( fgets(scratch,MAXLINE,stdin)==NULL )\n			error(E_INPUT,""fin_double"");\n#if REAL == DOUBLE\n		retcode = sscanf(scratch,""%lf"",&x);\n#elif REAL == FLOAT \n		retcode = sscanf(scratch,""%f"",&x);\n#endif\n		if ( ( retcode==1 && low > high ) ||\n					( x >= low && x <= high ) )\n			return (double)x;\n		fprintf(stderr,""Please type an double in range [%g,%g].\n"",\n							low,high);\n	}\n}\n\n\n"
leukocyte/meschach_lib/sptort.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Steward & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n\n/*\n	This file contains tests for the sparse matrix part of Meschach\n*/\n\n#include	<stdio.h>\n#include	<math.h>\n#include	""matrix2.h""\n#include	""sparse2.h""\n#include        ""iter.h""\n\n#define	errmesg(mesg)	printf(""Error: %s error: line %d\n"",mesg,__LINE__)\n#define notice(mesg)	printf(""# Testing %s...\n"",mesg);\n\n/* for iterative methods */\n\n#if REAL == DOUBLE\n#define	EPS	1e-7\n#elif REAL == FLOAT\n#define EPS   1e-3\n#endif\n\nint	chk_col_accessSPT(A)\nSPMAT	*A;\n{\n    int		i, j, nxt_idx, nxt_row, scan_cnt, total_cnt;\n    SPROW	*r;\n    row_elt	*e;\n\n    if ( ! A )\n	error(E_NULL,""chk_col_accessSPT"");\n    if ( ! A->flag_col )\n	return FALSE;\n\n    /* scan down each column, counting the number of entries met */\n    scan_cnt = 0;\n    for ( j = 0; j < A->n; j++ )\n    {\n	i = -1;\n	nxt_idx = A->start_idx[j];\n	nxt_row = A->start_row[j];\n	while ( nxt_row >= 0 && nxt_idx >= 0 && nxt_row > i )\n	{\n	    i = nxt_row;\n	    r = &(A->row[i]);\n	    e = &(r->elt[nxt_idx]);\n	    nxt_idx = e->nxt_idx;\n	    nxt_row = e->nxt_row;\n	    scan_cnt++;\n	}\n    }\n\n    total_cnt = 0;\n    for ( i = 0; i < A->m; i++ )\n	total_cnt += A->row[i].len;\n    if ( total_cnt != scan_cnt )\n	return FALSE;\n    else\n	return TRUE;\n}\n\n\nvoid	main(argc, argv)\nint	argc;\nchar	*argv[];\n{\n    VEC		*x, *y, *z, *u, *v;\n    Real	s1, s2;\n    PERM	*pivot;\n    SPMAT	*A, *B, *C;\n    SPMAT       *B1, *C1;\n    SPROW	*r;\n    int		i, j, k, deg, seed, m, m_old, n, n_old;\n\n\n    mem_info_on(TRUE);\n\n    setbuf(stdout, (char *)NULL);\n    /* get seed if in argument list */\n    if ( argc == 1 )\n	seed = 1111;\n    else if ( argc == 2 && sscanf(argv[1],""%d"",&seed) == 1 )\n	;\n    else\n    {\n	printf(""usage: %s [seed]\n"", argv[0]);\n	exit(0);\n    }\n    srand(seed);\n\n    /* set up two random sparse matrices */\n    m = 120;\n    n = 100;\n    deg = 8;\n    notice(""allocating sparse matrices"");\n    A = sp_get(m,n,deg);\n    B = sp_get(m,n,deg);\n    notice(""setting and getting matrix entries"");\n    for ( k = 0; k < m*deg; k++ )\n    {\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(A,i,j,rand()/((Real)MAX_RAND));\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(B,i,j,rand()/((Real)MAX_RAND));\n    }\n    for ( k = 0; k < 10; k++ )\n    {\n	s1 = rand()/((Real)MAX_RAND);\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(A,i,j,s1);\n	s2 = sp_get_val(A,i,j);\n	if ( fabs(s1 - s2) >= MACHEPS )\n	    break;\n    }\n    if ( k < 10 )\n	errmesg(""sp_set_val()/sp_get_val()"");\n\n    /* test copy routines */\n    notice(""copy routines"");\n    x = v_get(n);\n    y = v_get(m);\n    z = v_get(m);\n    /* first copy routine */\n    C = sp_copy(A);\n    for ( k = 0; k < 100; k++ )\n    {\n	v_rand(x);\n	sp_mv_mlt(A,x,y);\n	sp_mv_mlt(C,x,z);\n	if ( v_norm_inf(v_sub(y,z,z)) >= MACHEPS*deg*m )\n	    break;\n    }\n    if ( k < 100 )\n    {\n	errmesg(""sp_copy()/sp_mv_mlt()"");\n	printf(""# Error in A.x (inf norm) = %g [cf MACHEPS = %g]\n"",\n	       v_norm_inf(z), MACHEPS);\n    }\n    /* second copy routine\n       -- note that A & B have different sparsity patterns */\n\n    mem_stat_mark(1);\n    sp_copy2(A,B);\n    mem_stat_free(1);\n    for ( k = 0; k < 10; k++ )\n    {\n	v_rand(x);\n	sp_mv_mlt(A,x,y);\n	sp_mv_mlt(B,x,z);\n	if ( v_norm_inf(v_sub(y,z,z)) >= MACHEPS*deg*m )\n	    break;\n    }\n    if ( k < 10 )\n    {\n	errmesg(""sp_copy2()/sp_mv_mlt()"");\n	printf(""# Error in A.x (inf norm) = %g [cf MACHEPS = %g]\n"",\n	       v_norm_inf(z), MACHEPS);\n    }\n\n    /* now check compacting routine */\n    notice(""compacting routine"");\n    sp_compact(B,0.0);\n    for ( k = 0; k < 10; k++ )\n    {\n	v_rand(x);\n	sp_mv_mlt(A,x,y);\n	sp_mv_mlt(B,x,z);\n	if ( v_norm_inf(v_sub(y,z,z)) >= MACHEPS*deg*m )\n	    break;\n    }\n    if ( k < 10 )\n    {\n	errmesg(""sp_compact()"");\n	printf(""# Error in A.x (inf norm) = %g [cf MACHEPS = %g]\n"",\n	       v_norm_inf(z), MACHEPS);\n    }\n    for ( i = 0; i < B->m; i++ )\n    {\n	r = &(B->row[i]);\n	for ( j = 0; j < r->len; j++ )\n	    if ( r->elt[j].val == 0.0 )\n		break;\n    }\n    if ( i < B->m )\n    {\n	errmesg(""sp_compact()"");\n	printf(""# Zero entry in compacted matrix\n"");\n    }\n\n    /* check column access paths */\n    notice(""resizing and access paths"");\n    m_old = A->m-1;\n    n_old = A->n-1;\n    A = sp_resize(A,A->m+10,A->n+10);\n    for ( k = 0 ; k < 20; k++ )\n    {\n	i = m_old + ((rand() >> 8) % 10);\n	j = n_old + ((rand() >> 8) % 10);\n	s1 = rand()/((Real)MAX_RAND);\n	sp_set_val(A,i,j,s1);\n	if ( fabs(s1 - sp_get_val(A,i,j)) >= MACHEPS )\n	    break;\n    }\n    if ( k < 20 )\n	errmesg(""sp_resize()"");\n    sp_col_access(A);\n    if ( ! chk_col_accessSPT(A) )\n    {\n	errmesg(""sp_col_access()"");\n    }\n    sp_diag_access(A);\n    for ( i = 0; i < A->m; i++ )\n    {\n	r = &(A->row[i]);\n	if ( r->diag != sprow_idx(r,i) )\n	    break;\n    }\n    if ( i < A->m )\n    {\n	errmesg(""sp_diag_access()"");\n    }\n\n    /* test both sp_mv_mlt() and sp_vm_mlt() */\n    x = v_resize(x,B->n);\n    y = v_resize(y,B->m);\n    u = v_get(B->m);\n    v = v_get(B->n);\n    for ( k = 0; k < 10; k++ )\n    {\n	v_rand(x);\n	v_rand(y);\n	sp_mv_mlt(B,x,u);\n	sp_vm_mlt(B,y,v);\n	if ( fabs(in_prod(x,v) - in_prod(y,u)) >=\n	    MACHEPS*v_norm2(x)*v_norm2(u)*5 )\n	    break;\n    }\n    if ( k < 10 )\n    {\n	errmesg(""sp_mv_mlt()/sp_vm_mlt()"");\n	printf(""# Error in inner products = %g [cf MACHEPS = %g]\n"",\n	       fabs(in_prod(x,v) - in_prod(y,u)), MACHEPS);\n    }\n\n    SP_FREE(A);\n    SP_FREE(B);\n    SP_FREE(C);\n\n    /* now test Cholesky and LU factorise and solve */\n    notice(""sparse Cholesky factorise/solve"");\n    A = iter_gen_sym(120,8);\n    B = sp_copy(A);\n    spCHfactor(A);\n    x = v_resize(x,A->m);\n    y = v_resize(y,A->m);\n    v_rand(x);\n    sp_mv_mlt(B,x,y);\n    z = v_resize(z,A->m);\n    spCHsolve(A,y,z);\n    v = v_resize(v,A->m);\n    sp_mv_mlt(B,z,v);\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*10 )\n    {\n	errmesg(""spCHfactor()/spCHsolve()"");\n	printf(""# Sparse Cholesky residual = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*10 )\n    {\n	errmesg(""spCHfactor()/spCHsolve()"");\n	printf(""# Solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* now test symbolic and incomplete factorisation */\n    SP_FREE(A);\n    A = sp_copy(B);\n    \n    mem_stat_mark(2);\n    spCHsymb(A);\n    mem_stat_mark(2);\n\n    spICHfactor(A);\n    spCHsolve(A,y,z);\n    v = v_resize(v,A->m);\n    sp_mv_mlt(B,z,v);\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*5 )\n    {\n	errmesg(""spCHsymb()/spICHfactor()"");\n	printf(""# Sparse Cholesky residual = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*10 )\n    {\n	errmesg(""spCHsymb()/spICHfactor()"");\n	printf(""# Solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* now test sparse LU factorisation */\n    notice(""sparse LU factorise/solve"");\n    SP_FREE(A);\n    SP_FREE(B);\n    A = iter_gen_nonsym(100,100,8,1.0);\n\n    B = sp_copy(A);\n    x = v_resize(x,A->n);\n    z = v_resize(z,A->n);\n    y = v_resize(y,A->m);\n    v = v_resize(v,A->m);\n\n    v_rand(x);\n    sp_mv_mlt(B,x,y);\n    pivot = px_get(A->m);\n\n    mem_stat_mark(3);\n    spLUfactor(A,pivot,0.1);\n    spLUsolve(A,pivot,y,z);\n    mem_stat_free(3);\n    sp_mv_mlt(B,z,v);\n\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*A->m )\n    {\n	errmesg(""spLUfactor()/spLUsolve()"");\n	printf(""# Sparse LU residual = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*100*A->m )\n    {\n	errmesg(""spLUfactor()/spLUsolve()"");\n	printf(""# Sparse LU solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* now check spLUTsolve */\n    mem_stat_mark(4);\n    sp_vm_mlt(B,x,y);\n    spLUTsolve(A,pivot,y,z);\n    sp_vm_mlt(B,z,v);\n    mem_stat_free(4);\n\n    /* compute residual */\n    v_sub(y,v,v);\n    if ( v_norm2(v) >= MACHEPS*v_norm2(y)*A->m )\n    {\n	errmesg(""spLUTsolve()"");\n	printf(""# Sparse LU residual = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(v), MACHEPS);\n    }\n    /* compute error in solution */\n    v_sub(x,z,z);\n    if ( v_norm2(z) > MACHEPS*v_norm2(x)*100*A->m )\n    {\n	errmesg(""spLUTsolve()"");\n	printf(""# Sparse LU solution error = %g [cf MACHEPS = %g]\n"",\n	       v_norm2(z), MACHEPS);\n    }\n\n    /* algebraic operations */\n    notice(""addition,subtraction and multiplying by a number"");\n    SP_FREE(A);\n    SP_FREE(B);\n\n    m = 120;\n    n = 120;\n    deg = 5;\n    A = sp_get(m,n,deg);\n    B = sp_get(m,n,deg);\n    C = sp_get(m,n,deg);\n    C1 = sp_get(m,n,deg);\n\n    for ( k = 0; k < m*deg; k++ )\n    {\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(A,i,j,rand()/((Real)MAX_RAND));\n	i = (rand() >> 8) % m;\n	j = (rand() >> 8) % n;\n	sp_set_val(B,i,j,rand()/((Real)MAX_RAND));\n    }\n    \n    s1 = mrand(); \n    B1 = sp_copy(B);\n\n    mem_stat_mark(1);\n    sp_smlt(B,s1,C);\n    sp_add(A,C,C1);\n    sp_sub(C1,A,C);\n    sp_smlt(C,-1.0/s1,C);\n    sp_add(C,B1,C);\n\n    s2 = 0.0;\n    for (k=0; k < C->m; k++) {\n       r = &(C->row[k]);\n       for (j=0; j < r->len; j++) {\n	  if (s2 < fabs(r->elt[j].val)) \n	    s2 = fabs(r->elt[j].val);\n       }\n    }\n\n    if (s2 > MACHEPS*A->m) {\n       errmesg(""add, sub, mlt sparse matrices (args not in situ)\n"");\n       printf("" difference = %g [MACEPS = %g]\n"",s2,MACHEPS);\n    }\n\n    sp_mltadd(A,B1,s1,C1);\n    sp_sub(C1,A,A);\n    sp_smlt(A,1.0/s1,C1);\n    sp_sub(C1,B1,C1);\n    mem_stat_free(1);\n\n    s2 = 0.0;\n    for (k=0; k < C1->m; k++) {\n       r = &(C1->row[k]);\n       for (j=0; j < r->len; j++) {\n	  if (s2 < fabs(r->elt[j].val)) \n	    s2 = fabs(r->elt[j].val);\n       }\n    }\n\n    if (s2 > MACHEPS*A->m) {\n       errmesg(""add, sub, mlt sparse matrices (args not in situ)\n"");\n       printf("" difference = %g [MACEPS = %g]\n"",s2,MACHEPS);\n    }\n\n    V_FREE(x);\n    V_FREE(y);    \n    V_FREE(z);\n    V_FREE(u);\n    V_FREE(v);  \n    PX_FREE(pivot);\n    SP_FREE(A);\n    SP_FREE(B);\n    SP_FREE(C);\n    SP_FREE(B1);\n    SP_FREE(C1);\n\n    printf(""# Done testing (%s)\n"",argv[0]);\n    mem_info();\n}\n    \n\n\n\n\n"
leukocyte/meschach_lib/MACHINES/RS6000/machine.c,"\n/**************************************************************************\n**\n** Copyright (C) 1993 David E. Stewart & Zbigniew Leyk, all rights reserved.\n**\n**			     Meschach Library\n** \n** This Meschach Library is provided ""as is"" without any express \n** or implied warranty of any kind with respect to this software. \n** In particular the authors shall not be liable for any direct, \n** indirect, special, incidental or consequential damages arising \n** in any way from use of the software.\n** \n** Everyone is granted permission to copy, modify and redistribute this\n** Meschach Library, provided:\n**  1.  All copies contain this copyright notice.\n**  2.  All modified copies shall carry a notice stating who\n**      made the last modification and the date of such modification.\n**  3.  No charge is made for this software or works derived from it.  \n**      This clause shall not be construed as constraining other software\n**      distributed on the same medium as this software, nor is a\n**      distribution fee considered a charge.\n**\n***************************************************************************/\n\n/*\n  This file contains basic routines which are used by the functions\n  in matrix.a etc.\n  These are the routines that should be modified in order to take\n  full advantage of specialised architectures (pipelining, vector\n  processors etc).\n  */\nstatic	char	*rcsid = ""$Header: /usr/local/home/des/meschach/meschach/RCS/machine.c,v 1.3 1991/08/29 06:42:11 des Exp $"";\n\n#include	""machine.h""\n\n/* __ip__ -- inner product */\ndouble	__ip__(dp1,dp2,len)\nregister double	*dp1, *dp2;\nint	len;\n{\n    register int	len4;\n    register int	i;\n    register double	sum0, sum1, sum2, sum3;\n    \n    sum0 = sum1 = sum2 = sum3 = 0.0;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    \n    for ( i = 0; i < len4; i++ )\n    {\n	sum0 += dp1[4*i]*dp2[4*i];\n	sum1 += dp1[4*i+1]*dp2[4*i+1];\n	sum2 += dp1[4*i+2]*dp2[4*i+2];\n	sum3 += dp1[4*i+3]*dp2[4*i+3];\n    }\n    sum0 += sum1 + sum2 + sum3;\n    dp1 += 4*len4;	dp2 += 4*len4;\n    \n    for ( i = 0; i < len; i++ )\n	sum0 += (*dp1++)*(*dp2++);\n    \n    return sum0;\n}\n\n/* __mltadd__ -- scalar multiply and add c.f. v_mltadd() */\nvoid	__mltadd__(dp1,dp2,s,len)\nregister double	*dp1, *dp2, s;\nregister int	len;\n{\n    register int	i, len4;\n    \n    len4 = len / 4;\n    len  = len % 4;\n    for ( i = 0; i < len4; i++ )\n    {\n	dp1[4*i]   += s*dp2[4*i];\n	dp1[4*i+1] += s*dp2[4*i+1];\n	dp1[4*i+2] += s*dp2[4*i+2];\n	dp1[4*i+3] += s*dp2[4*i+3];\n    }\n    dp1 += 4*len4;	dp2 += 4*len4;\n    \n    for ( i = 0; i < len; i++ )\n	(*dp1++) += s*(*dp2++);\n}\n\n/* __smlt__ scalar multiply array c.f. sv_mlt() */\nvoid	__smlt__(dp,s,out,len)\nregister double	*dp, s, *out;\nregister int	len;\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	(*out++) = s*(*dp++);\n}\n\n/* __add__ -- add arrays c.f. v_add() */\nvoid	__add__(dp1,dp2,out,len)\nregister double	*dp1, *dp2, *out;\nregister int	len;\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	(*out++) = (*dp1++) + (*dp2++);\n}\n\n/* __sub__ -- subtract arrays c.f. v_sub() */\nvoid	__sub__(dp1,dp2,out,len)\nregister double	*dp1, *dp2, *out;\nregister int	len;\n{\n    register int	i;\n    for ( i = 0; i < len; i++ )\n	(*out++) = (*dp1++) - (*dp2++);\n}\n\n/* __zero__ -- zeros an array of double precision numbers */\nvoid	__zero__(dp,len)\nregister double	*dp;\nregister int	len;\n{\n    /* if a double precision zero is equivalent to a string of nulls */\n    MEM_ZERO((char *)dp,len*sizeof(double));\n    /* else, need to zero the array entry by entry */\n    /*************************************************\n      while ( len-- )\n      *dp++ = 0.0;\n      *************************************************/\n}\n\n/***********************************************************************\n ******			Faster versions				********\n ***********************************************************************/\n\n/* __ip4__ -- compute 4 inner products in one go */\nvoid	__ip4__(v0,v1,v2,v3,w,out,len)\ndouble	*v0, *v1, *v2, *v3, *w;\ndouble	out[4];\nint	len;\n{\n    register int	i, len2;\n    register double	sum00, sum10, sum20, sum30, w_val0;\n    register double	sum01, sum11, sum21, sum31, w_val1;\n    \n    len2 = len / 2;\n    len  = len % 2;\n    sum00 = sum10 = sum20 = sum30 = 0.0;\n    sum01 = sum11 = sum21 = sum31 = 0.0;\n    for ( i = 0; i < len2; i++ )\n    {\n	w_val0 = w[2*i];\n	w_val1 = w[2*i+1];\n	sum00 += v0[2*i]  *w_val0;\n	sum01 += v0[2*i+1]*w_val1;\n	sum10 += v1[2*i]  *w_val0;\n	sum11 += v1[2*i+1]*w_val1;\n	sum20 += v2[2*i]  *w_val0;\n	sum21 += v2[2*i+1]*w_val1;\n	sum30 += v3[2*i]  *w_val0;\n	sum31 += v3[2*i+1]*w_val1;\n    }\n    w += 2*len2;\n    v0 += 2*len2;\n    v1 += 2*len2;\n    v2 += 2*len2;\n    v3 += 2*len2;\n    for ( i = 0; i < len; i++ )\n    {\n	w_val0 = w[i];\n	sum00 += v0[i]*w_val0;\n	sum10 += v1[i]*w_val0;\n	sum20 += v2[i]*w_val0;\n	sum30 += v3[i]*w_val0;\n    }\n    out[0] = sum00 + sum01;\n    out[1] = sum10 + sum11;\n    out[2] = sum20 + sum21;\n    out[3] = sum30 + sum31;\n}\n\n/* __lc4__ -- linear combinations: w <- w+a[0]*v0+ ... + a[3]*v3 */\nvoid	__lc4__(v0,v1,v2,v3,w,a,len)\ndouble	*v0, *v1, *v2, *v3, *w;\ndouble	a[4];\nint	len;\n{\n    register int	i, len2;\n    register double	a0, a1, a2, a3, tmp0, tmp1;\n    \n    len2 = len / 2;\n    len  = len % 2;\n    \n    a0 = a[0];	a1 = a[1];\n    a2 = a[2];	a3 = a[3];\n    for ( i = 0; i < len2; i++ )\n    {\n	tmp0 = w[2*i]   + a0*v0[2*i];\n	tmp1 = w[2*i+1] + a0*v0[2*i+1];\n	tmp0 += a1*v1[2*i];\n	tmp1 += a1*v1[2*i+1];\n	tmp0 += a2*v2[2*i];\n	tmp1 += a2*v2[2*i+1];\n	tmp0 += a3*v3[2*i];\n	tmp1 += a3*v3[2*i+1];\n	w[2*i]   = tmp0;\n	w[2*i+1] = tmp1;\n    }\n    w += 2*len2;\n    v0 += 2*len2;\n    v1 += 2*len2;\n    v2 += 2*len2;\n    v3 += 2*len2;\n    for ( i = 0; i < len; i++ )\n	w[i] += a0*v0[i] + a1*v1[i] + a2*v2[i] + a3*v3[i];\n}\n\n/* __ma4__ -- multiply and add with 4 vectors: vi <- vi + ai*w */\nvoid	__ma4__(v0,v1,v2,v3,w,a,len)\ndouble	*v0, *v1, *v2, *v3, *w;\ndouble	a[4];\nint	len;\n{\n    register int	i;\n    register double	a0, a1, a2, a3, w0, w1, w2, w3;\n\n    a0 = a[0];	a1 = a[1];\n    a2 = a[2];	a3 = a[3];\n    for ( i = 0; i < len; i++ )\n    {\n	w0 = w[i];\n	v0[i] += a0*w0;\n	v1[i] += a1*w0;\n	v2[i] += a2*w0;\n	v3[i] += a3*w0;\n    }\n}\n"
srad/srad_v1/main.c,"//====================================================================================================100\n//		UPDATE\n//====================================================================================================100\n\n//    2006.03   Rob Janiczek\n//        --creation of prototype version\n//    2006.03   Drew Gilliam\n//        --rewriting of prototype version into current version\n//        --got rid of multiple function calls, all code in a  \n//         single function (for speed)\n//        --code cleanup & commenting\n//        --code optimization efforts   \n//    2006.04   Drew Gilliam\n//        --added diffusion coefficent saturation on [0,1]\n//		2009.12 Lukasz G. Szafaryn\n//		-- reading from image, command line inputs\n//		2010.01 Lukasz G. Szafaryn\n//		--comments\n\n//====================================================================================================100\n//	DEFINE / INCLUDE\n//====================================================================================================100\n\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\n#include <omp.h>\n\n#include ""define.c""\n#include ""graphics.c""\n#include ""resize.c""\n#include ""timer.c""\n\n//====================================================================================================100\n//====================================================================================================100\n//	MAIN FUNCTION\n//====================================================================================================100\n//====================================================================================================100\n\nint main(int argc, char *argv []){\n\n	//================================================================================80\n	// 	VARIABLES\n	//================================================================================80\n\n	// time\n	long long time0;\n	long long time1;\n	long long time2;\n	long long time3;\n	long long time4;\n	long long time5;\n	long long time6;\n	long long time7;\n	long long time8;\n	long long time9;\n	long long time10;\n\n	time0 = get_time();\n\n    // inputs image, input paramenters\n    fp* image_ori;																// originalinput image\n	int image_ori_rows;\n	int image_ori_cols;\n	long image_ori_elem;\n\n    // inputs image, input paramenters\n    fp* image;															// input image\n    long Nr,Nc;													// IMAGE nbr of rows/cols/elements\n	long Ne;\n\n	// algorithm parameters\n    int niter;																// nbr of iterations\n    fp lambda;															// update step size\n\n    // size of IMAGE\n	int r1,r2,c1,c2;												// row/col coordinates of uniform ROI\n	long NeROI;														// ROI nbr of elements\n    \n    // ROI statistics\n    fp meanROI, varROI, q0sqr;											//local region statistics\n    \n    // surrounding pixel indicies\n    int *iN,*iS,*jE,*jW;    \n\n    // center pixel value\n    fp Jc;\n\n	// directional derivatives\n	fp *dN,*dS,*dW,*dE;\n    \n    // calculation variables\n    fp tmp,sum,sum2;\n    fp G2,L,num,den,qsqr,D;\n       \n    // diffusion coefficient\n    fp *c; \n	fp cN,cS,cW,cE;\n    \n    // counters\n    int iter;   // primary loop\n    long i,j;    // image row/col\n    long k;      // image single index    \n\n	// number of threads\n	int threads;\n\n	time1 = get_time();\n\n	//================================================================================80\n	// 	GET INPUT PARAMETERS\n	//================================================================================80\n\n	if(argc != 6){\n		printf(""ERROR: wrong number of arguments\n"");\n		return 0;\n	}\n	else{\n		niter = atoi(argv[1]);\n		lambda = atof(argv[2]);\n		Nr = atoi(argv[3]);						// it is 502 in the original image\n		Nc = atoi(argv[4]);						// it is 458 in the original image\n		threads = atoi(argv[5]);\n	}\n\n	omp_set_num_threads(threads);\n	// printf(""THREAD %d\n"", omp_get_thread_num());\n	// printf(""NUMBER OF THREADS: %d\n"", omp_get_num_threads());\n\n	time2 = get_time();\n\n	//================================================================================80\n	// 	READ IMAGE (SIZE OF IMAGE HAS TO BE KNOWN)\n	//================================================================================80\n\n    // read image\n	image_ori_rows = 502;\n	image_ori_cols = 458;\n	image_ori_elem = image_ori_rows * image_ori_cols;\n\n	image_ori = (fp*)malloc(sizeof(fp) * image_ori_elem);\n\n	read_graphics(	""../../../data/srad/image.pgm"",\n								image_ori,\n								image_ori_rows,\n								image_ori_cols,\n								1);\n\n	time3 = get_time();\n\n	//================================================================================80\n	// 	RESIZE IMAGE (ASSUMING COLUMN MAJOR STORAGE OF image_orig)\n	//================================================================================80\n\n	Ne = Nr*Nc;\n\n	image = (fp*)malloc(sizeof(fp) * Ne);\n\n	resize(	image_ori,\n				image_ori_rows,\n				image_ori_cols,\n				image,\n				Nr,\n				Nc,\n				1);\n\n	time4 = get_time();\n\n	//================================================================================80\n	// 	SETUP\n	//================================================================================80\n\n    r1     = 0;											// top row index of ROI\n    r2     = Nr - 1;									// bottom row index of ROI\n    c1     = 0;											// left column index of ROI\n    c2     = Nc - 1;									// right column index of ROI\n\n    // ROI image size    \n    NeROI = (r2-r1+1)*(c2-c1+1);											// number of elements in ROI, ROI size\n    \n    // allocate variables for surrounding pixels\n    iN = malloc(sizeof(int*)*Nr) ;									// north surrounding element\n    iS = malloc(sizeof(int*)*Nr) ;									// south surrounding element\n    jW = malloc(sizeof(int*)*Nc) ;									// west surrounding element\n    jE = malloc(sizeof(int*)*Nc) ;									// east surrounding element\n    \n	// allocate variables for directional derivatives\n	dN = malloc(sizeof(fp)*Ne) ;											// north direction derivative\n    dS = malloc(sizeof(fp)*Ne) ;											// south direction derivative\n    dW = malloc(sizeof(fp)*Ne) ;											// west direction derivative\n    dE = malloc(sizeof(fp)*Ne) ;											// east direction derivative\n\n	// allocate variable for diffusion coefficient\n    c  = malloc(sizeof(fp)*Ne) ;											// diffusion coefficient\n        \n    // N/S/W/E indices of surrounding pixels (every element of IMAGE)\n	// #pragma omp parallel\n    for (i=0; i<Nr; i++) {\n        iN[i] = i-1;														// holds index of IMAGE row above\n        iS[i] = i+1;														// holds index of IMAGE row below\n    }\n	// #pragma omp parallel\n    for (j=0; j<Nc; j++) {\n        jW[j] = j-1;														// holds index of IMAGE column on the left\n        jE[j] = j+1;														// holds index of IMAGE column on the right\n    }\n	// N/S/W/E boundary conditions, fix surrounding indices outside boundary of IMAGE\n    iN[0]    = 0;															// changes IMAGE top row index from -1 to 0\n    iS[Nr-1] = Nr-1;														// changes IMAGE bottom row index from Nr to Nr-1 \n    jW[0]    = 0;															// changes IMAGE leftmost column index from -1 to 0\n    jE[Nc-1] = Nc-1;														// changes IMAGE rightmost column index from Nc to Nc-1\n\n	time5 = get_time();\n\n	//================================================================================80\n	// 	SCALE IMAGE DOWN FROM 0-255 TO 0-1 AND EXTRACT\n	//================================================================================80\n\n	// #pragma omp parallel\n	for (i=0; i<Ne; i++) {													// do for the number of elements in input IMAGE\n		image[i] = exp(image[i]/255);											// exponentiate input IMAGE and copy to output image\n    }\n\n	time6 = get_time();\n\n	//================================================================================80\n	// 	COMPUTATION\n	//================================================================================80\n\n	// printf(""iterations: "");\n\n    // primary loop\n    for (iter=0; iter<niter; iter++){										// do for the number of iterations input parameter\n\n		// printf(""%d "", iter);\n		// fflush(NULL);\n\n        // ROI statistics for entire ROI (single number for ROI)\n        sum=0; \n		sum2=0;\n        for (i=r1; i<=r2; i++) {											// do for the range of rows in ROI\n            for (j=c1; j<=c2; j++) {										// do for the range of columns in ROI\n                tmp   = image[i + Nr*j];										// get coresponding value in IMAGE\n                sum  += tmp ;												// take corresponding value and add to sum\n                sum2 += tmp*tmp;											// take square of corresponding value and add to sum2\n            }\n        }\n        meanROI = sum / NeROI;												// gets mean (average) value of element in ROI\n        varROI  = (sum2 / NeROI) - meanROI*meanROI;							// gets variance of ROI\n        q0sqr   = varROI / (meanROI*meanROI);								// gets standard deviation of ROI\n\n        // directional derivatives, ICOV, diffusion coefficent\n		#pragma omp parallel for shared(image, dN, dS, dW, dE, c, Nr, Nc, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n		for (j=0; j<Nc; j++) {												// do for the range of columns in IMAGE\n\n            for (i=0; i<Nr; i++) {											// do for the range of rows in IMAGE \n\n                // current index/pixel\n                k = i + Nr*j;												// get position of current element\n                Jc = image[k];													// get value of the current element\n\n                // directional derivates (every element of IMAGE)\n                dN[k] = image[iN[i] + Nr*j] - Jc;								// north direction derivative\n                dS[k] = image[iS[i] + Nr*j] - Jc;								// south direction derivative\n                dW[k] = image[i + Nr*jW[j]] - Jc;								// west direction derivative\n                dE[k] = image[i + Nr*jE[j]] - Jc;								// east direction derivative\n\n                // normalized discrete gradient mag squared (equ 52,53)\n                G2 = (dN[k]*dN[k] + dS[k]*dS[k]								// gradient (based on derivatives)\n                    + dW[k]*dW[k] + dE[k]*dE[k]) / (Jc*Jc);\n\n                // normalized discrete laplacian (equ 54)\n                L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;					// laplacian (based on derivatives)\n\n                // ICOV (equ 31/35)\n                num  = (0.5*G2) - ((1.0/16.0)*(L*L)) ;						// num (based on gradient and laplacian)\n                den  = 1 + (.25*L);											// den (based on laplacian)\n                qsqr = num/(den*den);										// qsqr (based on num and den)\n \n                // diffusion coefficent (equ 33) (every element of IMAGE)\n                den = (qsqr-q0sqr) / (q0sqr * (1+q0sqr)) ;					// den (based on qsqr and q0sqr)\n                c[k] = 1.0 / (1.0+den) ;									// diffusion coefficient (based on den)\n\n                // saturate diffusion coefficent to 0-1 range\n                if (c[k] < 0)												// if diffusion coefficient < 0\n					{c[k] = 0;}												// ... set to 0\n                else if (c[k] > 1)											// if diffusion coefficient > 1\n					{c[k] = 1;}												// ... set to 1\n\n            }\n\n        }\n\n        // divergence & image update\n		#pragma omp parallel for shared(image, c, Nr, Nc, lambda) private(i, j, k, D, cS, cN, cW, cE)\n        for (j=0; j<Nc; j++) {												// do for the range of columns in IMAGE\n\n			// printf(""NUMBER OF THREADS: %d\n"", omp_get_num_threads());\n\n            for (i=0; i<Nr; i++) {											// do for the range of rows in IMAGE\n\n                // current index\n                k = i + Nr*j;												// get position of current element\n\n                // diffusion coefficent\n                cN = c[k];													// north diffusion coefficient\n                cS = c[iS[i] + Nr*j];										// south diffusion coefficient\n                cW = c[k];													// west diffusion coefficient\n                cE = c[i + Nr*jE[j]];										// east diffusion coefficient\n\n                // divergence (equ 58)\n                D = cN*dN[k] + cS*dS[k] + cW*dW[k] + cE*dE[k];				// divergence\n\n                // image update (equ 61) (every element of IMAGE)\n                image[k] = image[k] + 0.25*lambda*D;								// updates image (based on input time step and divergence)\n\n            }\n\n        }\n\n	}\n\n	// printf(""\n"");\n\n	time7 = get_time();\n\n	//================================================================================80\n	// 	SCALE IMAGE UP FROM 0-1 TO 0-255 AND COMPRESS\n	//================================================================================80\n\n	// #pragma omp parallel\n	for (i=0; i<Ne; i++) {													// do for the number of elements in IMAGE\n		image[i] = log(image[i])*255;													// take logarithm of image, log compress\n	}\n\n	time8 = get_time();\n\n	//================================================================================80\n	// 	WRITE IMAGE AFTER PROCESSING\n	//================================================================================80\n\n	write_graphics(	""image_out.pgm"",\n								image,\n								Nr,\n								Nc,\n								1,\n								255);\n\n	time9 = get_time();\n\n	//================================================================================80\n	// 	DEALLOCATE\n	//================================================================================80\n\n	free(image_ori);\n	free(image);\n\n    free(iN); free(iS); free(jW); free(jE);									// deallocate surrounding pixel memory\n    free(dN); free(dS); free(dW); free(dE);									// deallocate directional derivative memory\n    free(c);																// deallocate diffusion coefficient memory\n\n	time10 = get_time();\n\n	//================================================================================80\n	//		DISPLAY TIMING\n	//================================================================================80\n\n	printf(""Time spent in different stages of the application:\n"");\n	printf(""%.12f s, %.12f % : SETUP VARIABLES\n"", 									(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : READ COMMAND LINE PARAMETERS\n"", 	(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : READ IMAGE FROM FILE\n"", 						(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : RESIZE IMAGE\n"", 										(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : SETUP, MEMORY ALLOCATION\n"", 				(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : EXTRACT IMAGE\n"", 									(float) (time6-time5) / 1000000, (float) (time6-time5) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : COMPUTE\n"", 												(float) (time7-time6) / 1000000, (float) (time7-time6) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : COMPRESS IMAGE\n"", 									(float) (time8-time7) / 1000000, (float) (time8-time7) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : SAVE IMAGE INTO FILE\n"", 							(float) (time9-time8) / 1000000, (float) (time9-time8) / (float) (time10-time0) * 100);\n	printf(""%.12f s, %.12f % : FREE MEMORY\n"", 										(float) (time10-time9) / 1000000, (float) (time10-time9) / (float) (time10-time0) * 100);\n	printf(""Total time:\n"");\n	printf(""%.12f s\n"", 																					(float) (time10-time0) / 1000000);\n\n//====================================================================================================100\n//	END OF FILE\n//====================================================================================================100\n\n}\n\n\n"
srad/srad_v1/timer.c,"#include <stdlib.h>\n#include <sys/time.h>\n\n // Returns the current system time in microseconds\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n"
srad/srad_v1/graphics.c,"//====================================================================================================100\n//====================================================================================================100\n//	INCLUDE/DEFINE\n//====================================================================================================100\n//====================================================================================================100\n\n// #include <stdlib.h>\n// #include <string.h>\n#include <stdio.h>\n// #include <math.h>\n// #include <time.h>\n// #include <sys/types.h>\n// #include <dirent.h>\n// #include <errno.h>\n\n//====================================================================================================100\n//====================================================================================================100\n//	WRITE FUNCTION\n//====================================================================================================100\n//====================================================================================================100\n\nvoid write_graphics(	char* filename,\n									fp* input, \n									int data_rows, \n									int data_cols, \n									int major,\n									int data_range){\n\n	//================================================================================80\n	//	VARIABLES\n	//================================================================================80\n\n	FILE* fid;\n	int i, j;\n\n	//================================================================================80\n	//	CREATE/OPEN FILE FOR WRITING\n	//================================================================================80\n\n	fid = fopen(filename, ""w"");\n	if( fid == NULL ){\n		printf( ""The file was not created/opened for writing\n"" );\n		return;\n	}\n\n	//================================================================================80\n	//	WRITE PGM FILE HEADER\n	//================================================================================80\n\n	fprintf(fid, ""P2\n"");\n	fprintf(fid, ""%d %d\n"", data_cols, data_rows);\n	fprintf(fid, ""%d\n"", data_range);\n\n	//================================================================================80\n	//	WRITE VALUES TO THE FILE\n	//================================================================================80\n\n	// if matrix is saved row major in memory (C)\n	if(major==0){\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fprintf(fid, ""%d "", (int)input[i*data_cols+j]);\n			}\n			fprintf(fid, ""\n"");\n		}\n	}\n	// if matrix is saved column major in memory (MATLAB)\n	else{\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fprintf(fid, ""%d "", (int)input[j*data_rows+i]);\n			}\n			fprintf(fid, ""\n"");\n		}\n	}\n\n	//================================================================================80\n	//	CLOSE FILE\n	//================================================================================80\n\n	fclose(fid);\n\n}\n\n//====================================================================================================100\n//====================================================================================================100\n//	READ FUNCTION\n//====================================================================================================100\n//====================================================================================================100\n\nvoid read_graphics(	char* filename,\n									fp* input,\n									int data_rows, \n									int data_cols,\n									int major){\n\n	//================================================================================80\n	//	VARIABLES\n	//================================================================================80\n\n	FILE* fid;\n	int i, j;\n	char c;\n	int temp;\n\n	//================================================================================80\n	//	OPEN FILE FOR READING\n	//================================================================================80\n\n	fid = fopen(filename, ""r"");\n	if( fid == NULL ){\n		printf( ""The file was not opened for reading\n"" );\n		return;\n	}\n\n	//================================================================================80\n	//	SKIP PGM FILE HEADER\n	//================================================================================80\n\n	i = 0;\n	while(i<3){\n		c = fgetc(fid);\n		if(c == '\n'){\n			i = i+1;\n		}\n	};\n\n	//================================================================================80\n	//	READ VALUES FROM THE FILE\n	//================================================================================80\n\n	if(major==0){																// if matrix is saved row major in memory (C)\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fscanf(fid, ""%d"", &temp);\n				input[i*data_cols+j] = (fp)temp;\n			}\n		}\n	}\n	else{																				// if matrix is saved column major in memory (MATLAB)\n		for(i=0; i<data_rows; i++){\n			for(j=0; j<data_cols; j++){\n				fscanf(fid, ""%d"", &temp);\n				input[j*data_rows+i] = (fp)temp;\n			}\n		}\n	}\n\n	//================================================================================80\n	//	CLOSE FILE\n	//================================================================================80\n\n	fclose(fid);\n\n}\n"
srad/srad_v1/resize.c,"//====================================================================================================100\n//====================================================================================================100\n//	RESIZE FUNCTION\n//====================================================================================================100\n//====================================================================================================100\n\nvoid resize(	fp* input, \n					int input_rows,\n					int input_cols,\n					fp* output,\n					int output_rows,\n					int output_cols,\n					int major){\n\n	//================================================================================80\n	//	VARIABLES\n	//================================================================================80\n\n	int i, j;\n	int i2, j2;\n\n	//================================================================================80\n	//	COMPUTATION\n	//================================================================================80 \n\n	//============================================================60\n	//	ROW MAJOR\n	//============================================================60\n\n	if(major == 0){																												// do if data is saved row major\n\n		for(i=0, i2=0; i<output_rows; i++, i2++){\n			if(i2>=input_rows){\n				i2 = i2 - input_rows;\n			}\n			for(j=0, j2=0; j<output_cols; j++, j2++){\n				if(j2>=input_cols){\n					j2 = j2 - input_cols;\n				}\n				output[i*output_cols+j] = input[i2*input_cols+j2];\n			}\n		}\n\n	}\n\n	//============================================================60\n	//	COLUMN MAJOR\n	//============================================================60\n\n	else{																															// do if data is saved column major\n\n		for(j=0, j2=0; j<output_cols; j++, j2++){\n			if(j2>=input_cols){\n				j2 = j2 - input_cols;\n			}\n			for(i=0, i2=0; i<output_rows; i++, i2++){\n				if(i2>=input_rows){\n					i2 = i2 - input_rows;\n				}\n				output[j*output_rows+i] = input[j2*input_rows+i2];\n			}\n		}\n\n	}\n\n}\n"
srad/srad_v1/define.c,//====================================================================================================100\n//====================================================================================================100\n//	DEFINE\n//====================================================================================================100\n//====================================================================================================100\n\n#define fp float\n
srad/srad_v2/srad.cpp,"// srad.cpp : Defines the entry point for the console application.\n//\n\n//#define OUTPUT\n\n\n#define OPEN\n#define	ITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\n\nvoid random_matrix(float *I, int rows, int cols);\n\nvoid usage(int argc, char **argv)\n{\n	fprintf(stderr, ""Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\n"", argv[0]);\n	fprintf(stderr, ""\t<rows>   - number of rows\n"");\n	fprintf(stderr, ""\t<cols>    - number of cols\n"");\n	fprintf(stderr, ""\t<y1> 	 - y1 value of the speckle\n"");\n	fprintf(stderr, ""\t<y2>      - y2 value of the speckle\n"");\n	fprintf(stderr, ""\t<x1>       - x1 value of the speckle\n"");\n	fprintf(stderr, ""\t<x2>       - x2 value of the speckle\n"");\n	fprintf(stderr, ""\t<no. of threads>  - no. of threads\n"");\n	fprintf(stderr, ""\t<lamda>   - lambda (0,1)\n"");\n	fprintf(stderr, ""\t<no. of iter>   - number of iterations\n"");\n	\n	exit(1);\n}\n\nint main(int argc, char* argv[])\n{   \n	int rows, cols, size_I, size_R, niter = 10, iter, k;\n    float *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n	float Jc, G2, L, num, den, qsqr;\n	int *iN,*iS,*jE,*jW;\n	float *dN,*dS,*dW,*dE;\n	int r1, r2, c1, c2;\n	float cN,cS,cW,cE;\n	float *c, D;\n	float lambda;\n	int i, j;\n    int nthreads;\n\n	if (argc == 10)\n	{\n		rows = atoi(argv[1]); //number of rows in the domain\n		cols = atoi(argv[2]); //number of cols in the domain\n		if ((rows%16!=0) || (cols%16!=0)){\n			fprintf(stderr, ""rows and cols must be multiples of 16\n"");\n			exit(1);\n		}\n		r1   = atoi(argv[3]); //y1 position of the speckle\n		r2   = atoi(argv[4]); //y2 position of the speckle\n		c1   = atoi(argv[5]); //x1 position of the speckle\n		c2   = atoi(argv[6]); //x2 position of the speckle\n		nthreads = atoi(argv[7]); // number of threads\n		lambda = atof(argv[8]); //Lambda value\n		niter = atoi(argv[9]); //number of iterations\n	}\n    else{\n		usage(argc, argv);\n    }\n\n\n	size_I = cols * rows;\n    size_R = (r2-r1+1)*(c2-c1+1);   \n\n	I = (float *)malloc( size_I * sizeof(float) );\n    J = (float *)malloc( size_I * sizeof(float) );\n	c  = (float *)malloc(sizeof(float)* size_I) ;\n\n    iN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n    iS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n    jW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n    jE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\n\n	dN = (float *)malloc(sizeof(float)* size_I) ;\n    dS = (float *)malloc(sizeof(float)* size_I) ;\n    dW = (float *)malloc(sizeof(float)* size_I) ;\n    dE = (float *)malloc(sizeof(float)* size_I) ;    \n    \n\n    for (int i=0; i< rows; i++) {\n        iN[i] = i-1;\n        iS[i] = i+1;\n    }    \n    for (int j=0; j< cols; j++) {\n        jW[j] = j-1;\n        jE[j] = j+1;\n    }\n    iN[0]    = 0;\n    iS[rows-1] = rows-1;\n    jW[0]    = 0;\n    jE[cols-1] = cols-1;\n	\n	printf(""Randomizing the input matrix\n"");\n\n    random_matrix(I, rows, cols);\n\n    for (k = 0;  k < size_I; k++ ) {\n     	J[k] = (float)exp(I[k]) ;\n    }\n   \n	printf(""Start the SRAD main loop\n"");\n\n#ifdef ITERATION\n	for (iter=0; iter< niter; iter++){\n#endif        \n		sum=0; sum2=0;     \n		for (i=r1; i<=r2; i++) {\n            for (j=c1; j<=c2; j++) {\n                tmp   = J[i * cols + j];\n                sum  += tmp ;\n                sum2 += tmp*tmp;\n            }\n        }\n        meanROI = sum / size_R;\n        varROI  = (sum2 / size_R) - meanROI*meanROI;\n        q0sqr   = varROI / (meanROI*meanROI);\n		\n\n#ifdef OPEN\n		omp_set_num_threads(nthreads);\n		#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n		for (int i = 0 ; i < rows ; i++) {\n            for (int j = 0; j < cols; j++) { \n		\n				k = i * cols + j;\n				Jc = J[k];\n \n				// directional derivates\n                dN[k] = J[iN[i] * cols + j] - Jc;\n                dS[k] = J[iS[i] * cols + j] - Jc;\n                dW[k] = J[i * cols + jW[j]] - Jc;\n                dE[k] = J[i * cols + jE[j]] - Jc;\n			\n                G2 = (dN[k]*dN[k] + dS[k]*dS[k] \n                    + dW[k]*dW[k] + dE[k]*dE[k]) / (Jc*Jc);\n\n   		        L = (dN[k] + dS[k] + dW[k] + dE[k]) / Jc;\n\n				num  = (0.5*G2) - ((1.0/16.0)*(L*L)) ;\n                den  = 1 + (.25*L);\n                qsqr = num/(den*den);\n \n                // diffusion coefficent (equ 33)\n                den = (qsqr-q0sqr) / (q0sqr * (1+q0sqr)) ;\n                c[k] = 1.0 / (1.0+den) ;\n                \n                // saturate diffusion coefficent\n                if (c[k] < 0) {c[k] = 0;}\n                else if (c[k] > 1) {c[k] = 1;}\n   \n		}\n  \n    }\n#ifdef OPEN\n		omp_set_num_threads(nthreads);\n		#pragma omp parallel for shared(J, c, rows, cols, lambda) private(i, j, k, D, cS, cN, cW, cE)\n#endif \n		for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {        \n\n                // current index\n                k = i * cols + j;\n                \n                // diffusion coefficent\n					cN = c[k];\n					cS = c[iS[i] * cols + j];\n					cW = c[k];\n					cE = c[i * cols + jE[j]];\n\n                // divergence (equ 58)\n                D = cN * dN[k] + cS * dS[k] + cW * dW[k] + cE * dE[k];\n                \n                // image update (equ 61)\n                J[k] = J[k] + 0.25*lambda*D;\n                #ifdef OUTPUT\n                //printf(""%.5f "", J[k]); \n                #endif //output\n            }\n	            #ifdef OUTPUT\n                //printf(""\n""); \n                #endif //output\n	     }\n\n#ifdef ITERATION\n	}\n#endif\n\n\n#ifdef OUTPUT\n	  for( int i = 0 ; i < rows ; i++){\n		for ( int j = 0 ; j < cols ; j++){\n\n         printf(""%.5f "", J[i * cols + j]); \n    \n		}\n         printf(""\n""); \n   }\n#endif \n\n	printf(""Computation Done\n"");\n\n	free(I);\n	free(J);\n	free(iN); free(iS); free(jW); free(jE);\n    free(dN); free(dS); free(dW); free(dE);\n\n	free(c);\n	return 0;\n}\n\n\n\n\nvoid random_matrix(float *I, int rows, int cols){\n\n	srand(7);\n	\n	for( int i = 0 ; i < rows ; i++){\n		for ( int j = 0 ; j < cols ; j++){\n		 I[i * cols + j] = rand()/(float)RAND_MAX ;\n		 #ifdef OUTPUT\n         //printf(""%g "", I[i * cols + j]); \n         #endif \n		}\n		 #ifdef OUTPUT\n         //printf(""\n""); \n         #endif \n	}\n\n}\n\n"
lavaMD/main.c,"//========================================================================================================================================================================================================200\n//======================================================================================================================================================150\n//====================================================================================================100\n//==================================================50\n\n//========================================================================================================================================================================================================200\n//	UPDATE\n//========================================================================================================================================================================================================200\n\n//	14 APR 2011 Lukasz G. Szafaryn\n\n//========================================================================================================================================================================================================200\n//	DEFINE/INCLUDE\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	LIBRARIES\n//======================================================================================================================================================150\n\n#include <stdio.h>					// (in path known to compiler)			needed by printf\n#include <stdlib.h>					// (in path known to compiler)			needed by malloc\n#include <stdbool.h>				// (in path known to compiler)			needed by true/false\n\n//======================================================================================================================================================150\n//	UTILITIES\n//======================================================================================================================================================150\n\n#include ""./util/timer/timer.h""			// (in path specified here)\n#include ""./util/num/num.h""				// (in path specified here)\n\n//======================================================================================================================================================150\n//	MAIN FUNCTION HEADER\n//======================================================================================================================================================150\n\n#include ""./main.h""						// (in the current directory)\n\n//======================================================================================================================================================150\n//	KERNEL\n//======================================================================================================================================================150\n\n#include ""./kernel/kernel_cpu.h""				// (in library path specified here)\n\n//========================================================================================================================================================================================================200\n//	MAIN FUNCTION\n//========================================================================================================================================================================================================200\n\nint \nmain(	int argc, \n		char *argv [])\n{\n\n	//======================================================================================================================================================150\n	//	CPU/MCPU VARIABLES\n	//======================================================================================================================================================150\n\n	// timer\n	long long time0;\n\n	time0 = get_time();\n\n	// timer\n	long long time1;\n	long long time2;\n	long long time3;\n	long long time4;\n	long long time5;\n	long long time6;\n	long long time7;\n\n	// counters\n	int i, j, k, l, m, n;\n\n	// system memory\n	par_str par_cpu;\n	dim_str dim_cpu;\n	box_str* box_cpu;\n	FOUR_VECTOR* rv_cpu;\n	fp* qv_cpu;\n	FOUR_VECTOR* fv_cpu;\n	int nh;\n\n	time1 = get_time();\n\n	//======================================================================================================================================================150\n	//	CHECK INPUT ARGUMENTS\n	//======================================================================================================================================================150\n\n	// assing default values\n	dim_cpu.cores_arg = 1;\n	dim_cpu.boxes1d_arg = 1;\n\n	// go through arguments\n	for(dim_cpu.cur_arg=1; dim_cpu.cur_arg<argc; dim_cpu.cur_arg++){\n		// check if -cores\n		if(strcmp(argv[dim_cpu.cur_arg], ""-cores"")==0){\n			// check if value provided\n			if(argc>=dim_cpu.cur_arg+1){\n				// check if value is a number\n				if(isInteger(argv[dim_cpu.cur_arg+1])==1){\n					dim_cpu.cores_arg = atoi(argv[dim_cpu.cur_arg+1]);\n					if(dim_cpu.cores_arg<0){\n						printf(""ERROR: Wrong value to -cores parameter, cannot be <=0\n"");\n						return 0;\n					}\n					dim_cpu.cur_arg = dim_cpu.cur_arg+1;\n				}\n				// value is not a number\n				else{\n					printf(""ERROR: Value to -cores parameter in not a number\n"");\n					return 0;\n				}\n			}\n			// value not provided\n			else{\n				printf(""ERROR: Missing value to -cores parameter\n"");\n				return 0;\n			}\n		}\n		// check if -boxes1d\n		else if(strcmp(argv[dim_cpu.cur_arg], ""-boxes1d"")==0){\n			// check if value provided\n			if(argc>=dim_cpu.cur_arg+1){\n				// check if value is a number\n				if(isInteger(argv[dim_cpu.cur_arg+1])==1){\n					dim_cpu.boxes1d_arg = atoi(argv[dim_cpu.cur_arg+1]);\n					if(dim_cpu.boxes1d_arg<0){\n						printf(""ERROR: Wrong value to -boxes1d parameter, cannot be <=0\n"");\n						return 0;\n					}\n					dim_cpu.cur_arg = dim_cpu.cur_arg+1;\n				}\n				// value is not a number\n				else{\n					printf(""ERROR: Value to -boxes1d parameter in not a number\n"");\n					return 0;\n				}\n			}\n			// value not provided\n			else{\n				printf(""ERROR: Missing value to -boxes1d parameter\n"");\n				return 0;\n			}\n		}\n		// unknown\n		else{\n			printf(""ERROR: Unknown parameter\n"");\n			return 0;\n		}\n	}\n\n	// Print configuration\n	printf(""Configuration used: cores = %d, boxes1d = %d\n"", dim_cpu.cores_arg, dim_cpu.boxes1d_arg);\n\n	time2 = get_time();\n\n	//======================================================================================================================================================150\n	//	INPUTS\n	//======================================================================================================================================================150\n\n	par_cpu.alpha = 0.5;\n\n	time3 = get_time();\n\n	//======================================================================================================================================================150\n	//	DIMENSIONS\n	//======================================================================================================================================================150\n\n	// total number of boxes\n	dim_cpu.number_boxes = dim_cpu.boxes1d_arg * dim_cpu.boxes1d_arg * dim_cpu.boxes1d_arg;\n\n	// how many particles space has in each direction\n	dim_cpu.space_elem = dim_cpu.number_boxes * NUMBER_PAR_PER_BOX;\n	dim_cpu.space_mem = dim_cpu.space_elem * sizeof(FOUR_VECTOR);\n	dim_cpu.space_mem2 = dim_cpu.space_elem * sizeof(fp);\n\n	// box array\n	dim_cpu.box_mem = dim_cpu.number_boxes * sizeof(box_str);\n\n	time4 = get_time();\n\n	//======================================================================================================================================================150\n	//	SYSTEM MEMORY\n	//======================================================================================================================================================150\n\n	//====================================================================================================100\n	//	BOX\n	//====================================================================================================100\n\n	// allocate boxes\n	box_cpu = (box_str*)malloc(dim_cpu.box_mem);\n\n	// initialize number of home boxes\n	nh = 0;\n\n	// home boxes in z direction\n	for(i=0; i<dim_cpu.boxes1d_arg; i++){\n		// home boxes in y direction\n		for(j=0; j<dim_cpu.boxes1d_arg; j++){\n			// home boxes in x direction\n			for(k=0; k<dim_cpu.boxes1d_arg; k++){\n\n				// current home box\n				box_cpu[nh].x = k;\n				box_cpu[nh].y = j;\n				box_cpu[nh].z = i;\n				box_cpu[nh].number = nh;\n				box_cpu[nh].offset = nh * NUMBER_PAR_PER_BOX;\n\n				// initialize number of neighbor boxes\n				box_cpu[nh].nn = 0;\n\n				// neighbor boxes in z direction\n				for(l=-1; l<2; l++){\n					// neighbor boxes in y direction\n					for(m=-1; m<2; m++){\n						// neighbor boxes in x direction\n						for(n=-1; n<2; n++){\n\n							// check if (this neighbor exists) and (it is not the same as home box)\n							if(		(((i+l)>=0 && (j+m)>=0 && (k+n)>=0)==true && ((i+l)<dim_cpu.boxes1d_arg && (j+m)<dim_cpu.boxes1d_arg && (k+n)<dim_cpu.boxes1d_arg)==true)	&&\n									(l==0 && m==0 && n==0)==false	){\n\n								// current neighbor box\n								box_cpu[nh].nei[box_cpu[nh].nn].x = (k+n);\n								box_cpu[nh].nei[box_cpu[nh].nn].y = (j+m);\n								box_cpu[nh].nei[box_cpu[nh].nn].z = (i+l);\n								box_cpu[nh].nei[box_cpu[nh].nn].number =	(box_cpu[nh].nei[box_cpu[nh].nn].z * dim_cpu.boxes1d_arg * dim_cpu.boxes1d_arg) + \n																			(box_cpu[nh].nei[box_cpu[nh].nn].y * dim_cpu.boxes1d_arg) + \n																			 box_cpu[nh].nei[box_cpu[nh].nn].x;\n								box_cpu[nh].nei[box_cpu[nh].nn].offset = box_cpu[nh].nei[box_cpu[nh].nn].number * NUMBER_PAR_PER_BOX;\n\n								// increment neighbor box\n								box_cpu[nh].nn = box_cpu[nh].nn + 1;\n\n							}\n\n						} // neighbor boxes in x direction\n					} // neighbor boxes in y direction\n				} // neighbor boxes in z direction\n\n				// increment home box\n				nh = nh + 1;\n\n			} // home boxes in x direction\n		} // home boxes in y direction\n	} // home boxes in z direction\n\n	//====================================================================================================100\n	//	PARAMETERS, DISTANCE, CHARGE AND FORCE\n	//====================================================================================================100\n\n	// random generator seed set to random value - time in this case\n	srand(time(NULL));\n\n	// input (distances)\n	rv_cpu = (FOUR_VECTOR*)malloc(dim_cpu.space_mem);\n	for(i=0; i<dim_cpu.space_elem; i=i+1){\n		rv_cpu[i].v = (rand()%10 + 1) / 10.0;			// get a number in the range 0.1 - 1.0\n		rv_cpu[i].x = (rand()%10 + 1) / 10.0;			// get a number in the range 0.1 - 1.0\n		rv_cpu[i].y = (rand()%10 + 1) / 10.0;			// get a number in the range 0.1 - 1.0\n		rv_cpu[i].z = (rand()%10 + 1) / 10.0;			// get a number in the range 0.1 - 1.0\n	}\n\n	// input (charge)\n	qv_cpu = (fp*)malloc(dim_cpu.space_mem2);\n	for(i=0; i<dim_cpu.space_elem; i=i+1){\n		qv_cpu[i] = (rand()%10 + 1) / 10.0;			// get a number in the range 0.1 - 1.0\n	}\n\n	// output (forces)\n	fv_cpu = (FOUR_VECTOR*)malloc(dim_cpu.space_mem);\n	for(i=0; i<dim_cpu.space_elem; i=i+1){\n		fv_cpu[i].v = 0;								// set to 0, because kernels keeps adding to initial value\n		fv_cpu[i].x = 0;								// set to 0, because kernels keeps adding to initial value\n		fv_cpu[i].y = 0;								// set to 0, because kernels keeps adding to initial value\n		fv_cpu[i].z = 0;								// set to 0, because kernels keeps adding to initial value\n	}\n\n	time5 = get_time();\n\n	//======================================================================================================================================================150\n	//	KERNEL\n	//======================================================================================================================================================150\n\n	//====================================================================================================100\n	//	CPU/MCPU\n	//====================================================================================================100\n\n	kernel_cpu(	par_cpu,\n				dim_cpu,\n				box_cpu,\n				rv_cpu,\n				qv_cpu,\n				fv_cpu);\n\n	time6 = get_time();\n\n	//======================================================================================================================================================150\n	//	SYSTEM MEMORY DEALLOCATION\n	//======================================================================================================================================================150\n\n	// dump results\n#ifdef OUTPUT\n        FILE *fptr;\n	fptr = fopen(""result.txt"", ""w"");	\n	for(i=0; i<dim_cpu.space_elem; i=i+1){\n        	fprintf(fptr, ""%f, %f, %f, %f\n"", fv_cpu[i].v, fv_cpu[i].x, fv_cpu[i].y, fv_cpu[i].z);\n	}\n	fclose(fptr);\n#endif       	\n\n\n\n	free(rv_cpu);\n	free(qv_cpu);\n	free(fv_cpu);\n	free(box_cpu);\n\n	time7 = get_time();\n\n	//======================================================================================================================================================150\n	//	DISPLAY TIMING\n	//======================================================================================================================================================150\n\n	// printf(""Time spent in different stages of the application:\n"");\n\n	// printf(""%15.12f s, %15.12f % : VARIABLES\n"",						(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time7-time0) * 100);\n	// printf(""%15.12f s, %15.12f % : INPUT ARGUMENTS\n"", 					(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time7-time0) * 100);\n	// printf(""%15.12f s, %15.12f % : INPUTS\n"",							(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time7-time0) * 100);\n	// printf(""%15.12f s, %15.12f % : dim_cpu\n"", 							(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time7-time0) * 100);\n	// printf(""%15.12f s, %15.12f % : SYS MEM: ALO\n"",						(float) (time5-time4) / 1000000, (float) (time5-time4) / (float) (time7-time0) * 100);\n\n	// printf(""%15.12f s, %15.12f % : KERNEL: COMPUTE\n"",					(float) (time6-time5) / 1000000, (float) (time6-time5) / (float) (time7-time0) * 100);\n\n	// printf(""%15.12f s, %15.12f % : SYS MEM: FRE\n"", 					(float) (time7-time6) / 1000000, (float) (time7-time6) / (float) (time7-time0) * 100);\n\n	// printf(""Total time:\n"");\n	// printf(""%.12f s\n"", 												(float) (time7-time0) / 1000000);\n\n	//======================================================================================================================================================150\n	//	RETURN\n	//======================================================================================================================================================150\n\n	return 0.0;																					// always returns 0.0\n\n}\n"
lavaMD/kernel/kernel_cpu.c,"#ifdef __cplusplus\nextern ""C"" {\n#endif\n\n//========================================================================================================================================================================================================200\n//	DEFINE/INCLUDE\n//========================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	LIBRARIES\n//======================================================================================================================================================150\n\n#include <omp.h>									// (in path known to compiler)			needed by openmp\n#include <stdlib.h>									// (in path known to compiler)			needed by malloc\n#include <stdio.h>									// (in path known to compiler)			needed by printf\n#include <math.h>									// (in path known to compiler)			needed by exp\n\n//======================================================================================================================================================150\n//	MAIN FUNCTION HEADER\n//======================================================================================================================================================150\n\n#include ""./../main.h""								// (in the main program folder)	needed to recognized input variables\n\n//======================================================================================================================================================150\n//	UTILITIES\n//======================================================================================================================================================150\n\n#include ""./../util/timer/timer.h""					// (in library path specified to compiler)	needed by timer\n\n//======================================================================================================================================================150\n//	KERNEL_CPU FUNCTION HEADER\n//======================================================================================================================================================150\n\n#include ""kernel_cpu.h""								// (in the current directory)\n\n//========================================================================================================================================================================================================200\n//	PLASMAKERNEL_GPU\n//========================================================================================================================================================================================================200\n\nvoid  kernel_cpu(	par_str par, \n					dim_str dim,\n					box_str* box,\n					FOUR_VECTOR* rv,\n					fp* qv,\n					FOUR_VECTOR* fv)\n{\n\n	//======================================================================================================================================================150\n	//	Variables\n	//======================================================================================================================================================150\n\n	// timer\n	long long time0;\n\n	time0 = get_time();\n\n	// timer\n	long long time1;\n	long long time2;\n	long long time3;\n	long long time4;\n\n	// parameters\n	fp alpha;\n	fp a2;\n\n	// counters\n	int i, j, k, l;\n\n	// home box\n	long first_i;\n	FOUR_VECTOR* rA;\n	FOUR_VECTOR* fA;\n\n	// neighbor box\n	int pointer;\n	long first_j; \n	FOUR_VECTOR* rB;\n	fp* qB;\n\n	// common\n	fp r2; \n	fp u2;\n	fp fs;\n	fp vij;\n	fp fxij,fyij,fzij;\n	THREE_VECTOR d;\n\n	time1 = get_time();\n\n	//======================================================================================================================================================150\n	//	MCPU SETUP\n	//======================================================================================================================================================150\n\n	omp_set_num_threads(dim.cores_arg);\n\n	time2 = get_time();\n\n	//======================================================================================================================================================150\n	//	INPUTS\n	//======================================================================================================================================================150\n\n	alpha = par.alpha;\n	a2 = 2.0*alpha*alpha;\n\n	time3 = get_time();\n\n	//======================================================================================================================================================150\n	//	PROCESS INTERACTIONS\n	//======================================================================================================================================================150\n\n	#pragma omp	parallel for \\n				private(i, j, k) \\n				private(first_i, rA, fA) \\n				private(pointer, first_j, rB, qB) \\n				private(r2, u2, fs, vij, fxij, fyij, fzij, d)\n	for(l=0; l<dim.number_boxes; l=l+1){\n\n		//------------------------------------------------------------------------------------------100\n		//	home box - box parameters\n		//------------------------------------------------------------------------------------------100\n\n		first_i = box[l].offset;												// offset to common arrays\n\n		//------------------------------------------------------------------------------------------100\n		//	home box - distance, force, charge and type parameters from common arrays\n		//------------------------------------------------------------------------------------------100\n\n		rA = &rv[first_i];\n		fA = &fv[first_i];\n\n		//------------------------------------------------------------------------------------------100\n		//	Do for the # of (home+neighbor) boxes\n		//------------------------------------------------------------------------------------------100\n\n		for (k=0; k<(1+box[l].nn); k++) \n		{\n\n			//----------------------------------------50\n			//	neighbor box - get pointer to the right box\n			//----------------------------------------50\n\n			if(k==0){\n				pointer = l;													// set first box to be processed to home box\n			}\n			else{\n				pointer = box[l].nei[k-1].number;							// remaining boxes are neighbor boxes\n			}\n\n			//----------------------------------------50\n			//	neighbor box - box parameters\n			//----------------------------------------50\n\n			first_j = box[pointer].offset; \n\n			//----------------------------------------50\n			//	neighbor box - distance, force, charge and type parameters\n			//----------------------------------------50\n\n			rB = &rv[first_j];\n			qB = &qv[first_j];\n\n			//----------------------------------------50\n			//	Do for the # of particles in home box\n			//----------------------------------------50\n\n			for (i=0; i<NUMBER_PAR_PER_BOX; i=i+1){\n\n				// do for the # of particles in current (home or neighbor) box\n				for (j=0; j<NUMBER_PAR_PER_BOX; j=j+1){\n\n					// // coefficients\n					r2 = rA[i].v + rB[j].v - DOT(rA[i],rB[j]); \n					u2 = a2*r2;\n					vij= exp(-u2);\n					fs = 2.*vij;\n					d.x = rA[i].x  - rB[j].x; \n					d.y = rA[i].y  - rB[j].y; \n					d.z = rA[i].z  - rB[j].z; \n					fxij=fs*d.x;\n					fyij=fs*d.y;\n					fzij=fs*d.z;\n\n					// forces\n					fA[i].v +=  qB[j]*vij;\n					fA[i].x +=  qB[j]*fxij;\n					fA[i].y +=  qB[j]*fyij;\n					fA[i].z +=  qB[j]*fzij;\n\n				} // for j\n\n			} // for i\n\n		} // for k\n\n	} // for l\n\n	time4 = get_time();\n\n	//======================================================================================================================================================150\n	//	DISPLAY TIMING\n	//======================================================================================================================================================150\n\n	printf(""Time spent in different stages of CPU/MCPU KERNEL:\n"");\n\n	printf(""%15.12f s, %15.12f % : CPU/MCPU: VARIABLES\n"",				(float) (time1-time0) / 1000000, (float) (time1-time0) / (float) (time4-time0) * 100);\n	printf(""%15.12f s, %15.12f % : MCPU: SET DEVICE\n"",					(float) (time2-time1) / 1000000, (float) (time2-time1) / (float) (time4-time0) * 100);\n	printf(""%15.12f s, %15.12f % : CPU/MCPU: INPUTS\n"", 				(float) (time3-time2) / 1000000, (float) (time3-time2) / (float) (time4-time0) * 100);\n	printf(""%15.12f s, %15.12f % : CPU/MCPU: KERNEL\n"",					(float) (time4-time3) / 1000000, (float) (time4-time3) / (float) (time4-time0) * 100);\n\n	printf(""Total time:\n"");\n	printf(""%.12f s\n"", 												(float) (time4-time0) / 1000000);\n\n} // main\n\n#ifdef __cplusplus\n}\n#endif\n"
lavaMD/util/timer/timer.c,"#ifdef __cplusplus\nextern ""C"" {\n#endif\n\n//===============================================================================================================================================================================================================200\n//	TIMER CODE\n//===============================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	INCLUDE/DEFINE\n//======================================================================================================================================================150\n\n#include <stdlib.h>\n\n//======================================================================================================================================================150\n//	FUNCTIONS\n//======================================================================================================================================================150\n\n//====================================================================================================100\n//	DISPLAY TIME\n//====================================================================================================100\n\n // Returns the current system time in microseconds\nlong long get_time() {\n	struct timeval tv;\n	gettimeofday(&tv, NULL);\n	return (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\n//===============================================================================================================================================================================================================200\n//	END TIMER CODE\n//===============================================================================================================================================================================================================200\n\n#ifdef __cplusplus\n}\n#endif\n"
lavaMD/util/num/num.c,"#ifdef __cplusplus\nextern ""C"" {\n#endif\n\n//===============================================================================================================================================================================================================200\n//	DESCRIPTION\n//===============================================================================================================================================================================================================200\n\n// Returns:	0 if string does not represent integer\n//			1 if string represents integer\n\n//===============================================================================================================================================================================================================200\n//	NUM CODE\n//===============================================================================================================================================================================================================200\n\n//======================================================================================================================================================150\n//	ISINTEGER FUNCTION\n//======================================================================================================================================================150\n\nint isInteger(char *str){\n\n	//====================================================================================================100\n	//	make sure it's not empty\n	//====================================================================================================100\n\n	if (*str == '\0'){\n		return 0;\n	}\n\n	//====================================================================================================100\n	//	if any digit is not a number, return false\n	//====================================================================================================100\n\n	for(; *str != '\0'; str++){\n		if (*str < 48 || *str > 57){	// digit characters (need to include . if checking for float)\n			return 0;\n		}\n	}\n\n	//====================================================================================================100\n	//	it got past all my checks so I think it's a number\n	//====================================================================================================100\n\n	return 1;\n}\n\n//===============================================================================================================================================================================================================200\n//	END NUM CODE\n//===============================================================================================================================================================================================================200\n\n#ifdef __cplusplus\n}\n#endif\n"
mummergpu/src/morton.c,"#include <stdio.h>\n\nvoid morton(int i, int *x, int *y)\n{\n  *x = 0;\n  *y = 0;\n\n  int b;\n  for (b = 0; b < 16; b++)\n  {\n    *x |= (i & (1 << (b*2)))     >> b;\n    *y |= (i & (1 << (b*2+1))) >> (b+1);\n  }\n}\n\nint main(int argc, char ** argv)\n{\n  int i;\n  for (i = 0; i < 100; i++)\n  {\n    int x;\n    int y;\n\n    morton(i,&x,&y);\n\n    printf(""%d: %d %d\n"", i, x, y);\n  }\n\n  return 0;\n}\n"
mummergpu/src/smith-waterman.cpp,"#include <iostream>\nusing namespace std;\n\ninline int max2(int a, int b)\n{\n  return (a > b) ? a : b;\n}\n\ninline int max4(int a, int b, int c, int d)\n{\n  int maxl = (a > b) ? a : b;\n  int maxr = (c > d) ? c : d;\n\n  return (maxl > maxr) ? maxl : maxr;\n}\n\nint s(char a, char b, int match_score, int mismatch_score)\n{\n  if (a == b)\n  {\n    return match_score;\n  }\n  \n  return mismatch_score;\n}\n\nstruct aligned_t\n{\n  char s;\n  char t;\n  int score;\n};\ntypedef struct aligned_t aligned_t;\n\n\n\nvoid align(const string & S, \n           const string & T,\n           int match_score,\n           int mismatch_score,\n           int gap_open,\n           int gap_extension)\n{\n  int m = S.length()-1;\n  int n = T.length()-1;\n\n  int E[m+2][n+2];\n  int F[m+2][n+2];\n  int G[m+2][n+2];\n  int V[m+2][n+2];\n\n\n  // initialize matrices\n  for (int i = 0; i <= m; i++)\n  {\n    //E[i][0] = -gap_open + -gap_extension*i;\n    E[i][0] = 0;\n    F[i][0] = 0;\n    G[i][0] = 0;\n    V[i][0] = E[i][0];\n  }\n\n  for (int j = 0; j <= n; j++)\n  {\n    //F[0][j] = -gap_open + -gap_extension*j;\n    F[0][j] = 0;\n    E[0][j] = 0;\n    G[0][j] = 0;\n    V[0][j] = F[0][j];\n  }\n\n  G[0][0] = 0;\n  V[0][0] = 0;\n\n  int maxi = 0;\n  int maxj = 0;\n  int maxv = 0;\n\n  // compute the matrix\n  for (int i = 1; i <= m; i++)\n  {\n    for (int j = 1; j <= n; j++)\n    {\n      E[i][j] = max2(E[i-1][j] - gap_extension,\n                     V[i-1][j] - gap_open - gap_extension);\n\n      F[i][j] = max2(F[i-1][j] - gap_extension,\n                     V[i-1][j] - gap_open - gap_extension);\n\n      G[i][j] = V[i-1][j-1] + s(S[i], T[j], match_score, mismatch_score);\n\n      V[i][j] = max4(E[i][j], F[i][j], G[i][j], 0);\n\n      if (V[i][j] > maxv)\n      {\n        maxv = V[i][j];\n        maxi = i;\n        maxj = j;\n      }\n    }\n  }\n\n\n  // // print the scores\n  // cout << ""V"" << endl;\n  // cout << ""======================================="" << endl;\n  // for (int i = 0; i <= m; i++)\n  // {\n  //   if (i == 0)\n  //   {\n  //     cout << "" \t"";\n  //     for (int j = 0; j <= n; j++) { cout << T[j] << ""\t""; }\n  //     cout << endl;\n  //   }\n  // \n  //   cout << S[i] << ""\t"";\n  //   for (int j = 0; j <= n; j++)\n  //   {\n  //     cout << V[i][j];\n  //     if (V[i][j] == maxv) { cout << ""*""; }\n  //     cout << ""\t"";\n  //   }\n  // \n  // \n  //   cout << endl;\n  // }\n  // \n  // cout << endl << endl;\n  // cout << ""E"" << endl;\n  // cout << ""======================================="" << endl;\n  // for (int i = 0; i <= m; i++)\n  // {\n  //   if (i == 0)\n  //   {\n  //     cout << "" \t"";\n  //     for (int j = 0; j <= n; j++) { cout << T[j] << ""\t""; }\n  //     cout << endl;\n  //   }\n  // \n  //   cout << S[i] << ""\t"";\n  //   for (int j = 0; j <= n; j++)\n  //   {\n  //     cout << E[i][j];\n  //     cout << ""\t"";\n  //   }\n  // \n  //   cout << endl;\n  // }\n  // \n  // cout << endl << endl;\n  // cout << ""F"" << endl;\n  // cout << ""======================================="" << endl;\n  // for (int i = 0; i <= m; i++)\n  // {\n  //   if (i == 0)\n  //   {\n  //     cout << "" \t"";\n  //     for (int j = 0; j <= n; j++) { cout << T[j] << ""\t""; }\n  //     cout << endl;\n  //   }\n  // \n  //   cout << S[i] << ""\t"";\n  //   for (int j = 0; j <= n; j++)\n  //   {\n  //     cout << F[i][j];\n  //     cout << ""\t"";\n  //   }\n  // \n  //   cout << endl;\n  // }\n  // \n  // cout << endl << endl;\n  // cout << ""G"" << endl;\n  // cout << ""======================================="" << endl;\n  // for (int i = 0; i <= m; i++)\n  // {\n  //   if (i == 0)\n  //   {\n  //     cout << "" \t"";\n  //     for (int j = 0; j <= n; j++) { cout << T[j] << ""\t""; }\n  //     cout << endl;\n  //   }\n  // \n  //   cout << S[i] << ""\t"";\n  //   for (int j = 0; j <= n; j++)\n  //   {\n  //     cout << G[i][j];\n  //     cout << ""\t"";\n  //   }\n  // \n  //   cout << endl;\n  // }\n  // \n  // \n  // cout << ""max score["" << maxi << "","" << maxj << ""]:"" << maxv << endl;\n\n\n  // print the alignment\n  aligned_t trace[m+n];\n  //int i = m; int j = n;\n  int i = maxi, j = maxj;\n  int tlen = 0;\n\n  while (i > 0 && j > 0)\n  {\n    int v = V[i][j];\n    trace[tlen].score = v;\n\n    if (v == G[i][j])\n    {\n      trace[tlen].s = S[i];\n      trace[tlen].t = T[j];\n      i--;\n      j--;\n    }\n    else if (v == E[i][j])\n    {\n      trace[tlen].s = S[i];\n      trace[tlen].t = '-';\n      i--;\n    }\n    else if (v == F[i][j])\n    {\n      trace[tlen].s = '-';\n      trace[tlen].t = T[j];\n      j--;\n    }\n    else // v == 0;\n    {\n      break;\n    }\n\n    tlen++;\n  }\n\n  // for (int k = tlen - 1; k >= 0; k--)\n  // {\n  //   cout << ""   "" << trace[k].s;\n  // }\n  // cout << endl;\n  // \n  // for (int k = tlen - 1; k >= 0; k--)\n  // {\n  //   cout << ""   "" << trace[k].t;\n  // }\n  // cout << endl;\n  // \n  // for (int k = tlen - 1; k >= 0; k--)\n  // {\n  //   printf("" %3d"", trace[k].score);\n  // }\n  // cout << endl;\n}\n\n\n// int main(int argc, char ** argv)\n// {\n//   string S = ""sMIKESCHATZ"";\n//   string T = ""sQMILKSHAKE"";\n//   //string S = ""sAATTTGGTG"";\n//   //string T = ""sAAGGTCCA"";\n//   \n//   int match_score = 10;\n//   int mismatch_score = -2;\n//   int gap_open = 4;\n//   int gap_extension = 1;\n// \n//   cout << ""S: "" << S << "" "" << S.length()-1 << endl;\n//   cout << ""T: "" << T << "" "" << T.length()-1 << endl;\n// \n//   align(S,T, match_score, mismatch_score, gap_open, gap_extension);\n// \n//   return 0;\n// }\n\n\n"
mummergpu/src/mummergpu_main.cpp,"#include <stdio.h>\n#include <unistd.h>\n#include <fstream>\n\n#define int2 int32_t\n#define ulong4 uint32_t\n#define uint4 uint32_t\n#include ""mummergpu.h""\n\nchar * OPT_reffilename = NULL;\nchar * OPT_qryfilename = NULL;\nchar * OPT_dotfilename = NULL;\nchar * OPT_texfilename = NULL;\nint    OPT_num_reference_pages = 1;\nchar * OPT_stats_file = NULL;\n\n// MUMmer options\nint  OPT_match_length = 20;\nbool OPT_reverse = false;\nbool OPT_forwardreverse = false;\nbool OPT_forwardcoordinates = false;\nbool OPT_showQueryLength = false;\nbool OPT_maxmatch = false;\nbool OPT_on_cpu = false;\nbool OPT_stream_queries = false;\n\nvoid printHelp()\n{\n   fprintf(stderr, \n		   ""Align a set of query strings to a reference sequence using the GPU.\n""\n		   ""\n""\n		   ""Usage: mummergpu [options] reference.fa query.fa\n""\n		   ""\n""\n		   ""Options\n""\n		   ""  -h Print this help\n""\n		   ""  -d file.dot Output suffix tree in dot format\n""\n		   ""  -t file.tex Output suffix tree texture\n""\n		   ""  -C             Compute the matches using the CPU instead of the GPU\n""\n		   ""  -s <file>      write timing and memory stats to <file> \n""\n           ""\n""\n           ""  -l <matchlen>  minimal match length to report [Default: 20]\n""\n           ""  -b             compute forward and reverse complement matches\n""\n           ""  -r             only compute reverse complement matches\n""\n           ""  -c             report the query-position of a reverse complement match\n""\n           ""                 relative to the original query sequence\n""\n           ""  -L             show the length of the query sequences on the header line\n""\n	  );\n\n   exit(0);\n}\n\nvoid printUsage()\n{\n   fprintf(stderr, ""Usage: mummergpu [options] reference.fa query.fa\n"");\n   exit(0);\n}\n\n\nvoid ParseCommandLine(int argc, char ** argv)\n{\n   bool errflg = false;\n   int ch;\n   optarg = NULL;\n\n   while(!errflg && ((ch = getopt (argc, argv, ""aCchql:d:t:s:brcLM"")) != EOF))\n   {\n      switch  (ch)\n	  {\n		 case 'h': printHelp(); break;\n		 case '?': fprintf(stderr, ""Unknown option %c\n"", optopt); errflg = true; break;\n		 case 'd': OPT_dotfilename = optarg; break;\n		 case 't': OPT_texfilename = optarg; break;\n		 case 'C': OPT_on_cpu = true; break;\n		 case 'l': OPT_match_length = atoi(optarg); break;\n         case 'b': OPT_forwardreverse = true; break;\n         case 'r': OPT_reverse = true; break;\n		 case 's': OPT_stats_file = optarg; break;\n         case 'c': OPT_forwardcoordinates = true; break;\n         case 'L': OPT_showQueryLength = true; break;\n         case 'M': OPT_maxmatch = true; break;\n\n		 default: errflg = true; break;\n	  };\n   }\n\n   if ((optind != argc-2) || errflg) { printUsage(); }\n\n   if (!OPT_maxmatch)\n   {\n     OPT_maxmatch = true;\n   }\n\n   if (OPT_reverse && OPT_forwardreverse)\n   {\n     fprintf(stderr, ""ERROR: Reverse (-r) and Forward & Reverse (-b) specified\n"");\n     exit(1);\n   }\n\n   OPT_reffilename = argv[optind++];\n   OPT_qryfilename = argv[optind++];\n}\n\nint main(int argc, char* argv[])\n{\n   ParseCommandLine(argc, argv);\n\n   fprintf(stderr, ""TWO_LEVEL_NODE_TREE is %d\n"", TWO_LEVEL_NODE_TREE);\n   fprintf(stderr, ""TWO_LEVEL_CHILD_TREE is %d\n"", TWO_LEVEL_CHILD_TREE);\n   fprintf(stderr, ""QRYTEX is %d\n"", QRYTEX);\n   fprintf(stderr, ""COALESCED_QUERIES is %d\n"", COALESCED_QUERIES);\n   fprintf(stderr, ""REFTEX is %d\n"", REFTEX);\n   fprintf(stderr, ""REORDER_REF is %d\n"", REORDER_REF);\n   fprintf(stderr, ""NODETEX is %d\n"", NODETEX);\n   fprintf(stderr, ""CHILDTEX is %d\n"", CHILDTEX);\n   fprintf(stderr, ""MERGETEX is %d\n"", MERGETEX);\n   fprintf(stderr, ""REORDER_TREE is %d\n"", REORDER_TREE);\n	fprintf(stderr, ""RENUMBER_TREE is %d\n"", RENUMBER_TREE);\n\n   int err = 0;\n\n   Reference ref;\n   if ((err = createReference(OPT_reffilename, &ref)))\n   {\n	  printStringForError(err);\n	  exit(err);\n   }\n   \n   QuerySet queries;\n   if ((err = createQuerySet(OPT_qryfilename, &queries)))\n   {\n	  printStringForError(err);\n	  exit(err);\n   }\n\n   MatchContext ctx;\n   if ((err = createMatchContext(&ref, \n								&queries, \n								0, \n								OPT_on_cpu, \n								OPT_match_length, \n								OPT_stats_file,\n								OPT_reverse,\n                                OPT_forwardreverse,\n                                OPT_forwardcoordinates,\n                                OPT_showQueryLength,\n								OPT_dotfilename,\n                                OPT_texfilename,\n								&ctx)))\n   {\n	  printStringForError(err);\n	  exit(err);\n   }   \n\n   if ((err = matchQueries(&ctx)))\n   {\n	  printStringForError(err);\n	  exit(err);\n   }   \n   \n   if ((err = destroyMatchContext(&ctx)))\n   {\n	  printStringForError(err);\n	  exit(err);\n   }   \n}\n\n\n"
mummergpu/src/PoolMalloc.cpp,"#include ""PoolMalloc.hh""\n//#include ""CUtilities.h""\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nstatic const size_t POOLBLOCKSIZE = 10*1024*1024;\n\n/// Print current line and exit\n#define DIE()                                                           \\n  do {                                                                  \\n    fprintf(stderr,""Aborted. File: %s, Line: %d\n"",__FILE__,__LINE__);  \\n    exit(EXIT_FAILURE);                                                 \\n  } while(0)\n\n/// Print a message and then DIE()\n#define DIEM(m) do { fprintf(stderr,m""\n""); DIE(); } while(0)\n\n/// DIE() if the pointer is NULL\n#define DIENULL(p) do { if ( !(p) ) { DIEM(""Out of memory""); } } while(0)\n\n\n/// Malloc memory, DIE() if NULL\n#define MALLOC(p,t,s) DIENULL( (p) = (t) malloc(s) )\n\n/// Malloc memory for objects of type t, DIE() if NULL\n#define NEW(p,t) MALLOC(p, t*, sizeof(t))\n\n\n#include <cstdlib>\n\nstruct PoolNode_t\n{\n  char *block;\n  size_t offset;\n  size_t remaining;\n  size_t size;\n  \n  PoolNode_t *next;\n};\n\n\n\n//============================================================ PoolMalloc_t ====\n//------------------------------------------------------------ PoolMalloc_t ----\nPoolMalloc_t::PoolMalloc_t()\n{\n  head_m = NULL;\n}\n\n\n//----------------------------------------------------------- ~PoolMalloc_t ----\nPoolMalloc_t::~PoolMalloc_t()\n{\n  pfree();\n}\n\n\n//-------------------------------------------------------------------- free ----\nvoid PoolMalloc_t::pfree()\n{\n  PoolNode_t * next;\n\n  while ( head_m )\n    {\n      next = head_m->next;\n      free(head_m->block);\n      free(head_m);\n      head_m = next;\n    }\n\n  head_m = NULL;\n}\n\n\n//------------------------------------------------------------------ malloc ----\n///\n/// Parcel memory from big byte buckets. Return all memory with 8 byte\n/// alignment to silence the bus errors on Alpha and Solaris.\n///\nvoid * PoolMalloc_t::pmalloc(size_t size)\n{\n  size_t remainder = size % 8;\n\n  //-- Make sure the next block is 8 byte aligned\n  if ( remainder ) size += 8 - remainder;\n\n  if ( head_m == NULL || size > head_m->remaining )\n    {\n      size_t blockSize = POOLBLOCKSIZE;\n      if ( size > blockSize ) blockSize = size;\n\n      PoolNode_t *newHead;\n      NEW(newHead, PoolNode_t);\n      MALLOC(newHead->block, char*, blockSize);\n      newHead->size = blockSize;\n      newHead->remaining = blockSize;\n      newHead->offset = 0;\n      newHead->next = head_m;\n      head_m = newHead;\n    }\n\n  void *retval = head_m->block + head_m->offset;\n  head_m->offset += size;\n  head_m->remaining -= size;\n\n  return retval;\n}\n\n\n//------------------------------------------------------------------ strdup ----\nchar * PoolMalloc_t::pstrdup(const char * s)\n{\n  size_t size = strlen(s) + 1;\n  char *retval = (char *) pmalloc(size);\n  memcpy(retval, s, size);\n  return retval;\n}\n"
mummergpu/src/suffix-tree.cpp,"#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <cmath>\n#include <sys/time.h>\n#include <list>\n#include <map>\n#include <vector>\n#include <queue>\n#include <cstring>\n\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <errno.h>\n#include <assert.h>\n\n#define ulong4 uint32_t\n#define uint4 uint32_t\n#define int2 int32_t\n#include ""mummergpu.h""\n\n#define MPOOL 0\n\n#include ""PoolMalloc.hh""\n\nusing namespace std;\n\n// Enable verification/debug options\n#define VERIFY  0\n#define VERBOSE 0\nconst bool DEBUG = 0;\n\n// Setting for linear time alg\nbool FORCEROOT = false;\nbool DOJUMP = true;\nbool DOINTERNALSKIP = true;\nbool DOPHASETRICK = true;\n\n// Statistics\nint skippedbases = 0;\nint skippedextensions = 0;\n\nchar substrbuffer[1024];\nconst char * substr(const char * str, int start, int len)\n{\n  if (len > 1024) { len = 1024; }\n  strncpy(substrbuffer, str+start, len);\n  substrbuffer[len] = '\0';\n\n  return substrbuffer;\n}\n\n\n// Helper to convert from ascii to single byte\nunsigned char b2i(char base)\n{\n  switch (base)\n  {\n    case 'A' : return 0;\n    case 'C' : return 1;\n    case 'G' : return 2;\n    case 'T' : return 3;\n    case '$' : return 4;\n\n    default: \n      cerr << ""Unknown base: "" << base << endl;\n      return b2i('A');\n  };\n}\n\n#include <sys/time.h>\n#include <string>\n\nclass EventTime_t\n{\npublic:\n  /// Constructor, starts the stopwatch\n  EventTime_t()\n  {\n    start();\n    memset(&m_end, 0, sizeof(struct timeval));\n  }\n\n\n  /// Explicitly restart the stopwatch\n  void start()\n  {\n    gettimeofday(&m_start, NULL);\n  }\n\n\n  /// Explicitly stop the stopwatch\n  void stop()\n  {\n    gettimeofday(&m_end, NULL);\n  }\n\n\n  /// Return the duration in seconds\n  double duration()\n  {\n    if ((m_end.tv_sec == 0) && (m_end.tv_usec == 0)) { stop(); }\n    return ((m_end.tv_sec - m_start.tv_sec)*1000000.0 + (m_end.tv_usec - m_start.tv_usec)) / 1e6;\n  }\n\n\n  /** \brief Pretty-print the duration in seconds.\n   ** If stop() has not already been called, uses the current time as the end\n   ** time.\n   ** \param format Controls if time should be enclosed in [ ] \n   ** \param precision Controls number of digits past decimal pt\n   **/\n  std::string str(bool format = true, \n                  int precision=2)\n  {\n    double r = duration();\n\n    char buffer[1024];\n    sprintf(buffer, ""%0.*f"", precision, r);\n\n    if (format)\n    {\n      string s(""["");\n      s += buffer;\n      s += ""s]"";\n      return s;\n    }\n\n    return buffer;\n  }\n\n\nprivate:\n  /// Start time\n  struct timeval m_start;\n\n  /// End time\n  struct timeval m_end;\n};\n\n\n// A node in the suffix tree\nclass SuffixNode\n{\npublic:\n  static int s_nodecount;\n\n#ifdef MPOOL\n  void *operator new( size_t num_bytes, PoolMalloc_t *mem)\n  {\n    return mem->pmalloc(num_bytes);\n  }\n#endif\n\n  SuffixNode(int s, int e, int leafid,\n             SuffixNode * p, SuffixNode * x)\n    : m_start(s), m_end(e), \n      m_nodeid(++s_nodecount),\n      m_leafid(leafid),\n      m_numleaves(0),\n      m_parent(p), \n	  m_suffix(x),\n      m_printParent(NULL)\n  {\n    for (int i = 0; i < basecount; i++)\n    { m_children[i] = NULL; }\n	\n	m_depth = len();\n	if (p)\n	   m_depth += p->m_depth;\n  }\n\n  ~SuffixNode()\n  {\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i]) { delete m_children[i]; }\n    }\n  }\n\n  int id()\n  {\n    if (this) { return m_nodeid; }\n    return 0;\n  }\n\n  void setPrintParent(int min_match_len)\n  {\n    if (!m_parent)\n    {\n      // at root\n      m_printParent = this;\n    }\n    else if (m_parent->m_depth <= min_match_len)\n    {\n      m_printParent = this;\n    }\n    else\n    {\n      m_printParent = m_parent->m_printParent;\n    }\n\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i])\n      {\n        m_children[i]->setPrintParent(min_match_len);\n      }\n    }\n  }\n\n  bool isLeaf()\n  {\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i]) { return false; }\n    }\n\n    return true;\n  }\n\n  const char * str(const char * refstr)\n  {\n    return substr(refstr, m_start, m_end-m_start+1);\n  }\n\n  int len(int i=-1)\n  {\n    if (i != -1)\n    {\n      if (i < m_end)\n      {\n        return i - m_start + 1;\n      }\n    }\n\n    return m_end - m_start + 1;\n  }\n\n  int depth()\n  { \n	 return m_depth;\n  }\n\n  ostream & printLabel(ostream & os, const char * refstr)\n  {\n    if (m_start == m_end && m_start == 0)\n    {\n      os << ""\""ROOT\"""";\n    }\n    else\n    {\n      os << ""\"""" << str(refstr) << ""\"""";\n\n       //  << "" ["" << m_start \n       //  << "",""  << m_end \n       //  << ""("" << m_nodeid << "")\"""";\n    }\n\n    return os;\n  }\n\n\n  ostream & printNodeLabel(ostream & os)\n  {\n    os << m_nodeid;\n    return os;\n  }\n\n  ostream & printEdgeLabel(ostream & os, const char * refstr)\n  {\n    string seq = substr(refstr, m_start, m_end-m_start+1);\n    os << ""\"""" << seq << ""\"""";\n    //os << ""\"""" << seq << "" ["" << m_start << "","" << m_end << ""]\"""";\n    return os;\n  }\n\n  int setNumLeaves()\n  {\n    if (isLeaf())\n    {\n      m_numleaves = 1;\n      return 1;\n    }\n\n    int sum = 0;\n    for (int i = 0; i < basecount; i++)\n    {\n      if (m_children[i])\n      {\n        sum += m_children[i]->setNumLeaves();\n      }\n    }\n\n    m_numleaves = sum;\n    return sum;\n  }\n\n\n  int  m_start;                         // start pos in string\n  int  m_end;                           // end pos in string\n  int  m_nodeid;                        // the id for this node\n  int  m_leafid;                        // For leafs, the start position of the suffix in the string\n  int  m_depth;                         // string depth to me\n  int  m_numleaves;                     // number of leaves below me\n  SuffixNode * m_children [basecount];  // children nodes\n  SuffixNode * m_parent;                // parent node\n  SuffixNode * m_suffix;                // suffixlink\n  SuffixNode * m_printParent;           // where to start printing\n\n#if VERIFY\n  string m_pathstring;                  // string of path to node\n#endif\n};\n\nint SuffixNode::s_nodecount(0);\n\nostream & operator<< (ostream & os, SuffixNode * n)\n{\n  return n->printNodeLabel(os);\n}\n\n\n// Encapsulate the tree with some helper functions\nclass SuffixTree\n{\npublic:\n  SuffixTree(const char * s) : m_string(s)\n  { \n    m_strlen = strlen(s);\n#ifdef MPOOL\n    m_root = new (&m_pool) SuffixNode(0,0,0,NULL,NULL); // whole tree\n#else\n    m_root = new SuffixNode(0,0,0,NULL,NULL); // whole tree\n#endif\n    m_root->m_suffix = m_root;\n  }\n\n  ~SuffixTree()\n  {\n#ifdef MPOOL\n#else\n	 delete m_root;\n#endif\n  }\n\n  SuffixNode * m_root;\n  const char * m_string;\n  int m_strlen;\n\n#ifdef MPOOL\n  PoolMalloc_t m_pool;\n#endif\n\n  // Print a node for dot\n  void printNodeDot(SuffixNode * node, ostream & dfile)\n  {\n    int children = 0;\n    for (int i = 0; i < basecount; i++)\n    {\n      SuffixNode * child = node->m_children[i];\n      if (child)\n      {\n        children++;\n\n        dfile << "" "" << node << ""->"" << child;\n\n        //node->printNodeLabel(dfile, m_string) << "" -> "";\n        //child->printNodeLabel(dfile, m_string);\n\n        //dfile << "" [minlen="" << child->len() << "", label="";\n        dfile << "" [minlen=1, label="";\n        child->printEdgeLabel(dfile, m_string) << ""]"" << endl;\n\n        printNodeDot(child, dfile);\n      }\n    }\n\n    if (node->m_suffix)\n    {\n      dfile << "" "" << node << "" -> "" << node->m_suffix\n           << "" [style=dotted, constraint=false]"" << endl;\n\n      //node->printLabel(dfile, m_string) << "" -> "";\n      //node->m_suffix->printLabel(dfile, m_string) << "" [style=dotted, constraint=false]"" << endl;\n    }\n\n    if (children == 0)\n    {\n      //dfile << "" "" << node << "" [shape=box, label="";\n      //node->printLabel(dfile, m_string) << ""]"" << endl;\n\n      dfile << "" "" << node << "" [shape=box,width=.2,height=.2,label=\"""" << node->id() << "":"" << node->m_leafid << ""\""]"" << endl;\n    }\n    else\n    {\n      //dfile << "" "" << node << "" [label="";\n      //node->printLabel(dfile, m_string) << ""]"" << endl;\n      dfile << "" "" << node << "" [width=.2,height=.2,label=\"""" << node->id() << ""\""]"" << endl;\n    }\n  }\n\n  // Print the whole tree for dot\n  void printDot(const char * dotfilename)\n  {\n    ofstream dfile;\n    dfile.open(dotfilename, ofstream::out | ofstream::trunc);\n\n    cerr << ""Printing dot tree to "" << dotfilename << endl;\n\n    dfile << ""digraph G {"" << endl;\n    dfile << "" size=\""7.5,10\"""" << endl;\n    dfile << "" center=true"" << endl;\n    dfile << "" label=\""Suffix tree of \'"" << m_string << ""\' len:"" \n          << m_strlen-1 << "" nc:""\n          << SuffixNode::s_nodecount << ""\"""" << endl;\n\n    printNodeDot(m_root, dfile);\n    dfile << ""}"" << endl;\n  }\n\n  // Print a node in text format\n  void printNodeText(ostream & out, SuffixNode * n, int depth)\n  {\n    for (int b = 0; b < basecount; b++)\n    {\n      if (n->m_children[b])\n      {\n        for (int i = 0; i < depth; i++)\n        {\n          out << "" "";\n        }\n        out << "" "";\n        out << n->m_children[b]->str(m_string) << endl;\n        printNodeText(out, n->m_children[b], depth+1);\n      }\n    }\n  }\n\n  // Print the tree in Text\n  void printText(ostream & out)\n  {\n    out << ""Suffix Tree len="" << m_strlen-1 << endl; \n    out << ""String: \"""" << m_string << ""\"""" << endl;\n    out << ""+"" << endl;\n    printNodeText(out, m_root, 0);\n  }\n\n  // Print the tree as list of sorted suffixes\n  void printTreeSorted(ostream & out, SuffixNode * node, const string & pathstring)\n  {\n    bool isLeaf = true;\n\n    string ps(pathstring);\n    if (node != m_root) { ps.append(node->str(m_string)); }\n\n    for (int i = 0; i < basecount; i++)\n    {\n      if (node->m_children[i])\n      {\n        isLeaf = false;\n        printTreeSorted(out, node->m_children[i], ps);\n      }\n    }\n\n    if (isLeaf) { out << ps << endl; }\n  }\n\n  void printTreeFlat(ostream & out)\n  {\n    out << ""nodeid\tparent\tSL\tstart\tend\t$\tA\tC\tG\tT\tnodestring"" << endl;\n    out << ""0\t0\t0\t0\t0\t0\t0\t0\t0\t0\t0"" << endl;\n    printNodeFlat(out, m_root);\n  }\n\n  void printNodeFlat(ostream & out, SuffixNode * node)\n  {\n    out << node->id()           << ""\t""\n        << node->m_parent->id() << ""\t""\n        << node->m_suffix->id() << ""\t""\n        << node->m_start        << ""\t""\n        << node->m_end          << ""\t"";\n\n    for (int i = 0; i < basecount; i++)\n    {\n      out << node->m_children[i]->id() << ""\t"";\n    }\n\n	out << node->m_start << ""\t"" << node->m_end << ""\t""; \n\n    if (node == m_root) { out << ""ROOT"" << endl; } \n    else                { out << node->str(m_string) << endl; }\n\n    for (int i = 0; i < basecount; i++)\n    {\n      if (node->m_children[i]) { printNodeFlat(out, node->m_children[i]); }\n    }\n  }\n\n#if VERIFY\n  void setNodePath(SuffixNode * node, const string & parentString)\n  {\n    node->m_pathstring = parentString;\n\n    if (node != m_root)\n    {\n      node->m_pathstring.append(m_string, node->m_start, node->m_end - node->m_start + 1);\n    }\n\n    for (int b = 0; b < basecount; b++)\n    {\n      if (node->m_children[b])\n      {\n        setNodePath(node->m_children[b], node->m_pathstring);\n      }\n    }\n  }\n\n  int verifyNodeSuffixLinks(SuffixNode * node, int & linkcount)\n  {\n    int errs = 0;\n    if (node != m_root && node->m_suffix)\n    {\n      const string & np = node->m_pathstring;\n      const string & sp = node->m_suffix->m_pathstring;\n      if (np.substr(1, np.length() -1) != sp)\n      {\n        cerr << ""Suffix Link Mismatch!!"" << endl;\n        node->printLabel(cerr, m_string) << "": "" << np << endl;\n        node->m_suffix->printLabel(cerr, m_string) << "": "" << sp << endl;\n        errs++;\n      }\n\n      linkcount++;\n    }\n\n    if (node == m_root && node->m_suffix != m_root)\n    {\n      cerr << ""Error m_root suffix != m_root !!!"" << endl;\n      errs++;\n    }\n\n    int childcount = 0;\n    for (int b = 0; b < basecount; b++)\n    {\n      if (node->m_children[b])\n      {\n        childcount++;\n        errs += verifyNodeSuffixLinks(node->m_children[b], linkcount);\n      }\n    }\n\n    if (childcount && !node->m_suffix)\n    {\n      errs++;\n      node->printLabel(cerr, m_string) << "" has no suffix link!!!"" << endl;\n    }\n\n    return errs;\n  }\n\n  void verifySuffixLinks()\n  {\n    cerr << endl;\n    cerr << ""Verifing links"" << endl;\n    setNodePath(m_root, """");\n    int linkcount = 0;\n    int err = verifyNodeSuffixLinks(m_root, linkcount);\n    cerr << err << "" suffix link errors detected"" << endl;\n    cerr << linkcount << "" suffix links checked"" << endl;\n\n    if (err) { exit(1); }\n  }\n#endif\n  \n\n  void buildUkkonen()\n  {\n    int len = m_strlen - 1; // length of the string, not of the buffer (remove s)\n    char base = m_string[1];\n\n    if (DEBUG)\n    {\n      cerr << ""Building Ukkonen Tree for "" << m_string << endl\n           << ""Len: "" << len << endl;\n    }\n\n    // Construct T1\n#ifdef MPOOL\n    SuffixNode * node = new (&m_pool) SuffixNode(1, len, 1, m_root, NULL); // leaf: 1\n#else\n    SuffixNode * node = new SuffixNode(1, len, 1, m_root, NULL); // leaf: 1\n#endif\n    m_root->m_children[b2i(base)] = node;\n    SuffixNode * firstleaf = node;\n    SuffixNode * lastleaf = node;\n\n    if (DEBUG)\n    { cerr << ""Phase 1 Child: ""; node->printLabel(cerr, m_string) << endl; }\n\n    int startj = 2;\n\n    // phase i+1\n    for (int i = 2; i <= len; i++)\n    {\n      // Start at the last leaf created which will allow easy\n      // access to the node for startj\n      node = lastleaf;\n      int nodewalk = 0;\n\n      // Keep track of last internal nodes created in split so we can add suffix links\n      SuffixNode * splitnode = NULL;\n\n      if (!DOPHASETRICK)\n      {\n        startj = 2;\n        node = firstleaf;\n      }\n\n      if (DEBUG) \n      { \n        char next = m_string[i];\n        cerr << endl;\n        cerr << i << "".0 "" << ""Phase "" << i << "" adding "" << next << "" starting with "" << startj << endl; \n\n        string beta = substr(m_string, 1, i);\n        cerr << i << "".1"" << "" Extension 1: \"""" << beta << ""\"" [implicit]"" << endl;\n      }\n\n      for (int j = startj; j <= i; j++)\n      {\n        // Goal: Ensure S[j .. i] (beta) is in the suffix tree \n        // Precondition: S[j-1 .. i] (alpha) is in the suffix tree ""near"" node\n        //               All Internal nodes have a suffix link\n\n        // Idea: 1) Remember where alpha is in the tree relative to node\n        //       2) Walk up the tree w bases until we get to a node with a suffix link.\n        //       3) Follow suffix link which shifts the path from S[j-1..i] to S[j..i]\n        //       4) Walk down tree in new location ensuring S[i-w .. i] is in tree\n\n        // Notes: 1) All internal nodes have a suffix link by next extension\n        //        2) Any time we walk up to root, have to check S[j..i]\n        //        3) Suffix [1..i] is always present so start extension j with 2\n\n        int betapos = i; // The first position in string we need to check in tree\n\n        if (DEBUG)\n        {\n          cerr << endl;\n          string beta = substr(m_string, j, i-j+1);\n          cerr << i << ""."" << j << "" Phase "" << i << "" Extension "" << j << "": \"""" << beta << ""\"" bp:"" << betapos << endl;\n\n          cerr << i << ""."" << j << ""  Walking up from n:""; \n          node->printLabel(cerr, m_string) << "" nw: "" << nodewalk << endl;\n        }\n\n        if (node == m_root)\n        {\n          // If we are at root, we have to check the full string s[j..i] anyways\n        }\n        else\n        {\n          if (nodewalk)\n          {\n            // partially walked down node->child, but didn't switch to child\n            // Match at i=6 on left... nodewalk=2, at 5 after suffix link\n            // 5 = i-2+1\n            //                 o ----- o\n            //               5 A       A 5  <-\n            //            -> 6 T       T 6 \n\n            betapos -= nodewalk-1;\n\n            if (DEBUG)\n            {\n              cerr << i << ""."" << j << ""   Adjusted nw: "" << nodewalk << endl;\n            }\n          }\n          else\n          {\n            // Exactly at a node or leaf. \n            // Walk up to parent, subtracting length of that edge\n            int len = node->len(i);\n            betapos -= len-1;\n            node = node->m_parent;\n\n            if (DEBUG)\n            {\n              cerr << i << ""."" << j << ""   Adjusted len: "" << len << endl;\n            }\n          }\n          \n          if (DEBUG)\n          {\n            cerr << i << ""."" << j << ""   parent bp: "" << betapos <<  "" n:"";\n            node->printLabel(cerr, m_string) << endl;\n          }\n\n          if (node->m_suffix == NULL)\n          {\n            // Subtract entire edge length\n            betapos -= node->len(i);\n            node = node->m_parent;\n\n            if (DEBUG)\n            {\n              cerr << i << ""."" << j << ""   grandparent bp: "" << betapos << "" n:"";\n              node->printLabel(cerr, m_string) << endl;\n            }\n\n            #if VERIFY\n            if (node->m_suffix == NULL)\n            {\n              cerr << ""Missing suffix link!!! "";\n              exit(1);\n            }\n            #endif\n          }\n        }\n\n        // jump across suffix link\n        node = node->m_suffix;\n        if (node == m_root) { betapos = j; } // have to check full string\n\n        if (DEBUG)\n        {\n          cerr << i << ""."" << j << ""  Starting to walk down from bp: "" << betapos << "" to "" << i << "" n:"";\n          node->printLabel(cerr, m_string) << endl;\n        }\n\n        if (FORCEROOT && node != m_root)\n        {\n          node = m_root;\n          betapos = j;\n\n          if (DEBUG)\n          {\n            cerr << i << ""."" << j << "" AtRoot bp: "" << betapos << endl;\n          }\n        }\n\n        bool done = false;\n        startj = j+1; // assume this extension should be skipped in the next phase\n\n        while ((betapos <= i) && !done)\n        {\n          char base = m_string[betapos];\n          unsigned char b = b2i(base);\n          SuffixNode * child = node->m_children[b];\n\n          if (DEBUG)\n          {\n            cerr << i << ""."" << j << ""  node betapos: "" << betapos << ""["" << base << ""] n:"";\n            node->printLabel(cerr, m_string) << "" "";\n            if (child) { cerr << ""c: ""; child->printLabel(cerr, m_string); } \n            cerr << endl;\n          }\n\n          if (!child)\n          {\n            if (splitnode && betapos == splitnode->m_start)\n            {\n              if (DEBUG)\n              {\n                cerr << i << ""."" << j << ""   Add SL1: "";\n                splitnode->m_parent->printLabel(cerr, m_string) << "" sl-> "";\n                node->printLabel(cerr, m_string) << endl;\n              }\n\n              splitnode->m_parent->m_suffix = node;\n              splitnode = NULL;\n            }\n\n#ifdef MPOOL\n            SuffixNode * newnode = new (&m_pool) SuffixNode(betapos, len, j, node, NULL); // leaf: j\n#else\n            SuffixNode * newnode = new SuffixNode(betapos, len, j, node, NULL); // leaf: j\n#endif\n            node->m_children[b] = newnode; \n            lastleaf = newnode;\n\n            if (DEBUG)\n            {\n              cerr << i << ""."" << j << ""   New Node: "";\n              newnode->printLabel(cerr, m_string) << endl;\n            }\n\n            node = newnode;\n\n            // This is the first base that differs, but the edgelength to \n            // i may be longer. Therefore set nodewalk to 0, so the entire\n            // edge is subtracted.\n            nodewalk = 0;\n            done = true;\n            break;\n          }\n          else\n          {\n            int nodepos = child->m_start;\n            nodewalk = 0;\n\n            char nodebase = m_string[nodepos];\n\n            #if VERIFY\n            if (nodebase != base)\n            {\n              char nb = m_string[nodepos];\n              cerr << ""ERROR: first base on edge doesn't match edge label"" << endl;\n              cerr << ""       nb: "" << nb << "" base: "" << base << endl;\n              exit(1);\n            }\n            #endif\n\n            // By construction, the string from j-1 to betapos to i-1\n            // must already by present in the suffix tree\n            // Therefore, we can skip checking every character, and zoom\n            // to exactly the right character, possibly skipping the entire edge\n\n            if (DOJUMP)\n            {\n              int mustmatch = i-1 - betapos + 1;\n              int childlen = child->len(i);\n\n              if (mustmatch >= childlen)\n              {\n                betapos += childlen;\n                nodepos += childlen;\n\n                skippedbases += childlen;\n\n                if (DEBUG)\n                {\n                  cerr << i << ""."" << j << ""   Edge Jump by: "" << childlen << "" new bp: "" << betapos << "" np: "" << nodepos << endl;\n                }\n\n                #if VERIFY\n                if (nodepos != child->m_end+1)\n                {\n                  cerr << ""ERROR: jump should have skipped entire edge, but didn't!"" << endl;\n                  exit(1);\n                }\n                #endif\n              }\n              else if (mustmatch)\n              {\n                betapos += mustmatch;\n                nodepos += mustmatch;\n                nodewalk += mustmatch;\n\n                skippedbases += mustmatch;\n\n                if (DEBUG)\n                {\n                  cerr << i << ""."" << j << ""   Partial Jump by: "" << mustmatch << "" new bp: "" << betapos << "" np: "" << nodepos << endl;\n                }\n\n                #if VERIFY\n                if (VERIFY)\n                {\n                  if (m_string[betapos-1] != m_string[nodepos-1])\n                  {\n                    cerr << ""ERROR: jump should have matched at least the mustmatch-1 characters"" << endl;\n                    cerr << ""s[bp-1]: "" << m_string[betapos-1] << "" s[np-1]: "" << m_string[nodepos-1] << endl;\n                    exit(1);\n                  }\n                }\n                #endif\n              }\n            }\n\n            while (nodepos <= child->m_end && betapos <= i)\n            {\n              nodebase = m_string[nodepos];\n\n              #if VERBOSE\n                cerr << i << ""."" << j << ""   child bp: "" << betapos << ""["" << m_string[betapos] \n                     << ""] nb ["" << nodebase << ""]"" << endl;\n              #endif\n\n              if (m_string[betapos] == nodebase)\n              {\n                if (splitnode && betapos == splitnode->m_start)\n                {\n                  if (DEBUG)\n                  {\n                    cerr << i << ""."" << j << ""   Add SL2: "";\n                    splitnode->m_parent->printLabel(cerr, m_string) << "" sl-> "";\n                    node->printLabel(cerr, m_string) << endl;\n                  }\n\n                  splitnode->m_parent->m_suffix = node;\n                  splitnode = NULL;\n                }\n\n                nodepos++; betapos++; nodewalk++;\n\n                if (betapos == i+1)\n                {\n                  if (DEBUG)\n                  {\n                    cerr << i << ""."" << j << ""    Internal edge match nw: "" << nodewalk << endl;\n                  }\n\n                  if ((nodewalk == child->len(i)) && (child->m_end == len))\n                  {\n                    // we walked the whole edge to leaf, implicit rule I extension\n                    if (DEBUG)\n                    {\n                      cerr << i << ""."" << j << ""    Leaf Node, Implicit Rule I Extension"" << endl;\n                    }\n                  }\n                  else\n                  {\n                    // ""Real"" rule III implicit extension\n\n                    // The j-1 extension was the last explicit extension in this round\n                    // Start the next round at the last explicit extension\n                    if (DOPHASETRICK)\n                    {\n                      startj = j;\n\n                      int skip = startj - 2;\n\n                      if (DEBUG)\n                      {\n                        cerr << i << ""."" << j << ""    Implicit Extension... start next phase at "" << startj << "", saved "" << skip << endl;\n                      }\n\n                      skippedextensions += skip;\n                    }\n\n                    if (DOINTERNALSKIP)\n                    {\n                      // Since we hit an internal match on a non-leaf, we know every other \n                      // extension in this phase will also hit an internal match. \n\n                      // Have to be careful since leafs get the full string immediately, but\n                      // they really have a Rule 1 extension\n\n                      int skip = i-j;\n\n                      if (DEBUG)\n                      { \n                        cerr << i << ""."" << j << ""    Implicit Extension... skipping rest of phase, saved "" << skip << endl;\n                      }\n\n                      skippedextensions += skip;\n                      j = i+1;\n                    }\n                  }\n\n                  done = true;\n                }\n              }\n              else\n              {\n                if (DEBUG) { cerr << i << ""."" << j << ""   Spliting ""; child->printLabel(cerr, m_string); }\n\n                // Split is a copy of the child with the end shifted\n                // Then adjust start of child\n#ifdef MPOOL\n                SuffixNode * split = new (&m_pool) SuffixNode(child->m_start, nodepos-1, 0, node, NULL); // internal\n#else\n                SuffixNode * split = new SuffixNode(child->m_start, nodepos-1, 0, node, NULL); // internal\n#endif\n\n                split->m_children[b2i(nodebase)] = child;\n                child->m_start = nodepos;\n                child->m_parent = split;\n\n                if (DEBUG)\n                {\n                  cerr << "" => "";\n                  split->printLabel(cerr, m_string) << "" + "";\n                  child->printLabel(cerr, m_string) << endl;\n                }\n\n                node->m_children[b] = split;\n                node = split;\n\n                if (splitnode && betapos == splitnode->m_start)\n                {\n                  if (DEBUG)\n                  {\n                    cerr << i << ""."" << j << ""   Add SL3: "";\n                    splitnode->m_parent->printLabel(cerr, m_string) << "" sl-> "";\n                    node->printLabel(cerr, m_string) << endl;\n                  }\n\n                  splitnode->m_parent->m_suffix = split;\n                  splitnode = NULL;\n                }\n\n                // Now create the new node\n#ifdef MPOOL\n                SuffixNode * newnode = new (&m_pool) SuffixNode(betapos, len, j, split, NULL); // leaf j\n#else\n                SuffixNode * newnode = new SuffixNode(betapos, len, j, split, NULL); // leaf j\n#endif\n                lastleaf = newnode;\n\n                split->m_children[b2i(m_string[betapos])] = newnode; \n                splitnode = newnode;\n\n                node = newnode;\n\n                if (DEBUG)\n                {\n                  cerr << i << ""."" << j << ""   Split New Node: "";\n                  newnode->printLabel(cerr, m_string) << endl;\n                }\n\n                // This is the first base that differs, but the edgelength to \n                // i may be longer. Therefore set nodewalk to 0, so the entire\n                // edge is subtracted.\n                nodewalk = 0;\n                done = true;\n                break;\n              }\n            }\n          }\n\n          if (!done) { node = child; }\n        }\n      }\n\n      #if VERIFY\n      if (VERIFY) { verifySuffixLinks(); }\n      #endif\n    }\n  }\n};\n\n\nSuffixTree * gtree = NULL;\n\nvoid buildUkkonenSuffixTree(const char * str)\n{\n   gtree = new SuffixTree(str);\n   gtree->buildUkkonen();\n}\n\nstatic const int TEXBLOCKSIZE = 32;\n\n#define LOW3(x) (x & 0xFF)\n#define MID3(x) (x & 0xFF00) >> 8\n#define HI3(x)  (x & 0xFF0000) >> 16\n\n#define HALF_TEXTURE_DIMENSION 2048\n\ninline TextureAddress id2addr(int id)\n{\n  TextureAddress retval;\n\n#if MERGETEX && REORDER_TREE\n  // Half width is 2048 => 11 bits\n  // TEXBLOCKSIZE is 32 => 5 bits\n  int bigx = id & 0xFFFF; // 11 + 5 bits\n  int bigy = id >> 16;\n\n  retval.y = (bigy << 5) + (bigx & 0x1F);\n  retval.x = bigx >> 5;\n\n  // now stuff y's 13th bit into x's 12th bit\n  \n  retval.x |= (retval.y & 0x1000) >> 1;\n  retval.y &= 0xFFF;\n\n#elif REORDER_TREE\n  // MAX_TEXTURE_DIMENSION is 4096 => 12 bits\n  // TEXBLOCKSIZE is 32 => 5 bits\n  int bigx = id & 0x1FFFF; // 12 + 5 bits\n  int bigy = id >> 17;\n  retval.y = (bigy << 5) + (bigx & 0x1F);\n  retval.x = bigx >> 5;\n\n#elif MERGETEX\n  retval.x = id;\n\n#else\n  retval.x = id;\n\n#endif\n  return retval;\n}\n\ninline int addr2id(TextureAddress addr)\n{\n#if MERGETEX && REORDER_TREE\n  // shift x'a 12th bit as y's 13th\n  addr.y |= (addr.x & 0x800) << 1;\n  addr.x &= 0x7FF;\n\n  int blocky = addr.y & 0x1F;\n  int bigy = addr.y >> 5;\n  int bigx = (addr.x << 5) + blocky;\n  return bigx + (bigy << 16);\n\n#elif REORDER_TREE\n  int blocky = addr.y & 0x1F;\n  int bigy = addr.y >> 5;\n  int bigx = (addr.x << 5) + blocky;\n  return bigx + (bigy << 17);\n\n#elif MERGETEX\n    return addr.x;\n\n#else\n    return addr.x;\n\n#endif\n}\n\nvoid writeAddress(unsigned char arr[3], TextureAddress addr)\n{\n#if REORDER_TREE\n  arr[0] = addr.x & 0xFF;\n  arr[1] = addr.y & 0xFF;\n  arr[2] = (((addr.x) >> 8) & 0xF) | (((addr.y) >> 4) & 0xF0);\n#else\n  arr[0] = LOW3(addr.x);\n  arr[1] = MID3(addr.x);\n  arr[2] = HI3(addr.x);\n#endif\n}\n\nTextureAddress arrayToAddress(unsigned char arr[3])\n{\n  TextureAddress retval;\n\n#if REORDER_TREE\n  retval.x = arr[0] | ((arr[2] & 0xF) << 8);\n  retval.y = arr[1] | ((arr[2] & 0xF0) << 4);\n#else\n  retval.x = MK3(arr);\n#endif\n\n  return retval;\n}\n\n\n\nvoid buildNodeTexture(SuffixNode * node,\n                      PixelOfNode * nodeTexture,\n                      PixelOfChildren * childrenTexture,\n                      AuxiliaryNodeData aux_data[],\n                      const char * refstr)\n{	\n  int origid = node->id();\n    \n  aux_data[origid].length = node->len();\n  aux_data[origid].numleaves = node->m_numleaves;\n  aux_data[origid].printParent = id2addr(node->m_printParent->id());\n\n  TextureAddress myaddress(id2addr(origid));\n\n  PixelOfNode * nd;\n  PixelOfChildren * cd;\n\n#if MERGETEX && REORDER_TREE\n  int tex = myaddress.x & 0x800;\n  myaddress.x &= 0x7FF;\n  myaddress.x *= 2;\n\n  int loc = myaddress.x + myaddress.y*MAX_TEXTURE_DIMENSION;\n\n  if (tex)\n  {\n    nd = (PixelOfNode*)    &childrenTexture[loc];\n    cd = (PixelOfChildren*)&childrenTexture[loc+1];\n  }\n  else\n  {\n    nd = (PixelOfNode*)    &nodeTexture[loc];\n    cd = (PixelOfChildren*)&nodeTexture[loc+1];\n  }\n\n#elif REORDER_TREE\n  int loc = myaddress.x + myaddress.y*MAX_TEXTURE_DIMENSION;\n\n  nd = &(nodeTexture[loc]);\n  cd = &(childrenTexture[loc]);\n\n#elif MERGETEX\n  int loc = myaddress.x * 2;\n\n  if (loc >= (MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION))\n  {\n    loc -= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION;\n    nd = (PixelOfNode*)    &(childrenTexture[loc]);\n    cd = (PixelOfChildren*)&(childrenTexture[loc+1]);\n  }\n  else\n  {\n    nd = (PixelOfNode*)    &(nodeTexture[loc]);\n    cd = (PixelOfChildren*)&(nodeTexture[loc+1]);\n  }\n\n#else\n  int loc = myaddress.x;\n  nd = &(nodeTexture[loc]);\n  cd = &(childrenTexture[loc]);\n#endif\n\n  unsigned char arr[3];\n  writeAddress(arr, myaddress);\n  TextureAddress newaddr = arrayToAddress(arr);\n\n  TextureAddress parent(id2addr(node->m_parent->id()));\n  writeAddress(nd->parent, parent);\n  assert(arrayToAddress(nd->parent).data == parent.data);\n\n  TextureAddress suffix(id2addr(node->m_suffix->id()));\n  writeAddress(nd->suffix, suffix);\n  assert(arrayToAddress(nd->suffix).data == suffix.data);\n\n  nd->start[0]  = LOW3(node->m_start);\n  nd->start[1]  = MID3(node->m_start);\n  nd->start[2]  = HI3(node->m_start);\n\n  assert(MK3(nd->start) == node->m_start);\n\n  nd->end[0]    = LOW3(node->m_end);\n  nd->end[1]    = MID3(node->m_end);\n  nd->end[2]    = HI3(node->m_end);\n\n  assert(MK3(nd->end) == node->m_end);\n\n  int depth = node->depth();\n  nd->depth[0]  = LOW3(depth);\n  nd->depth[1]  = MID3(depth);\n  nd->depth[2]  = HI3(depth);\n    \n  assert(MK3(nd->depth) == depth);\n    \n  cd->leafchar = 0;\n\n  if (node->m_leafid != 0)\n  {\n    cd->leafchar  = refstr[node->m_leafid-1];\n\n    cd->leafid[0] = LOW3(node->m_leafid);\n    cd->leafid[1] = MID3(node->m_leafid);\n    cd->leafid[2] = HI3(node->m_leafid);\n  }\n  else\n  {\n    if (node->m_children[0]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[0]->id());\n      writeAddress(cd->a, childaddr);\n      assert(arrayToAddress(cd->a).data == childaddr.data);\n      buildNodeTexture(node->m_children[0], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n            \n    if (node->m_children[1]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[1]->id());\n      writeAddress(cd->c, childaddr);\n      assert(arrayToAddress(cd->c).data == childaddr.data);\n      buildNodeTexture(node->m_children[1], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n\n    if (node->m_children[2]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[2]->id());\n      writeAddress(cd->g, childaddr);\n      assert(arrayToAddress(cd->g).data == childaddr.data);\n      buildNodeTexture(node->m_children[2], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n\n    if (node->m_children[3]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[3]->id());\n      writeAddress(cd->t, childaddr);\n      assert(arrayToAddress(cd->t).data == childaddr.data);\n      buildNodeTexture(node->m_children[3], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n\n    if (node->m_children[4]) \n    { \n      TextureAddress childaddr = id2addr(node->m_children[4]->id());\n      writeAddress(cd->d, childaddr);\n      assert(arrayToAddress(cd->d).data == childaddr.data);\n      buildNodeTexture(node->m_children[4], nodeTexture, childrenTexture, aux_data, refstr); \n    }\n  }\n}\n\nvoid buildSuffixTreeTexture(PixelOfNode** nodeTexture,\n                            PixelOfChildren **childrenTexture,\n                            unsigned int* width, \n                            unsigned int* node_height,\n                            unsigned int* children_height,\n                            AuxiliaryNodeData **aux_data,\n                            const char * refstr,\n                            int min_match_len) \n{\n    // Leave space for NULL node\n    int allnodes = SuffixNode::s_nodecount + 1;\n\n    assert(allnodes < MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION);\n    \n    assert(sizeof(PixelOfNode) == 16);\n    assert(sizeof(PixelOfChildren) == 16);\n    \n\n#if MERGETEX && REORDER_TREE\n    *width = MAX_TEXTURE_DIMENSION;\n    \n	int numrows = ((int)ceil((allnodes+0.0) / ((MAX_TEXTURE_DIMENSION/2) * TEXBLOCKSIZE))) * TEXBLOCKSIZE;\n    if (numrows <= MAX_TEXTURE_DIMENSION)\n    {\n      *node_height = numrows;\n      *children_height = 0;\n    }\n    else\n    {\n      *node_height = MAX_TEXTURE_DIMENSION;\n      *children_height = (numrows - MAX_TEXTURE_DIMENSION);\n    }\n\n#elif REORDER_TREE\n    *width = MAX_TEXTURE_DIMENSION;\n	int numrows = ((int)ceil((allnodes+0.0) / ((MAX_TEXTURE_DIMENSION) * TEXBLOCKSIZE))) * TEXBLOCKSIZE;\n    *node_height = numrows;\n    *children_height = numrows;\n\n#elif MERGETEX\n    *width = 1;\n    int numcells = allnodes*2;\n\n    if (numcells <= (MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION))\n    {\n      *node_height = numcells;\n      *children_height = 0;\n    }\n    else\n    {\n      *node_height = MAX_TEXTURE_DIMENSION * MAX_TEXTURE_DIMENSION;\n      *children_height = numcells - *node_height;\n    }\n\n#else\n    *width = 1;\n    *node_height = allnodes;\n    *children_height = allnodes;\n#endif\n\n    int alloc = 0;\n\n    // allocate space for the node and children textures\n    *nodeTexture     = (PixelOfNode*) calloc((*width) * (*node_height), sizeof(PixelOfNode));\n    alloc += (*width) * (*node_height) * sizeof(PixelOfNode);\n\n    *childrenTexture = NULL;\n\n    if (*children_height)\n    {\n      *childrenTexture = (PixelOfChildren*) calloc((*width) * (*children_height), sizeof(PixelOfChildren));\n      alloc += (*width) * (*children_height) * sizeof(PixelOfChildren);\n    }\n    \n    fprintf(stderr, "" node: %dx%d"",     *width, *node_height);\n    fprintf(stderr, "" children: %dx%d "", *width, *children_height);\n\n    *aux_data = (AuxiliaryNodeData*)calloc(allnodes, sizeof(AuxiliaryNodeData));\n\n    if (!*nodeTexture || (*children_height && !*childrenTexture) || !*aux_data) \n    {\n        fprintf(stderr, ""arg.  texture allocation failed.\n"");\n        exit(-1);\n    }\n    \n    gtree->m_root->setNumLeaves();\n    gtree->m_root->setPrintParent(min_match_len);\n    \n    buildNodeTexture(gtree->m_root,\n                     *nodeTexture,\n                     *childrenTexture,\n                     *aux_data,\n                     refstr);\n};\n\n\nvoid printTreeTexture(const char * texfilename,\n                      PixelOfNode * nodeTexture,\n                      PixelOfChildren * childrenTexture,\n                      int nodecount)\n{\n  cerr << ""Printing tree texture to "" << texfilename << endl;\n\n  ofstream texfile;\n  texfile.open(texfilename, ofstream::out | ofstream::trunc);\n\n  texfile << ""id\tx\ty\tstart\tend\tdepth\ta.x\ta.y\tc.x\tc.y\tg.x\tg.y\tt.x\tt.y\t$.x\t$.y\tp.x\tp.y"" << endl;\n  for (int i = 0; i < nodecount; i++)\n  {\n    TextureAddress myaddress(id2addr(i)); \n\n    texfile << i << ""\t""\n            << myaddress.x << ""\t""\n#if REORDER_TREE\n            << myaddress.y << ""\t""\n#endif\n            << MK3(nodeTexture[i].start) << ""\t""\n            << MK3(nodeTexture[i].end)   << ""\t""\n            << MK3(nodeTexture[i].depth) << ""\t"";\n\n    TextureAddress a = arrayToAddress(childrenTexture[i].a);\n    texfile << a.x << ""\t"";\n#if REORDER_TREE\n    texfile << a.y << ""\t"";\n#endif\n\n    TextureAddress c = arrayToAddress(childrenTexture[i].c);\n    texfile << c.x << ""\t"";\n#if REORDER_TREE\n    texfile << c.y << ""\t"";\n#endif\n\n    TextureAddress g = arrayToAddress(childrenTexture[i].g);\n    texfile << g.x << ""\t"";\n#if REORDER_TREE\n    texfile << g.y << ""\t"";\n#endif\n\n    TextureAddress t = arrayToAddress(childrenTexture[i].t);\n    texfile << t.x << ""\t"";\n#if REORDER_TREE\n    texfile << t.y << ""\t"";\n#endif\n\n    TextureAddress d = arrayToAddress(childrenTexture[i].d);\n    texfile << d.x << ""\t"";\n#if REORDER_TREE\n    texfile << d.y << ""\t"";\n#endif\n\n    TextureAddress p = arrayToAddress(nodeTexture[i].parent);\n    texfile << p.x << ""\t"";\n#if REORDER_TREE\n    texfile << p.y;\n#endif\n\n    texfile << endl;\n  }\n\n  texfile.close();\n}\n\nvoid renumberTree()\n{\n  queue<pair<SuffixNode *, int> > nodequeue;\n\n  nodequeue.push(make_pair(gtree->m_root,0));\n  int nodecount = 0;\n\n  while(!nodequeue.empty())\n  {\n    pair<SuffixNode *,int> npair = nodequeue.front(); nodequeue.pop();\n\n    SuffixNode * node = npair.first;\n    int depth = npair.second;\n    \n    node->m_nodeid = ++nodecount;\n\n    if (depth < 16)\n    {\n      for (int i = 0; i < basecount; i++)\n      {\n        SuffixNode * child = node->m_children[i];\n        if (child) { nodequeue.push(make_pair(child,depth+1)); }\n      }\n    }\n    else\n    {\n      for (int i = 0; i < basecount; i++)\n      {\n        SuffixNode * child = node->m_children[i];\n        if (child)\n        {\n          child->m_nodeid = ++nodecount;\n          \n          for(int j = 0; j < basecount; j++)\n          {\n            SuffixNode * gchild = child->m_children[j];\n\n            if (gchild)\n            {\n              gchild->m_nodeid = ++nodecount;\n              for (int k = 0; k < basecount; k++)\n              {\n                SuffixNode * ggchild = gchild->m_children[k];\n\n                if (ggchild)\n                { \n                  ggchild->m_nodeid = ++nodecount;\n\n                  for (int l = 0; l < basecount; l++)\n                  {\n                    SuffixNode * gggchild = ggchild->m_children[l];\n\n                    if (gggchild)\n                    {\n                      gggchild->m_nodeid = ++nodecount;\n\n                      for (int m = 0; m < basecount; m++)\n                      {\n                        SuffixNode * ggggchild = gggchild->m_children[m];\n                        if (ggggchild){ nodequeue.push(make_pair(ggggchild, depth+5)); }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n\nextern ""C""\nvoid createTreeTexture(const char * refstr,\n                       PixelOfNode** nodeTexture,\n                       PixelOfChildren** childrenTexture,\n                       unsigned int* width,\n                       unsigned int* node_height,\n                       unsigned int* children_height,\n                       AuxiliaryNodeData** aux_data,\n                       int* num_nodes,\n                       int min_match_len,\n                       Statistics* statistics,\n                       const char * dotfilename,\n                       const char * texfilename)\n\n{\n    cerr << ""  Creating Suffix Tree... "";\n    EventTime_t btimer;\n    char* ctimer = createTimer();\n    startTimer(ctimer);\n\n    SuffixNode::s_nodecount = 0;\n    buildUkkonenSuffixTree(refstr);\n\n	stopTimer(ctimer);\n	if (statistics)\n		statistics->t_tree_construction += getTimerValue(ctimer);\n	deleteTimer(ctimer);\n	\n    cerr << SuffixNode::s_nodecount << "" nodes ""\n    << btimer.str(true, 5) << endl;\n\n#if RENUMBER_TREE    \n    cerr << ""  Renumbering tree... "";\n    EventTime_t rtimer;\n    char* reordertimer = createTimer();\n    startTimer(reordertimer);\n    renumberTree();\n    stopTimer(reordertimer);\n    if (statistics)\n        statistics->t_tree_reorder += getTimerValue(reordertimer);\n    deleteTimer(reordertimer);\n    cerr << rtimer.str(true, 5) << endl;\n#endif\n    \n    EventTime_t ftimer;\n    cerr << ""  Flattening Tree... "";\n    char* flattentimer = createTimer();\n    startTimer(flattentimer);\n    buildSuffixTreeTexture(nodeTexture,\n                           childrenTexture,\n                           width, node_height, children_height,\n                           aux_data,\n                           gtree->m_string,\n                           min_match_len);\n    stopTimer(flattentimer);\n    if (statistics)\n        statistics->t_tree_flatten += getTimerValue(flattentimer);\n    deleteTimer(flattentimer);  \n\n    *num_nodes = SuffixNode::s_nodecount + 1;\n    cerr << ftimer.str(true, 5) << endl;\n    \n    if (dotfilename)\n    {\n        gtree->printDot(dotfilename);\n    }\n    \n    if (texfilename)\n    {\n        printTreeTexture(texfilename,\n                         *nodeTexture,\n                         *childrenTexture,\n                         SuffixNode::s_nodecount + 1);\n    }\n    \n    delete gtree;\n    gtree = NULL;\n}\n\n\n\nextern ""C""\nvoid getReferenceString(const char * filename, char** refstr, size_t* reflen)\n{\n  EventTime_t timer;\n  cerr << ""Loading ref: "" << filename << ""... "";\n\n  string S=""s"";\n\n  ifstream file;\n  file.open(filename);\n\n  if (!file)\n  {\n    cerr << ""Can't open "" << filename << endl;\n    exit (1);\n  }\n\n  // Skip over the reference header line\n  char refline[2048];\n  file.getline(refline, sizeof(refline));\n\n  if (refline[0] != '>')\n  {\n    cerr << endl\n         << ""ERROR: Reference file is not in FASTA format""\n         << endl;\n  }\n\n  // Now read the reference string\n  string buffer;\n  while (file >> buffer)\n  {\n    if (buffer[0] == '>')\n    {\n      cerr << endl\n           << ""ERROR: Only a single reference sequence is supported!"" \n           << endl;\n\n      exit (1);\n    }\n    else\n    {\n      for (unsigned int i = 0; i < buffer.length(); i++)\n      {\n        char b = toupper(buffer[i]);\n		if (b == ' ')\n			continue;\n        if (b == 'A' || b == 'C' || b == 'G' || b=='T')\n        {\n          S += b;\n        }\n		else\n		{\n		   S += 'A';\n		}\n      }\n    }\n  }\n\n  S += ""$"";\n *refstr = strdup(S.c_str());\n  *reflen = strlen(*refstr) + 1;\n\n  cerr << *reflen-3 << "" bp. "" << timer.str(true, 5) << endl;\n}\n\ninline void addChar(char **buf, int * size, int * pos, char c)\n{\n  if (*pos == *size)\n  {\n    (*size) *= 2; // double the size of the buffer\n    *buf = (char *) realloc(*buf, *size);\n    if (!*buf)\n    {\n      cerr << ""ERROR: Realloc failed, requested: "" << *size << endl;\n      exit(1);\n    }\n  }\n\n  (*buf)[*pos] = c;\n  (*pos)++;\n}\n\ninline size_t bytesNeededOnGPU(unsigned int querylen, int min_match_len)\n{\n   if (min_match_len == -1)\n	  return sizeof(MatchCoord) + (querylen + 10);\n   else\n	  return sizeof(MatchCoord) * (querylen - min_match_len + 1) + \n		(querylen + 10);\n} \n\n#define WARP_SIZE 16\n\n//Gets up to set_size queries.\nextern ""C""\n    void getQueriesTexture(int qfile,\n                           char** queryTexture,\n                           size_t* queryTextureSize,\n                           int** queryAddrs,\n                           char*** queryNames,\n                           int** queryLengths,\n                           unsigned int* numQueries,\n                           unsigned int* num_match_coords,\n                           unsigned int memory_avail,\n                           int min_match_length,\n                           bool rc)\n{\n    EventTime_t timer;\n    \n    int qstringpos = 0;\n    int qstringsize = 1024 * 1024;\n    char * qstring = (char *) malloc(qstringsize);\n    \n    bool resetAmbiguity  = true;\n    \n    // offset of query i in qstring\n    int offsetspos = 0;\n    int offsetssize = 1024;\n    int * offsets = (int *) malloc(offsetssize * sizeof(int));\n    int * lengths = (int *) malloc(offsetssize * sizeof(int));\n    \n    int qrylen = 0;\n    int this_qrylen = 0;\n    \n    int bytes_read;\n    unsigned char buf[32*1024];\n    \n    vector<char*> names;\n    string header;\n    bool inheader = false;\n    int total_read = 0;\n    \n    unsigned char dnachar [256];\n    \n    bool set_full = false;\n    \n#if COALESCED_QUERIES\n    unsigned int curr_warp_padding = 0;\n    unsigned int warp_max_qry_len = 2;\n#endif\n    \n    // tracks the GPU memory needed by the queries read so far.\n    unsigned int  curr_mem_usage = 0;\n    \n    for (int i = 0; i < 256; i++)\n    {\n        dnachar[i] = 0;\n    }\n    \n    dnachar[(unsigned char) 'A'] = 1;\n    dnachar[(unsigned char) 'C'] = 1;\n    dnachar[(unsigned char) 'G'] = 1;\n    dnachar[(unsigned char) 'T'] = 1;\n    \n    while ((bytes_read = read(qfile, buf, sizeof(buf))) != 0)\n    {\n        // cerr << ""bytes_read: "" << bytes_read << endl;\n        \n        if (bytes_read == -1)\n        {\n            cerr << ""ERROR: Error reading file: "" << errno << endl;\n            exit(1);\n        }\n        \n        int i = 0;\n        \n        if (inheader)\n        {\n            // Handle case where last read was inside a header\n            for (; i < bytes_read; i++)\n            {\n                if (buf[i] == '\n')\n                {\n                    inheader = false;\n                    i++;\n                    char* name = strdup(header.c_str());\n                    names.push_back(name);\n                    header.clear();\n                    break;\n                }\n                else\n                {\n                    header.insert(header.end(), buf[i]);\n                }\n            }\n        }\n        \n        for (; i < bytes_read; i++)\n        {\n            unsigned char b = toupper(buf[i]);\n            \n            if (b == '>')\n            {\n            \n                if (curr_mem_usage + bytesNeededOnGPU(MAX_QUERY_LEN, min_match_length) >= memory_avail)\n                {\n                    set_full = true;\n                    off_t seek = lseek(qfile, -(bytes_read - i), SEEK_CUR);\n                    if (seek == (off_t) - 1)\n                    {\n                        cerr << ""lseek failed: "" << errno << endl;\n                        exit(-1);\n                    }\n                    break;\n                }\n                \n                \n                // in a header line\n                if (offsetspos != 0)\n                {\n                    if (this_qrylen < min_match_length)\n                    {\n                        //printf(""> %s\n"", names.back());\n                        //if (rc)\n                        //    printf(""> %s Reverse\n"", names.back());\n                        names.pop_back();\n                        --offsetspos;\n                        qstringpos -= this_qrylen  + 1;\n                    }\n                    else\n                    {\n                        addChar(&qstring, &qstringsize, &qstringpos, '\0');\n                        lengths[offsetspos - 1] = this_qrylen;\n#if COALESCED_QUERIES\n                        if (warp_max_qry_len < this_qrylen + 2)\n                        {\n                            int num_warp_queries = (offsetspos - 1) % WARP_SIZE;\n                            \n                            curr_warp_padding -= num_warp_queries * warp_max_qry_len;\n                            curr_mem_usage -= num_warp_queries * warp_max_qry_len;\n                            \n                            warp_max_qry_len = this_qrylen  + 2;\n                            if (warp_max_qry_len % 4)\n                                warp_max_qry_len += 4 - (warp_max_qry_len % 4);\n                                \n                            curr_warp_padding += num_warp_queries * warp_max_qry_len;\n                            curr_mem_usage += num_warp_queries * warp_max_qry_len;\n                        }\n                        //TODO: We shouldn't simply pass in warp_max_qry_len,\n                        // we really ought to pass the real length in, and then add the padding\n                        // For now, we are overestimating.\n                        curr_mem_usage += bytesNeededOnGPU(warp_max_qry_len, min_match_length);\n                        curr_warp_padding += warp_max_qry_len;\n#else\n                        curr_mem_usage += bytesNeededOnGPU(this_qrylen, min_match_length);\n#endif\n                    }\n                }\n                \n                if (offsetspos == offsetssize)\n                {\n                    offsetssize *= 2;\n                    offsets = (int *) realloc(offsets, sizeof(int) * offsetssize);\n                    lengths = (int *) realloc(lengths, sizeof(int) * offsetssize);\n                    if (!offsets || !lengths)\n                    {\n                        cerr << endl\n                        << ""ERROR: Realloc failed: requested ""\n                        << sizeof(int) * offsetssize << endl;\n                        exit(1);\n                    }\n                }\n                \n                offsets[offsetspos++] = qstringpos;\n#if COALESCED_QUERIES\n                if ((offsetspos % WARP_SIZE) == 0)\n                {\n                    warp_max_qry_len = 2;\n                }\n#endif\n                inheader = true;\n                \n                // Try to walk out of header\n                for (i++; i < bytes_read; i++)\n                {\n                    if (buf[i] == '\n')\n                    {\n                        inheader = false;\n                        char* name = strdup(header.c_str());\n                        names.push_back(name);\n                        header.clear();\n                        break;\n                    }\n                    else\n                    {\n                        header.insert(header.end(), buf[i]);\n                    }\n                }\n                \n                addChar(&qstring, &qstringsize, &qstringpos, 'q');\n                this_qrylen = 0;\n            }\n            else if (dnachar[b])\n            {\n                addChar(&qstring, &qstringsize, &qstringpos, b);\n                qrylen++;\n                this_qrylen++;\n            }\n            else if (isspace(b))\n            {\n            \n            }\n            else if (resetAmbiguity)\n            {\n                addChar(&qstring, &qstringsize, &qstringpos, 'x');\n                this_qrylen++;\n            }\n            else\n            {\n                cerr << endl\n                << ""ERROR: Unexpected character: "" << buf[i]\n                << "" in query file at byte: "" << total_read + i << endl;\n                exit(1);\n            }\n        }\n        \n        if (set_full)\n            break;\n            \n        total_read += bytes_read;\n    }\n    \n    if (qstringpos)\n    {\n        if (this_qrylen < min_match_length)\n        {\n            //printf(""> %s\n"", names.back());\n            //if (rc)\n            //    printf(""> %s Reverse\n"", names.back());\n            names.pop_back();\n            --offsetspos;\n            qstringpos -= this_qrylen + 1;\n        }\n        else\n        {\n            addChar(&qstring, &qstringsize, &qstringpos, '\0');\n            lengths[offsetspos - 1] = this_qrylen;\n#if COALESCED_QUERIES\n            int num_warp_queries = (offsetspos - 1) % WARP_SIZE;\n            if (warp_max_qry_len < this_qrylen + 2)\n            {\n            \n            \n                curr_warp_padding -= num_warp_queries * warp_max_qry_len;\n                curr_mem_usage -= num_warp_queries * warp_max_qry_len;\n                \n                warp_max_qry_len = this_qrylen  + 2;\n                if (warp_max_qry_len % 4)\n                    warp_max_qry_len += 4 - (warp_max_qry_len % 4);\n                    \n                curr_warp_padding += num_warp_queries * warp_max_qry_len;\n                curr_mem_usage += num_warp_queries * warp_max_qry_len;\n            }\n            curr_mem_usage += bytesNeededOnGPU(warp_max_qry_len, min_match_length);\n            curr_warp_padding += warp_max_qry_len;\n            \n            if ((++num_warp_queries) % WARP_SIZE)\n            {\n                curr_warp_padding += warp_max_qry_len * (WARP_SIZE - (num_warp_queries % WARP_SIZE));\n            }\n#else\n            curr_mem_usage += bytesNeededOnGPU(this_qrylen, min_match_length);\n#endif\n            \n        }\n    }\n    \n    *numQueries = offsetspos;\n    \n    if (offsetspos == 0)\n    {\n        free(offsets);\n        free(lengths);\n        free(qstring);\n        *queryAddrs = NULL;\n        *queryTexture = NULL;\n        *queryTextureSize = 0;\n        *queryNames = NULL;\n        \n        return;\n    }\n    \n    \n    *queryAddrs = offsets;\n    \n    *queryTexture = qstring;\n    *queryTextureSize = qstringpos;\n    *queryNames = (char**)malloc(names.size() * sizeof(char*));\n    *queryLengths = lengths;\n    \n    for (unsigned int i = 0; i < *numQueries; ++i)\n    {\n        *(*queryNames + i) = names[i];\n    }\n    \n    \n#if COALESCED_QUERIES\n    EventTime_t reorder_timer;\n    unsigned int total_reordered_qry_size = 0;\n    vector<pair<int*, int> > reordered_query_chunks;\n    \n    \n    for (unsigned int i = 0; i < *numQueries; i += WARP_SIZE)\n    {\n        int max_qry_len = 0;\n        for (unsigned int j = 0; j < WARP_SIZE && (i + j) < *numQueries; ++j)\n        {\n            if ( max_qry_len < lengths[i + j] )\n                max_qry_len = lengths[i + j];\n        }\n        if (max_qry_len == 0)\n        {\n            int a = 0;\n        }\n        max_qry_len += 2;\n        unsigned int block_size = WARP_SIZE * (max_qry_len + ((max_qry_len % 4) ? 4 - (max_qry_len % 4) : 0));\n        int* reordered_query_chars = (int*)calloc(block_size / sizeof(int), sizeof(int));\n        //fprintf (stderr, ""reordering block for warp %d\n"", i / WARP_SIZE);\n        \n        for (int curr_char = 0; curr_char < max_qry_len; ++curr_char)\n        {\n            for (unsigned int curr_qry = 0; curr_qry < WARP_SIZE && (i + curr_qry) < *numQueries; ++curr_qry)\n            {\n                int qlen = lengths[i + curr_qry] + 2;\n                if (curr_qry == 16 && curr_char == 0)\n                {\n                    int a = 0;\n                }\n                if (curr_char < qlen)\n                {\n                    int* qry_word = reordered_query_chars + ((curr_char / 4) * WARP_SIZE + curr_qry);\n                    int c = *(qstring + offsets[i + curr_qry] + curr_char);\n                    //*((char*) ((void*)qry_word + (curr_char & 0x0000000f) = c;\n                    //*qry_word |= c << ((curr_char & 0x0000000f) << (3 - (curr_char & 0x0000000f)));\n                    *qry_word |= (c << (8 * ( (curr_char % 4))));\n                    //fprintf(stderr, ""writing (%d, %d, %d)\n"",i, curr_qry, curr_char);\n                }\n            }\n        }\n        total_reordered_qry_size += block_size;\n        \n        reordered_query_chunks.push_back(make_pair<int*, int>(reordered_query_chars, block_size));\n    }\n    \n    free(*queryTexture);\n    *queryTexture = (char*)malloc( total_reordered_qry_size );\n    *queryTextureSize = total_reordered_qry_size;\n    unsigned int p = 0;\n    *num_match_coords = 0;\n    for (unsigned int i = 0; i < reordered_query_chunks.size(); ++i)\n    {\n        for (unsigned int j = 0; j < WARP_SIZE && (i*WARP_SIZE + j) < *numQueries; ++j)\n        {\n            int qryid = i * WARP_SIZE + j;\n            offsets[qryid] = (p / 4) + j;\n        }\n        //*num_match_coords += reordered_query_chunks[i].second - WARP_SIZE * (min_match_length + 1);\n        memcpy(*queryTexture + p, reordered_query_chunks[i].first, reordered_query_chunks[i].second);\n        p += reordered_query_chunks[i].second;\n        \n    }\n    cerr <<  ""Reordering complete. "" << reorder_timer.str(true, 5) << endl;\n    fprintf(stderr, "" curr_warp_padding = %d, total_reordered = %d\n"", curr_warp_padding, total_reordered_qry_size);\n    //assert (curr_warp_padding == total_reordered_qry_size);\n    curr_mem_usage = total_reordered_qry_size;\n#else\n    \n    *num_match_coords = *queryTextureSize - *numQueries * (min_match_length + 1);\n#endif\n	assert (curr_mem_usage < memory_avail);\n    cerr << offsetspos << "" queries (""\n    << qrylen << "" bp), need ""\n    << curr_mem_usage << "" bytes on the GPU (""\n    << memory_avail << "" avail) ""\n    << timer.str(true, 5) << endl;\n}\n\n\n\nstruct pathblock\n{\n    TextureAddress node_addr;\n    int string_depth;\n};\n\n\n#define __USE_BUFFERED_IO__ \n\nstatic const size_t output_buf_limit = 32*1024;\nchar output_buf[output_buf_limit];\n\n//FIXME: needs to be reinitialized to zero at the beginning of each round of printing.\nsize_t bytes_written = 0;\n\nint addToBuffer(char* string)\n{\n	 size_t buf_length = strlen(string);\n	 \n	 if (buf_length + bytes_written>= output_buf_limit)\n	 {\n		size_t chunk = (output_buf_limit - bytes_written - 1);\n		strncpy(output_buf + bytes_written, string, chunk);\n		output_buf[bytes_written + chunk] = 0;\n		printf(""%s"", output_buf);\n		//memset(output_buf, 0, sizeof(output_buf));\n		strncpy(output_buf, string + chunk, buf_length - chunk);\n		bytes_written = buf_length - chunk;\n	 }\n	 else\n	 {\n		strncpy(output_buf + bytes_written, string, buf_length);\n		bytes_written += buf_length;\n	 }\n   return 0;\n}\n\nvoid flushOutput()\n{\n   if (bytes_written)\n   {\n	  output_buf[bytes_written] = 0;\n	  printf(""%s"", output_buf);\n	  bytes_written  = 0;\n   }\n	//memset(output_buf, 0, sizeof(output_buf));\n   //cerr << ""expectedvisit: "" << expectedvisit << endl;\n   //cerr << ""leavesvisited: "" << leavesvisited << endl;\n   //cerr << ""leavesprinted: "" << leavesprinted << endl;\n}\n\ninline char *itoa(int i, char *a)\n{\n	char b[24];\n	char* c = b;\n	while (i / 10 > 0)\n	{\n		*c = ""0123456789""[i % 10];\n		++c;\n		i /= 10;\n	}\n	\n	*c = ""0123456789""[i % 10];\n	++c;\n	\n	while (c > b) {--c; *a = *c; ++a;}\n	return a;\n}\n\nint addMatchToBuffer(int left_in_ref, int qrypos, int matchlen)\n{\n	// The ridiculous second term here comes from the maximum number of \n	// characters one might need to express a match to a reference that is \n	// no more than 10 billion bases long, using a MAX_QUERY_LENGTH of 8192,\n	// plus whitespace\n	if (bytes_written >= output_buf_limit - (12 + 4 + 4 + 4))\n	{\n		flushOutput();\n	}\n	\n	char* p_buf = output_buf + bytes_written;	\n	p_buf = itoa(left_in_ref, p_buf);\n	*p_buf = '\t';\n	++p_buf;\n	p_buf = itoa(qrypos,p_buf);\n	*p_buf = '\t';\n	++p_buf;\n	p_buf = itoa(matchlen,p_buf);\n	*p_buf = '\n';\n	++p_buf;\n	bytes_written +=  p_buf - (output_buf + bytes_written);\n}\n\n#define NODE_LENGTH(x)      (page->ref.aux_data[x].length)\n#define NODE_PRINTPARENT(x) (page->ref.aux_data[x].printParent)\n#define NODE_NUMLEAVES(x)   (page->ref.aux_data[x].numleaves)\n\n#if REORDER_TREE\n#define GETNODE(node_addr)     (((PixelOfNode*)    (page->ref.h_node_tex_array))     + (node_addr.x) + (node_addr.y * MAX_TEXTURE_DIMENSION))\n#define GETCHILDREN(node_addr) (((PixelOfChildren*)(page->ref.h_children_tex_array)) + (node_addr.x) + (node_addr.y * MAX_TEXTURE_DIMENSION))\n#define PADDR(node_addr)        node_addr.x << "","" << node_addr.y\n#else\n#define GETCHILDREN(node_addr) (((PixelOfChildren*)(page->ref.h_children_tex_array)) + (node_addr.x))\n#define GETNODE(node_addr)     (((PixelOfNode*)    (page->ref.h_node_tex_array))     + (node_addr.x))\n#define PADDR(node_addr)       node_addr.x\n#endif\n\n#if MERGETEX\n\nchar * getMerged(const ReferencePage * page, TextureAddress cur, int getChildrenData)\n{\n#if !REORDER_TREE\n  bool useChildrenForData = false;\n\n  cur.x *= 2;\n  if (cur.x >= (MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION))\n  {\n    useChildrenForData = true;\n    cur.x -= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION;\n  }\n#else\n  bool useChildrenForData = cur.x & 0x800;\n  cur.x &= 0x7FF;\n  cur.x *= 2;\n#endif\n\n  cur.x += getChildrenData;\n\n  if (useChildrenForData)\n  {\n    return (char *) GETCHILDREN(cur);\n  }\n  else\n  {\n    return (char *) GETNODE(cur);\n  }\n}\n\n#define SDEPTH(node_addr)   (((PixelOfNode*)    getMerged(page, node_addr, 0))->depth)\n#define PARENT(node_addr)   (((PixelOfNode*)    getMerged(page, node_addr, 0))->parent)\n\n#define LEAFCHAR(node_addr) (((PixelOfChildren*)getMerged(page, node_addr, 1))->leafchar)\n#define LEAFID(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->leafid)\n#define CHILDA(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->a)\n#define CHILDC(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->c)\n#define CHILDG(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->g)\n#define CHILDT(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->t)\n#define CHILDD(node_addr)   (((PixelOfChildren*)getMerged(page, node_addr, 1))->d)\n\n#else // !MERGETEX\n\n#define SDEPTH(node_addr)   (GETNODE(node_addr)->depth)\n#define PARENT(node_addr)   (GETNODE(node_addr)->parent)\n\n#define LEAFCHAR(node_addr) (GETCHILDREN(node_addr)->leafchar)\n#define LEAFID(node_addr)   (GETCHILDREN(node_addr)->leafid)\n#define CHILDA(node_addr)   (GETCHILDREN(node_addr)->a)\n#define CHILDC(node_addr)   (GETCHILDREN(node_addr)->c)\n#define CHILDG(node_addr)   (GETCHILDREN(node_addr)->g)\n#define CHILDT(node_addr)   (GETCHILDREN(node_addr)->t)\n#define CHILDD(node_addr)   (GETCHILDREN(node_addr)->d)\n\n#endif // MERGETEX\n\n\n\nchar buf[256];\n\nvoid printNodeAlignments(const ReferencePage* page,\n						 const char queryflankingbase, \n						 const TextureAddress node,\n						 const int qrypos, \n						 int qrylen,\n						 const pathblock path[],\n						 int path_idx,\n                         bool rc)\n{\n  char isLeaf = LEAFCHAR(node); \n\n  if (path[path_idx].node_addr.data == node.data)\n  {\n	 qrylen = path[path_idx].string_depth;\n	 path_idx--;  \n  }\n  \n  if (isLeaf)\n  {\n     if (isLeaf != queryflankingbase)\n     {\n       int leafid = MK3(LEAFID(node));\n       int left_in_ref = (leafid - 1) + page->begin; \n       int right_in_ref = left_in_ref + qrylen;\n\n       if ((left_in_ref != page->begin || page->shadow_left == -1) && \n           (right_in_ref != page->end || page->shadow_right == -1))\n       {\n		 if (!(left_in_ref > page->begin && right_in_ref < page->shadow_left))\n		 {\n		   sprintf(buf, ""\t%d\t%d\t%d\n"", left_in_ref, qrypos, qrylen);\n		   //sprintf(buf, ""%8d%10d%10d\n"", left_in_ref, qrypos, qrylen);\n		   addToBuffer(buf);\n		 }\n	   }\n	 }\n  }\n  else\n  {\n    TextureAddress child;\n\n    child = arrayToAddress(CHILDA(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDC(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDG(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDT(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n    child = arrayToAddress(CHILDD(node));\n    if (child.data) { printNodeAlignments(page, queryflankingbase, child, qrypos, \n                                          qrylen, path, path_idx, rc); }\n\n  }\n}\n\nint expectedvisit = 0;\nint leavesvisited = 0;\nint leavesprinted = 0;\n\n\n//FIXME: hardcoded path buffer, needs to be as long as the longest query in the query set.\npathblock path[8192];\n\nchar RC(char c)\n{\n  switch(c)\n  {\n    case 'A': return 'T';\n    case 'C': return 'G';\n    case 'G': return 'C';\n    case 'T': return 'A';\n    case 'q': return '\0';\n    default:  return c;\n  };\n}\n\n\n\nvoid printAlignmentsOld( ReferencePage* page,\n					 char* query, \n                     int qrylen,\n					 int nodeid, \n					 int qrypos, \n					 int edge_match, \n					 int min_match,\n                     bool rc,\n                     bool forwardcoordinates)\n{\n   TextureAddress node_addr = id2addr(nodeid);\n   TextureAddress prev;\n   prev.data = 0; \n  \n   int path_idx = 0;\n   int string_depth = MK3(SDEPTH(node_addr)) - 1;\n\n   if (edge_match > 0)\n   {\n     string_depth = MK3(SDEPTH(node_addr)) - (NODE_LENGTH(nodeid) - edge_match) - 1;\n   }\n   else\n   {\n     edge_match = NODE_LENGTH(nodeid);\n   }\n\n   path[path_idx].node_addr = node_addr;\n   path[path_idx].string_depth = string_depth;\n   path_idx++;\n   string_depth -= edge_match;\n   prev = node_addr;\n\n   node_addr = arrayToAddress(PARENT(node_addr));\n   \n   while ((node_addr.data) && string_depth >= min_match)\n   {\n	  nodeid = addr2id(node_addr);\n	  path[path_idx].node_addr = node_addr;\n	  path[path_idx].string_depth = string_depth;\n	  path_idx++;	\n	  string_depth -= NODE_LENGTH(nodeid);	  \n	  \n	  prev = node_addr;\n	  node_addr = arrayToAddress(PARENT(node_addr));\n   }\n   \n   char flankingbase = query[qrypos];\n\n   if (rc)\n   {\n     flankingbase = RC(query[strlen(query)-qrypos]);\n     if (forwardcoordinates) { qrypos = qrylen - 1 - qrypos; }\n   }\n\n   printNodeAlignments(page, flankingbase, prev, qrypos + 1, \n   				       MK3(SDEPTH(prev)), path, path_idx - 1, rc);\n}\n\ninline char getQueryChar(char* query, int position)\n{\n#if COALESCED_QUERIES\n	int shift = 8 * (position % 4);\n    int mask = (0xFF) << shift;\n    int c_word = ((int*)query)[(position >> 2) * WARP_SIZE];\n//	XPRINTF(""c_word = %x, mask = %x\n"", c_word, mask);\n	return (c_word & mask) >> shift;\n#else\n	return *(query + position);\n#endif	\n}\n\n// Stackless printing\nvoid printAlignments(ReferencePage* page,\n					 Alignment* h_alignments,\n                     char* query,\n                     int qrylen,\n                     TextureAddress matchNodeAddr,\n                     int qrystartpos,\n                     int edge_match,\n                     int min_match,\n                     bool rc,\n                     bool forwardcoordinates) \n{\n  char queryflankingbase = getQueryChar(query, qrystartpos);\n	Alignment* alignments = h_alignments;  \n  if (rc) \n  {\n    queryflankingbase = RC(query[strlen(query)-qrystartpos]);\n    if (forwardcoordinates) { qrystartpos = qrylen - 1 - qrystartpos; }\n  }\n    \n  // Find the top node to start printing from\n  TextureAddress cur = matchNodeAddr;\n  TextureAddress printParent = cur;\n	unsigned int matchNodeId = addr2id(matchNodeAddr);\n  int verbose = 0;\n    \n  if (verbose)\n  {\n    cout << ""query: "" << query << endl;\n    cout << ""starting node: "" << PADDR(cur)\n         << "" depth: "" << MK3(SDEPTH(cur)) << endl;\n  }\n\n  while (MK3(SDEPTH(cur)) > min_match)\n  {\n    printParent = cur;\n    cur = arrayToAddress(PARENT(cur));\n\n    if (verbose)\n    {\n      cout << ""par: "" << PADDR(cur)\n           << "" depth: "" << MK3(SDEPTH(cur)) << endl;\n    }\n  }\n\n  if (printParent.data != NODE_PRINTPARENT(matchNodeId).data)\n  {\n    TextureAddress other;\n    other.data = NODE_PRINTPARENT(matchNodeId).data;\n    \n    cout << ""printParent (""          << PADDR(printParent) << ""):"" << MK3(SDEPTH(printParent)) \n         << "" != NODE_PRINTPARENT ("" << PADDR(other)       << ""):"" << MK3(SDEPTH(other)) \n         << endl;\n        exit(1);\n  }\n    \n  if (verbose)\n  {\n    cout << ""printParent: "" << PADDR(printParent) << endl;\n  }\n    \n  expectedvisit += NODE_NUMLEAVES(addr2id(printParent));\n    \n  // traverse the tree starting at printParent\n  TextureAddress badParent = cur;\n  cur = printParent;\n    \n  char curchild = 'A';\n  bool forceToParent = false;\n    \n  int printParentId = addr2id(printParent);\n  int matchlen = MK3(SDEPTH(printParent))-1;\n  int depthToGoldenPath = 0;\n    \n    \n  // If the printparent is the matchnode, then we are already off the golden path\n  if (printParentId == matchNodeId)\n  {\n    if (edge_match > 0)\n    {\n      matchlen = MK3(SDEPTH(badParent)) - 1 + edge_match;\n    }\n        \n    depthToGoldenPath = 1;\n  }\n    \n  // keep going until I hit the printParent's parent\n  while (cur.data != badParent.data)\n  {\n    if (verbose)\n    {\n      cout << "" cur: "" << PADDR(cur)\n           << "" curchild: "" << curchild << endl;\n    }\n\n    char isLeaf = LEAFCHAR(cur);\n        \n    if (isLeaf || forceToParent)\n    {\n      // See if I am left maximal and print\n      if (isLeaf)\n      {\n        leavesvisited++;\n                \n        if (isLeaf != queryflankingbase)\n        {\n          int leafid = MK3(LEAFID(cur));\n          int left_in_ref = (leafid - 1) + page->begin;\n          int right_in_ref = left_in_ref + matchlen;\n                    \n          if ((left_in_ref != page->begin || page->shadow_left == -1) &&\n              (right_in_ref != page->end || page->shadow_right == -1))\n          {\n            if (!(left_in_ref > page->begin && right_in_ref < page->shadow_left))\n            {\n              leavesprinted++;\n	            alignments->left_in_ref = left_in_ref;\n	            alignments->matchlen = matchlen;\n	            ++alignments;\n\n              if (verbose)\n              {\n                fprintf(stderr, ""%8d%10d%10d\n"", left_in_ref, qrystartpos+1, matchlen);\n              }\n            }\n          }\n        }\n      }\n            \n      forceToParent = false;\n            \n      // now return to my parent and advance curchild\n      TextureAddress myParent = arrayToAddress(PARENT(cur));\n\n      if      (cur.data == arrayToAddress(CHILDA(myParent)).data) { curchild = 'C'; }\n      else if (cur.data == arrayToAddress(CHILDC(myParent)).data) { curchild = 'G'; }\n      else if (cur.data == arrayToAddress(CHILDG(myParent)).data) { curchild = 'T'; }\n      else if (cur.data == arrayToAddress(CHILDT(myParent)).data) { curchild = '$'; }\n      else  // I must be the $ child, go up a level\n      {\n                forceToParent = true;\n      }\n            \n      cur = myParent;\n            \n      if (depthToGoldenPath) { depthToGoldenPath--; }\n            \n      if (depthToGoldenPath == 0)\n      {\n        matchlen = MK3(SDEPTH(cur)) - 1;\n      }\n    }\n    else\n    {\n      // try to walk down the tree\n            \n      char goldenChild = 0;\n            \n      if (depthToGoldenPath == 0)\n      {\n        // we are currently on the golden path\n        // one of the children is also on the golden path\n        goldenChild = query[qrystartpos+matchlen+1];\n      }\n            \n      do\n      {\n        TextureAddress a;\n        if (curchild == 'A')\n        {\n          a = arrayToAddress(CHILDA(cur));\n          if (a.data) { cur = a; break; }\n          curchild = 'C';\n        }\n                \n        if (curchild == 'C')\n        {\n          a = arrayToAddress(CHILDC(cur));\n          if (a.data) { cur = a; break; }\n          curchild = 'G';\n        }\n                \n        if (curchild == 'G')\n        {\n          a = arrayToAddress(CHILDG(cur));\n          if (a.data) { cur = a; break; }\n          curchild = 'T';\n        }\n                \n        if (curchild == 'T')\n        {\n          a = arrayToAddress(CHILDT(cur));\n          if (a.data) { cur = a; break; }\n          curchild = '$';\n        }\n                \n        if (curchild == '$')\n        {\n          a = arrayToAddress(CHILDD(cur));\n          if (a.data) { cur = a; break; }\n        }\n                \n        // checked all of the children, go back to parent\n        forceToParent = true;\n      }\n      while (0);\n            \n      if (!forceToParent)\n      {\n        if (depthToGoldenPath == 0)\n        {\n          if (curchild == goldenChild)\n          {\n            int cid = addr2id(cur);\n            matchlen = MK3(SDEPTH(cur))-1;\n                        \n            if (cid == matchNodeId)\n            {\n              // we overextended the golden path\n              depthToGoldenPath = 1;\n                            \n              if (edge_match > 0)\n              {\n                matchlen = MK3(SDEPTH(cur)) - (NODE_LENGTH(cid) - edge_match) - 1;\n              }\n            }\n          }\n          else\n          {\n            depthToGoldenPath = 1;\n          }\n        }\n        else\n        {\n          depthToGoldenPath++;\n        }\n                \n        curchild = 'A';\n      }\n    }\n  }\n}\n\nextern ""C""\nint lookupNumLeaves(ReferencePage * page, TextureAddress addr)\n{\n	unsigned int nodeid = addr2id(addr);\n  	TextureAddress printParent = NODE_PRINTPARENT(nodeid);\n	nodeid = addr2id(printParent);\n  	return NODE_NUMLEAVES(nodeid);\n}\n\n#if 0\nstruct ExactMatch\n{\n	ExactMatch(unsigned int lr, unsigned short qs, unsigned short ml) \n		: left_in_ref(lr), qrystartpos(qs), matchlen(ml) {}\n		\n	unsigned int left_in_ref;\n	unsigned short qrystartpos;\n	unsigned short matchlen;\n};\n\nstruct EMSortByRefPos\n{\n	bool operator()(const ExactMatch& lhs, const ExactMatch& rhs)\n	{\n		return lhs.left_in_ref < rhs.left_in_ref;\n	}\n};\n\nvoid align(const string & S, \n           const string & T,\n           int match_score,\n           int mismatch_score,\n           int gap_open,\n		int gap_extension);\n\nstatic const int MAX_MISMATCH = 4;\nvoid mapQueryEndToEnd(MatchContext* ctx, vector<ExactMatch>& ems, unsigned int qry)\n{\n	sort(ems.begin(), ems.end(), EMSortByRefPos());\n	vector<unsigned int> candidate_alignments;\n\n	unsigned int length = ctx->queries->h_lengths_array[qry];\n	unsigned int min_bases_covered = 2 * ctx->min_match_length;\n	if (string(*(ctx->queries->h_names + qry)) == ""rid754"")\n	{\n		int a = 5;\n	}\n	\n	for (int i = 0; i < (int)(ems.size() - 1); ++i)\n	{\n		if (candidate_alignments.size() && \n			(ems[i].left_in_ref - length > ems[candidate_alignments.back()].left_in_ref))\n			continue;\n		\n		unsigned int j = i;\n		unsigned int left_ref = ems[j].left_in_ref;\n		unsigned int right_ref = left_ref + ems[j].matchlen;\n\n		unsigned int leftmost_qrypos = ems[i].qrystartpos;\n		unsigned int rightmost_qrypos = leftmost_qrypos + ems[i].matchlen;\n		do {\n			if (rightmost_qrypos - leftmost_qrypos >= min_bases_covered)\n			{\n				candidate_alignments.push_back(i);\n				break;\n			}\n			++j;\n			right_ref = ems[j].left_in_ref + ems[j].matchlen;\n			unsigned int right_qpos = ems[j].qrystartpos + ems[j].matchlen;\n			if (right_qpos > rightmost_qrypos)\n				rightmost_qrypos = right_qpos;\n		} while(right_ref - left_ref < length && j < ems.size());\n	}\n	for(unsigned int i = 0; i < candidate_alignments.size(); ++i)\n	{\n		char refstr[2 * (MAX_QUERY_LEN + MAX_MISMATCH)];\n		memset(refstr, 0, sizeof(refstr));\n		ExactMatch& m = ems[candidate_alignments[i]];\n		strncpy(refstr, \n				ctx->ref->str + m.left_in_ref - m.qrystartpos - MAX_MISMATCH, \n				2 * (length + MAX_MISMATCH));\n		char* qrystr = ctx->queries->h_tex_array + ctx->queries->h_addrs_tex_array[qry];\n		align(string(refstr), string(qrystr), 10, -2, -2, -2);\n	}\n	// addToBuffer(""> "");\n	// addToBuffer(*(ctx->queries->h_names + qry));\n	// addToBuffer(""\n"");\n	// char buf[256];\n	// sprintf(buf, ""%d candidate matches\n"", candidate_alignments.size());\n	// addToBuffer(buf);\n	// for (int i = 0; i < (int)(ems.size() - 1); ++i)\n	// {	if (find(candidate_alignments.begin(), candidate_alignments.end(), i) != candidate_alignments.end())\n	// 	{\n	// 		sprintf(buf, ""%8d%10d%10d\t****\n"",\n	// 		       ems[i].left_in_ref,\n	// 		       ems[i].qrystartpos + 1,\n	// 		       ems[i].matchlen);\n	// \n	// 	}\n	// 	else\n	// 	{\n	// 		sprintf(buf, ""%8d%10d%10d\n"",\n	// 		       ems[i].left_in_ref,\n	// 		       ems[i].qrystartpos + 1,\n	// 		       ems[i].matchlen);\n	// 	}\n	// 	addToBuffer(buf);\n	//}\n	\n	//flushOutput();\n}\n\nextern ""C""\nvoid mapQueriesEndToEnd(MatchContext* ctx,\n                        ReferencePage* page,\n                        MatchInfo* h_matches,\n                        unsigned int numMatches,\n                        Alignment* h_alignments,\n                        unsigned int numAligments)\n{\n    int lastqry = -1;\n	vector<ExactMatch> ems;\n    for (int m = 0; m < numMatches; m++)\n    {\n        if (h_matches[m].queryid != lastqry)\n        {\n			if (lastqry != -1)\n				mapQueryEndToEnd(ctx, ems, lastqry);\n			ems.clear();\n			\n            lastqry = h_matches[m].queryid;\n            // addToBuffer(""> "");\n            // addToBuffer(*(ctx->queries->h_names + lastqry));\n            // addToBuffer(""\n"");\n			if (string(*(ctx->queries->h_names + lastqry)) == ""rid754"")\n			{\n				int a = 5;\n			}\n        }\n        \n        int base = h_matches[m].resultsoffset;\n\n        for (int i = 0; i < h_matches[m].numLeaves; i++)\n        {\n            // See if there are any more left maximal alignments for this match\n            if (h_alignments[base+i].left_in_ref == 0)\n            {\n                break;\n            }\n            ems.push_back(ExactMatch(h_alignments[base+i].left_in_ref,\n            					     h_matches[m].qrystartpos + 1,\n									 h_alignments[base+i].matchlen));\n			\n        }\n    }\n}\n#endif\n"
mummergpu/src/mummergpu_gold.cpp,"#include <stdio.h>\n#include <string.h>\n\n#include <fstream>\n\n#define ulong4 uint32_t\n#define int2 int32_t\n#define uint4 uint32_t\n\n#include ""omp.h""\n#include ""mummergpu.h""\n// Matches are reported as a node in the suffix tree,\n// plus a distance up the node's parent link for partial\n// matches on the patch from the root to the node\n\n#define OMP\n#define N_THREADS 8\n\n\nstatic const int maxdim = 4096;\n\n#define __VERBOSE___no \n\n#ifdef __VERBOSE__\n#define XPRINTF(...)  printf(__VA_ARGS__)\n#else\n#define XPRINTF(...)  do{}while(0)\n#endif\n\n#define WARP_SIZE 16\n\n#if REORDER_TREE            \n#define fNID ""%d,%d""\n#define NID(addr) (addr & 0x0000FFFF), ((addr & 0xFFFF0000)>>16)\n#define GOROOT(addr) addr = 0x00010000\n//#define GOROOT(addr) addr.x = 0; addr.y = 1\n#else\n#define fNID ""%d""\n#define NID(addr) addr\n#define GOROOT(addr) addr = 1\n#endif\n\n\n#define GETQCHAR(qrypos) queries[qrypos]\n#define RESULT_SPAN 1\n#define MATCH_BASE(match_coords, qryid) (MatchCoord*)match_coords + qryAddr - (qryid * (min_match_len + 1))\n\n#define GETRCHAR(refpos) getRef(refpos, ref)\n\n\n\n#if MERGETEX\n\n#if TREE_ACCESS_HISTOGRAM\n#define GETNODE(addr, two_level)         getMerged(nodes, childrenarr, addr,  0, NULL, NULL).node\n#define GETNODEHIST(addr, two_level)     getMerged(nodes, childrenarr, addr,  0, node_hist, child_hist).node\n#define GETCHILDREN(addr, two_level)     getMerged(nodes, childrenarr, addr,  1, NULL, NULL).children\n#define GETCHILDRENHIST(addr, two_level) getMerged(nodes, childrenarr, addr,  1, node_hist, child_hist).children\n#else\n#define GETNODE(addr, two_level)         getMerged(nodes, childrenarr, addr,  0).node\n#define GETNODEHIST(addr, two_level)     getMerged(nodes, childrenarr, addr,  0).node\n#define GETCHILDREN(addr, two_level)     getMerged(nodes, childrenarr, addr,  1).children\n#define GETCHILDRENHIST(addr, two_level) getMerged(nodes, childrenarr, addr,  1).children\n#endif\n\n#else\n\n#if TREE_ACCESS_HISTOGRAM\n#define GETNODEHIST(addr, two_level)    getNode(addr,  nodes, node_hist)\n#define GETNODE(addr, two_level)        getNode(addr,  nodes, NULL)\n#else\n#define GETNODEHIST(addr, two_level)    getNode(addr,  nodes)\n#define GETNODE(addr, two_level)        getNode(addr,  nodes)\n#endif\n\n\n#if TREE_ACCESS_HISTOGRAM\n#define GETCHILDRENHIST(addr, two_level)    getChildren(addr,  childrenarr, child_hist) \n#define GETCHILDREN(addr, two_level)        getChildren(addr,  childrenarr, NULL)\n#else\n#define GETCHILDRENHIST(addr, two_level)    getChildren(addr,  childrenarr)\n#define GETCHILDREN(addr, two_level)        getChildren(addr,  childrenarr)\n#endif\n\n#endif\n\n#define SHIFT_QUERIES(queries, qryAddr) queries += qryAddr\n#define SET_RESULT(c, r, e, q, m, rc) set_result(c, r, e, q, m, rc)\n//////////////////////////////////\n/// getRef\n//////////////////////////////////\n\nchar getRef(int refpos, char* ref)\n{\n	return ref[refpos];\n}\n\n\nunion SingleNode\n{\n	PixelOfNode node;\n	PixelOfChildren children;\n};\n\n\n//////////////////////////////////\n/// getNode\n//////////////////////////////////\n\nPixelOfNode getNode(unsigned int cur,  PixelOfNode* nodes\n#if TREE_ACCESS_HISTOGRAM\n               , int* node_hist\n#endif\n               ) \n{\n#if TREE_ACCESS_HISTOGRAM\n  int id = addr2id(cur);\n  if (node_hist) { node_hist[id]++; }\n#endif\n\n#if REORDER_TREE\n  return *(nodes + (cur & 0x0000FFFF) + (((cur & 0xFFFF0000)>>16) * MAX_TEXTURE_DIMENSION));\n#else\n  return *(nodes + cur);\n#endif\n}\n\n//////////////////////////////////\n/// getChildren\n//////////////////////////////////\n\nPixelOfChildren getChildren(unsigned int cur, PixelOfChildren* childrenarr\n#if TREE_ACCESS_HISTOGRAM\n                   , int* child_hist\n#endif\n                   )\n{\n#if TREE_ACCESS_HISTOGRAM\n  int id = addr2id(cur);\n  if (child_hist) { child_hist[id]++; }\n#endif\n\n#if REORDER_TREE\n  return *(childrenarr +  (cur & 0x0000FFFF) + (((cur & 0xFFFF0000)>>16) * MAX_TEXTURE_DIMENSION));\n#else\n  return *(childrenarr + cur);\n#endif\n}\n\n#if MERGETEX\n\n//////////////////////////////////\n/// getMerged\n//////////////////////////////////\n\nSingleNode getMerged(PixelOfNode * nodes,\n                 PixelOfChildren * childrenarr,\n                 unsigned int cur, \n                 int   getChildrenData\n#if TREE_ACCESS_HISTOGRAM\n               , int* node_hist\n               , int* child_hist\n#endif\n                            )\n{\n	SingleNode n;\n//	TextureAddress cur = _cur;\n#if !REORDER_TREE\n  //cur.x *= 2;\n	unsigned int x = cur * 2;\n  int useChildrenForData = 0;\n\n  if (x >= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION)\n  {\n    x -= MAX_TEXTURE_DIMENSION*MAX_TEXTURE_DIMENSION;\n    useChildrenForData = 1;\n  }\n\n#else\n	unsigned short x = cur & 0x0000FFFF;\n	unsigned short y = (cur & 0xFFFF0000) >> 16;\n  int useChildrenForData = 0; \n\n  // WARNING INSANE HACK TO WORK AROUND NVCC BUG\n\n  goto TEST;\n  MASK:\n\n  x &= 0x7FF;\n  x *= 2;\n\n  goto INC;\n  TEST:\n\n  if (x >= 2048)\n  {\n    useChildrenForData = 1;\n  }\n\n  goto MASK;\n  INC:\n\n#endif\n\n  x += getChildrenData;\n\n#if !REORDER_TREE\n	cur = x;\n#else\n	cur = (y << 16) | x;\n#endif\n\n	  if (useChildrenForData)\n	  {\n	    n.children = getChildren(cur, childrenarr\n	#if TREE_ACCESS_HISTOGRAM\n	                       , child_hist\n	#endif\n	                       );\n	  }\n	  else\n	  {\n	    n.node =  getNode(cur, nodes\n	#if TREE_ACCESS_HISTOGRAM\n	                   , node_hist\n	#endif\n	                   );\n	  }\n	return n;\n}\n\n#endif\n\n\n//////////////////////////////////\n/// set_result\n//////////////////////////////////\n\nvoid set_result(unsigned int cur,\n					   MatchCoord* result, \n					   int edge_match_length,\n                       int qry_match_len,\n                       int min_match_len,\n                       int rc\n                       )\n{\n  if (qry_match_len > min_match_len)\n  {\n    edge_match_length |= rc;\n	result->node.data = cur;\n	result->edge_match_length = edge_match_length;\n  }\n  else\n  {\n    XPRINTF(""  match too short (%d < %d)\n"", qry_match_len, min_match_len);\n  }\n}\n\nvoid arrayToAddress(unsigned char arr[3], unsigned int& addr)\n{\n#if REORDER_TREE\n  addr = (arr[0] | ((arr[2] & 0xF) << 8)) | ((arr[1] | ((arr[2] & 0xF0) << 4)) << 16); \n#else\n  addr = MK3(arr);\n#endif\n}\n\ntemplate<typename T>\ninline T min(T x, T y)\n{\n	return x < y ? x : y;\n}\n\ntemplate<typename T>\ninline T max(T x, T y)\n{\n	return x < y ? y : x;\n}\n\nint kernel_gold(int qryid,\n				MatchResults* results, 		\n				char* queries,\n                PixelOfNode* nodes,\n                PixelOfChildren* childrenarr,\n                char* ref,\n                const int* queryAddrs,\n                const int* queryLengths,\n                const int numQueries,\n                const int min_match_len\n#if TREE_ACCESS_HISTOGRAM\n				,int* node_hist,\n				int* child_hist\n#endif\n				)\n{\n	    if (qryid >= numQueries) { return 0; }\n	    XPRINTF(""> qryid: %d\n"", qryid);\n\n	    int qlen = queryLengths[qryid];\n	    int qryAddr = queryAddrs[qryid];\n \n		unsigned int cur = 0;\n\n	    int mustmatch = 0;\n	    int qry_match_len = 0;\n		MatchCoord* match_coords = results->h_match_coords;\n	    MatchCoord * result = MATCH_BASE(match_coords, qryid);\n\n	    SHIFT_QUERIES(queries, qryAddr);\n\n	    int last = qlen - min_match_len;\n	    for (int qrystart = 0;\n	             qrystart <= last;\n	             qrystart++, \n	             result += RESULT_SPAN) \n	    {\n			//PixelOfNode node;\n			unsigned int node_start;\n	        unsigned int prev;\n\n	        if ((cur == 0) || (qry_match_len < 1)) \n	        {\n	            // start at root of tree\n	            GOROOT(cur);\n	            qry_match_len = 1;\n	            mustmatch = 0;\n	        }\n\n	        char c = GETQCHAR(qrystart + qry_match_len);\n\n	        XPRINTF(""In node (""fNID""): starting with %c [%d] =>  \n"",\n	                NID(cur), c, qry_match_len);\n\n	        unsigned int refpos = 0;\n	        while ((c != '\0')) \n	        {\n	            XPRINTF(""Next edge to follow: %c (%d)\n"", c, qry_match_len);\n\n				PixelOfChildren children;\n	            children = GETCHILDRENHIST(cur, false);\n				prev = cur;\n\n				switch (c) \n	            {\n					case 'A': arrayToAddress(children.a,cur); break;\n	                case 'C': arrayToAddress(children.c,cur); break;\n	                case 'G': arrayToAddress(children.g,cur); break;\n	                case 'T': arrayToAddress(children.t,cur); break;\n					default: cur = 0; break;\n	            };\n\n				//arrayToAddress(next, cur);\n\n	            XPRINTF("" In node: (""fNID"")\n"", NID(cur));\n\n	            // No edge to follow out of the node\n	            if (cur == 0) {\n	                XPRINTF("" no edge\n"");\n	                SET_RESULT(prev, result, 0, qry_match_len, min_match_len, FORWARD);\n\n	                qry_match_len -= 1;\n	                mustmatch = 0;\n\n	                goto NEXT_SUBSTRING;\n	            }\n\n				PixelOfNode node;\n				node = GETNODEHIST(cur, true);\n				node_start = MK3(node.start);\n				unsigned int node_end = MK3(node.end);\n\n	            XPRINTF("" Edge coordinates: %d - %d\n"", node_start, node_end);\n	            {\n	                int edgelen = node_end - node_start + 1;\n	                int edge_matchlen = node_start + mustmatch;\n	                int past_node_end = node_end + 1;\n	                int dist_to_edge_end = mustmatch - edgelen;\n	                if (mustmatch) {\n	                    refpos = min(edge_matchlen, past_node_end);\n	                    qry_match_len += min(edgelen, mustmatch);\n	                    mustmatch = max(dist_to_edge_end, 0);\n	                }\n	                else {\n	                    // Try to walk the edge, the first char definitely matches\n	                    qry_match_len++;\n	                    refpos = node_start + 1;\n	                }\n	            }\n\n	            c = GETQCHAR(qrystart + qry_match_len);\n\n	            while (refpos <= node_end && c != '\0') \n	            {\n	                char r = GETRCHAR(refpos);\n\n	                XPRINTF("" Edge cmp ref: %d %c, qry: %d %c\n"", refpos, r, qry_match_len, c);\n\n	                if (r != c) \n	                {\n	                    // mismatch on edge\n	                    XPRINTF(""mismatch on edge: %d, edge_pos: %d\n"", qry_match_len, refpos - (node_start));\n	                    goto RECORD_RESULT;\n	                }\n\n	                qry_match_len++;\n	                refpos++;\n\n	                c = GETQCHAR(qrystart + qry_match_len);\n	            }\n	        }\n\n	        XPRINTF(""end of string\n"");\n\n	RECORD_RESULT:\n			{\n				//PixelOfNode node;\n				//node.data = getnodehist(cur, false);\n		        SET_RESULT(cur, result, refpos - node_start, qry_match_len,\n		                   min_match_len, FORWARD);\n\n		        mustmatch = refpos - node_start;\n		        qry_match_len -= mustmatch + 1;\n	    	}\n	NEXT_SUBSTRING:\n			{\n				PixelOfNode node;\n				node = GETNODEHIST(prev, false);\n		        arrayToAddress(node.suffix, cur);\n			}\n	        //XPRINTF("" following suffix link. mustmatch:%d qry_match_len:%d sl:(""fNID"")\n"",\n	        //       mustmatch, qry_match_len, NID(cur));\n	        do {} while (0);\n	    }\n\n	    return 0;\n\n#if 0\n\n   XPRINTF(""> qryid: %d\n"", qryid);\n\n   int qlen = queryLengths[qryid];\n\n   // start at root for first query character\n   TextureAddress cur;\n   cur.data = 0;\n   int mustmatch = 0;\n   int qry_match_len = 0;\n\n   int qryAddr=queryAddrs[qryid];\n   MatchCoord * result = results->h_match_coords + qryAddr - (qryid * ( min_match_len + 1));\n   queries += qryAddr;\n\n   int last = qlen - min_match_len;\n   for (int qrystart = 0;\n       qrystart <= last;\n       qrystart++, result++, queries++)\n   {\n	  XPRINTF(""qry: %s\n"", queries + 1);\n\n	  PixelOfNode node;\n      TextureAddress prev;\n\n      if ((cur.data == 0) || (qry_match_len < 1))\n      {\n	    // start at root of tree\n	    cur.x = 0; cur.y = 1;\n	    qry_match_len = 1; \n        mustmatch = 0;\n      }\n\n	  char c = queries[qry_match_len];\n\n	  XPRINTF(""In node (%d,%d): starting with %c [%d] =>  \n"", cur.x, cur.y, c, qry_match_len);\n\n	  int refpos = 0;\n	  while ((c != '\0'))\n	  {\n		 XPRINTF(""Next edge to follow: %c (%d)\n"", c, qry_match_len);\n\n	     PixelOfChildren children;\n		 children = *(childrenTexture +  (cur.x) + ((cur.y) * maxdim));\n		 prev = cur;\n\n		 switch(c)\n		 {\n			case 'A': cur=children.children[0]; break;\n			case 'C': cur=children.children[1]; break;\n			case 'G': cur=children.children[2]; break;\n			case 'T': cur=children.children[3]; break;\n            default: cur.data = 0; break;\n		 };		 \n\n		 XPRINTF("" In node: (%d,%d)\n"", cur.x, cur.y);\n\n		 // No edge to follow out of the node\n         if (cur.data == 0)\n		 {\n			XPRINTF("" no edge\n"");\n	        set_result(prev, result, 0, qry_match_len, min_match_len, FORWARD);\n\n            qry_match_len -= 1;\n            mustmatch = 0;\n\n			goto NEXT_SUBSTRING;\n		 }\n\n         {\n           unsigned short xval = cur.data & 0xFFFF;\n           unsigned short yval = (cur.data & 0xFFFF0000) >> 16;\n		   node = *(nodeTexture +  (xval) + (yval * maxdim));\n         }\n\n		 XPRINTF("" Edge coordinates: %d - %d\n"", node.start, node.end);\n\n         if (mustmatch)\n         {\n           int edgelen = node.end - node.start+1;\n           if (mustmatch >= edgelen)\n           {\n             XPRINTF("" mustmatch(%d) >= edgelen(%d), skipping edge\n"", mustmatch, edgelen);\n\n             refpos = node.end+1;\n             qry_match_len += edgelen;\n             mustmatch -= edgelen;\n           }\n           else\n           {\n             XPRINTF("" mustmatch(%d) < edgelen(%d), skipping to:%d\n"", \n                     mustmatch, edgelen, node.start+mustmatch);\n\n             qry_match_len += mustmatch;\n             refpos = node.start + mustmatch;\n             mustmatch = 0;\n           }\n         }\n         else\n         {\n           // Try to walk the edge, the first char definitely matches\n           qry_match_len++;\n           refpos = node.start+1;\n         }\n\n		 c = queries[qry_match_len];\n\n		 while (refpos <= node.end && c != '\0')\n		 { \n            //char r = getRef(refpos);\n			char r = refstr[refpos];\n			XPRINTF("" Edge cmp ref: %d %c, qry: %d %c\n"", refpos, r, qry_match_len, c);\n						\n			if (r != c)\n			{\n			   // mismatch on edge\n			   XPRINTF(""mismatch on edge: %d, edge_pos: %d\n"", qry_match_len,refpos - (node.start));\n               goto RECORD_RESULT;\n			}\n\n	        qry_match_len++;\n			refpos++;\n			c = queries[qry_match_len];\n		 }\n	  }\n\n	  XPRINTF(""end of string\n"");\n\n      RECORD_RESULT:\n	\n      set_result(cur, result, refpos - node.start, qry_match_len, min_match_len, FORWARD);\n      mustmatch = refpos - node.start;\n      qry_match_len -= mustmatch + 1;\n\n      NEXT_SUBSTRING:\n\n      //node.data = texfetch(nodetex, prev.x, prev.y);\n	  node = *(nodeTexture +  (prev.x) + ((prev.y) * maxdim));\n      cur = node.suffix;\n\n      XPRINTF("" following suffix link. mustmatch:%d qry_match_len:%d sl:(%d,%d)\n"", \n              mustmatch, qry_match_len, cur.x, cur.y);\n\n      do {} while(0);\n   }\n\n#endif\n	\n   return 0 ;\n}\n\n\n\ninline char rc(char c)\n{\n  switch(c)\n  {\n    case 'A': return 'T';\n    case 'C': return 'G';\n    case 'G': return 'C';\n    case 'T': return 'A';\n    case 'q': return '\0';\n    default:  return c;\n  };\n}\n\n///////////////////////////////////////\n//// Compute reverse substring matches\n///////////////////////////////////////\n\n\nvoid\nrc_kernel_gold(int qryid,\n			   MatchResults* results,\n			   char* refstr,\n               char* queries, \n               const int* queryAddrs,\n			   const int* queryLengths,\n			   PixelOfNode* nodeTexture,\n				PixelOfChildren* childrenTexture,\n               const int numQueries,\n			   const int min_match_len) \n{\n   \n   if (qryid >= numQueries) { return; }\n\n#if 0\n\n   int qlen = queryLengths[qryid];\n\n   XPRINTF(""> rc qryid: %d\n"", qryid);\n\n   queries++; // skip the 'q' character\n\n\n   // start at root for first query character\n   TextureAddress cur;\n\n   int mustmatch = 0;\n   int qry_match_len = 0;\n\n   int qryAddr=queryAddrs[qryid]; \n   MatchCoord * result = results->h_match_coords + qryAddr - (qryid * ( min_match_len + 1));\n   queries += qryAddr;\n\n   for (int qrystart = qlen;\n       qrystart >= min_match_len ;\n       qrystart--, result++)\n   {\n      #ifdef VERBOSE\n      queries[qrystart] = '\0';\n	  XPRINTF(""qry: "", queries);\n      for (int j = qrystart-1; j >= 0; j--)\n      { XPRINTF(""%c"", rc(queries[j])); }\n      XPRINTF(""\n"");\n      #endif\n\n	  PixelOfNode node;\n      TextureAddress prev;\n\n      if (((cur.data == 0)) || (qry_match_len < 1))\n      {\n	    // start at root of tree\n	    cur.x = 0; cur.y = 1;\n	    qry_match_len = 1; \n        mustmatch = 0;\n      }\n\n	  char c = rc(queries[qrystart-qry_match_len]);\n\n	  XPRINTF(""In node (%d,%d): starting with %c [%d] =>  \n"", cur.x, cur.y, c, qry_match_len);\n\n	  int refpos = 0;\n	  while ((c != '\0'))\n	  {\n		 XPRINTF(""Next edge to follow: %c (%d)\n"", c, qry_match_len);\n\n	     PixelOfChildren children;\n		 children = *(childrenTexture +  (cur.x) + ((cur.y) * maxdim));\n		 prev = cur;\n\n		 switch(c)\n		 {\n			case 'A': cur=children.children[0]; break;\n			case 'C': cur=children.children[1]; break;\n			case 'G': cur=children.children[2]; break;\n			case 'T': cur=children.children[3]; break;\n            default: cur.data = 0; break;\n		 };		 \n\n		 XPRINTF("" In node: (%d,%d)\n"", cur.x, cur.y);\n\n		 // No edge to follow out of the node\n         if (cur.data == 0)\n		 {\n			XPRINTF("" no edge\n"");\n	        set_result(prev, result, 0, qry_match_len, min_match_len, \n                       REVERSE);\n\n            qry_match_len -= 1;\n            mustmatch = 0;\n\n			goto NEXT_SUBSTRING;\n		 }\n\n         {\n           unsigned short xval = cur.data & 0xFFFF;\n           unsigned short yval = (cur.data & 0xFFFF0000) >> 16;\n		   node = *(nodeTexture +  (xval) + (yval * maxdim));\n         }\n\n		 XPRINTF("" Edge coordinates: %d - %d\n"", node.start, node.end);\n\n         if (mustmatch)\n         {\n           int edgelen = node.end - node.start+1;\n           if (mustmatch >= edgelen)\n           {\n             XPRINTF("" mustmatch(%d) >= edgelen(%d), skipping edge\n"", mustmatch, edgelen);\n\n             refpos = node.end+1;\n             qry_match_len += edgelen;\n             mustmatch -= edgelen;\n           }\n           else\n           {\n             XPRINTF("" mustmatch(%d) < edgelen(%d), skipping to:%d\n"", \n                     mustmatch, edgelen, node.start+mustmatch);\n\n             qry_match_len += mustmatch;\n             refpos = node.start + mustmatch;\n             mustmatch = 0;\n           }\n         }\n         else\n         {\n           // Try to walk the edge, the first char definitely matches\n           qry_match_len++;\n           refpos = node.start+1;\n         }\n\n		 c = rc(queries[qrystart-qry_match_len]);\n\n		 while (refpos <= node.end && c != '\0')\n		 { \n            //char r = getRef(refstr, refpos);\n			char r = refstr[refpos];\n			XPRINTF("" Edge cmp ref: %d %c, qry: %d %c\n"", refpos, r, qry_match_len, c);\n						\n			if (r != c)\n			{\n			   // mismatch on edge\n			   XPRINTF(""mismatch on edge: %d, edge_pos: %d\n"", qry_match_len,refpos - (node.start));\n               goto RECORD_RESULT;\n			}\n\n	        qry_match_len++;\n			refpos++;\n			c = rc(queries[qrystart-qry_match_len]);\n		 }\n	  }\n\n	  XPRINTF(""end of string\n"");\n\n      RECORD_RESULT:\n	\n      set_result(cur, result, refpos - node.start, qry_match_len, \n                 min_match_len, REVERSE);\n\n      mustmatch = refpos - node.start;\n      qry_match_len -= mustmatch + 1;\n\n      NEXT_SUBSTRING:\n\n	  node = *(nodeTexture +  (prev.x) + ((prev.y) * maxdim));\n      cur = node.suffix;\n\n      XPRINTF("" following suffix link. mustmatch:%d qry_match_len:%d sl:(%d,%d)\n"", \n              mustmatch, qry_match_len, cur.x, cur.y);\n\n      do {} while(0);\n   }\n\n#endif\n	\n   return;\n}\n\n\nextern ""C"" \nvoid computeGold(MatchResults* results,\n				 char* refstr, \n				 char* queries, \n				 int* queryAddrs,\n				 int* queryLengths,\n				 PixelOfNode* nodeTexture,\n				 PixelOfChildren* childrenTexture,\n				 int numQueries,\n				 int match_length,\n				 int rc)\n{\n\n   if (rc == REVERSE)\n   {\n   \n#ifdef OMP\n    omp_set_num_threads(N_THREADS);\n	//fprintf(stderr, ""num of omp threads: %d\n"", omp_get_num_threads());\n   #pragma omp parallel for \n#endif\n	  for (int i = 0; i < numQueries; ++i)\n	  {\n		 rc_kernel_gold(i, \n					 results, \n					 refstr, \n					 queries, \n					 queryAddrs, \n					 queryLengths,\n					 nodeTexture, \n					 childrenTexture,\n					 numQueries, \n					 match_length);\n	  }\n\n	  \n   }\n   else\n   {\n    \n#ifdef OMP\n	omp_set_num_threads(N_THREADS);\n	fprintf(stderr, ""num of omp threads: %d\n"", omp_get_num_threads());\n	#pragma omp parallel for \n#endif\n	  for (int i = 0; i < numQueries; ++i)\n	  {\n		\n		/*\n		int qryid,\n						MatchResults* results, 		\n						char* queries,\n		                PixelOfNode* nodes,\n		                PixelOfChildren* childrenarr,\n		                char* ref,\n		                const int* queryAddrs,\n		                const int* queryLengths,\n		                const int numQueries,\n		                const int min_match_len\n		#if TREE_ACCESS_HISTOGRAM\n						,int* node_hist,\n						int* child_hist\n		#endif\n		*/\n		 kernel_gold(i, \n					 results, \n					 queries, \n					 nodeTexture, \n					 childrenTexture,\n					 refstr, \n					 queryAddrs, \n					 queryLengths,\n					 numQueries, \n					 match_length\n#if TREE_ACCESS_HISTOGRAM\n					 ,int* node_hist,\n					 int* child_hist\n#endif\n					 );\n	  }\n   }\n}\n\n"
nn/nn_openmp.c,"#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n\n#define MAX_ARGS 10\n#define REC_LENGTH 49	// size of a record in db\n#define REC_WINDOW 10	// number of records to read at a time\n#define LATITUDE_POS 28	// location of latitude coordinates in input record\n#define OPEN 10000	// initial value of nearest neighbors\nstruct neighbor {\n	char entry[REC_LENGTH];\n	double dist;\n};\n\n/**\n* This program finds the k-nearest neighbors\n* Usage:	./nn <filelist> <num> <target latitude> <target longitude>\n*			filelist: File with the filenames to the records\n*			num: Number of nearest neighbors to find\n*			target lat: Latitude coordinate for distance calculations\n*			target long: Longitude coordinate for distance calculations\n* The filelist and data are generated by hurricane_gen.c\n* REC_WINDOW has been arbitrarily assigned; A larger value would allow more work for the threads\n*/\nint main(int argc, char* argv[]) {\n	long long time0 = clock();\n    FILE   *flist,*fp;\n	int    i=0,j=0, k=0, rec_count=0, done=0;\n	char   sandbox[REC_LENGTH * REC_WINDOW], *rec_iter,*rec_iter2, dbname[64];\n	struct neighbor *neighbors = NULL;\n	float target_lat, target_long, tmp_lat=0, tmp_long=0;\n\n	if(argc < 5) {\n		fprintf(stderr, ""Invalid set of arguments\n"");\n		exit(-1);\n	}\n\n	flist = fopen(argv[1], ""r"");\n	if(!flist) {\n		printf(""error opening flist\n"");\n		exit(1);\n	}\n\n	k = atoi(argv[2]);\n	target_lat = atof(argv[3]);\n	target_long = atof(argv[4]);\n\n	neighbors = malloc(k*sizeof(struct neighbor));\n\n	if(neighbors == NULL) {\n		fprintf(stderr, ""no room for neighbors\n"");\n		exit(0);\n	}\n\n	for( j = 0 ; j < k ; j++ ) { //Initialize list of nearest neighbors to very large dist\n		neighbors[j].dist = OPEN;\n	}\n\n	/**** main processing ****/  \n	if(fscanf(flist, ""%s\n"", dbname) != 1) {\n		fprintf(stderr, ""error reading filelist\n"");\n		exit(0);\n	}\n\n	fp = fopen(dbname, ""r"");\n	if(!fp) {\n		printf(""error opening flist\n"");\n		exit(1);\n	}\n\n	float *z;\n	z  = (float *) malloc(REC_WINDOW * sizeof(float));\n\n	while(!done) {\n		//Read in REC_WINDOW number of records\n		rec_count = fread(sandbox, REC_LENGTH, REC_WINDOW, fp);\n		if( rec_count != REC_WINDOW ) {\n			if(!ferror(flist)) {// an eof occured\n				fclose(fp);\n\n				if(feof(flist))\n		  			done = 1;\n				else {\n	 				if(fscanf(flist, ""%s\n"", dbname) != 1) {\n	    					fprintf(stderr, ""error reading filelist\n"");\n	    					exit(0);\n					}\n\n	  				fp = fopen(dbname, ""r"");\n\n	  				if(!fp) {\n					    printf(""error opening a db\n"");\n					    exit(1);\n	  				}\n				}\n			} else {\n				perror(""Error"");\n				exit(0);\n			}\n		}\n\n		/* Launch threads to  */\n        // Lingjie Zhang modificated on 11/08/2015\n        // original code \n		// #pragma omp parallel for shared(z, target_lat, target_long) private(i, rec_iter, tmp_lat, tmp_long)\n		// for( i = 0 ; i < rec_count ; i++ ) {\n			// rec_iter = sandbox+(i * REC_LENGTH + LATITUDE_POS - 1);\n			// sscanf(rec_iter, ""%f %f"", &tmp_lat, &tmp_long);\n			// z[i] = sqrt(( (tmp_lat-target_lat) * (tmp_lat-target_lat) )+( (tmp_long-target_long) * (tmp_long-target_long) ));\n		// } /* omp end parallel */\n		// #pragma omp barrier\n       \n        #pragma omp parallel for shared (z, target_lat, target_long) private(i,rec_iter)\n        for (i = 0; i < rec_count; i++){\n			rec_iter = sandbox+(i * REC_LENGTH + LATITUDE_POS - 1);\n            float tmp_lat = atof(rec_iter);\n            float tmp_long = atof(rec_iter+5);\n			z[i] = sqrt(( (tmp_lat-target_lat) * (tmp_lat-target_lat) )+( (tmp_long-target_long) * (tmp_long-target_long) ));\n        }\n        #pragma omp barrier\n        // end of Lingjie Zhang's modification\n\n		\n        for( i = 0 ; i < rec_count ; i++ ) {\n			float max_dist = -1;\n			int max_idx = 0;\n			// find a neighbor with greatest dist and take his spot if allowed!\n			for( j = 0 ; j < k ; j++ ) {\n				if( neighbors[j].dist > max_dist ) {\n					max_dist = neighbors[j].dist;\n					max_idx = j;\n				}\n			}\n			// compare each record with max value to find the nearest neighbor\n			if( z[i] < neighbors[max_idx].dist ) {\n				sandbox[(i+1)*REC_LENGTH-1] = '\0';\n			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);\n			  	neighbors[max_idx].dist = z[i];\n			}\n		}\n	}//End while loop\n\n	fprintf(stderr, ""The %d nearest neighbors are:\n"", k);\n	for( j = 0 ; j < k ; j++ ) {\n		if( !(neighbors[j].dist == OPEN) )\n			fprintf(stderr, ""%s --> %f\n"", neighbors[j].entry, neighbors[j].dist);\n	}\n\n	fclose(flist);\n	\n\n    long long time1 = clock();\n    printf(""total time : %15.12f s"", (float) (time1 - time0) / 1000000);\n    return 0;\n}\n\n"
nn/hurricane_gen.c,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n\n// 641986 gets you ~30 MB of data\nint main(int argc, char **argv)\n{\n  FILE *fp;\n  int i=0, canes=0,num_files=0,j=0;\n  int year,month,date,hour,num,speed,press;\n  float lat,lon;\n  int hours[4] = {0,6,12,18};\n  char *name, fname[16];\n  char names[21][10] = {""ALBERTO"", ""BERYL"", ""CHRIS"",""DEBBY"",""ERNESTO"",""FLORENCE"",""GORDON"",\n      ""HELENE"",""ISAAC"",""JOYCE"",""KIRK"",""LESLIE"",""MICHAEL"",""NADINE"",""OSCAR"",""PATTY"",""RAFAEL"",\n      ""SANDY"",""TONY"",""VALERIE"",""WILLIAM""};\n\n  if(argc < 3)\n  {\n    fprintf(stderr,""we need a number of hurricanes to create and number of files to create\n"");\n    exit(0);\n  }\n\n  canes = atoi(argv[1]);\n  num_files = atoi(argv[2]);\n\n  canes = (canes / num_files) + 1;\n  \n  for(j=0;j<num_files;j++)\n  {\n    sprintf(fname, ""data/cane%d_%d.db"", num_files,j);\n    \n    if ((fp = fopen(fname, ""w"")) == NULL) {\n		 fprintf(stderr, ""Failed to open output file '%s'!\n"", fname);\n		 return -1;\n	 }\n  \n    srand(time(NULL));\n\n    for(i=0;i<canes;i++)\n    {\n      year = 1950 + rand() % 55;\n      month = 1 + rand() % 12;\n      date = 1 + rand() % 28;\n      hour = hours[rand()%4];\n      num = 1 + rand() % 28;\n      name = names[rand()%21];\n      lat = ((float)(7 + rand() % 63)) + ((float) rand() / (float) 0x7fffffff);\n      lon = ((float)(rand() % 358)) + ((float) rand() / (float) 0x7fffffff); \n      speed = 10+ rand() % 155;\n      press = rand() % 900;\n\n      fprintf(fp, ""%4d %2d %2d %2d %2d %-9s %5.1f %5.1f %4d %4d\n"", year, month, date, hour, num, name, lat, lon, speed, press); \n\n    }\n\n    fclose(fp);\n  }\n\n    return 0;\n\n  }\n"
