Source,Code Snippet,Question,Answer
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,No
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,No
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,Yes
Rodinia Kmeans Clustering - OpenMP,"#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n#include ""kmeans.h""\n#include <omp.h>\n#define RANDOM_MAX 2147483647\n#ifndef FLT_MAX\n#define FLT_MAX 3.40282347e+38\n#endif\nextern double wtime(void);\nextern int num_omp_threads;\nint find_nearest_point(float  *pt, int     nfeatures, float **pts, int     npts) {\n    int index, i;\n    float min_dist=FLT_MAX;\n    for (i=0; i<npts; i++) {\n        float dist;\n        dist = euclid_dist_2(pt, pts[i], nfeatures);\n        if (dist < min_dist) {\n            min_dist = dist;\n            index    = i;\n        }\n    }\n    return(index);\n}\n__inline\nfloat euclid_dist_2(float *pt1,float *pt2,int    numdims) {\n    int i;\n    float ans=0.0;\n    for (i=0; i<numdims; i++)\n        ans += (pt1[i]-pt2[i]) * (pt1[i]-pt2[i]);\n    return(ans);\n}\nfloat** kmeans_clustering(float **feature, int     nfeatures, int     npoints, int     nclusters, float   threshold, int    *membership) {\n    int      i, j, k, n=0, index, loop=0;\n    int     *new_centers_len;\n    float  **new_centers;\n    float  **clusters;\n    float    delta;\n    double   timing;\n    int      nthreads;\n    int    **partial_new_centers_len;\n    float ***partial_new_centers;\n    nthreads = num_omp_threads; \n    clusters    = (float**) malloc(nclusters *             sizeof(float*));\n    clusters[0] = (float*)  malloc(nclusters * nfeatures * sizeof(float));\n    for (i=1; i<nclusters; i++)\n        clusters[i] = clusters[i-1] + nfeatures;\n    for (i=0; i<nclusters; i++) {\n        for (j=0; j<nfeatures; j++)\n            clusters[i][j] = feature[n][j];\n        n++;\n    }\n    for (i=0; i<npoints; i++)\n        membership[i] = -1;\n    new_centers_len = (int*) calloc(nclusters, sizeof(int));\n    new_centers    = (float**) malloc(nclusters *            sizeof(float*));\n    new_centers[0] = (float*)  calloc(nclusters * nfeatures, sizeof(float));\n    for (i=1; i<nclusters; i++)\n        new_centers[i] = new_centers[i-1] + nfeatures;\n    partial_new_centers_len    = (int**) malloc(nthreads * sizeof(int*));\n    partial_new_centers_len[0] = (int*)  calloc(nthreads*nclusters, sizeof(int));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers_len[i] = partial_new_centers_len[i-1]+nclusters;\n    partial_new_centers    =(float***)malloc(nthreads * sizeof(float**));\n    partial_new_centers[0] =(float**) malloc(nthreads*nclusters * sizeof(float*));\n    for (i=1; i<nthreads; i++)\n        partial_new_centers[i] = partial_new_centers[i-1] + nclusters;\n    for (i=0; i<nthreads; i++)\n    {\n        for (j=0; j<nclusters; j++)\n            partial_new_centers[i][j] = (float*)calloc(nfeatures, sizeof(float));\n    }\n    printf(""num of threads = %d\n"", num_omp_threads);\n    do {\n        delta = 0.0;\n        omp_set_num_threads(num_omp_threads);\n        #pragma omp parallel shared(feature,clusters,membership,partial_new_centers,partial_new_centers_len)\n        {\n            int tid = omp_get_thread_num();\n            #pragma omp for private(i,j,index) firstprivate(npoints,nclusters,nfeatures) schedule(static) reduction(+:delta)\n            for (i=0; i<npoints; i++) {\n                index = find_nearest_point(feature[i],nfeatures,clusters,nclusters);\n                if (membership[i] != index) delta += 1.0;\n                membership[i] = index;\n                partial_new_centers_len[tid][index]++;\n                for (j=0; j<nfeatures; j++)\n                    partial_new_centers[tid][index][j] += feature[i][j];\n            }\n        }\n        for (i=0; i<nclusters; i++) {\n            for (j=0; j<nthreads; j++) {\n                new_centers_len[i] += partial_new_centers_len[j][i];\n                partial_new_centers_len[j][i]",,No
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia Pathfinder,"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include <assert.h>\n\n#include \timer.h\""\n\nvoid run(int argc, char** argv);\n\n/* define timer macros */\n#define pin_stats_reset()   startCycle()\n#define pin_stats_pause(cycles)   stopCycle(cycles)\n#define pin_stats_dump(cycles)    printf(\""timer: %Lu\\n\"", cycles)\n\n#define BENCH_PRINT\n\nint rows, cols;\nint* data;\nint** wall;\nint* result;\n#define M_SEED 9\n\nvoid\ninit(int argc, char** argv)\n{\n\tif(argc==3){\n\t\tcols = atoi(argv[1]);\n\t\trows = atoi(argv[2]);\n\t}else{\n                printf(\""Usage: pathfiner width num_of_steps\\n\"");\n                exit(0);\n        }\n\tdata = new int[rows*cols];\n\twall = new int*[rows];\n\tfor(int n=0; n<rows; n++)\n\t\twall[n]=data+cols*n;\n\tresult = new int[cols];\n\t\n\tint seed = M_SEED;\n\tsrand(seed);\n\n\tfor (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            wall[i][j] = rand() % 10;\n        }\n    }\n    for (int j = 0; j < cols; j++)\n        result[j] = wall[0][j];\n#ifdef BENCH_PRINT\n    for (int i = 0; i < rows; i++)\n    {\n        for (int j = 0; j < cols; j++)\n        {\n            printf(\""%d \"",wall[i][j]) ;\n        }\n        printf(\""\\n\"") ;\n    }\n#endif\n}\n\nvoid \nfatal(char *s)\n{\n\tfprintf(stderr, \""error: %s\\n\"", s);\n\n}\n\n#define IN_RANGE(x, min, max)   ((x)>=(min) && (x)<=(max))\n#define CLAMP_RANGE(x, min, max) x = (x<(min)) ? min : ((x>(max)) ? max : x )\n#define MIN(a, b) ((a)<=(b) ? (a) : (b))\n\nint main(int argc, char** argv)\n{\n    run(argc,argv);\n\n    return EXIT_SUCCESS;\n}\n\nvoid run(int argc, char** argv)\n{\n    init(argc, argv);\n\n    unsigned long long cycles;\n\n    int *src, *dst, *temp;\n    int min;\n\n    dst = result;\n    src = new int[cols];\n\n    pin_stats_reset();\n    for (int t = 0; t < rows-1; t++) {\n        temp = src;\n        src = dst;\n        dst = temp;\n        #pragma omp parallel for private(min)\n        for(int n = 0; n < cols; n++){\n          min = src[n];\n          if (n > 0)\n            min = MIN(min, src[n-1]);\n          if (n < cols-1)\n            min = MIN(min, src[n+1]);\n          dst[n] = wall[t+1][n]+min;\n        }\n    }\n\n    pin_stats_pause(cycles);\n    pin_stats_dump(cycles);\n\n#ifdef BENCH_PRINT\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",data[i]) ;\n\n    printf(\""\\n\"") ;\n\n    for (int i = 0; i < cols; i++)\n\n            printf(\""%d \"",dst[i]) ;\n\n    printf(\""\\n\"") ;\n\n#endif\n\n    delete [] data;\n    delete [] wall;\n    delete [] dst;\n    delete [] src;\n}\n""",,
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,Yes
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,Yes
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,Yes
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia rng,"#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <sys/time.h>\n#include <omp.h>\n#include <limits.h>\n#define PI acos(-1)\nlong M = INT_MAX;\nint A = 1103515245;\nint C = 12345;\ndouble randu(int * seed, int index)\n{\n\tint num = A*seed[index] + C;\n\tseed[index] = num % M;\n\treturn fabs(seed[index]/((double) M));\n}\ndouble randn(int * seed, int index)\n{\n\tdouble u = randu(seed, index);\n\tdouble v = randu(seed, index);\n\tdouble cosine = cos(2*PI*v);\n\tdouble rt = -2*log(u);\n\treturn sqrt(rt)*cosine;\n}\nint main()\n{\n\tint length = 10000;\n\tint * seed = (int *)malloc(sizeof(int)*length);\n\tint x;\n\tfor(x = 0; x < length; x++)\n\t{\n\t\tseed[x] = time(0)*x;\n\t}\n\tfree(seed);\n\treturn 0;\n}",,No
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,No
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,No
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,No
Rodinia-hotspot,"#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include <sys/time.h>\n\nlong long get_time()\n{\nstruct timeval tv;\ngettimeofday(&tv, NULL);\nreturn (tv.tv_sec * 1000000) + tv.tv_usec;\n}\n\nusing namespace std;\n\n#define BLOCK_SIZE 16\n#define BLOCK_SIZE_C BLOCK_SIZE\n#define BLOCK_SIZE_R BLOCK_SIZE\n\n#define STR_SIZE 256\n\n#define MAX_PD (3.0e6)\n#define PRECISION 0.001\n#define SPEC_HEAT_SI 1.75e6\n#define K_SI 100\n#define FACTOR_CHIP 0.5\n#define OPEN\n#define NUM_THREAD 4\n\ntypedef float FLOAT;\n\nconst FLOAT t_chip = 0.0005;\nconst FLOAT chip_height = 0.016;\nconst FLOAT chip_width = 0.016;\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nconst FLOAT amb_temp = 80.0;\n\nint num_omp_threads;\n\nvoid single_iteration(FLOAT *result, FLOAT *temp, FLOAT *power, int row, int col,\nFLOAT Cap_1, FLOAT Rx_1, FLOAT Ry_1, FLOAT Rz_1,\nFLOAT step)\n{\nFLOAT delta;\nint r, c;\nint chunk;\nint num_chunk = row*col / (BLOCK_SIZE_R * BLOCK_SIZE_C);\nint chunks_in_row = col/BLOCK_SIZE_C;\nint chunks_in_col = row/BLOCK_SIZE_R;\n\n#ifdef OPEN\n#ifndef __MIC__\nomp_set_num_threads(num_omp_threads);\n#endif\n#pragma omp parallel for shared(power, temp, result) private(chunk, r, c, delta) firstprivate(row, col, num_chunk, chunks_in_row) schedule(static)\n#endif\nfor ( chunk = 0; chunk < num_chunk; ++chunk )\n{\nint r_start = BLOCK_SIZE_R*(chunk/chunks_in_col);\nint c_start = BLOCK_SIZE_C*(chunk%chunks_in_row);\nint r_end = r_start + BLOCK_SIZE_R > row ? row : r_start + BLOCK_SIZE_R;\nint c_end = c_start + BLOCK_SIZE_C > col ? col : c_start + BLOCK_SIZE_C;\n\nif ( r_start == 0 || c_start == 0 || r_end == row || c_end == col )\n{\nfor ( r = r_start; r < r_start + BLOCK_SIZE_R; ++r ) {\nfor ( c = c_start; c < c_start + BLOCK_SIZE_C; ++c ) {\nif ( (r == 0) && (c == 0) ) {\ndelta = (Cap_1) * (power[0] +\n(temp[1] - temp[0]) * Rx_1 +\n(temp[col] - temp[0]) * Ry_1 +\n(amb_temp - temp[0]) * Rz_1);\n} else if ((r == 0) && (c == col-1)) {\ndelta = (Cap_1) * (power[c] +\n(temp[c-1] - temp[c]) * Rx_1 +\n(temp[c+col] - temp[c]) * Ry_1 +\n(amb_temp - temp[c]) * Rz_1);\n} else if ((r == row-1) && (c == col-1)) {\ndelta = (Cap_1) * (power[r*col+c] +\n(temp[r*col+c-1] - temp[r*col+c]) * Rx_1 +\n(temp[(r-1)*col+c] - temp[r*col+c]) * Ry_1 +\n(amb_temp - temp[r*col+c]) * Rz_1);\n} else if ((r == row-1) && (c == 0)) {\ndelta = (Cap_1) * (power[r*col] +\n(temp[r*col+1] - temp[r*col]) * Rx_1 +\n(temp[(r-1)*col] - temp[r*col]) * Ry_1 +\n(amb_temp - temp[r*col]) * Rz_1);\n} else if (r == 0) {\ndelta = (Cap_1) * (power[c] +\n(temp[c+1] + temp[c-1] - 2.0*temp[c]) * Rx_1 +\n(temp[col+c] -
",,Yes
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-SRAD,"#define OPEN\n#define\tITERATION\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <omp.h>\nvoid random_matrix(float *I, int rows, int cols);\nvoid usage(int argc, char **argv)\n{\n\tfprintf(stderr, \Usage: %s <rows> <cols> <y1> <y2> <x1> <x2> <no. of threads><lamda> <no. of iter>\\n\"", argv[0]);\n\tfprintf(stderr, \""\t<rows>   - number of rows\\n\"");\n\tfprintf(stderr, \""\t<cols>    - number of cols\\n\"");\n\tfprintf(stderr, \""\t<y1> \t - y1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<y2>      - y2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x1>       - x1 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<x2>       - x2 value of the speckle\\n\"");\n\tfprintf(stderr, \""\t<no. of threads>  - no. of threads\\n\"");\n\tfprintf(stderr, \""\t<lamda>   - lambda (0,1)\\n\"");\n\tfprintf(stderr, \""\t<no. of iter>   - number of iterations\\n\"");\n\t\n\texit(1);\n}\nint main(int argc, char* argv[])\n{\n\tint rows, cols, size_I, size_R, niter = 10, iter, k;\n\tfloat *I, *J, q0sqr, sum, sum2, tmp, meanROI,varROI ;\n\tfloat Jc, G2, L, num, den, qsqr;\n\tint *iN,*iS,*jE,*jW;\n\tfloat *dN,*dS,*dW,*dE;\n\tint r1, r2, c1, c2;\n\tfloat cN,cS,cW,cE;\n\tfloat *c, D;\n\tfloat lambda;\n\tint i, j;\n\tint nthreads;\n\tif (argc == 10)\n\t{\n\t\trows = atoi(argv[1]); //number of rows in the domain\n\t\tcols = atoi(argv[2]); //number of cols in the domain\n\t\tif ((rows%16!=0) || (cols%16!=0)){\n\t\t\tfprintf(stderr, \""rows and cols must be multiples of 16\\n\"");\n\t\t\texit(1);\n\t\t}\n\t\tr1   = atoi(argv[3]); //y1 position of the speckle\n\t\tr2   = atoi(argv[4]); //y2 position of the speckle\n\t\tc1   = atoi(argv[5]); //x1 position of the speckle\n\t\tc2   = atoi(argv[6]); //x2 position of the speckle\n\t\tnthreads = atoi(argv[7]); // number of threads\n\t\tlambda = atof(argv[8]); //Lambda value\n\t\tniter = atoi(argv[9]); //number of iterations\n\t}\n\telse{\n\t\tusage(argc, argv);\n\t}\n\n\n\tsize_I = cols * rows;\n\tsize_R = (r2-r1+1)*(c2-c1+1);   \n\tI = (float *)malloc( size_I * sizeof(float) );\n\tJ = (float *)malloc( size_I * sizeof(float) );\n\tc  = (float *)malloc(sizeof(float)* size_I) ;\n\tiN = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tiS = (int *)malloc(sizeof(unsigned int*) * rows) ;\n\tjW = (int *)malloc(sizeof(unsigned int*) * cols) ;\n\tjE = (int *)malloc(sizeof(unsigned int*) * cols) ;    \n\tdN = (float *)malloc(sizeof(float)* size_I) ;\n\tdS = (float *)malloc(sizeof(float)* size_I) ;\n\tdW = (float *)malloc(sizeof(float)* size_I) ;\n\tdE = (float *)malloc(sizeof(float)* size_I) ;    \n\tfor (int i=0; i< rows; i++) {\n\t\tiN[i] = i-1;\n\t\tiS[i] = i+1;\n\t}    \n\tfor (int j=0; j< cols; j++) {\n\t\tjW[j] = j-1;\n\t\tjE[j] = j+1;\n\t}\n\tiN[0]    = 0;\n\tiS[rows-1] = rows-1;\n\tjW[0]    = 0;\n\tjE[cols-1] = cols-1;\n\t\n\tprintf(\""Randomizing the input matrix\\n\"");\n\n\trandom_matrix(I, rows, cols);\n\n\tfor (k = 0;  k < size_I; k++ ) {\n\t\tJ[k] = (float)exp(I[k]) ;\n\t}\n\t\n\tprintf(\""Start the SRAD main loop\\n\"");\n\n#ifdef ITERATION\n\tfor (iter=0; iter< niter; iter++){\n#endif        \n\t\tsum=0; sum2=0;     \n\t\tfor (i=r1; i<=r2; i++) {\n\t\t\tfor (j=c1; j<=c2; j++) {\n\t\t\t\ttmp   = J[i * cols + j];\n\t\t\t\tsum  += tmp ;\n\t\t\t\tsum2 += tmp*tmp;\n\t\t\t}\n\t\t}\n\t\tmeanROI = sum / size_R;\n\t\tvarROI  = (sum2 / size_R) - meanROI*meanROI;\n\t\tq0sqr   = varROI / (meanROI*meanROI);\n\t\t\n\n#ifdef OPEN\n\t\tomp_set_num_threads(nthreads);\n\t\t#pragma omp parallel for shared(J, dN, dS, dW, dE, c, rows, cols, iN, iS, jW, jE) private(i, j, k, Jc, G2, L, num, den, qsqr)\n#endif    \n\t\tfor (int i = 0 ; i < rows ; i++) {\n\t\t\tfor (int j = 0; j < cols; j++) { \n\t\t\t\n\t\t\t\tk = i * cols",,
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,No
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,No
Rodinia-LUD,"#include <stdio.h>\n#include <omp.h>\n\nextern int omp_num_threads;\n\n#define BS 16\n\n#define AA(_i,_j) a[offset*size+_i*size+_j+offset]\n#define BB(_i,_j) a[_i*size+_j]\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(push, target(mic))\n#endif\n\nvoid lud_diagonal_omp (float* a, int size, int offset)\n{\n    int i, j, k;\n    for (i = 0; i < BS; i++) {\n\n        for (j = i; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(i,j) = AA(i,j) - AA(i,k) * AA(k,j);\n            }\n        }\n   \n        float temp = 1.f/AA(i,i);\n        for (j = i+1; j < BS; j++) {\n            for (k = 0; k < i ; k++) {\n                AA(j,i) = AA(j,i) - AA(j,k) * AA(k,i);\n            }\n            AA(j,i) = AA(j,i)*temp;\n        }\n    }\n\n}\n\n#ifdef OMP_OFFLOAD\n#pragma offload_attribute(pop)\n#endif\n\n\n// implements block LU factorization \nvoid lud_omp(float *a, int size)\n{\n    int offset, chunk_idx, size_inter, chunks_in_inter_row, chunks_per_inter;\n\n#ifdef OMP_OFFLOAD\n#pragma omp target map(to: size) map(a[0:size*size])\n#endif\n\n#ifdef OMP_OFFLOAD\n{\n    omp_set_num_threads(224);\n#else\n    printf(\running OMP on host\\n\"");\n    omp_set_num_threads(omp_num_threads);\n#endif\n    for (offset = 0; offset < size - BS ; offset += BS)\n    {\n        // lu factorization of left-top corner block diagonal matrix \n        //\n        lud_diagonal_omp(a, size, offset);\n            \n        size_inter = size - offset -  BS;\n        chunks_in_inter_row  = size_inter/BS;\n        \n        // calculate perimeter block matrices\n        // \n        #pragma omp parallel for default(none) \\\n          private(chunk_idx) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for ( chunk_idx = 0; chunk_idx < chunks_in_inter_row; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global, i_here, j_here;\n            float sum;           \n            float temp[BS*BS] __attribute__ ((aligned (64)));\n\n            for (i = 0; i < BS; i++) {\n                #pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp[i*BS + j] = a[size*(i + offset) + offset + j ];\n                }\n            }\n            i_global = offset;\n            j_global = offset;\n            \n            // processing top perimeter\n            //\n            j_global += BS * (chunk_idx+1);\n            for (j = 0; j < BS; j++) {\n                for (i = 0; i < BS; i++) {\n                    sum = 0.f;\n                    for (k=0; k < i; k++) {\n                        sum += temp[BS*i +k] * BB((i_global+k),(j_global+j));\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    BB(i_here, j_here) = BB(i_here,j_here) - sum;\n                }\n            }\n\n            // processing left perimeter\n            //\n            j_global = offset;\n            i_global += BS * (chunk_idx + 1);\n            for (i = 0; i < BS; i++) {\n                for (j = 0; j < BS; j++) {\n                    sum = 0.f;\n                    for (k=0; k < j; k++) {\n                        sum += BB((i_global+i),(j_global+k)) * temp[BS*k + j];\n                    }\n                    i_here = i_global + i;\n                    j_here = j_global + j;\n                    a[size*i_here + j_here] = ( a[size*i_here+j_here] - sum ) / a[size*(offset+j) + offset+j];\n                }\n            }\n\n        }\n        \n        // update interior block matrices\n        //\n        chunks_per_inter = chunks_in_inter_row*chunks_in_inter_row;\n\n#pragma omp parallel for schedule(auto) default(none) \\\n         private(chunk_idx ) shared(size, chunks_per_inter, chunks_in_inter_row, offset, a) \n        for  (chunk_idx =0; chunk_idx < chunks_per_inter; chunk_idx++)\n        {\n            int i, j, k, i_global, j_global;\n            float temp_top[BS*BS] __attribute__ ((aligned (64)));\n            float temp_left[BS*BS] __attribute__ ((aligned (64)));\n            float sum[BS] __attribute__ ((aligned (64))) = {0.f};\n            \n            i_global = offset + BS * (1 +  chunk_idx/chunks_in_inter_row);\n            j_global = offset + BS * (1 + chunk_idx%chunks_in_inter_row);\n\n            for (i = 0; i < BS; i++) {\n#pragma omp simd\n                for (j =0; j < BS; j++){\n                    temp_top[i*BS + j]  = a[size*(i + offset) + j + j_global ];\n                    temp_left[i*BS + j] = a[size*(i + i_global) + offset + j];\n                }\n            }\n\n            for (i = 0; i < BS; i++)\n            {\n                for (k=0; k < BS; k++) {\n#pragma omp simd \n                    for (j = 0; j < BS; j++) {\n                        sum[j] += temp_left[BS*i + k] * temp_top[BS*k + j];\n                    }\n                }\n#pragma omp simd \n                for (j = 0; j < BS; j++) {\n                    BB((i+i_global),(j+j_global)) -= sum[j];\n                    sum[j] = 0.f;\n                }\n            }\n        }\n    }\n\n    lud_diagonal_omp(a, size, offset);\n#ifdef OMP_OFFLOAD\n}\n#endif\n\n}\n""",,Yes
